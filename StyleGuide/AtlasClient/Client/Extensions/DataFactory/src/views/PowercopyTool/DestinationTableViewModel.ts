/* tslint:disable:no-unused-variable */
import FormFields = require("../../bootstrapper/FormFields");
import ValidatedSelectBoxViewModel = FormFields.ValidatedSelectBoxViewModel;
import Common = require("./Common");
import Configuration = require("./Configuration");
import requiredValidation = Common.requiredValidation;
import IADFInputTable = Common.IADFInputTable;
import DataNavModule = require("./DataNavModel");
import DataNavModel = DataNavModule.DataNavModel;
import SyncMethods = require("./SyncMethods");
import Constants = require("./Constants");
import IdempotencyMethods = require("./IdempotencyMethods");
import NetTypes = require("./NetTypes");
import Validation = require("../../bootstrapper/Validation");
import DataTypeConstants = require("./DataTypeConstants");
import FactoryEntities = require("./FactoryEntities");
/* tslint:enable:no-unused-variable */

export interface IColumnMapping {
    sourceColumnName: KnockoutObservable<string>;
    destinationColumn: Common.IColumn;
    destinationColumnDisplayText: string;
    copy: KnockoutObservable<boolean>;
    warning: KnockoutComputed<boolean>;
}

function columnToText(column: Common.IColumn): string {
    return column.name + " (" + column.type + ")";
}

let idempotencyMethodOptions: FormFields.IOption[] =
    [{ value: IdempotencyMethods.script, displayText: "Autogenerated cleanup script" },
        { value: IdempotencyMethods.customScript, displayText: "Custom script" },
        { value: IdempotencyMethods.column, displayText: "Slice identifier column" },
        { value: "", displayText: "None" }];

interface ISourceColumnOption extends FormFields.IOption {
    isAutoIncrementing: boolean;
}

class AzureTableSyncViewModel {
    private static value = "value";
    private static guid = "guid";
    private static column = "column";

    public valid: KnockoutComputed<boolean>;
    public insertType = new FormFields.ValidatedSelectBoxViewModel<string>(ko.observableArray([
        { value: "merge", displayText: "Merge" }, { value: "replace", displayText: "Replace" }]), {
            label: "Insert type"
        });

    public partitionValueSelection = new FormFields.ValidatedSelectBoxViewModel<string>(ko.observableArray([
        { value: AzureTableSyncViewModel.value, displayText: "Specify partition value" },
        { value: AzureTableSyncViewModel.column, displayText: "Use destination column" }
    ]), {
            label: "Partition key value selection",
            infoBalloon: "Partition value can be fixed value or it can take value from a destination column"
        });

    public defaultPartitionValue = new FormFields.ValidatedBoxViewModel<string>({
        label: "Default partition value",
        visible: ko.computed(() => this.partitionValueSelection.value() === AzureTableSyncViewModel.value),
        defaultValue: "DefaultPartitionKey",
        validations: [Common.requiredValidation]
    });

    public rowKeyValueSelection = new FormFields.ValidatedSelectBoxViewModel<string>(ko.observableArray([
        { value: AzureTableSyncViewModel.guid, displayText: "Unique identifier" }, { value: AzureTableSyncViewModel.column, displayText: "Use destination column" }
    ]), {
            label: "Row key value selection",
            infoBalloon: "Row key value can be an autogenerated unique identifier or it can take value from a destination column"
        });

    public partitionKeyColumn: FormFields.ValidatedSelectBoxViewModel<string>;
    public rowKeyColumn: FormFields.ValidatedSelectBoxViewModel<string>;

    public getProperties(): Common.IAzureTableSinkProperties {
        return {
            insertType: this.insertType.value(),
            partitionColumn: this.partitionValueSelection.value() === AzureTableSyncViewModel.column ? this.partitionKeyColumn.value() : undefined,
            rowKeyColumn: this.rowKeyValueSelection.value() === AzureTableSyncViewModel.column ? this.rowKeyColumn.value() : undefined,
            partitionValue: this.partitionValueSelection.value() === AzureTableSyncViewModel.value ? this.defaultPartitionValue.value() : undefined
        };
    }

    constructor(destinationColumns: KnockoutObservableArray<FormFields.IOption>) {
        this.partitionKeyColumn = new FormFields.ValidatedSelectBoxViewModel<string>(destinationColumns, {
            label: "Partition key column",
            visible: ko.computed(() => this.partitionValueSelection.value() === AzureTableSyncViewModel.column),
            validations: [Common.requiredValidation]
        });

        this.rowKeyColumn = new FormFields.ValidatedSelectBoxViewModel<string>(destinationColumns, {
            label: "Row key column",
            visible: ko.computed(() => this.rowKeyValueSelection.value() === AzureTableSyncViewModel.column),
            validations: [Common.requiredValidation]
        });

        let fieldsWithValidation: FormFields.ValidatedBoxViewModel<string>[] = [this.partitionKeyColumn, this.rowKeyColumn, this.defaultPartitionValue];
        this.valid = ko.computed(() => {
            return fieldsWithValidation.every(field => !field.options.visible() || field.valid());
        });
    }
}

export class DestinationTableViewModel {
    private static id = 0;

    public selectedTable: KnockoutComputed<string>;
    public expandedInTableMappingList = ko.observable(false);
    public selectedForColumnMapping = ko.observable(false);
    public resultingStoredProc: KnockoutComputed<string>;
    public resultingStoredProcTableType: KnockoutComputed<string>;
    public resultingCleanupScript: KnockoutComputed<string>;
    public resultingSliceIdentifier: KnockoutComputed<string>;
    public resultingSchema: KnockoutComputed<Common.IColumn[]>;
    public translation: KnockoutComputed<Common.ITranslation[]>;
    public storedProcParameters = ko.observableArray<Common.IStoredProcParameter>();
    public columnMappings = ko.observableArray<IColumnMapping>();
    public idempotencyMethodConstants = IdempotencyMethods;
    public tableMappingValidateable: Validation.IValidatable;
    public columnMappingValidateable: Validation.IValidatable;

    private sqlSyncMethods = ko.observableArray<FormFields.IOption>([{ displayText: "Existing table", value: "Existing" }]);
    private syncMethodFormField = new FormFields.ValidatedSelectBoxViewModel<string>(this.sqlSyncMethods, {
        label: "Copy data to",
        infoBalloon: "Select whether you want to copy data to extising table or create new table prior to submiting copy pipelines" +
        " (new table option will only appear if the destination supports it)"
    });
    private idempotencyMethod = new FormFields.ValidatedSelectBoxViewModel<string>(ko.observableArray(idempotencyMethodOptions), {
        label: "Method",
        infoBalloon: "Method for performing an idempotent (repeatable) copy. Data in the destination table have to be cleaned"
        +
        " by running an auto-generated or custom script (or) by using a slice identifier column. See "
        +
        "<a href='http://go.microsoft.com/fwlink/?LinkId=734874' target='_blank class='link'>this article</a> for details."
    });

    private isAzureTable: KnockoutObservable<boolean>;
    private idempotencyDateColumnSelect: ValidatedSelectBoxViewModel<string>;
    private idempotencyBinaryColumnSelect: ValidatedSelectBoxViewModel<string>;
    private inputTable: IADFInputTable;
    private destinationViewModel: DataNavModel;
    private existingTable: FormFields.ValidatedSelectBoxViewModel<string>;
    private storedProcName: FormFields.ValidatedBoxViewModel<string>;
    private storedProcTableType: FormFields.ValidatedBoxViewModel<string>;
    private sourceOptions: ISourceColumnOption[] = [];
    private storedProcText: KnockoutComputed<string>;
    /* tslint:disable:no-unused-variable */
    private syncMethods = SyncMethods;
    /* tslint:enable:no-unused-variable */
    private candidateIdempotencyColumn: KnockoutComputed<string>;
    // private autoselectedDateTimeColumnMessage = ko.observable<string>();
    private generatedCleanupScript: KnockoutComputed<string>;
    private customCleanupScript = ko.observable("$$Text.Format('delete myTable where myColumn >= \\'{0:yyyy-MM-dd HH:mm}\\' AND myColumn < \\'{1:yyyy-MM-dd HH:mm}\\'', WindowStart, WindowEnd");
    private destinationDateColumns = ko.observableArray<FormFields.IOption>();
    private destinationBinaryColumns = ko.observableArray<FormFields.IOption>();
    private useStoredProcedure = ko.observable(false);
    private createNewTableSupported = ko.observable(false);
    private storedProcSupported = ko.observable(false);
    private isPreviewSchemaTableVisible: KnockoutComputed<boolean>;
    private exisingTableMappingError: KnockoutComputed<boolean>;
    private tableMappingValid: KnockoutComputed<boolean>;
    private columnMappingWarning: KnockoutComputed<boolean>;
    private idSprocCheckbox: string;
    private loadingColumnMappings = ko.observable(false);
    private azureTableSyncViewModel: AzureTableSyncViewModel;
    private useExistingTable = ko.computed(() => {
        return this.syncMethodFormField.value() === SyncMethods.existingTable;
    });

    /* tslint:disable:no-unused-variable */
    private syncMethodToggleLinkText = ko.computed(() => {
        /* tslint:enable:no-unused-variable */
        return this.useExistingTable() ? "Specify new table" : "Use existing table";
    });

    private newTableName = new FormFields.ValidatedBoxViewModel<string>({
        label: "New table name",
        visible: ko.computed(() => !this.useExistingTable())
    });

    public addSPParameter() {
        this.storedProcParameters.push({
            name: ko.observable<string>(),
            type: ko.observable<string>(),
            value: ko.observable<string>()
        });
    }

    public removeSPParameter(parameter: Common.IStoredProcParameter) {
        this.storedProcParameters.remove(parameter);
    }

    public getAzureTableSinkProperties(): Common.IAzureTableSinkProperties {
        if (this.azureTableSyncViewModel) {
            return this.azureTableSyncViewModel.getProperties();
        } else {
            return undefined;
        }
    }

    public onColumnMappingLoaded() {
        if (this.isAzureTable() && this.syncMethodFormField.value() === SyncMethods.newTable) {
            let startIndex = 0;
            let mappings: IColumnMapping[] = [];

            if (this.inputTable.dataType === DataTypeConstants.azureTable) {
                startIndex = 3;
            }
            for (let i = startIndex; i < this.inputTable.columns.length; i++) {
                /* tslint:disable:no-var-keyword */
                var entry: IColumnMapping = {
                    /* tslint:enable:no-var-keyword */
                    copy: ko.observable(true),
                    destinationColumn: this.inputTable.columns[i],
                    destinationColumnDisplayText: columnToText(this.inputTable.columns[i]),
                    sourceColumnName: ko.observable(this.inputTable.columns[i].name),
                    warning: undefined
                };
                entry.warning = ko.computed(() => {
                    return entry.copy() && !entry.sourceColumnName();
                });
                mappings.push(entry);
            }
            this.columnMappings(mappings);
        }
    }

    /* tslint:disable:no-unused-variable */
    private toggleSyncMethod() {
        /* tslint:enable:no-unused-variable */
        if (this.useExistingTable()) {
            this.syncMethodFormField.value(SyncMethods.newTable);
        } else {
            this.syncMethodFormField.value(SyncMethods.existingTable);
        }
    }

    private getConfigEntry() {
        if (this.destinationViewModel.dataType()) {
            return Configuration.copyConfig[this.destinationViewModel.dataType()];
        } else {
            return undefined;
        }
    }

    constructor(input: IADFInputTable, destinationViewModel: DataNavModel) {
        this.idSprocCheckbox = "usesprocid" + DestinationTableViewModel.id++;
        this.inputTable = input;

        this.destinationViewModel = destinationViewModel;
        if (Configuration.copyConfig[this.destinationViewModel.dataType()].createSupported) {
            this.createNewTableSupported(true);
            this.sqlSyncMethods.unshift({ displayText: "New table", value: SyncMethods.newTable });
        }

        if (Configuration.copyConfig[this.destinationViewModel.dataType()].storedProcEgress) {
            this.storedProcSupported(true);
        }

        this.useStoredProcedure.subscribe(useSP => {
            this.syncMethodFormField.value(useSP ? SyncMethods.storedProcedure : SyncMethods.existingTable);
        });

        this.existingTable = new FormFields.ValidatedSelectBoxViewModel<string>(this.destinationViewModel.tableListOptions, {
            label: "Select table",
            visible: this.useExistingTable
        });

        this.sourceOptions.push({ value: "", displayText: "-Select a column-", isAutoIncrementing: false });
        this.inputTable.columns.forEach(column => {
            this.sourceOptions.push({ value: column.name, displayText: columnToText(column), isAutoIncrementing: column.isAutoIncrementing });
        });

        this.idempotencyDateColumnSelect = new ValidatedSelectBoxViewModel<string>(this.destinationDateColumns,
            { label: "Select date-time column", infoBalloon: "Column that will be used for generating cleanup script", validations: [requiredValidation], required: true });

        this.idempotencyBinaryColumnSelect = new ValidatedSelectBoxViewModel<string>(this.destinationBinaryColumns,
            {
                label: "Select slice identifier column", infoBalloon: "Column that identifies a slice. This column must be of data type binary(32).",
                validations: [requiredValidation], required: true
            });

        this.newTableName.value("Table" + DestinationTableViewModel.id);
        let tableNameAvailableValidation = (name: string) => {
            return this.destinationViewModel.tablesLoadedDefered.promise.then(() => {
                let mathcingTables = this.destinationViewModel.tableList().filter(tbl => tbl.data.tableName.toLowerCase() === name.toLowerCase());
                if (mathcingTables.length > 0) {
                    return {
                        valid: false,
                        message: `Table '${name}' already exists`
                    };
                } else {
                    return {
                        valid: true,
                        message: ""
                    };
                }
            });
        };
        this.newTableName.setValidation([Common.requiredValidation, tableNameAvailableValidation]);
        this.newTableName.validationEnabled(true);
        this.idempotencyDateColumnSelect.value(this.inputTable.dateColumnName);

        this.selectedTable = ko.computed(() => {
            return this.syncMethodFormField.value() === SyncMethods.newTable ? this.newTableName.value() : this.existingTable.value();
        });

        this.isPreviewSchemaTableVisible = ko.computed(() => {
            return this.syncMethodFormField.value() === this.syncMethods.existingTable && this.existingTable.value() !== "";
        });

        this.exisingTableMappingError = ko.computed(() => {
            return this.syncMethodFormField.value() === SyncMethods.existingTable && !this.existingTable.value() ||
                this.syncMethodFormField.value() === SyncMethods.storedProcedure && !this.storedProcName.value();
        });

        this.columnMappingWarning = ko.computed(() => {
            return this.columnMappings().filter(cm => cm.warning()).length > 0;
        });

        ko.computed(() => {
            if (this.syncMethodFormField.value() === SyncMethods.existingTable) {
                this.idempotencyMethod.value(undefined);
            }
        });

        this.storedProcName = new FormFields.ValidatedBoxViewModel<string>({
            label: "Stored procedure name",
            infoBalloon: "Name of the stored procedure that will be used to write data to the destination.",
            defaultValue: ""
        });

        this.storedProcTableType = new FormFields.ValidatedBoxViewModel<string>({
            label: "Stored procedure table type",
            infoBalloon: "Table type used by stored procedure",
            defaultValue: ""
        });

        this.storedProcText = ko.computed(() => {
            return "Stored procedure: " + this.storedProcName.value();
        });

        this.isAzureTable = ko.observable(destinationViewModel.dataType() === DataTypeConstants.azureTable);
        this.syncMethodFormField.value(this.isAzureTable() ? SyncMethods.newTable : SyncMethods.existingTable);

        if (this.isAzureTable()) {
            let availableDestinationColumns = ko.observableArray<FormFields.IOption>();
            ko.computed(() => {
                availableDestinationColumns.removeAll();
                this.columnMappings().filter(m => m.copy()).forEach(mapping => {
                    availableDestinationColumns.push({ value: mapping.destinationColumn.name, displayText: mapping.destinationColumn.name });
                });
            });
            this.azureTableSyncViewModel = new AzureTableSyncViewModel(availableDestinationColumns);
        }

        // automap table
        this.destinationViewModel.tablesLoadedDefered.promise.then(() => {
            let matchingTables = this.destinationViewModel.tableList().filter(t => t.data.tableName === this.inputTable.sqlTableName);
            if (matchingTables.length > 0) {
                this.existingTable.value(matchingTables[0].data.tableName);
            }
        });

        let loadPreviewAndSchema = (tableName: string): Q.Promise<void> => {
            let matchingTables = this.destinationViewModel.tableList().filter(t => t.data.tableName === tableName);
            if (matchingTables.length > 0) {
                return this.destinationViewModel.getPreviewAndSchema(matchingTables[0].data);
            } else {
                return undefined;
            }
        };
        /* tslint:disable:align */
        let loadSchema = (tableName: string): Q.Promise<void> => {
            let matchingTables = this.destinationViewModel.tableList().filter(t => t.data.tableName === tableName);
            if (matchingTables.length > 0) {
                let destTableAndColumns = matchingTables[0].data;
                this.destinationDateColumns.removeAll();
                this.destinationBinaryColumns.removeAll();
                this.columnMappings.removeAll();
                this.loadingColumnMappings(true);
                this.destinationViewModel.getSchema(destTableAndColumns).then(() => {
                    if (destTableAndColumns.tableName === this.existingTable.value()) {
                        let columnMappings: IColumnMapping[] = [];
                        // Skipping 0 because 0 is '--None--'
                        let sourceSelectIndex = 1;
                        // If source and destination tables are identiacal, then source autoincrementing column
                        // should be skipped when mapping, otherwise it should not
                        let skipSourceAutoincrementColumnWhenMapping = true;
                        if (this.sourceOptions.filter(o => o.isAutoIncrementing).length === destTableAndColumns.columns().filter(c => c.isAutoIncrementing).length &&
                            this.sourceOptions.length - 1 === destTableAndColumns.columns().length) {
                            skipSourceAutoincrementColumnWhenMapping = false;
                        }

                        destTableAndColumns.columns().forEach((column, index) => {
                            // Azure table has 3 columns that cannot be mapped into directly: PartitionKey, RowKey and Timestamp
                            if (this.isAzureTable() && index < 3) {
                                return;
                            }
                            if (!column.isAutoIncrementing) {
                                let entry: IColumnMapping = {
                                    destinationColumn: column,
                                    destinationColumnDisplayText: columnToText(column),
                                    sourceColumnName: ko.observable<string>(),
                                    copy: ko.observable(true),
                                    warning: undefined
                                };

                                entry.warning = ko.computed(() => {
                                    return entry.copy() && !entry.sourceColumnName();
                                });

                                while (!skipSourceAutoincrementColumnWhenMapping && sourceSelectIndex < this.sourceOptions.length && this.sourceOptions[sourceSelectIndex].isAutoIncrementing) {
                                    sourceSelectIndex++;
                                }

                                // match columns by order
                                if (sourceSelectIndex < this.sourceOptions.length) {
                                    entry.sourceColumnName(this.sourceOptions[sourceSelectIndex].value);
                                }

                                columnMappings.push(entry);
                                if (column.type === NetTypes.dateTime) {
                                    this.destinationDateColumns.push({ value: column.name, displayText: column.name });
                                }
                                if (column.type === NetTypes.byteArray) {
                                    this.destinationBinaryColumns.push({ value: column.name, displayText: column.name });
                                }
                                sourceSelectIndex++;
                            }
                        });
                        if (this.destinationBinaryColumns.length === 0) {
                            this.destinationBinaryColumns.push({ value: "", displayText: "No slice identifier column found" });
                        }
                        if (this.destinationDateColumns.length === 0) {
                            this.destinationDateColumns.push({ value: "", displayText: "No date-time columns found" });
                        }
                        this.columnMappings(columnMappings);
                    }
                }).finally(() => {
                    this.loadingColumnMappings(false);
                });
            } else {
                return null;
            };
        };
        /* tslint:enable:align */

        this.existingTable.value.subscribe(tableName => {
            loadSchema(tableName);
        });

        ko.computed(() => {
            if (this.expandedInTableMappingList() && this.existingTable.value()) {
                loadPreviewAndSchema(this.existingTable.value());
            }
        });

        this.candidateIdempotencyColumn = ko.computed(() => {
            if (this.inputTable.dateColumnName) {
                let targetMapping = this.columnMappings().filter(cm => cm.sourceColumnName() === this.inputTable.dateColumnName);

                if (targetMapping.length !== 1) {
                    return undefined;
                } else {
                    let candidateColumn = targetMapping[0].destinationColumn;
                    if (candidateColumn.type === NetTypes.dateTime) {
                        this.idempotencyMethod.value(IdempotencyMethods.script);
                        this.idempotencyDateColumnSelect.value(candidateColumn.name);
                        return candidateColumn.name;
                    }
                }
            }
            return undefined;
        });

        ko.computed(() => {
            if (this.candidateIdempotencyColumn() && this.candidateIdempotencyColumn() === this.idempotencyDateColumnSelect.value()) {
                // this.autoselectedDateTimeColumnMessage("Date time column has been selected automatically based on source column");
            } else {
                // this.autoselectedDateTimeColumnMessage("");
            }
        });

        this.generatedCleanupScript = ko.computed(() => {
            let configEntry = this.getConfigEntry();
            let startQuote = (configEntry && configEntry.tableColumnNameQuoteCharaters && configEntry.tableColumnNameQuoteCharaters[0]) || "";
            let endQuote = (configEntry && configEntry.tableColumnNameQuoteCharaters && configEntry.tableColumnNameQuoteCharaters[1]) || "";
            let tableName = this.existingTable.value();
            if (tableName) {
                let tmp = "";
                tableName.split(".").forEach(n => {
                    tmp += `${startQuote}${n}${endQuote}.`;
                });
                tableName = tmp.substring(0, tmp.length - 1);
            }
            return `$$Text.Format('delete ${tableName} where ${startQuote}${this.idempotencyDateColumnSelect.value()}${endQuote} >= \\'{0:yyyy-MM-dd HH:mm}\\' ` +
                `AND ${startQuote}${this.idempotencyDateColumnSelect.value()}${endQuote} <\\'{1:yyyy-MM-dd HH:mm}\\'', WindowStart, WindowEnd)`;
        });

        this.resultingSliceIdentifier = ko.computed(() => {
            return this.idempotencyMethod.value() === IdempotencyMethods.column ? this.idempotencyBinaryColumnSelect.value() : undefined;
        });

        this.resultingCleanupScript = ko.computed(() => {
            if (this.idempotencyMethod.value() === IdempotencyMethods.script) {
                return this.generatedCleanupScript();
            } else if (this.idempotencyMethod.value() === IdempotencyMethods.customScript) {
                return this.customCleanupScript();
            } else {
                return undefined;
            }
        });

        this.resultingStoredProc = ko.computed(() => {
            return this.syncMethodFormField.value() === SyncMethods.storedProcedure ? this.storedProcName.value() : undefined;
        });

        this.resultingStoredProcTableType = ko.computed(() => {
            return this.syncMethodFormField.value() === SyncMethods.storedProcedure ? this.storedProcTableType.value() : undefined;
        });

        this.resultingSchema = ko.computed(() => {
            return this.columnMappings().filter(mapping => mapping.copy()).map(mapping => mapping.destinationColumn);
        });

        this.translation = ko.computed(() => {
            let translateMappings = this.columnMappings().filter(mapping => mapping.copy());

            return translateMappings.map(tMapping => <Common.ITranslation>{
                source: tMapping.sourceColumnName(),
                destination: tMapping.destinationColumn.name
            });

        });

        this.tableMappingValid = ko.computed(() => {
            if (this.useExistingTable()) {
                return !this.exisingTableMappingError();
            } else {
                return this.newTableName.valid();
            }
        });

        this.tableMappingValidateable = {
            isValid: () => {
                if (this.useExistingTable()) {
                    return Q({ valid: !this.exisingTableMappingError(), message: "Table not selected" });
                } else {
                    return this.newTableName.isValid();
                }
            },
            valid: this.tableMappingValid
        };
        this.columnMappingValidateable = Common.syncronousValidateable(ko.computed(() => !this.columnMappingWarning()), "One or more columns are not mapped");
    }
}
