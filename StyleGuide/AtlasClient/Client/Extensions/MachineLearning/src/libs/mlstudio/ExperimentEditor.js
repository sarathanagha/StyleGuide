var ExperimentEditor;(function (ExperimentEditor) {ExperimentEditor._allExperimentsMarkup = "<div id=\"experiments\">    <div id=\"grid\"></div>    <div id=\"previewPane\">        <div id=\"thumbnailContainer\" data-bind=\"visible: pageLoaded\">        <!-- ko ifnot: selectedItems().length !== 1 -->        <!-- ko template: { name: 'experimentSvgTemplate', data: thumbnail, if: thumbnail } --><!-- /ko -->        <div class=\"spinner\" data-bind=\"css: { thumbnailLoading: loading() }\"></div>        <div class=\"shield\"></div>        <!-- /ko -->        <!-- ko if: selectedItems().length !== 1 -->        <div class=\"selection-info\">            <span data-bind=\"text: itemsSelectedMessage\"></span>        </div>        <!-- /ko -->    </div>    </div></div>"})(ExperimentEditor || (ExperimentEditor = {}));ExperimentEditor.typescriptResourceVariables = ExperimentEditor.typescriptResourceVariables || []; ExperimentEditor.typescriptResourceVariables.push("ExperimentEditor._allExperimentsMarkup");
var ExperimentEditor;(function (ExperimentEditor) {ExperimentEditor._apiCodeDialogMarkup = "<p class=\"aux-dialogHeader\" data-bind=\"text: DataLab.LocalizedResources.apiCodeDialogTopText\"></p><p class=\"aux-dialogSubHeader\" data-bind=\"text: DataLab.LocalizedResources.apiCodeDialogTitle\"></p><div class=\"api-code-dialog\">    <p><span data-bind=\"text: DataLab.LocalizedResources.apiCodeDialogWelcomeMessage\"></span><a href=\" http://go.microsoft.com/fwlink/?LinkId=524527\" target=\"_blank\">Learn More.</a></p>    <div class=\"dialog-warning\" data-bind=\"text: DataLab.LocalizedResources.apiCodeDialogTokenWarning\"></div>    <br />        <label id=\"long-code-label\" for=\"long-code-text\" data-bind=\"text: DataLab.LocalizedResources.apiCodeDialogLongCodeLabel\"></label>    <ul class=\"language\">        <li>Python</li>    </ul>    <textarea id=\"long-code-text\" data-bind=\"value: longCode\" readonly=\"readonly\" rows=\"13\" style=\"width: 100%\"></textarea>    <label><input data-bind=\"checked: useSecondaryToken, visible: !showExtraHelp\" type=\"checkbox\" /><span data-bind=\"text: DataLab.LocalizedResources.apiCodeDialogUseSecondaryTokenLabel, visible: !showExtraHelp\"></span></label>        <a href=\" http://go.microsoft.com/fwlink/?LinkId=524830\" target=\"_blank\" data-bind=\"visible: showExtraHelp\"> Why is my workspace token unavailable?</a></div><!--See ApiCodeDialogViewModel.ts for the JavaScript code that shouldbe executed as part of this dialog. DialogView does not support usingJS within templates.-->"})(ExperimentEditor || (ExperimentEditor = {}));ExperimentEditor.typescriptResourceVariables = ExperimentEditor.typescriptResourceVariables || []; ExperimentEditor.typescriptResourceVariables.push("ExperimentEditor._apiCodeDialogMarkup");
var ExperimentEditor;(function (ExperimentEditor) {ExperimentEditor._columnPickerMarkup = "<div class=\"columnPicker\">    <h1 data-bind=\"text: singleColumnSelection() ? DataLab.LocalizedResources.singleColumnSelectHeading : DataLab.LocalizedResources.multipleColumnSelectHeading\"></h1>    <flexfill style=\"min-height: 210px\">        <flexcontent class=\"ruleSection\">            <!-- ko if: !singleColumnSelection() -->                <input id=\"AllowDuplicatesCheckbox\" type=\"checkbox\" data-bind=\"checked: allowDuplicates\" />                <label for=\"AllowDuplicatesCheckbox\" data-bind=\"text: DataLab.LocalizedResources.allowDuplicatesInSelectionLabel\"></label>            <!-- /ko -->            <div class=\"ruleTable\">                <!-- ko if: !allowDuplicates() && !singleColumnSelection() -->                <hflexbox class=\"ruleRow\">                    <flexstatic>                        <label for=\"RulesStartingChoice\" data-bind=\"text: DataLab.LocalizedResources.rulesStartingChoiceLabel\"></label>                        <select id=\"RulesStartingChoice\" class=\"startingChoice\" data-bind=\"options: startingChoices, value: startingChoice, optionsText: 'name'\"></select>                    </flexstatic>                </hflexbox>                <!-- /ko -->                <!-- ko foreach: visibleRules -->                <hflexbox class=\"ruleRow\" data-bind=\"validate: { value:  isFirstRule }\">                    <flexstatic>                        <select class=\"ruleCategoryChoice\" data-bind=\"options: ruleCategoryChoices, value: ruleCategory, optionsText: 'name', optionsValue: 'exclude', oninit: setWidthToStartingChoiceLabelWidth \"></select>                        <select class=\"ruleTypeChoice\" data-bind=\"options: ruleChoices, value: ruleType, optionsText: 'name'\"></select>                    </flexstatic>                    <!-- ko if: ruleType().id === \"ColumnNames\" -->                    <hflexbox class=\"columnNameList\" data-bind=\"validate: { value: currentColumn }, click: setNameInputFocused, css: {hasItems: selectedColumns().length > 0 || invalidColumns().length > 0}\">                        <!-- ko foreach: selectedColumns -->                        <flexstatic class=\"columnNameBox\">                            <span data-bind=\"text: $data\"></span>                            <span class=\"removeColumnName\" data-bind=\"click: $parent.removeColumnName\"></span>                        </flexstatic>                        <!-- /ko -->                        <!-- ko foreach: invalidColumns -->                        <flexstatic class=\"columnNameBoxInvalid\">                            <span data-bind=\"text: $data\"></span>                            <span class=\"removeColumnName\" data-bind=\"click: $parent.removeInvalidColumnName\"></span>                        </flexstatic>                        <!-- /ko -->                        <flexfill>                        <!-- ko if: $parent.hasSchema -->                        <input type=\"text\" class=\"itemTextBoxInput\" data-bind=\"hasfocus: nameInputFocused, attr: { placeholder: placeholderText }, style: { 'minWidth': selectedColumns().length === 0 ? '250px' : '50px' }, itemTextBox: { validColumnNames: selectedColumns, invalidColumnNames: invalidColumns }, columnPickerAutocomplete: { array: $parent.autocompleteArray, dependentObservable: currentColumn, allowAnyEntry: $parent.schemaIsInaccurate }\" />                        <!-- /ko -->                        <!-- ko ifnot: $parent.hasSchema -->                        <input type=\"text\" class=\"itemTextBoxInput\" data-bind=\"hasfocus: nameInputFocused, attr: { placeholder: placeholderText }, style: { 'minWidth': selectedColumns().length === 0 ? '250px' : '50px' }, itemTextBox: { validColumnNames: selectedColumns, invalidColumnNames: invalidColumns }, value: currentColumn\" />                        <!-- /ko -->                        </flexfill>                        <div class=\"textWidthSpan\"></div>                    </hflexbox>                    <!-- /ko -->                    <!-- ko if: ruleType().id === \"ColumnIndexes\" -->                    <input class=\"columnIndicesInput\" type=\"text\" placeholder=\"Enter column indices\" data-bind=\"value: indexList, validatedInputBox: { value: indexList } \" />                    <!-- /ko -->                    <!-- ko if: ruleType().id === \"ColumnTypes\" -->                    <select class=\"columnAttributeDropDown\" data-bind=\"options: typeChoices, selectedOptions: columnTypes\"></select>                        <!-- ko if: hasKinds() -->                        <span style=\"padding: 4px;\">%ColumnPickerColumnsThatAre%</span>                        <select class=\"columnAttributeDropDown\" data-bind=\"options: kindChoices, selectedOptions: columnKinds\"></select>                        <!-- /ko -->                    <!-- /ko -->                    <flexstatic class=\"buttonBox\" data-bind=\"visible: $parent.allowMultipleRules\">                        <input style=\"width: 20px;\" type=\"button\" value=\"+\" data-bind=\"click: function(data, event) { $parent.createNewRule(data, true) }, enable: !$parent.allowDuplicates()\" />                        <input style=\"width: 20px;\" type=\"button\" value=\"-\" data-bind=\"click: function(data, event) { $parent.removeRule(data) }, enable: $parent.rules().length > 1\" />                    </flexstatic>                </hflexbox>                <!-- /ko -->            </div>        </flexcontent>    </flexfill>    <flexstatic>        <hflexbox>            <flexfill></flexfill>            <flexstatic class=\"icon tick\" data-bind=\"click: function(data, event) { if (!hasErrors()) { saveRulesAndClose()} }\"></flexstatic>         </hflexbox>    </flexstatic></div>"})(ExperimentEditor || (ExperimentEditor = {}));ExperimentEditor.typescriptResourceVariables = ExperimentEditor.typescriptResourceVariables || []; ExperimentEditor.typescriptResourceVariables.push("ExperimentEditor._columnPickerMarkup");
var ExperimentEditor;(function (ExperimentEditor) {ExperimentEditor._columnPickerLegacyMarkup = "<div class=\"columnPicker\">    <h1 data-bind=\"text: singleColumnSelection() ? DataLab.LocalizedResources.singleColumnSelectHeading : DataLab.LocalizedResources.multipleColumnSelectHeading\"></h1>    <flexfill style=\"min-height: 210px\">        <flexcontent class=\"ruleSection\">            <!-- ko if: !singleColumnSelection() -->                <input id=\"AllowDuplicatesCheckbox\" type=\"checkbox\" data-bind=\"checked: allowDuplicates\" />                <label for=\"AllowDuplicatesCheckbox\" data-bind=\"text: DataLab.LocalizedResources.allowDuplicatesInSelectionLabel\"></label>            <!-- /ko -->            <div class=\"ruleTable\">                <!-- ko foreach: rules -->                <hflexbox class=\"ruleRow\" data-bind=\"validate: { value: firstRule }\">                    <flexstatic>                        <select class=\"ruleTypeChoice\" data-bind=\"options: $root.ruleChoices, value: ruleType, optionsText: 'name', columnSelectionEnabledOptions: ruleChoicesObservable\"></select>                    </flexstatic>                    <!-- ko if: ruleType().id === \"ColumnNames\" -->                    <div class=\"columnNameList\" data-bind=\"validate: { value: currentColumn }, click: setNameInputFocused\">                        <!-- ko foreach: selectedColumns -->                        <span class=\"columnNameBox\">                            <span data-bind=\"text: $data\"></span>                            <span class=\"removeColumnName\" data-bind=\"click: $parent.removeColumnName\"></span>                        </span>                        <!-- /ko -->                        <!-- ko foreach: invalidColumns -->                        <span class=\"columnNameBoxInvalid\">                            <span data-bind=\"text: $data\"></span>                            <span class=\"removeColumnName\" data-bind=\"click: $parent.removeInvalidColumnName\"></span>                        </span>                        <!-- /ko -->                        <!-- ko if: $parent.hasSchema -->                        <input type=\"text\" class=\"itemTextBoxInput\" data-bind=\"hasfocus: nameInputFocused, attr: { placeholder: selectedColumns().length === 0 ? DataLab.LocalizedResources.pressEnterColumnName : '' }, style: { 'minWidth': selectedColumns().length === 0 ? '250px' : '50px' }, itemTextBox: { validColumnNames: selectedColumns, invalidColumnNames: invalidColumns }, columnPickerAutocomplete: { array: $root.autocompleteArray, dependentObservable: currentColumn }\" />                        <!-- /ko -->                        <!-- ko ifnot: $parent.hasSchema -->                        <input type=\"text\" class=\"itemTextBoxInput\" data-bind=\"hasfocus: nameInputFocused, attr: { placeholder: selectedColumns().length === 0 ? DataLab.LocalizedResources.pressEnterColumnName : '' }, style: { 'minWidth': selectedColumns().length === 0 ? '250px' : '50px' }, itemTextBox: { validColumnNames: selectedColumns, invalidColumnNames: invalidColumns }, value: currentColumn\" />                        <!-- /ko -->                        <div class=\"textWidthSpan\"></div>                    </div>                    <!-- /ko -->                    <!-- ko if: ruleType().id === \"ColumnIndexes\" -->                    <input class=\"columnIndicesInput\" type=\"text\" placeholder=\"Enter column indices\" data-bind=\"value: indexList, validatedInputBox: { value: indexList } \" />                    <!-- /ko -->                    <!-- ko if: ruleType().id === \"ColumnTypes\" -->                    <select class=\"columnAttributeDropDown\" data-bind=\"options: $root.typeChoices, selectedOptions: columnTypes\"></select>                    <span style=\"padding: 4px;\">that are</span>                    <select class=\"columnAttributeDropDown\" data-bind=\"options: $root.kindChoices, selectedOptions: columnKinds\"></select>                    <!-- /ko -->                    <flexstatic class=\"buttonBox\" data-bind=\"visible: $parent.allowMultipleRules\">                        <input style=\"width: 20px;\" type=\"button\" value=\"+\" data-bind=\"click: function(data, event) { $parent.addRule(data) }, enable: !$parent.allowDuplicates()\" />                        <input style=\"width: 20px;\" type=\"button\" value=\"-\" data-bind=\"click: function(data, event) { $parent.removeRule(data) }, enable: $parent.rules().length > 1\" />                    </flexstatic>                </hflexbox>                <!-- /ko -->            </div>        </flexcontent>    </flexfill>    <flexstatic>        <hflexbox>            <flexfill></flexfill>            <flexstatic class=\"icon tick\" data-bind=\"click: function(data, event) { if (!hasErrors()) { saveRulesAndClose()} }\"></flexstatic>         </hflexbox>    </flexstatic></div>"})(ExperimentEditor || (ExperimentEditor = {}));ExperimentEditor.typescriptResourceVariables = ExperimentEditor.typescriptResourceVariables || []; ExperimentEditor.typescriptResourceVariables.push("ExperimentEditor._columnPickerLegacyMarkup");
var ExperimentEditor;(function (ExperimentEditor) {ExperimentEditor._confirmationDialogMarkup = "<h2 data-bind=\"text: title\"></h2><p data-bind=\"text: text\"></p>"})(ExperimentEditor || (ExperimentEditor = {}));ExperimentEditor.typescriptResourceVariables = ExperimentEditor.typescriptResourceVariables || []; ExperimentEditor.typescriptResourceVariables.push("ExperimentEditor._confirmationDialogMarkup");
var ExperimentEditor;(function (ExperimentEditor) {ExperimentEditor._copyExperimentDialogMarkup = "<h2>%copyExperimentDialogCopyExperiment%</h2><label>%copyExperimentDialogExperimentName%</label><input type=\"text\" data-bind=\"validatedInputBox: { value: experimentName }\" /> <label>%copyExperimentDialogDestinationWorkspace%</label><select data-bind=\"options: workspaces, optionsText: 'FriendlyName', value: destinationWorkspace, visible: workspaceInfoAvailable\"></select><div class=\"copy-experiment-noWorkspaces\" data-bind=\"visible: !workspaceInfoAvailable()\">%copyExperimentDialogWorkspaceInfoNotAvailable%</div>            <div class=\"dialog-warning copy-experiment-warning\" >%copyExperimentDialogCopyExperimentWarning%</div>"})(ExperimentEditor || (ExperimentEditor = {}));ExperimentEditor.typescriptResourceVariables = ExperimentEditor.typescriptResourceVariables || []; ExperimentEditor.typescriptResourceVariables.push("ExperimentEditor._copyExperimentDialogMarkup");
var ExperimentEditor;(function (ExperimentEditor) {ExperimentEditor._copyExperimentFromGalleryDialogMarkup = "<h2>%copyExperimentFromGalleryConfirmationTitle%</h2><label>%copyExperimentFromGalleryDialogDestinationWorkspace%</label><select data-bind=\"options: workspaces, optionsText: 'displayName', value: destinationWorkspace, visible: workspaceInfoAvailable\"></select><div class=\"copy-experiment-noWorkspaces\" data-bind=\"visible: !workspaceInfoAvailable()\">%copyExperimentDialogWorkspaceInfoNotAvailable%</div>"})(ExperimentEditor || (ExperimentEditor = {}));ExperimentEditor.typescriptResourceVariables = ExperimentEditor.typescriptResourceVariables || []; ExperimentEditor.typescriptResourceVariables.push("ExperimentEditor._copyExperimentFromGalleryDialogMarkup");
var ExperimentEditor;(function (ExperimentEditor) {ExperimentEditor._createWebServiceGraphFromTrainedModelDialogMarkup = "<h2>Create Web Service</h2><div>    <div>        <label for=\"create-web-service-name\" data-bind=\"text: '%createWebServiceGraphNameLabel%'\"></label>        <input id=\"create-web-service-name\" type=\"text\" data-bind=\"value: name\" />    </div>    <div>        <label for=\"create-web-service-description\" data-bind=\"text: '%createWebServiceGraphDescriptionLabel%'\"></label>        <textarea rows=\"4\" id=\"create-web-service-description\" data-bind=\"value: description\" />    </div>        <div style=\"color: gray\" data-bind=\"text: 'createWebServiceGraphTrainedModelCopyText'\">    </div></div>"})(ExperimentEditor || (ExperimentEditor = {}));ExperimentEditor.typescriptResourceVariables = ExperimentEditor.typescriptResourceVariables || []; ExperimentEditor.typescriptResourceVariables.push("ExperimentEditor._createWebServiceGraphFromTrainedModelDialogMarkup");
var ExperimentEditor;(function (ExperimentEditor) {ExperimentEditor._createWebServiceGraphFromTransformDialogMarkup = "<h2>Create Web Service</h2><div>    <div>        <label for=\"create-web-service-name\" data-bind=\"text: '%createWebServiceGraphNameLabel%'\"></label>        <input id=\"create-web-service-name\" type=\"text\" data-bind=\"value: name\" />    </div>    <div>        <label for=\"create-web-service-description\" data-bind=\"text: '%createWebServiceGraphDescriptionLabel%'\"></label>        <textarea rows=\"4\" id=\"create-web-service-description\" data-bind=\"value: description\" />    </div>        <div style=\"color: gray\" data-bind=\"text: 'createWebServiceGraphTransformCopyText'\">    </div></div>"})(ExperimentEditor || (ExperimentEditor = {}));ExperimentEditor.typescriptResourceVariables = ExperimentEditor.typescriptResourceVariables || []; ExperimentEditor.typescriptResourceVariables.push("ExperimentEditor._createWebServiceGraphFromTransformDialogMarkup");
var ExperimentEditor;(function (ExperimentEditor) {ExperimentEditor._disabledFeatureDialogMarkup = "<div class=\"trial-dialog\">    <h1 class=\"dialog-title\" data-bind=\"text: title\"></h1>    <div class=\"dialog-description\" data-bind=\"foreach: description\">        <p data-bind=\"html: $data\"></p>    </div>    <div class=\"dialog-button-container\">        <button class=\"dialog-green-button dialog-button-left\" data-bind=\"click: signIn\">%trialDialogSignInNow%</button>        <button class=\"dialog-gray-button dialog-button-right autofocus\" data-bind=\"click: dismiss\">%trialDialogReturnToTrial%</button>    </div>    <!-- ko with: link -->    <a class=\"dialog-link\" style=\"font-size: 10px\" href=\"#\" target=\"_blank\" data-bind=\"attr: { href: url }, text: text\"></a>    <!-- /ko --></div>"})(ExperimentEditor || (ExperimentEditor = {}));ExperimentEditor.typescriptResourceVariables = ExperimentEditor.typescriptResourceVariables || []; ExperimentEditor.typescriptResourceVariables.push("ExperimentEditor._disabledFeatureDialogMarkup");
var ExperimentEditor;(function (ExperimentEditor) {ExperimentEditor._editorSurfaceMarkup = "<script type =\"text/html\" id=\"experimentSvgTemplate\">        <svg            xmlns=\"http://www.w3.org/2000/svg\"            xmlns:xlink=\"http://www.w3.org/1999/xlink\"        data-bind=\"contextMenu: $data.menuBuilder\"            class=\"svgRoot\"            preserveAspectRatio=\"xMidYMid meet\"            width=\"100%\" height=\"100%\">            <g>            <!-- ko if: $data -->                <!-- TODO [1149812]: Bind to observable maps directly -->                                <!-- ko foreach:DataLab.Util.values(experimentViewModel().connections()) -->                <path class=\"connectionHitTest\" data-bind=\"attr:{d:path},event:{mousedown:$root.entityMouseDown,mouseup:$root.entityMouseUp}\" />                <path class=\"connection\"                      data-bind=\"attr:{class:getClassId($parent.experimentViewModel().displayFlowType()),d:path},event:{mousedown:$root.entityMouseDown,mouseup:$root.entityMouseUp}\" />                <!-- /ko -->                <!-- ko foreach:DataLab.Util.values(experimentViewModel().nodes()) -->                <g data-bind=\"attr:{class:belongsToCurrentFlow($parent.experimentViewModel().displayFlowType())?'':'disabledFlow'}\">                    <rect rx=\"10\" ry=\"10\"                          data-bind=\"attr:{class:getClassId($parent.experimentViewModel().displayFlowType()),x:x,y:y,width:width,height:height,id:'node-' + graphNode.id},contextMenu:$root.menuBuilder,event:{mousedown:$root.entityMouseDown,mouseup:$root.entityMouseUp,dblclick:$root.entityDoubleClick,mouseover:onMouseIn,mouseout:onMouseOut}\">                        <title data-bind=\"text: tooltip\"></title>                    </rect>                    <!-- ko foreach: DataLab.Util.values(inputPorts) -->                    <g class=\"portElement\" data-bind=\"attr:{transform:translation,class:getClassId($parents[1].experimentViewModel().displayFlowType()),'data-portname':portModel.name}\">                        <g data-bind=\"contextMenu:$root.menuBuilder,                                      event:{                                          mousedown:$root.entityMouseDown,                                          mouseup:$root.entityMouseUp,                                          dblclick:$root.entityDoubleClick,                                          mouseenter:showLabel,                                          mouseleave: function(data, event) {                                              if ($('.portTextLabel').length === 0) {                                                   hideLabel();                                              }                                            }                                          },                                      balloon:{message:balloonMessage}\">                            <!-- Creates a bounding box around the port circle -->                            <rect class=\"portNoHighlight\" height=\"14\" width=\"16\" x=\"-4\" y=\"-7\"></rect>                            <!-- ko if: !portModel.isInputPortForPublish() -->                            <!-- ko if: !portModel.isConnected() -->                            <circle r=\"5\" cx=\"4\" />                            <!-- /ko -->                            <!-- ko if: portModel.isConnected() -->                            <polygon points=\"-1,0 9,0 4,6\" />                            <!-- /ko -->                            <!-- /ko -->                            <!-- ko if: portModel.isInputPortForPublish() && !showFullLabel() -->                            <image data-bind=\"attrWithNamespace: { 'xlink:href': portModel.publishIcon }\" height=\"32\" width=\"32\" x=\"-12\" y=\"-16\"></image>                            <!-- /ko -->                        </g>                    </g>                    <!-- /ko -->                    <!-- ko foreach: DataLab.Util.values(outputPorts) -->                    <g data-bind=\"attr:{transform:translation,class:getClassId($parents[1].experimentViewModel().displayFlowType()),'data-portname':portModel.name}\">                        <g data-bind=\"contextMenu:$root.menuBuilder,                                      event:{                                          mousedown:$root.entityMouseDown,                                          mouseup:$root.entityMouseUp,                                          dblclick:$root.entityDoubleClick,                                          mouseenter:showLabel,                                          mouseleave:function(data, event) {                                            if ($('.portTextLabel').length === 0) {                                                 hideLabel();                                            }                                          }                                      },                                      balloon:{message:balloonMessage}\">                            <!-- Creates a bounding box around the port circle -->                            <rect class=\"portNoHighlight\"                                  height=\"14\"                                  width=\"16\"                                  x=\"-4\"                                  y=\"-7\">                            </rect>                            <!-- ko if: !portModel.isOutputPortForPublish() -->                            <!-- ko if: portModel.isConnected() -->                            <circle class=\"connectedOutputPort\" r=\"5\" cx=\"4\" />                            <!-- /ko -->                            <!-- ko if: !portModel.isConnected() -->                            <circle r=\"5\" cx=\"4\" />                            <!-- /ko -->                            <!-- /ko -->                            <!-- ko if: portModel.isOutputPortForPublish() && !showFullLabel() -->                            <image data-bind=\"attrWithNamespace: { 'xlink:href': portModel.publishIcon }\" height=\"32\" width=\"32\" x=\"-12\" y=\"-16\"></image>                            <!-- /ko -->                        </g>                    </g>                    <!-- /ko -->                    <text class=\"staticText\" data-bind=\"attr:{class:textClassId,x:labelPosX,y:labelPosY}\">                        <tspan data-bind=\"truncatedText:{label:label, maxWidth:labelMaxWidth}\" />                    </text>                    <svg data-bind=\"attr: { x: iconPosX(), y: iconPosY() }\" style=\"overflow: visible\">                        <text data-bind=\"text: iconSymbol, attr: { 'class': 'graphNode-icon ' + iconClass }\" x=\"0\" y=\"0\" dy=\"25\" width=\"25\" height=\"25\"></text>                    </svg>                    <svg data-bind=\"attr: { x: x() + width() - 40, y: labelPosY() - 13 }\" class=\"nodeStatus\">                        <image data-bind=\"hoverBalloon:{                                message:balloonMessage,                                forceBalloon:forceBalloon                            },                            click: $data.nodeIconClicked,                            event:{                                mousedown:$root.entityMouseDown,                                mouseup:$root.entityMouseUp,                                dblclick:$root.entityDoubleClick                            },                            contextMenu:$root.menuBuilder,                            attrWithNamespace:{                                'xlink:href':statusIconURL                            }\"                               height=\"16\"                               width=\"16\">                        </image>                    </svg>                    <!-- ko if: hasComment() -->                    <svg data-bind=\"attr: { x: x() + width() - 20, y: labelPosY() - 10 }\" class=\"expander\">                        <text data-bind=\"click: showHideComment,                            event:{                                mousedown:$root.entityMouseDown,                                mouseup:$root.entityMouseUp                            }, text: commentCollapsedExpandedIconSymbol,                            contextMenu:$root.menuBuilder\"                               dy=\"1em\"                               height=\"10\"                               width=\"10\">                        </text>                    </svg>                    <!-- /ko -->                </g>                <!-- /ko -->            <!-- ko ifnot: $root.renderThumbnail -->                <!-- Third loop to ensure port label tooltips are painted on top of everything else -->                <!-- ko foreach:DataLab.Util.values(experimentViewModel().nodes()) -->                <!-- ko ifnot: isConnection() -->                <!-- ko foreach: DataLab.Util.values(inputPorts) -->                <!-- ko if: showFullLabel() -->                <g data-bind=\"portTextLabel: { label: portModel.friendlyName + ' (' + portTypes + ')', model: $data }, portTooltipTransform: { x:tooltipPosX, y:tooltipPosY, name: portModel.friendlyName }, event: { mouseout:hideLabel, mousedown:$root.entityMouseDown,mouseup:$root.entityMouseUp, dblclick: $root.entityDoubleClick }, contextMenu:$root.menuBuilder\" />                <!-- /ko -->                <!-- /ko -->                <!-- ko foreach: DataLab.Util.values(outputPorts) -->                <!-- ko if: showFullLabel() -->                <g data-bind=\"portTextLabel: { label: portModel.friendlyName + ' (' + portTypes + ')', model: $data }, portTooltipTransform: { x:tooltipPosX, y:tooltipPosY, name: portModel.friendlyName }, event: { mouseout:hideLabel, mousedown:$root.entityMouseDown,mouseup:$root.entityMouseUp, dblclick: $root.entityDoubleClick } , contextMenu:$root.menuBuilder\" />                <!-- /ko -->                <!-- /ko -->                <!-- /ko -->                <!-- /ko -->                <!-- ko if: stateMachine.dragging() === ExperimentEditor.DraggingMode.SelectionRect -->                <!-- ko with: selectionManager -->                <rect class=\"selectionRect\" data-bind=\"attr:{x:curX,y:curY,width:width,height:height}\"></rect>                <!-- /ko -->                <!-- /ko -->                <!-- ko with: connector -->                <!-- ko if: isPreview -->                <path class=\"connector\" fill=\"none\" pointer-events=\"none\" data-bind=\"visible:visible,attr:{d:path}\" />                <!-- /ko -->                <!-- ko ifnot: isPreview -->                <line class=\"connector\" pointer-events=\"none\" data-bind=\"visible:visible,attr:{x1:x1,y1:y1,x2:x2,y2:y2}\"></line>                <g data-bind=\"attr:{transform:translation}\" class=\"port idlePort\">                    <polygon points=\"0,0 4,7 8,0\" />                </g>                <!-- /ko -->                <!-- /ko -->            <!-- /ko -->            <!-- /ko -->            </g>                </svg></script><!-- ko ifnot: $root.renderThumbnail --><!-- ExperimentEditor control template markup --><div class=\"experimentEditorContainer\" data-bind=\"attr:{class:classId}\">    <div class=\"experimentCanvas\">        <!-- ko if: shouldShowHelpWatermark -->        <div class=\"watermarkGraph\"></div>        <span class=\"watermarkTextbox\">            %experimentEditorWatermarkText%        </span>        <!-- /ko -->        <!-- Experiment Editor SVG template start here -->        <div class=\"customElements\">            <!-- ko template: { name: 'experimentSvgTemplate', data: $data } --><!-- /ko -->        <div class=\"xe-overlay\">        <!-- Div overlay for comments -->            <!-- ko foreach:DataLab.Util.values(experimentViewModel().nodes()) -->            <div class=\"comment\" data-bind=\"attr:{class:commentClass,title:tooltip},style:{left:commentPosX, top:commentPosY,width:commentWidth},visible:!editingComment(),contextMenu:$root.menuBuilder,event:{mouseup:$root.entityMouseUp,mouseover:onMouseIn,mouseout:onMouseOut}\">                <pre class=\"text\" data-bind=\"text:commentToShow,style:{height:(linesToShow()*20+'px')},event:{mousedown:$root.entityMouseDown,dblclick:$root.entityDoubleClick}\">&nbsp;</pre>            </div>            <!-- /ko -->        </div>        </div>        <!-- This is here because text areas should behave like text areas when you click, drag and scroll -->        <div class=\"nativeElements\">            <div class=\"xe-overlay\">                <!-- ko foreach:DataLab.Util.values(experimentViewModel().nodes()) -->                <textarea class=\"comment\" data-bind=\"style:{left:commentPosX,top:commentPosY,width:commentWidth},visible:editingComment,value:comment,hasfocus:editingComment,event:{keydown:$root.commentsEventHandler}\">                </textarea>                <!-- /ko -->            </div>        </div>            </div>    <div id=\"controlPanelContainer\">        <div id=\"controlPanel\"></div>        <div id=\"displayFlowSwitch\" data-bind=\"visible:experimentViewModel().experiment.isWebServiceExperiment()\">            <div class=\"displayFlowSwitchIcon\"                 data-bind=\"css: { experimentFlow: experimentViewModel().displayFlowType() === 'experiment', webServiceFlow: experimentViewModel().displayFlowType() === 'webservice'},                            click: experimentViewModel().displayFlowToggle.bind(experimentViewModel()),                            attr: { title: experimentViewModel().displayFlowType() === 'experiment' ? '%toggleToWebServiceViewTooltip%' : '%toggleToExperimentViewTooltip%' }\"></div>        </div>    </div>    <div class=\"experiment-statusAlertsContainer\">        <div class=\"experiment-statusAlerts\" data-bind=\"text: draftSaveLabel\"></div>        <div class=\"experiment-statusAlerts\" data-bind=\"text: refreshStatusLabel\"></div>    </div></div><!-- /ko -->"})(ExperimentEditor || (ExperimentEditor = {}));ExperimentEditor.typescriptResourceVariables = ExperimentEditor.typescriptResourceVariables || []; ExperimentEditor.typescriptResourceVariables.push("ExperimentEditor._editorSurfaceMarkup");
var ExperimentEditor;(function (ExperimentEditor) {ExperimentEditor._experimentEditorMarkup = "<div class=\"experiment-container\" style=\"height: 1038px !important;\">    <div class=\"xe-utilityPanelRoot\"         style=\"display: none;\"         data-bind=\"visible: !readOnlyMode(),                    resize: {                        direction: 'right',                        parentContainerSelector: '.experiment-container',                        minSize: 254,                        id: 'palette'                    },                    collapsepanel: {                        collapseButtonSelector: '.paletteExpander',                        collapsed: paletteIsCollapsed,                        collapseFrom: 'right',                        collapsedSize: 36,                        id: 'palette'                    }\">        <div class=\"icon paletteExpander\"></div>        <div class=\"xe-paletteTitle\">%datasetsModulesTrainedModelsLabel%</div>        <div class=\"xe-paletteContent\">        <div class=\"xe-searchBox\">            <input tabindex=\"3\" type=\"text\" data-bind=\"value:searchText, valueUpdate:['input','keyup']\" placeholder=\"%palletteSearchBoxPlaceholder%\" />            <span class=\"xe-searchIcon icon-Discovery\"></span>        </div>        <div class=\"xe-utilityPanel\"></div>    </div>    </div>    <div class=\"experiment-container-right\">        <div tabindex=\"5\" class=\"xe-propertyPanel\">            <div class=\"propertyEditorRoot\"></div>        </div>        <div class=\"headerExperimentEditorContainer\">            <!-- ko if: projectViewModel.experimentVMs().length > 1 -->            <div tabindex=\"1\" class=\"project-header\">                <ul class=\"project-experiments-tabs\" id=\"project-experiments-tabs\">                    <!-- ko foreach: projectViewModel.experimentVMs() -->                    <li data-bind=\"text: roleName,                        attr: { title: roleName },                        click: navigate,                        css: { active: active(),                                inactive: !active() },                        style: { 'border-left': $index() === 0 ? '1px solid #d9d9d9' : false }\" />                    <!-- /ko -->                </ul>            </div>            <!-- /ko -->            <div tabindex=\"2\" class=\"experiment-header\" data-bind=\"style: { top: projectViewModel.experimentVMs().length > 1 ? '52px' : '0px' }\">                <input class=\"experiment-description\"                       id=\"experiment-description\"                       type=\"text\"                       placeholder=\"Enter experiment name here\"                       data-bind=\"validatedInputBox: {                                        value: experiment.description,                                        disabled: readOnlyMode                                      },                                      hasfocus: descriptionFocus,                                  visible: experimentEditorViewModel.experimentViewModel().experimentLoaded,                                      attr: { disabled: readOnlyMode }\" />                <div class=\"experiment-stateLabel\" data-bind=\"text: experimentEditorViewModel.experimentViewModel().experimentStateDisplay().statusLabel, visible: experimentEditorViewModel.experimentViewModel().experimentLoaded\"></div>                <img class=\"experiment-stateIcon\" data-bind=\"hoverBalloon: { message: experimentEditorViewModel.experimentViewModel().experimentStateDisplay().iconHoverBalloon },                                      visible: experimentEditorViewModel.experimentViewModel().experimentLoaded,                                      attr: { src: experimentEditorViewModel.experimentViewModel().experimentStateDisplay().statusIconUrl }\" />            </div>            <div tabindex=\"3\" class=\"experimentEditorRoot\" data-bind=\"style: { top: projectViewModel.experimentVMs().length > 1 ? '96px' : '44px', stopBinding: true }\"></div>        </div>    </div>    <div class=\"customUX hidden\">    </div>    <div class=\"prefetchImages\"></div></div>"})(ExperimentEditor || (ExperimentEditor = {}));ExperimentEditor.typescriptResourceVariables = ExperimentEditor.typescriptResourceVariables || []; ExperimentEditor.typescriptResourceVariables.push("ExperimentEditor._experimentEditorMarkup");
var ExperimentEditor;(function (ExperimentEditor) {ExperimentEditor._experimentSaveAsMarkup = "<div class=\"experimentSaveAsDialog\">    <h1>%experimentSaveAsDialogHeading%</h1>    <div class=\"contentDiv\">        <label class=\"enterNameLabel\">%experimentSaveAsDialogExperimentName%</label>        <div class=\"experimentNameHelpLink dlwux-sprite-icon-drawer-help\" data-bind=\"click: launchSaveAsHelp\" />        <input type=\"text\" class=\"enterField\" data-bind=\"validatedInputBox: { value: name }, attr: { placeholder: name().length===0 ? DataLab.LocalizedResources.experimentSaveAsDialogEnterHere : '' }\" style=\"font-size: 18px;\" />    </div>    <div class=\"icon customUXTick\" data-bind=\"click: saveNameAndClose\"></div> </div>"})(ExperimentEditor || (ExperimentEditor = {}));ExperimentEditor.typescriptResourceVariables = ExperimentEditor.typescriptResourceVariables || []; ExperimentEditor.typescriptResourceVariables.push("ExperimentEditor._experimentSaveAsMarkup");
var ExperimentEditor;(function (ExperimentEditor) {ExperimentEditor._expiredTrialDialogMarkup = "<div class=\"trial-dialog\">    <h1 class=\"dialog-title\">%trialDialogExpiredTrialTitle%</h1>    <div class=\"dialog-description\" data-bind=\"html: descriptionHtml\"></div>    <div class=\"dialog-button-container\">        <button class=\"dialog-green-button dialog-button-left\" data-bind=\"click: signIn\">%trialDialogSignIn%</button>        <button class=\"dialog-gray-button dialog-button-right\" data-bind=\"click: endTrial\">%trialDialogEndTrial%</button>    </div>    <a class=\"dialog-link\" href=\"%trialDialogLearnMoreUrl%\" target=\"_blank\">%trialDialogLearnMore%</a></div>"})(ExperimentEditor || (ExperimentEditor = {}));ExperimentEditor.typescriptResourceVariables = ExperimentEditor.typescriptResourceVariables || []; ExperimentEditor.typescriptResourceVariables.push("ExperimentEditor._expiredTrialDialogMarkup");
var ExperimentEditor;(function (ExperimentEditor) {ExperimentEditor._feedbackControlMarkup = "<div title=\"%feedbackHoverText%\"     class=\"datalab-feedback\"     data-bind=\"css: { expanded: isExpanded() }\">    <!-- left -->    <div class=\"datalab-feedback-left\"         data-bind=\"css: { expanded: isExpanded() }\">        <div class=\"datalab-feedback-left-question\"             data-bind=\"css: { expanded: isExpanded() }, text: question\">            %feedbackWhatDidYouLike%        </div>        <textarea class=\"datalab-feedback-textarea\"                    placeholder=\"%feedbackPlaceholder%\"                    data-bind=\"click: expand, css: { expanded: isExpanded() }, value: feedbackText, valueUpdate: 'input', attr: { maxlength: MAX_LENGTH }\"></textarea>        <div class=\"datalab-feedback-character-counter\" data-bind=\"text: remainingLengthText, visible: isExpanded\"></div>    </div>    <!-- right -->    <div class=\"datalab-feedback-right\"         data-bind=\"css: { expanded: isExpanded() }\">        <a class=\"datalab-feedback-rightImage datalab-feedback-iconSmileyHappy selected\"           title=\"%feedbackSendASmile%\"           data-bind=\"click: smileyHappySelected, css: { selected: isHappy() }\"           href=\"#\">        </a>        <a class=\"datalab-feedback-rightImage datalab-feedback-iconSmileySad\"           title=\"%feedbackSendAFrown%\"           data-bind=\"click: smileySadSelected, css: { selected: !isHappy() }\"           href=\"#\">        </a>        <a class=\"datalab-feedback-bottomValidation\"           title=\"%feedbackSubmitFeedback%\"           data-bind=\"click: sendFeedback\"           href=\"#\">        </a>    </div></div>"})(ExperimentEditor || (ExperimentEditor = {}));ExperimentEditor.typescriptResourceVariables = ExperimentEditor.typescriptResourceVariables || []; ExperimentEditor.typescriptResourceVariables.push("ExperimentEditor._feedbackControlMarkup");
var ExperimentEditor;(function (ExperimentEditor) {ExperimentEditor._helpSearchMarkup = "<div class=\"helpSearch\">    <!-- ko if: !helpSearchEnabled()-->    <div class='helpIcon helpIconNoSearch'></div>    <!-- /ko -->    <!-- ko if: helpSearchEnabled() -->    <div class='helpIcon helpIconWithSearch'></div>    <input id=\"searchBox\" type='text' placeholder=\"%helpSearchPlaceholder%\" maxlength=\"100\" data-bind=\"value: queryInput,                                                                                   valueUpdate: 'input',                                                                                              event: { keydown: onKeyDownEvent }\" />    <div id=\"helpSearchResults\" data-bind=\"slideVisible: isSearchResultsVisible,                                           animating: isSearchResultsAnimating\">        <div id='helpResultsDownArrow' data-bind=\"click: hideResults\"></div>                <div class=\"helpResultsTitle\" id=\"resultsExistTitle\" data-bind=\"visible: !hasErrors()\">            <span data-bind=\"visible: searchResults().length !== 0\">%helpSearchHelpContentFor%</span>            <span data-bind=\"visible: searchResults().length === 0\">%helpSearchNoResults%</span>            <i data-bind=\"text: currentQuery\"></i>        </div>        <div class=\"helpResultsTitle\" data-bind=\"visible: hasErrors\">            %helpSearchNoResults%         </div>        <ul id=\"helpSearchQueryResults\" data-bind=\"visible: searchResults().length !== 0\">            <!-- ko foreach: searchResults -->            <li class='helpSearchResult' data-bind=\"text: moduleName,                                                    click: $root.searchResultClicked\"></li>            <!-- /ko -->        </ul>                <!-- ko if: synonymResults().length !== 0 -->        <div id='helpResultsDivider'></div>        <div class='helpResultsTitle' id=\"semanticSynonymsExistTitle\">%helpSearchDidYouMean%</div>        <ul id=\"semanticSynonymsQueryResults\">            <!-- ko foreach: synonymResults -->            <li class='semanticSynonym' data-bind=\"text: $data,                                                   click: $parent.synonymResultClicked\"></li>            <!-- /ko -->        </ul>        <!-- /ko -->    </div>    <div id=\"contextualHelpResults\" style=\"display:none\"></div>    <div id='helpLoader' data-bind=\"visible: isLoading\" />    <!-- /ko --></div>"})(ExperimentEditor || (ExperimentEditor = {}));ExperimentEditor.typescriptResourceVariables = ExperimentEditor.typescriptResourceVariables || []; ExperimentEditor.typescriptResourceVariables.push("ExperimentEditor._helpSearchMarkup");
var ExperimentEditor;(function (ExperimentEditor) {ExperimentEditor._invitationDialogMarkup = "<div class='invitationDialogContent'>    <div class=\"invitationDialogConnectInstructions\"><span>%accessPermissionInstructions%</span></div>    <span id='invitationDialogInstructions' data-bind=\"text: instructions,css:{invitationDialogInstructionsError: error}\"></span>    <br />    <div contenteditable='true' spellcheck='false' class='invitationDialogAddressesBox' data-bind=\"event:{keypress: pressHandler}\"></div>    <div class='invitationDialogRoleSelector'>        Add as:        <select data-bind='value: role'>            <option value='User'>%user%</option>            <option value='Owner'>%owner%</option>        </select>        <span data-bind='text:roleDescription' style='margin-left: 10px'></span>    </div></div>"})(ExperimentEditor || (ExperimentEditor = {}));ExperimentEditor.typescriptResourceVariables = ExperimentEditor.typescriptResourceVariables || []; ExperimentEditor.typescriptResourceVariables.push("ExperimentEditor._invitationDialogMarkup");
var ExperimentEditor;(function (ExperimentEditor) {ExperimentEditor._limitedFeatureDialogMarkup = "<div class=\"trial-dialog\">    <h1 class=\"dialog-title\" data-bind=\"text: title\"></h1>    <div class=\"dialog-description\" data-bind=\"foreach: description\">        <p data-bind=\"html: $data\"></p>    </div>    <div class=\"dialog-button-container\">        <button class=\"dialog-green-button dialog-button-left\" data-bind=\"click: signUp\">%trialDialogShowMeHow%</button>        <button class=\"dialog-gray-button dialog-button-right autofocus\" data-bind=\"click: dismiss\">%trialDialogNotNow%</button>    </div>    <!-- ko with: link -->    <a class=\"dialog-link\" style=\"font-size: 10px\" href=\"#\" target=\"_blank\" data-bind=\"attr: { href: url }, text: text\"></a>    <!-- /ko --></div>"})(ExperimentEditor || (ExperimentEditor = {}));ExperimentEditor.typescriptResourceVariables = ExperimentEditor.typescriptResourceVariables || []; ExperimentEditor.typescriptResourceVariables.push("ExperimentEditor._limitedFeatureDialogMarkup");
var ExperimentEditor;(function (ExperimentEditor) {ExperimentEditor._menuMarkup = "<script type=\"text/html\" id=\"menuItemTemplate\">    <!-- ko if:(!menuItem.divider()) -->    <li class=\"datalab-contextMenuItem\"         data-bind=\"event: {mouseup:onActivated,mousedown:onMouseDown},                   subMenu:{activate:subMenu, menuSelector:parentMenu},                   css: {disabled:!enabled(), enabled:enabled(), hasSubmenu: subMenu}\">        <!-- ko if:(menuItem.iconClass() !== '') -->        <div data-bind=\"attr:{class:menuItem.iconClass}\"></div>        <!-- /ko -->        <span data-bind=\"text: menuItem.label\"></span>        <!-- ko if: subMenu -->        <div class=\"datalab-contextMenu datalab-nocontext\" style=\"position: absolute;\">            <ul data-bind='template: { name: \"menuItemTemplate\", foreach: subMenu.items }'></ul>        </div>        <div class=\"ee-rightarrow\"></div>        <!-- /ko -->    </li>    <!-- /ko -->    <!-- ko if:menuItem.divider() -->    <li class=\"datalab-contextMenuItem divider\"></li>    <!-- /ko --></script><script type=\"text/html\" id=\"datalab-contextMenuTemplate\">    <div class=\"datalab-contextMenu datalab-nocontext\" style=\"position: absolute;\" data-bind=\"style: { zIndex: zIndex }, event: {contextmenu:menu.contextMenuMouseUp}\">        <ul class=\"datalab-contextMenu\" data-bind=\"template: { name: 'menuItemTemplate', foreach: menu.items }\"></ul>    </div></script>"})(ExperimentEditor || (ExperimentEditor = {}));ExperimentEditor.typescriptResourceVariables = ExperimentEditor.typescriptResourceVariables || []; ExperimentEditor.typescriptResourceVariables.push("ExperimentEditor._menuMarkup");
var ExperimentEditor;(function (ExperimentEditor) {ExperimentEditor._moduleErrorMarkup = "<div class=\"errorAndOutputLogDialog\">    <h1 data-bind=\"text: dialogHeading\"></h1>    <flexfill style=\"min-height: 210px\">        <!-- ko if: errorInfo().messageInExpectedFormat() -->        <hflexbox>            <flexstatic class=\"timeLabel\">%moduleErrorRecordStartLabel%</flexstatic>            <flexstatic class=\"timeLabel\" data-bind=\"text: errorInfo().startTime\"></flexstatic>        </hflexbox>        <hflexbox>            <flexstatic class=\"timeLabel\">%moduleErrorRecordEndLabel%</flexstatic>            <flexstatic class=\"timeLabel\" data-bind=\"text: errorInfo().endTime\"></flexstatic>        </hflexbox>        <!-- /ko -->        <vflexbox>            <flexstatic class=\"messageLabel\">%moduleErrorErrorMessageLabel%</flexstatic>            <textarea class=\"logMessage\" readonly wrap=\"off\" data-bind=\"text: errorInfo().errorMessage\"></textarea>            <!-- ko if: errorInfo().hasErrorId -->            <a class=\"errorHelpLink\" data-bind=\"attr: { href: errorHelpLink }, text: errorLinkLabel, click: launchErrorHelp\"></a>            <!-- /ko -->        </vflexbox>    </flexfill></div>"})(ExperimentEditor || (ExperimentEditor = {}));ExperimentEditor.typescriptResourceVariables = ExperimentEditor.typescriptResourceVariables || []; ExperimentEditor.typescriptResourceVariables.push("ExperimentEditor._moduleErrorMarkup");
var ExperimentEditor;(function (ExperimentEditor) {ExperimentEditor._newDatasetMenuMarkup = "<div class='fxs-drawerdetails-new-dataset'>    <div data-bind='text: detailMessage'></div></div>"})(ExperimentEditor || (ExperimentEditor = {}));ExperimentEditor.typescriptResourceVariables = ExperimentEditor.typescriptResourceVariables || []; ExperimentEditor.typescriptResourceVariables.push("ExperimentEditor._newDatasetMenuMarkup");
var ExperimentEditor;(function (ExperimentEditor) {ExperimentEditor._newExperimentMenuMarkup = " <div class='fxs-drawerdetails-new-experiment'>     <div class='search-box'>         <div class=\"icon-Discovery\"></div>         <input type='text' placeholder='%newExperimentMenuSearchPlaceholder%' data-bind='value : searchText, valueUpdate : [\"input\", \"keyup\"]'>     </div>    <div class='experiment-tile-list'>        <div data-bind='text: DataLab.LocalizedResources.newExperimentMenuMicrosoftSamplesHeader'></div>        <!-- ko foreach:sampleExperiments -->             <!-- ko if: isBlankTemplate -->            <div class='experiment-tile' data-bind='visible: isVisible, click: $parent.onExperimentSelected'>                <div class='blank-experiment-preview'>                    <img class='blank-icon' data-bind='attr: {src: icon}' />                </div>                <div class='blank-name' data-bind='text: title'></div>            </div>            <!-- /ko -->                    <!-- ko if: isGuidedExperiment -->            <div class='guided-experiment-tile' data-bind='visible: isVisible, click: $parent.onExperimentSelected'>                <div class='guided-experiment-name'>%guidedExperimentName%</div>            </div>            <!-- /ko -->                        <!-- ko if: !isBlankTemplate && !isGuidedExperiment -->            <div class='experiment-tile' data-bind='visible: isVisible, click: $parent.onExperimentSelected'>                <div class='name' data-bind='text: title'></div>                <div class='experiment-preview'>                    <img class='icon' data-bind='attr: {src: icon}' />                </div>            </div>            <!-- /ko -->        <!-- /ko -->    </div></div>"})(ExperimentEditor || (ExperimentEditor = {}));ExperimentEditor.typescriptResourceVariables = ExperimentEditor.typescriptResourceVariables || []; ExperimentEditor.typescriptResourceVariables.push("ExperimentEditor._newExperimentMenuMarkup");
var ExperimentEditor;(function (ExperimentEditor) {ExperimentEditor._newExperimentMenuWithCommunityMarkup = " <div class='fxs-drawerdetails-new-experiment'>    <vflexbox class=\"loading-shield\" data-bind=\"visible: loading()\">        <div class=\"loading-label\" data-bind='text: DataLab.LocalizedResources.newExperimentMenuLoading'></div>    </vflexbox>    <div class='search-box'>        <div class=\"icon-Discovery\"></div>        <input type='text' placeholder='%newExperimentMenuSearchPlaceholder%' data-bind='value : searchTextInstantValue, valueUpdate : [\"input\", \"keyup\"]'>    </div>    <hflexbox class='experiment-list-container' data-bind=\"visible: !loading()\">        <hflexbox class=\"experiment-list-header-container\">            <div>                <img class=\"experiment-list-title-icon\" src=\"/Content/Images/ExperimentCard/icons_msftSample.svg\" />                <span class=\"experiment-list-title\" data-bind='text: DataLab.LocalizedResources.newExperimentMenuMicrosoftSamplesHeader'></span>            </div>            <span data-bind='style: { marginRight: viewMoreSamplesMargin }, visible: !searchTextDelayedValue().trim()'>                <a class=\"experiment-list-view-more\" target=\"_blank\" data-bind='attr: { href: viewMoreSamplesLink }, text: DataLab.LocalizedResources.newExperimentMenuViewMoreInGallery'></a>                <div class=\"view-more-popout-image dlwux-sprite-popout-icon\"></div>            </span>        </hflexbox>        <hflexbox class='experiment-card-list'>            <!-- ko foreach:sampleExperiments -->                <!-- ko if: isBlank -->                    <vflexbox class=\"blankExperimentCard\" data-bind='click: $parent.onExperimentSelected, visible:isVisible()'>                        <img class='blank-icon' src='/Content/SampleExperimentIcons/PlusBlankExperiment.svg' />                        <span class='blank-name'>%newExperimentMenuBlankExperiment%</span>                    </vflexbox>                <!-- /ko -->                <!-- ko if: isTourExperiment -->                    <vflexbox class=\"tourExperimentCard\" data-bind='click: $parent.onExperimentSelected, visible:isVisible()'>                        <div class='tour-name'>%guidedExperimentName%</div>                    </vflexbox>                <!-- /ko -->                <!-- ko if: !isBlank && !isTourExperiment -->                    <div data-bind=\"template: { name: 'experiment-card-template'}, visible:isVisible()\"></div>                <!-- /ko -->            <!-- /ko -->        </hflexbox>    </hflexbox></div><script type=\"text/html\" id=\"experiment-card-template\">    <div class=\"experimentCard\" data-bind='event: { mouseover: activateOverlay, mouseleave: deactivateOverlay }'>        <!-- ko if: overlayIsActive -->        <div class=\"hoverOverlay\">            <button class=\"studioOpen\" data-bind=\"click: $parent.onExperimentSelected\">%newExperimentMenuOpenInStudio%</button>            <span class=\"galleryViewContainer\">                <a class=\"galleryViewLabel\" target=\"_blank\" data-bind=\"attr: { href: viewInGalleryLink }\">%newExperimentMenuViewInGallery%</a>                <div class=\"popoutImage dlwux-sprite-popout-icon\"></div>            </span>            <div class=\"description\" data-bind=\"ellipsisDiv: summary\"></div>        </div>        <!-- /ko -->        <div class=\"headerContainer\">            <div class=\"header\" data-bind=\"visible: !$parent.loading(), ellipsisDiv: title\"></div>        </div>        <img class=\"screenShot\" data-bind=\"attr:{src: imgUrl}\" />         <div class=\"algoContainer\">             <!-- ko if: algorithmList.length > 0 -->             <span class=\"algoIcon\"></span>             <div class=\"algoTextContainer\" data-bind=\"ellipsisDiv: algorithmList\"></div>             <!-- /ko -->         </div>    </div></script>"})(ExperimentEditor || (ExperimentEditor = {}));ExperimentEditor.typescriptResourceVariables = ExperimentEditor.typescriptResourceVariables || []; ExperimentEditor.typescriptResourceVariables.push("ExperimentEditor._newExperimentMenuWithCommunityMarkup");
var ExperimentEditor;(function (ExperimentEditor) {ExperimentEditor._newModuleMenuMarkup = "<div class='fxs-drawerdetails-new-module'>    <div data-bind='text: detailMessage'></div></div>"})(ExperimentEditor || (ExperimentEditor = {}));ExperimentEditor.typescriptResourceVariables = ExperimentEditor.typescriptResourceVariables || []; ExperimentEditor.typescriptResourceVariables.push("ExperimentEditor._newModuleMenuMarkup");
var ExperimentEditor;(function (ExperimentEditor) {ExperimentEditor._outputPromotionDialogMarkup = "<h2>%SaveOutputAsANewDataset%</h2><!-- This markup is repeated in all dialogs for creating new datasets --><div class=\"dataset-form\" data-bind=\"with: resource\">    <div class=\"deprecate-header\">        <input type=\"checkbox\" data-bind=\"checked: deprecate\"/>%uploadDatasetDialogNewVersionOfDataset%    </div>    <div class=\"animation-wrapper\" data-bind=\"css: { hide: deprecate() }\">        %uploadDatasetDialogEnterName%        <input type=\"text\" data-bind=\"validatedInputBox: { value: _name }, enable: !deprecate()\">    </div>    <div class=\"animation-wrapper\" data-bind=\"css: { hide: !deprecate() }\">        %uploadDatasetDialogExistingDataset%        <div class=\"datalab-validation-wrapper\">                    <div class=\"datalab-validation-icon\" data-bind=\"validate: { value: resourceToDeprecate }\"></div>            <div class=\"datalab-validation-icon heuristic-hint\" data-bind=\"style: { 'visibility': hint() ? 'visible' : 'hidden', 'opacity': hint() ? '1' : '0' }\"></div>            <select data-bind=\"options: availableResources, value: resourceToDeprecate, enable: deprecate, optionsCaption: DataLab.LocalizedResources.ChooseDatasetToDeprecateAndEllipsis\"></select>        </div>    </div></div>%uploadDatasetDialogDescription%<textarea rows=\"4\" data-bind=\"value: resource.description\"></textarea>"})(ExperimentEditor || (ExperimentEditor = {}));ExperimentEditor.typescriptResourceVariables = ExperimentEditor.typescriptResourceVariables || []; ExperimentEditor.typescriptResourceVariables.push("ExperimentEditor._outputPromotionDialogMarkup");
var ExperimentEditor;(function (ExperimentEditor) {ExperimentEditor._paletteMarkup = "<script type=\"text/html\" id=\"palette\">    <div class=\"xe-palette\"         data-bind=\"jQueryCollapse: {                        collapseButtonSelector: '.xe-paletteHeader',                        contentSelector: '.xe-paletteContent',                        collapsed: isCollapsed,                        collapseFrom: 'bottom',                        id: path ? path : name()                    }\">        <div class=\"xe-paletteHeader\">            <hflexbox>                <div class=\"paletteCategory-expander\"></div>                <!-- ko if: icon !== null -->                <span data-bind=\"attr: { 'class': 'paletteCategory-icon ' + icon }\"></span>                <!-- /ko -->                <div class=\"paletteCategory-title\" data-bind=\"text: name, visible: !isEmpty(), css: { expanded: !isCollapsed() }\"></div>            </hflexbox>        </div>        <div class=\"xe-paletteContent\">            <!-- ko foreach:items -->                <hflexbox class=\"xe-paletteItem\"                      data-bind=\"attr: { id: id, class: classId, title: tooltip },                                mouseCapture: { mouseMove: $root.mouseMove, mouseUp: $root.mouseUp },                                event: { mousedown: $root.mouseDown, dblclick: $root.activate },                                visible:isVisible\">                    <flexfill class=\"xe-paletteItemText\" data-bind=\"text: name\" ></flexfill>                    <flexstatic class=\"paletteGripper\"></flexstatic>                </hflexbox>            <!-- /ko -->                    <!-- ko foreach:childCategories -->                <!-- ko if: !isEmpty() -->                    <div data-bind=\"template: { name: 'palette' }\"></div>                <!-- /ko -->            <!-- /ko -->        </div>    </div></script><!-- ko foreach: categories -->    <!-- ko if: !isEmpty() -->        <div data-bind=\"template: { name: 'palette' }\"></div>    <!-- /ko --><!-- /ko -->"})(ExperimentEditor || (ExperimentEditor = {}));ExperimentEditor.typescriptResourceVariables = ExperimentEditor.typescriptResourceVariables || []; ExperimentEditor.typescriptResourceVariables.push("ExperimentEditor._paletteMarkup");
var ExperimentEditor;(function (ExperimentEditor) {ExperimentEditor._propertyEditorMarkup = "<script type=\"text/html\" id=\"inputParameter\">    <input type=\"text\"           class=\"datalab-gridCellPropertyItem\"           data-bind=\"validatedInputBox: { value: property.value, disabled: ($root.readOnlyMode() || isDisabled()) },                      hasfocus: focus,                      readonly:  $root.readOnlyMode() || isDisabled(),                      css: { disabled: $root.readOnlyMode() || isDisabled() },                      event: { focus: $root.onParameterFocus, keydown: $root.onParameterReturn },                      autocomplete: { array: autocompleteArray, dependentObservable: property.value }\"           /></script><script type=\"text/html\" id=\"textAreaParameter\">    <div style=\"position:relative\"         data-bind=\"resize: {                        direction: 'bottom',                        parentContainerSelector: '.propertyEditor-right',                        minSize: 125,                        maxSize: 9999,                        id: property.label                    }\">        <div class=\"monaco-container datalab-gridCellPropertyItem\"             data-bind=\"monaco: {                            value: property.value,                            mimetype: monacoMimeType,                            containerWidth: $root.width                        },                        validatedInputBox: {value: property.value},                        style: { backgroundColor: ($root.readOnlyMode() || isDisabled()) ? 'rgba(0, 0, 0, 0.05)' : '' },                        css: { focused: focus},                        readonly: $root.readOnlyMode() || isDisabled()\">        </div>    </div></script><script type=\"text/html\" id=\"checkboxParameter\">    <input type=\"checkbox\"           class=\"datalab-gridCellPropertyItem\"           data-bind=\"checkboxvalue: { value: property.value, choices: property.descriptor.choices },                      hasfocus: focus,                      disable: ($root.readOnlyMode() || isDisabled()),                      css: { disabled: ($root.readOnlyMode() || isDisabled()) },                      event: { focus: $root.onParameterFocus }\"            /></script><script type=\"text/html\" id=\"multiSelectParameter\">    <div class=\".datalab-gridCellTextArea\"         data-bind=\"multiSelectMenu: enumItems\">        <hflexbox class=\"datalab-gridCellPropertyItem multiSelectButton\">            <div class=\"datalab-gridCellPropertyItem\"                 data-bind=\"text: buttonLabel\"></div>            <div style=\"float:right\">&#9660</div>        </hflexbox>        <ul data-bind=\"foreach: enumItems\" class=\"datalab-gridCellPropertyItem multiSelectMenu\">            <li data-bind=\"css: classString\">                <a href=\" #\" data-bind=\"text: displayValue\" />            </li>        </ul>    </div></script><script type=\"text/html\" id=\"selectParameter\">    <select class=\"datalab-gridCellPropertyItem\"            data-bind=\"value: property.value,                   hasfocus: focus,                   options: property.descriptor.choices,                   optionsText: 'displayValue',                   optionsValue: 'value',                   disable: ($root.readOnlyMode() || isDisabled()),                   css: { disabled: ($root.readOnlyMode() || isDisabled()) },                   event: { focus: $root.onParameterFocus }\"></select></script><script type=\"text/html\" id=\"staticTextProperty\">    <div class=\"datalab-gridCellPropertyItem datalab-staticProperty\"         data-bind=\"text: property.value, attr: { title: property.value }, style: { whiteSpace: property.name === 'Status details' ? 'normal' : 'nowrap' }\">    </div></script><script type=\"text/html\" id=\"editableTextAreaProperty\">    <div class=\"editableTextAreaProperty\" data-bind=\"editableTextArea: {}\">        <textarea class=\"datalab-gridCellPropertyItem editableTextArea\" data-bind=\"value: $parent.property.value, css: { disabled: $data.isReadOnly }\"></textarea>        <span class=\"characterLimitReachedWarning\">            <span class=\"charactersLeftCount\"></span>            %charactersLeft%        </span>    </div></script><script type=\"text/html\" id=\"credentialParameter\">    <input type=\"password\"           class=\"datalab-gridCellPropertyItem\"           data-bind=\"validatedInputBox: { value: property.value, disabled: ($root.readOnlyMode() || isDisabled()) },                      disable: $root.readOnlyMode() || isDisabled(),                      hasfocus: focus,                      css: { disabled:$root.readOnlyMode() || isDisabled() }\"            /></script><script type=\"text/html\" id=\"columnPickerParameter\">    <div          class=\"datalab-gridCellPropertyItem columnPickerRules\"         data-bind=\"columnPickerRuleDisplay: property.value,                      css: { disabled: (isDisabled()) }\">    </div>    <input type=\"button\"           class=\"datalab-gridCellPropertyItem\"           value=\"Launch column selector\"           data-bind=\"click: $root.openColumnPicker,                      disable: $root.readOnlyMode() || isDisabled() || launchDisabled\"           /></script><script type=\"text/html\" id=\"parameterRangeParameter\">    <span class=\"parameterRangeLabel\"           data-bind=\"text: DataLab.LocalizedResources.useRangeBuilderLabel\"           style=\"font-size:12px;line-height: 16.25px; font-family: Segoe UI;\">    </span>    <input id=\"UseRangeBuilderCheckbox\"           type=\"checkbox\"           class=\"datalab-gridCellPropertyItem\"           data-bind=\"checked: useRangeBuilder,                      disable: $root.readOnlyMode(),                      css: { disabled: $root.readOnlyMode()}\" />    <!-- ko if: !useRangeBuilder() -->    <input type=\"text\"           class=\"datalab-gridCellPropertyItem\"           data-bind=\"value: literalList,                      validatedInputBox: { value: literalList, disabled: $root.readOnlyMode()},                      readonly: $root.readOnlyMode(),                      css: { disabled: $root.readOnlyMode()}\" />    <!-- /ko -->    <!-- ko if: useRangeBuilder() -->    <div>        <span>            <span data-bind=\"text: DataLab.LocalizedResources.ParameterRangeLabel\"                  style=\"font-size: 12px;line-height: 16.25px; font-family: Segoe UI;\">            </span>            <span id=\"ParameterRangeAsString\"                  data-bind=\"text: rangeString\"                   style=\"font-size: 12px;line-height: 16.25px; font-family: Segoe UI;\">            </span>        </span>        <!-- ko if: isLogarithmic() -->        <div class=\"parameterRangeSlider\"             data-bind=\"slider: [logMin, logMax],                        sliderOptions: {min: logMinLimit, max: logMaxLimit, range:true, step: logSliderStep, values: [logMin, logMax], disabled: $root.readOnlyMode()}\"             style=\"margin: 5px 10px\">        </div>        <!-- /ko -->        <!-- ko if: !isLogarithmic() -->        <div class=\"parameterRangeSlider\"             data-bind=\"slider: [minValue, maxValue],                        sliderOptions: {min: sliderMin, max: sliderMax, range:true, step: linSliderStep, values: [sliderMin, sliderMax], disabled: $root.readOnlyMode()}\"             style=\"margin: 5px 10px\">        </div>        <!-- /ko -->        <div>            <span class=\"parameterRangeLabel\"                   data-bind=\"text: DataLab.LocalizedResources.rangeBuilderCount\"                   style=\"font-size: 12px;line-height: 16.25px; font-family: Segoe UI;\">            </span>            <input class=\"parameterRangeCount\"                   id=\"rangeBuilderCount\"                   type=\"text\"                   data-bind=\"value: countValidatable,                              validatedInputBox: { value: countValidatable, disabled: $root.readOnlyMode()},                              readonly: $root.readOnlyMode(),                              css: { disabled: $root.readOnlyMode()}\"                   style=\"width:40px; border: 1px solid #ccc; padding-left: 5px; padding-right: 5px; background-color: #fff;\" />        </div>        <!-- ko if: logCapable -->        <div>            <span class=\"parameterRangeLabel\"                   data-bind=\"text: DataLab.LocalizedResources.rangeBuilderLogarithmicScaleCheckbox\"                   style=\"font-size: 12px;line-height: 16.25px; font-family: Segoe UI;\">            </span>            <input id=\"LogarithmicCheckbox\"                   type=\"checkbox\"                   class=\"datalab-gridCellPropertyItem\"                   data-bind=\"checked: isLogarithmic,                              disable: $root.readOnlyMode(),                              css: { disabled: $root.readOnlyMode()}\" />        </div>        <!-- /ko -->    </div>    <!-- /ko --></script><script type=\"text/html\" id=\"linkProperty\">    <div class=\"propertyLink\">        <a data-bind=\"attr: { title: property.tooltip, href: (property.endpoint && property.endpoint.Size === -1) ? false: property.value},                      hasfocus: focus,                      event: { focus: $root.onParameterFocus, click: onClick },                      text: property.label\"           target=\"_blank\">        </a>    </div>    <div class=\"propertyLinkMetaData\" data-bind=\"visible: (property.endpoint && property.endpoint.Size === -1)\">&nbsp;(none)</div></script><script type=\"text/html\" id=\"buttonProperty\">    <div class=\"propertyEditor-staticValueCell\">        <div class=\"datalab-gridCellTextArea\">            <div class=\" propertyeditor-statictextareaitem propertyeditor-headingcellwrapper\"                 data-bind=\"css: { isButton: templateType() === 'buttonProperty' }, visible: property.value() === false || property.value()\">                <button data-bind=\"attr: { title: property.tooltip, name: property.label},                           hasfocus: focus,                           event: { focus: $root.onParameterFocus, click: onClick },                           text: property.label,                           disable: clickDisabled\">                </button>            </div>            <div class=\"propertyLinkMetaData\" data-bind=\"visible: (property.endpoint && property.endpoint.Size === -1)\">&nbsp;(none)</div>        </div>    </div></script><script type=\"text/html\" id=\"propertyKey\">    <!-- ko if: isExperimentLevel() && !$root.readOnlyMode() -->    <div>        <input type=\"text\"               class=\"datalab-gridCellPropertyItem\"               data-bind=\"validatedInputBox: { value: property.validatableName },                              event: { blur: property.textboxBlur, keydown: property.textboxKeydown },                              visible: property.isEditingName\" />        <div class=\"datalab-gridCellKey\"             data-bind=\"attr: { title: property.tooltip },                    text: property.label,                    click: property.toggleEditingName,                    visible: !property.isEditingName()\">        </div>    </div>    <!-- /ko -->    <!-- ko ifnot: isExperimentLevel() && !$root.readOnlyMode() -->    <!-- ko if: templateType() === 'linkProperty' -->    <hflexbox class=\"datalab-gridCellKey\" data-bind=\"template: { name: 'linkProperty' }\"></hflexbox>    <!-- /ko -->    <!-- ko if: templateType() === 'buttonProperty' -->    <hflexbox class=\"datalab-gridCellKey\" data-bind=\"template: { name: 'buttonProperty' }\"></hflexbox>    <!-- /ko -->    <!-- ko if: templateType() !== 'linkProperty' && templateType() !== 'buttonProperty' -->    <div class=\"datalab-gridCellKey\" data-bind=\"attr: { title: property.tooltip }, text: property.label\"></div>    <!-- /ko -->    <!-- /ko --></script><script type=\"text/html\" id=\"propertyItem\">    <div class=\"propertyEditor-textAreaItem\">        <div class=\"propertyEditor-headingCellWrapper\" data-bind=\"css: { propertyEditorHeadingCellWrapperEditingName: property.isEditingName, isLink: templateType() === 'linkProperty' }\">            <div class=\"propertyEditor-headingCell\">                <div class=\"propertyEditor-sideButtonWrapper\">                    <div class=\"parameterIsLinked linkStatus propertyEditorButton\"                         data-bind=\"style: { visibility: property.isLinked() && !isExperimentLevel() ? 'visible' : 'hidden' },                                    event: { click: $root.focusLinkedWebServiceParameter },                                    attr: { title: DataLab.Util.format(DataLab.LocalizedResources.parameterIsLinkedToWebServiceParameter, linkedParameterName()) }\">                    </div>                    <!-- ko if: !isExperimentLevel() && isLinkable -->                    <div class=\"propertyEditorButton dropMenu\"                         data-bind=\"dropMenu: $root.menuBuilder\">                    </div>                    <!-- /ko -->                    <!-- ko if: isExperimentLevel() && !$root.readOnlyMode() -->                    <div class=\"propertyEditorButton dropMenu\"                         data-bind=\"dropMenu: $root.webServiceParameterMenuBuilder\">                    </div>                    <!-- /ko -->                </div>                <!-- ko if: templateType() === 'checkboxParameter' -->                <div data-bind=\"template: { name: 'checkboxParameter' },                                visible: !isExperimentLevel() || property.hasDefaultValue()\">                </div>                <!-- /ko -->                <div class=\"datalab-gridCellKeyWrapper\"                     data-bind=\"template: { name: 'propertyKey' }\">                </div>            </div>        </div>        <!-- ko if: templateType() !== 'checkboxParameter' && templateType() !== 'linkProperty' && templateType() !== 'buttonProperty' -->        <!-- ko if: !isExperimentLevel() || property.hasDefaultValue() -->        <div class=\"propertyEditor-valueCellWrapper\">            <div class=\"datalab-gridCellTextArea\" data-bind=\"template: { name: templateType }\"></div>        </div>        <!-- /ko -->        <!-- /ko -->    </div>    <!-- ko foreach: childParameters -->    <!-- ko if: property.isRelevant() -->    <div data-bind=\"template: { name: 'propertyItem' }\"></div>    <!-- /ko -->    <!-- /ko --></script><script type=\"text/html\" id=\"checkboxProperty\">    <input type=\"checkbox\"           class=\"datalab-gridCellPropertyItem\"           data-bind=\"checked: property.value,                        hasfocus: focus,                        disable: $root.readOnlyMode(),                        css: { disabled: $root.readOnlyMode() },                        event: { focus: $root.onParameterFocus }\"           />    <div class=\"datalab-gridCellKeyWrapper\"         data-bind=\"template: { name: 'propertyKey' }\">    </div></script><script type=\"text/html\" id=\"staticPropertyItem\">    <div class=\"propertyEditor-staticTextAreaItem propertyEditor-headingCellWrapper\"         data-bind=\"css: { isLink: templateType() === 'linkProperty', isButton: templateType() === 'buttonProperty' }, style: { height: property.name === 'Status details' ? '100%': '22px' }, visible: property.value() === false || property.value()\">        <!-- ko if: templateType() !== 'linkProperty' && templateType() !== 'checkboxProperty' && templateType() !== 'buttonProperty' -->        <div class=\"propertyEditor-staticHeadingCell\">            <div class=\"datalab-gridCellKeyWrapper\"                 data-bind=\"template: { name: 'propertyKey' }\">            </div>        </div>        <!-- /ko -->        <div class=\"propertyEditor-staticValueCell\">            <div class=\"datalab-gridCellTextArea\" data-bind=\"template: { name: templateType }\"></div>        </div>    </div></script><div data-bind=\"resize: {                    direction: 'left',                    parentContainerSelector: '.experiment-container-right',                    minSize: 278,                    id: 'propertyEditor'                },                collapsepanel: {                    collapseButtonSelector: '.drawerExpander',                    collapsed: drawerIsCollapsed,                    animationEnded: openCloseAnimationEnded,                    collapseFrom: 'left',                    collapsedSize: 36,                    id: 'propertyEditor'                }\"     class=\"datalab-propertyEditor\">    <vflexbox class=\"propertyEditorContainer\">        <flexstatic style=\"height:30px;\">            <flexcontent>                <hflexbox class=\"propertyEditorHeader\">                    <flexfill><span class=\"drawerExpandedTitle\">%drawerTitle%</span></flexfill>                    <flexstatic class=\"drawerExpander\"></flexstatic>                </hflexbox>            </flexcontent>        </flexstatic>        <flexstatic class=\"drawerTitle\">%drawerTitle%</flexstatic>        <flexfill class=\"propertyEditorContentContainer\">            <flexcontent>                <div class=\"propertyEditor-right\">                    <!-- ko if: graphNode() -->                    <div class=\"propertyEditor-entityParameters\"                         data-bind=\"jQueryCollapse: {                                        collapseButtonSelector: '.propertyEditor-heading',                                        contentSelector: '.propertyEditor-content',                                        collapsed: entityParamsCollapsed,                                        collapseFrom: 'bottom',                                        id: 'entityParameters'}\">                        <div class=\"propertyEditor-heading\">                            <div class=\"propertyEditor-expander\"></div>                            <h2 class=\"propertyEditor-expanderHeader\" data-bind=\"text: selectedGraphNodeName\"></h2>                        </div>                        <div class=\"propertyEditor-content\">                            <!-- ko if: graphNode() instanceof ExperimentEditor.Module-->                            <div class=\"noParameters\" data-bind=\"style: { display: Object.keys(graphNode().graphNode.parameters).length === 0 &&                                                                                  !graphNode().statusDetails.property.value() ? 'block' : 'none' }\">%PropertyEditorNoParameter%</div>                            <!-- ko foreach: nodeParameters -->                            <!-- ko if: !isStaticContent()-->                            <div class=\"textAreaProperty\" data-bind=\"template: { name: 'propertyItem' }\"></div>                            <!-- /ko -->                            <!-- ko if: isStaticContent()-->                            <div class=\"textAreaProperty\" data-bind=\"template: { name: 'staticPropertyItem' }\"></div>                            <!-- /ko -->                            <!-- /ko -->                            <!-- ko with: graphNode().startTime -->                            <div class=\"textAreaProperty\" data-bind=\"template: { name: 'staticPropertyItem' },                                                                                 style: { display: property.value() ? 'block' : 'none' }\"></div>                            <!-- /ko -->                            <!-- ko with: graphNode().endTime -->                            <div class=\"textAreaProperty\" data-bind=\"template: { name: 'staticPropertyItem' },                                                                                 style: { display: property.value() ? 'block' : 'none' }\"></div>                            <!-- /ko -->                            <!-- ko with: graphNode().elapsedTime -->                            <div class=\"textAreaProperty\" data-bind=\"template: { name: 'staticPropertyItem' },                                                                                 style: { display: property.value() ? 'block' : 'none' }\"></div>                            <!-- /ko -->                            <div data-bind=\"style: { display: graphNode().statusDetails.property.value() ? 'block' : 'none' }\">                                <!-- ko with: graphNode().statusCode -->                                <div class=\"textAreaProperty\" data-bind=\"template: { name: 'staticPropertyItem' }\"></div>                                <!-- /ko -->                                <!-- ko with: graphNode().statusDetails -->                                <div class=\"textAreaProperty\" data-bind=\"template: { name: 'staticPropertyItem' }\"></div>                                <!-- /ko -->                            </div>                            <div data-bind=\"style: { display: graphNode().statusCode.property.value() !== 'NotStarted' &&                                                              graphNode().statusCode.property.value() !== 'Canceled' ? 'block' : 'none' }\">                                <!-- ko with: graphNode().outputLog -->                                <div class=\"textAreaProperty\" data-bind=\"template: { name: 'staticPropertyItem' },                                                                                     style: { display: property.value() ? 'block' : 'none' }\"></div>                                <!-- /ko -->                            </div>                            <div data-bind=\"style: { display: graphNode().statusCode.property.value() !== 'NotStarted' &&                                                              graphNode().statusCode.property.value() !== 'Finished' &&                                                              graphNode().statusCode.property.value() !== 'Canceled' ? 'block' : 'none' }\">                                <!-- ko with: graphNode().errorLog -->                                <div class=\"textAreaProperty\" data-bind=\"template: { name: 'buttonProperty' },                                                                                     style: { display: property.value() ? 'block' : 'none' }\"></div>                                <!-- /ko -->                            </div>                            <div data-bind=\"style: { display: graphNode().statusCode.property.value() !== 'NotStarted' &&                                                              graphNode().statusCode.property.value() !== 'Canceled' &&                                                              graphNode().statusCode.property.value() !== 'Running' ? 'block' : 'none' }\">                            </div>                            <!-- /ko -->                            <!-- ko if: graphNode() instanceof ExperimentEditor.WebServicePort-->                            <!-- ko foreach: nodeParameters -->                            <div class=\"textAreaProperty\" data-bind=\"template: { name: 'propertyItem' }\"></div>                            <!-- /ko -->                            <!-- /ko -->                            <!-- ko if: graphNode() instanceof ExperimentEditor.Dataset-->                            <!-- ko with: graphNode().author -->                            <div class=\"textAreaProperty\" data-bind=\"template: { name: 'staticPropertyItem' }\"></div>                            <!-- /ko -->                            <!-- ko with: graphNode().size -->                            <div class=\"textAreaProperty\" data-bind=\"template: { name: 'staticPropertyItem' }\"></div>                            <!-- /ko -->                            <!-- ko with: graphNode().format -->                            <div class=\"textAreaProperty\" data-bind=\"template: { name: 'staticPropertyItem' }\"></div>                            <!-- /ko -->                            <!-- ko with: graphNode().createdOn -->                            <div class=\"textAreaProperty\" data-bind=\"template: { name: 'staticPropertyItem' }\"></div>                            <!-- /ko -->                            <!-- ko with: graphNode().viewDataset -->                            <div class=\"textAreaProperty\" data-bind=\"template: { name: 'staticPropertyItem' }\"></div>                            <!-- /ko -->                            <!-- /ko -->                            <!-- ko if: graphNode() instanceof ExperimentEditor.TrainedModel -->                            <!-- ko with: graphNode().author -->                            <div class=\"textAreaProperty\" data-bind=\"template: { name: 'staticPropertyItem' }\"></div>                            <!-- /ko -->                            <!-- ko with: graphNode().createdOn -->                            <div class=\"textAreaProperty\" data-bind=\"template: { name: 'staticPropertyItem' }\"></div>                            <!-- /ko -->                            <!-- ko with: graphNode().trainingExperiment -->                            <div class=textAreaProperty data-bind=\"template: { name: 'staticPropertyItem' }\"></div>                            <!-- /ko -->                            <!-- /ko -->                            <!-- ko if: graphNode() instanceof ExperimentEditor.Transform -->                            <!-- ko with: graphNode().author -->                            <div class=\"textAreaProperty\" data-bind=\"template: { name: 'staticPropertyItem' }\"></div>                            <!-- /ko -->                            <!-- ko with: graphNode().createdOn -->                            <div class=\"textAreaProperty\" data-bind=\"template: { name: 'staticPropertyItem' }\"></div>                            <!-- /ko -->                            <!-- ko with: graphNode().trainingExperiment -->                            <div class=textAreaProperty data-bind=\"template: { name: 'staticPropertyItem' }\"></div>                            <!-- /ko -->                            <!-- /ko -->                        </div>                    </div>                    <!-- /ko -->                    <!-- ko if: experimentEditorViewModel.experimentViewModel().webServiceParameters.count() > 0 -->                    <div class=\"propertyEditor-globalParameters\"                         data-bind=\"jQueryCollapse: {                                        collapseButtonSelector: '.propertyEditor-heading',                                        contentSelector: '.propertyEditor-content',                                        collapsed: globalParamsCollapsed,                                        collapseFrom: 'bottom',                                        id: 'globalParameters'                                    }\">                        <div class=\"propertyEditor-heading\">                            <div class=\"propertyEditor-expander\"></div>                            <h2 class=\"propertyEditor-expanderHeader\">%WebServiceParameters%</h2>                        </div>                        <div class=\"propertyEditor-content\">                            <!-- ko foreach:DataLab.Util.values(experimentEditorViewModel.experimentViewModel().webServiceParameters()) -->                            <div data-bind=\"template: { name: 'propertyItem' }\"></div>                            <!-- /ko -->                        </div>                    </div>                    <!-- /ko -->                    <!-- Competition Section -->                    <!-- todo: add compet. metadata check here too -->                    <!-- ko if: window.DataLab.Features.competitionExperimentSupportEnabled() && experimentEditorViewModel.experimentViewModel().experimentLoaded && !graphNode() -->                     <div class=\"propertyEditor-competitionProperties\"                         data-bind=\"jQueryCollapse: {                                        collapseButtonSelector: '.propertyEditor-heading',                                        contentSelector: '.propertyEditor-content',                                        collapsed: competitionPropertiesCollapsed,                                        collapseFrom: 'bottom',                                        id: 'competitionProperties'                                    }\">                        <div class=\"propertyEditor-heading\">                            <div class=\"propertyEditor-expander\"></div>                            <h2 class=\"propertyEditor-expanderHeader\">%CompetitionProperties%</h2>                        </div>                        <div class=\"propertyEditor-content\">                            <button class=\"submitButton\" data-bind=\"click: submitCompetitionEntry\">%submitCompetitionEntry%</button>                        </div>                    </div>                    <!-- /ko -->                    <!-- end of Competition Section -->                    <!-- ko if: experimentEditorViewModel.experimentViewModel().experimentLoaded && (!window.DataLab.Features.experimentDescriptionEnabled() || !graphNode()) -->                    <div class=\"propertyEditor-experimentProperties\"                            data-bind=\"jQueryCollapse: {                                           collapseButtonSelector: '.propertyEditor-heading',                                           contentSelector: '.propertyEditor-content',                                           collapsed: experimentPropertiesCollapsed,                                           collapseFrom: 'bottom',                                           id: 'experimentProperties'                                       }\">                        <div class=\"propertyEditor-heading\">                            <div class=\"propertyEditor-expander\"></div>                            <h2 class=\"propertyEditor-expanderHeader\">%ExperimentProperties%</h2>                        </div>                        <div class=\"propertyEditor-content\">                            <!-- ko foreach: experimentEditorViewModel.experimentViewModel().experimentProperties() -->                            <div data-bind=\"template: { name: 'staticPropertyItem' }\"></div>                            <!-- /ko -->                            <!--Experiment Summary and Description-->                            <div data-bind=\"visible: window.DataLab.Features.experimentDescriptionEnabled()\">                                <div class=\"experimentSummary\"                                     data-bind=\"jQueryCollapse: {                                         collapseButtonSelector: '.experimentSummary-heading',                                         contentSelector: '.experimentSummary-content',                                         collapsed: experimentSummaryCollapsed,                                         collapseFrom: 'bottom',                                         id: 'experimentSummary'                                     }\">                                    <div class=\"experimentSummary-heading\">                                        <div class=\"propertyEditor-expander\"></div>                                        <h2 class=\"propertyEditor-expanderHeader\">%experimentSummary%</h2>                                    </div>                                    <div class=\"experimentSummary-content\">                                        <!-- ko with: experimentEditorViewModel.experimentViewModel().summary -->                                        <div data-bind=\"template: { name: 'editableTextAreaProperty', data: {maxCharacters: 140, showMaxCharacterWarning: true, placeholderText: property.placeholderText, isReadOnly: $parent.readOnlyMode()}}\"></div>                                        <!-- /ko -->                                    </div>                                </div>                                <!-- ko if: !experimentEditorViewModel.experimentViewModel().isSampleExperiment() -->                                <div class=\"experimentDetails\"                                     data-bind=\"jQueryCollapse: {                                        collapseButtonSelector: '.experimentDetails-heading',                                        contentSelector: '.experimentDetails-content',                                        collapsed: experimentDetailsCollapsed,                                        collapseFrom: 'bottom',                                        id: 'experimentDetails'                                    }\">                                    <div class=\"experimentDetails-heading\">                                        <div class=\"propertyEditor-expander\"></div>                                        <h2 class=\"propertyEditor-expanderHeader\">%experimentDetailedDescription%</h2>                                    </div>                                    <div class=\"experimentDetails-content\">                                        <!-- ko with: experimentEditorViewModel.experimentViewModel().details -->                                        <div data-bind=\"template: { name: 'editableTextAreaProperty', data: {expandOnFocus: true, placeholderText: property.placeholderText, isReadOnly: $parent.readOnlyMode()} }\"></div>                                        <!-- /ko -->                                    </div>                                </div>                                <!-- /ko -->                                <!-- ko if: window.DataLab.Features.communityUXInStudioEnabled() -->                                <!-- ko with: experimentEditorViewModel.experimentViewModel().detailsLink -->                                <div class=\"original-experiment-documentation-link\" data-bind=\"template: { name: 'linkProperty' }, visible: property.value()\"></div>                                <!-- /ko -->                                <!-- /ko -->                            </div>                        </div>                    </div>                    <!-- /ko -->                </div>            </flexcontent>        </flexfill>        <flexstatic class=\"quickHelpContainer\"                    data-bind=\"resize: {                                   direction: 'top',                                   parentContainerSelector: '.propertyEditorContainer',                                   collapsed: quickHelpCollapsed,                                   minSize: 150,                                   id: 'quickHelp'                               },                               collapsepanel: {                                    collapseButtonSelector: '.quickHelpExpander',                                    collapsed: quickHelpCollapsed,                                    collapseFrom: 'top',                                    collapsedSize: 36,                                    id: 'quickHelp'                               }\">            <flexcontent>                <vflexbox>                    <flexstatic>                        <hflexbox class=\"quickHelpHeader\">                            <flexfill class=\"quickHelpTitle\">%quickHelpTitle%</flexfill>                            <flexstatic class=\"quickHelpExpander\"></flexstatic>                        </hflexbox>                    </flexstatic>                    <flexfill>                        <flexcontent style=\"padding:5px; width: auto; height: auto; top: 5px; bottom: 5px; left: 5px; right: 0px\">                            <div class=\"quickHelpContent\">                                <div data-bind=\"text: ExperimentEditor.Help.currentHelpTopic\"></div>                                <!-- ko if: ExperimentEditor.Help.moduleTopicID() -->                                <a class='pointerText' data-bind='click:getModuleHelp'>%quickHelpMore%</a>                                <!-- /ko -->                            </div>                        </flexcontent>                    </flexfill>                </vflexbox>            </flexcontent>        </flexstatic>    </vflexbox></div>"})(ExperimentEditor || (ExperimentEditor = {}));ExperimentEditor.typescriptResourceVariables = ExperimentEditor.typescriptResourceVariables || []; ExperimentEditor.typescriptResourceVariables.push("ExperimentEditor._propertyEditorMarkup");
var ExperimentEditor;(function (ExperimentEditor) {ExperimentEditor._publishToCommunityStep1Markup = "<script type=\"text/html\" id=\"PublishToCommunityStep1Template\">    <div class=\"fx-dialog-template publish-to-community-wizard-step\">        <div class=\"datalab-dialog\">            <label>%experimentSaveAsDialogExperimentName%</label>            <input type=\"text\" class=\"publishExperimentName\" data-bind=\"value: experimentName, validatedInputBox: { value: experimentName }\" />            <label>%publishExperimentToCommunityTagsLabel%</label>            <!-- ko template: { name: 'TagTextBox', data: new ExperimentEditor.TagTextBoxViewModel(tags) } --><!-- /ko -->            <label>%publishExperimentToCommunitySummaryLabel%</label>            <div data-bind=\"editableTextArea: {maxCharacters: 140, showMaxCharacterWarning: true}\">                <textarea class=\"summary\" data-bind=\"value: summary, placeholder: '%publishExperimentToCommunitySummaryPlaceholder%'\"></textarea>                <span class=\"characterLimitReachedWarning\">                    <span class=\"charactersLeftCount\"></span>                    %charactersLeft%                </span>            </div>            <label>%publishExperimentToCommunityDescriptionLabel%</label>            <!-- ko ifnot: useMarkdownEditor -->            <textarea class=\"description\" data-bind=\"value: description, placeholder: '%publishExperimentToCommunityDescriptionPlaceholder%'\"></textarea>            <!-- /ko -->            <!-- ko if: useMarkdownEditor -->            <markdown-editor params=\"value: description, placeholder: '%publishExperimentToCommunityDescriptionPlaceholder%'\"></markdown-editor>            <!-- /ko -->            <div class=\"dialog-warning publishConsents\">                <label>                    <input type=\"checkbox\" data-bind=\"checked: hasConsented\" />                    %publishExperimentToCommunityConsentLabel%                </label>                <!-- ko if: hasCredentials -->                <label>                    <input type=\"checkbox\" data-bind=\"checked: hasConsentedCredentials\" />                    %publishExperimentToCommunityConsentCredentialsLabel%                </label>                <div class=\"credentialsAbsentWarning\">%publishExperimentToCommunityCredentialsAbsentWarningLabel%</div>                <!-- /ko -->            </div>        </div>    </div></script>"})(ExperimentEditor || (ExperimentEditor = {}));ExperimentEditor.typescriptResourceVariables = ExperimentEditor.typescriptResourceVariables || []; ExperimentEditor.typescriptResourceVariables.push("ExperimentEditor._publishToCommunityStep1Markup");
var ExperimentEditor;(function (ExperimentEditor) {ExperimentEditor._publishToCommunityStep2Markup = "<script type=\"text/html\" id=\"PublishToCommunityStep2Template\">    <div class=\"fx-dialog-template publish-to-community-wizard-step\">        <div class=\"datalab-dialog\">            <p class=\"publishExperimentSubtitle\">%publishExperimentToCommunityWizardImageSelectionSubTitle%</p>            <!-- ko with: imageViewModel -->            <div class=\"publish-to-community-wizard-image-thumbnail\" data-bind=\"css: { imagePlaceholder: !hasImage() }\">                <img data-bind=\"attr: {src: selectedImageThumbnailSrc}\" />            </div>            <!-- /ko -->            <div class=\"radio pushbutton publishImageSelectionMode\" data-bind=\"fxRadio: {                                                        value: uploadImageOption,                                                        values: ExperimentEditor.PublishToCommunityWizardViewModel.uploadImageOptions,                                                        trackedit: false }\"></div>            <div data-bind=\"visible: uploadImageOption() === ExperimentEditor.ImageSelectionMode.SelectYourOwn\">                <!-- ko with: imageViewModel -->                <!-- ko with: imageUploadViewModel -->                <div>                    <input type=\"file\"                           data-bind=\"file: selectedImage, fxUpload: {acceptedMimeTypes: ['image/*']}\" />                    <span style=\"color: red\"                          data-bind=\"visible: errorMessage, text: errorMessage\"></span>                </div>                <p data-bind=\"visible: isProcessingSelectedImage, text: DataLab.LocalizedResources.imageUploadProcessingText\"></p>                <!-- /ko -->                <!-- /ko -->            </div>            <div data-bind=\"visible: uploadImageOption() === ExperimentEditor.ImageSelectionMode.StockImageFromGallery\">                <!-- ko with: imageViewModel -->                <div class=\"imgGalleryContainer\" data-bind=\"foreach: stockImages\">                    <div class=\"imgGalleryBox\">                        <img class=\"imgGallery\" data-bind=\"attr: { src: url }, click: $parent.selectStockImage\" />                    </div>                </div>                <!-- /ko -->            </div>        </div>    </div></script>"})(ExperimentEditor || (ExperimentEditor = {}));ExperimentEditor.typescriptResourceVariables = ExperimentEditor.typescriptResourceVariables || []; ExperimentEditor.typescriptResourceVariables.push("ExperimentEditor._publishToCommunityStep2Markup");
var ExperimentEditor;(function (ExperimentEditor) {ExperimentEditor._publishToCommunityStepOnCompleteMarkup = "<h2>%publishExperimentToCommunityPublishedExperimentHeader%</h2><label>%publishExperimentToCommunityPublishedExperimentLinkLabel%</label><div data-bind=\"fxsCopyButton: catalogExperimentUrl\"></div><br /><label class=\"shareWith\" data-bind=\"text: DataLab.LocalizedResources.shareWith\"></label><!-- Email --><a data-bind=\"attr: {href: emailLink()}\"><img src=\"/Content/Images/sharing-email.svg\" data-bind=\"attr: {title: DataLab.LocalizedResources.email}\" /></a> <!-- Twitter --><a data-bind=\"twitterButton: twitterButtonOptions()\"></a><!-- Linked In --><!-- @TODO Coming soon --><label class=\"shouldGoToPublishedExperimentLabel\">    <input type=\"checkbox\" data-bind=\"checked: shouldGoToPublishedExperiment\" />    %publishExperimentToCommunityShouldGoToPublishedExperimentText%</label>"})(ExperimentEditor || (ExperimentEditor = {}));ExperimentEditor.typescriptResourceVariables = ExperimentEditor.typescriptResourceVariables || []; ExperimentEditor.typescriptResourceVariables.push("ExperimentEditor._publishToCommunityStepOnCompleteMarkup");
var ExperimentEditor;(function (ExperimentEditor) {ExperimentEditor._publishWebServiceDialogMarkup = "<div id=\"publishWebServiceDialogContent\">    <div>        <label id=\"wsgNameLabel\" for=\"wsgNameBox\">%webServiceGroupNameLabel%</label>        <br/>               <input id=\"wsgNameBox\" type=\"text\" data-bind=\"value: webServiceGroupName\" />        <br/><br/>        <div id=\"webServiceInfoBox\">            %publishWebServiceDialogHelpText%        </div>    </div></div>"})(ExperimentEditor || (ExperimentEditor = {}));ExperimentEditor.typescriptResourceVariables = ExperimentEditor.typescriptResourceVariables || []; ExperimentEditor.typescriptResourceVariables.push("ExperimentEditor._publishWebServiceDialogMarkup");
var ExperimentEditor;(function (ExperimentEditor) {ExperimentEditor._recentWorkMarkup = "<div id=\"recentWork\">    <div id=\"preview\" data-bind=\"visible: thumbnail() || loading()\">        <div class=\"clearfix\">            <div class=\"heading left\">%recentWorkThumbnailLabel%</div>            <div class=\"selectorContainer right\">                <div class=\"heading\">%recentWorkThumbnailSize%</div>                <div id=\"thumbnailSizeSelector\" class=\"pushbutton\"></div>            </div>        </div>                <div id=\"thumbnailTitleContainer\" data-bind=\"if: thumbnailTitle\">            <h2 data-bind=\"text: thumbnailTitle\"></h2>        </div>        <div id=\"thumbnailContainer\">            <div id=\"thumbnail\" data-bind=\"attr: { class: thumbnailSize }\">                <!-- ko template: { name: 'experimentSvgTemplate', data: thumbnail, if: thumbnail } --><!-- /ko -->                <div class=\"spinner\" data-bind=\"css: { thumbnailLoading: loading() }\"></div>                <div class=\"shield\" data-bind=\"click: thumbnailOnClick, css: { clickable: thumbnail() }\"></div>            </div>        </div>    </div>        <div class=\"selectorContainer\">        <div class=\"heading\">%recentWorkFilterBy%</div>        <div id=\"filterSelector\" class=\"pushbutton\"></div>    </div>    <div class=\"shortExperimentList clearfix\" data-bind=\"visible: selectedFilter() === 'lastModified'\">        <div id=\"gridLastEdited\"></div>    </div>    <div class=\"shortExperimentList clearfix\" data-bind=\"visible: selectedFilter() === 'lastRun'\">        <div id=\"gridLastRun\"></div>    </div>        <div class=\"shortExperimentList clearfix\" data-bind=\"visible: selectedFilter() === 'lastPublished'\">        <div id=\"gridLastPublished\"></div>    </div></div>"})(ExperimentEditor || (ExperimentEditor = {}));ExperimentEditor.typescriptResourceVariables = ExperimentEditor.typescriptResourceVariables || []; ExperimentEditor.typescriptResourceVariables.push("ExperimentEditor._recentWorkMarkup");
var ExperimentEditor;(function (ExperimentEditor) {ExperimentEditor._saveSSIMDatasetMarkup = "<h2>Save Dataset From SSIM</h2><!-- This markup is repeated in all dialogs for creating new datasets --><div class=\"dataset-form\" data-bind=\"with: dataset\">    <div class=\"deprecate-header\">        <input type=\"checkbox\" data-bind=\"checked: deprecate\"/>%uploadDatasetDialogNewVersionOfDataset%    </div>    <div class=\"animation-wrapper\" data-bind=\"css: { hide: deprecate() }\">        %uploadDatasetDialogEnterName%        <input type=\"text\" data-bind=\"validatedInputBox: { value: _name }, enable: !deprecate()\">    </div>    <div class=\"animation-wrapper\" data-bind=\"css: { hide: !deprecate() }\">        %uploadDatasetDialogExistingDataset%        <div class=\"datalab-validation-wrapper\">                    <div class=\"datalab-validation-icon\" data-bind=\"validate: { value: resourceToDeprecate }\"></div>            <div class=\"datalab-validation-icon heuristic-hint\" data-bind=\"style: { 'visibility': hint() ? 'visible' : 'hidden', 'opacity': hint() ? '1' : '0' }\"></div>            <select data-bind=\"options: availableResources, value: resourceToDeprecate, enable: deprecate, optionsCaption: DataLab.LocalizedResources.ChooseDatasetToDeprecateAndEllipsis\"></select>        </div>    </div></div>    %uploadDatasetDialogDescription%<textarea rows=\"4\" data-bind=\"value: dataset.description\"></textarea>"})(ExperimentEditor || (ExperimentEditor = {}));ExperimentEditor.typescriptResourceVariables = ExperimentEditor.typescriptResourceVariables || []; ExperimentEditor.typescriptResourceVariables.push("ExperimentEditor._saveSSIMDatasetMarkup");
var ExperimentEditor;(function (ExperimentEditor) {ExperimentEditor._scoreDialogMarkup = "<h3 data-bind=\"text: DataLab.Util.format('%scoreDialogTitle%', wsgName)\"></h3><div id=\"scoreDialogContent\" class=\"datalab-dialog\">    <div id=\"parameterPanel\" >        <!-- ko if: (inputColumns.length == 0 && webServiceParameters.length == 0) -->            <h2>%scoreDialogNoDataNeeded%</h2>        <!-- /ko -->        <!-- ko if: (inputColumns.length > 0) -->            <h2>%scoreDialogEnterDataToPredict%</h2>        <div data-bind=\"foreach: inputColumns\">            <div class=\"field-group\">                <!-- ko if: valueType == \"Binary\" -->                    <input type=\"checkbox\" data-bind=\"checked: value, attr: { 'id': name }\" />                    <label data-bind=\"text: name, attr: { 'id': name + '_label', 'for': name, 'title': friendlyName }\"></label>                <!-- /ko -->                <!-- ko if: valueType == \"Categorical\" -->                    <label data-bind=\"text: name, attr: { 'id': name + '_label', 'for': name, 'title': friendlyName }\"></label>                <select type=\"text\" data-bind=\"value: value, options: allowedValues, attr: { 'id': name }\"></select>                <!-- /ko -->                <!-- ko if: valueType != \"Binary\" && valueType != \"Categorical\" -->                    <label data-bind=\"text: name, attr: { 'id': name + '_label', 'for': name, 'title': friendlyName }\"></label>                    <input type=\"text\" data-bind=\"value: value, attr: { 'id': name }\" />                <!-- /ko -->            </div>        </div>        <!-- /ko -->    </div>    <!-- ko if: (webServiceParameters.length > 0) -->        <div id=\"webServiceParametersPanel\" data-bind=\"style: { 'display': (webServiceParameters.length > 0) ? '' : 'none' }\">            <br />            <h2>%scoreDialogEnterWebServiceParameters%</h2>            <div data-bind=\"foreach: webServiceParameters\">                <div class=\"field-group\">                    <!-- ko if: metadata.Type == \"Boolean\" -->                        <input type=\"checkbox\" data-bind=\"checked: value, attr: { 'id':  metadata.Name  + '_wsp' }\" />                        <label data-bind=\"text: metadata.Name, attr: { 'for':  metadata.Name + '_wsp', 'title': metadata.Description }\" ></label>                    <!-- /ko -->                    <!-- ko if: metadata.Type != \"Boolean\" -->                        <label data-bind=\"text: metadata.Name, attr: { 'for':  metadata.Name + '_wsp', 'title': metadata.Description }\" ></label>                        <!-- ko if: metadata.Type == \"Script\" -->                            <textarea data-bind=\"value: value, attr: { 'id':  metadata.Name  + '_wsp' }\" ></textarea>                        <!-- /ko -->                        <!-- ko if: metadata.Type == \"Enumerated\" -->                            <select data-bind=\"value: value, options: metadata.ParameterRules[0].Values, attr: { 'id':  metadata.Name  + '_wsp' }\" ></select>                        <!-- /ko -->                        <!-- ko if: metadata.Type == \"Credential\" -->                            <input type=\"password\" data-bind=\"value: value, attr: { 'id':  metadata.Name  + '_wsp' }\" />                        <!-- /ko -->                        <!-- ko if: metadata.Type != \"Script\" && metadata.Type != \"Enumerated\" && metadata.Type != \"Credential\" -->                            <input type=\"text\" data-bind=\"value: value, attr: { 'id':  metadata.Name  + '_wsp' }\" />                        <!-- /ko -->                    <!-- /ko -->                </div>            </div>        </div>    <!-- /ko --></div>"})(ExperimentEditor || (ExperimentEditor = {}));ExperimentEditor.typescriptResourceVariables = ExperimentEditor.typescriptResourceVariables || []; ExperimentEditor.typescriptResourceVariables.push("ExperimentEditor._scoreDialogMarkup");
var ExperimentEditor;(function (ExperimentEditor) {ExperimentEditor._tagTextBoxMarkup = "<script type=\"text/html\" id=\"TagTextBox\">    <hflexbox class=\"columnNameList\" data-bind=\"validate: { value: currentTag }, click: setNameInputFocused, css: {hasItems: hasTags}\">        <!-- ko foreach: tags -->        <flexstatic class=\"columnNameBox\">            <span data-bind=\"text: $data\"></span>            <span class=\"removeColumnName\" data-bind=\"click: $parent.removeTag\"></span>        </flexstatic>        <!-- /ko -->        <flexfill>            <input type=\"text\" class=\"itemTextBoxInput\" data-bind=\"hasfocus: nameInputFocused, placeholder: hasTags() ? DataLab.LocalizedResources.pressEnterTag : '', style: { 'minWidth': tags().length === 0 ? '250px' : '50px' }, itemTextBox: { validColumnNames: tags, invalidColumnNames: ko.observableArray([]) }, value: currentTag\" />        </flexfill>        <div class=\"textWidthSpan\"></div>    </hflexbox></script>"})(ExperimentEditor || (ExperimentEditor = {}));ExperimentEditor.typescriptResourceVariables = ExperimentEditor.typescriptResourceVariables || []; ExperimentEditor.typescriptResourceVariables.push("ExperimentEditor._tagTextBoxMarkup");
var ExperimentEditor;(function (ExperimentEditor) {ExperimentEditor._trainedModelPromotionDialogMarkup = "<h2>%SaveTrainedModel%</h2><!-- This markup is repeated in all dialogs for creating new models --><div class=\"dataset-form\" data-bind=\"with: resource\">    <div class=\"deprecate-header\">        <input type=\"checkbox\" data-bind=\"checked: deprecate\"/>%uploadTrainedModelDialogNewVersionOfTrainedModel%    </div>    <div class=\"animation-wrapper\" data-bind=\"css: { hide: deprecate() }\">        %uploadTrainedModelDialogEnterName%        <input type=\"text\" data-bind=\"validatedInputBox: { value: _name }, enable: !deprecate()\">    </div>    <div class=\"animation-wrapper\" data-bind=\"css: { hide: !deprecate() }\">        %uploadTrainedModelDialogExistingTrainedModel%        <div class=\"datalab-validation-wrapper\">                    <div class=\"datalab-validation-icon\" data-bind=\"validate: { value: resourceToDeprecate }\"></div>            <div class=\"datalab-validation-icon heuristic-hint\" data-bind=\"style: { 'visibility': hint() ? 'visible' : 'hidden', 'opacity': hint() ? '1' : '0' }\"></div>            <select data-bind=\"options: availableResources, value: resourceToDeprecate, enable: deprecate, optionsCaption: DataLab.LocalizedResources.ChooseTrainedModelToDeprecateAndEllipsis\"></select>        </div>    </div></div>%uploadTrainedModelDialogDescription%<textarea rows=\"4\" data-bind=\"value: resource.description\"></textarea>"})(ExperimentEditor || (ExperimentEditor = {}));ExperimentEditor.typescriptResourceVariables = ExperimentEditor.typescriptResourceVariables || []; ExperimentEditor.typescriptResourceVariables.push("ExperimentEditor._trainedModelPromotionDialogMarkup");
var ExperimentEditor;(function (ExperimentEditor) {ExperimentEditor._transformPromotionDialogMarkup = "<h2>%SaveTransform%</h2><!-- This markup is repeated in all dialogs for creating new models --><div class=\"dataset-form\" data-bind=\"with: resource\">    <div class=\"deprecate-header\">        <input type=\"checkbox\" data-bind=\"checked: deprecate\"/>%uploadTransformDialogNewVersionOfTransform%    </div>    <div class=\"animation-wrapper\" data-bind=\"css: { hide: deprecate() }\">        %uploadTransformDialogEnterName%        <input type=\"text\" data-bind=\"validatedInputBox: { value: _name }, enable: !deprecate()\">    </div>    <div class=\"animation-wrapper\" data-bind=\"css: { hide: !deprecate() }\">        %uploadTransformDialogExistingTransform%        <div class=\"datalab-validation-wrapper\">                    <div class=\"datalab-validation-icon\" data-bind=\"validate: { value: resourceToDeprecate }\"></div>            <div class=\"datalab-validation-icon heuristic-hint\" data-bind=\"style: { 'visibility': hint() ? 'visible' : 'hidden', 'opacity': hint() ? '1' : '0' }\"></div>            <select data-bind=\"options: availableResources, value: resourceToDeprecate, enable: deprecate, optionsCaption: DataLab.LocalizedResources.ChooseTransformToDeprecateAndEllipsis\"></select>        </div>    </div></div>%uploadTransformDialogDescription%<textarea rows=\"4\" data-bind=\"value: resource.description\"></textarea>"})(ExperimentEditor || (ExperimentEditor = {}));ExperimentEditor.typescriptResourceVariables = ExperimentEditor.typescriptResourceVariables || []; ExperimentEditor.typescriptResourceVariables.push("ExperimentEditor._transformPromotionDialogMarkup");
var ExperimentEditor;(function (ExperimentEditor) {ExperimentEditor._uploadDatasetDialogMarkup = "<h2>%uploadDatasetUploadANewDataset%</h2><div class=\"datalab-validation-wrapper\">    <div class=\"datalab-validation-icon\" data-bind=\"validate: { value: fileToUpload }\"></div>    <label>        %uploadDatasetDialogDataToUpload%    </label>     <input type=\"file\" data-bind=\"file: fileToUpload\" />       </div><!-- This markup is repeated in all dialogs for creating new datasets --><div class=\"dataset-form\" data-bind=\"with: dataset\">    <div class=\"deprecate-header\">        <input type=\"checkbox\" data-bind=\"checked: deprecate\"/>%uploadDatasetDialogNewVersionOfDataset%    </div>    <div class=\"animation-wrapper\" data-bind=\"css: {hide: deprecate()}\">        <label>            %uploadDatasetDialogEnterName%        </label>        <input type=\"text\" data-bind=\"validatedInputBox: { value: _name }, enable: !deprecate()\" />    </div>    <div class=\"animation-wrapper\" data-bind=\"css: {hide: !deprecate()}\">                <div class=\"datalab-validation-wrapper\">                    <div class=\"datalab-validation-icon\" data-bind=\"validate: { value: resourceToDeprecate }\"></div>            <div class=\"datalab-validation-icon heuristic-hint\" data-bind=\"style: { 'visibility': hint() ? 'visible' : 'hidden', 'opacity': hint() ? '1' : '0' }\"></div>            <label>                %uploadDatasetDialogExistingDataset%            </label>            <select data-bind=\"options: availableResources, value: resourceToDeprecate, enable: deprecate, optionsCaption: DataLab.LocalizedResources.ChooseDatasetToDeprecateAndEllipsis\"></select>                    </div>    </div></div><div class=\"datalab-validation-wrapper\">    <div class=\"datalab-validation-icon\" data-bind=\"validate: { value: dataset.dataType }\"></div>    <label>        %uploadDatasetDialogSelectType%    </label>    <select data-bind=\"options: dataTypes, value: dataset.dataType, optionsText: getDataTypeCaption, optionsCaption: DataLab.LocalizedResources.ChooseADatasetTypeAndEllipsis\"></select>    </div> <label>    %uploadDatasetDialogDescription%</label><textarea data-bind=\"value: dataset.description\"></textarea>"})(ExperimentEditor || (ExperimentEditor = {}));ExperimentEditor.typescriptResourceVariables = ExperimentEditor.typescriptResourceVariables || []; ExperimentEditor.typescriptResourceVariables.push("ExperimentEditor._uploadDatasetDialogMarkup");
var ExperimentEditor;(function (ExperimentEditor) {ExperimentEditor._uploadModuleDialogMarkup = "<h2>%uploadModuleUploadANewModule%</h2><p><span data-bind=\"text: DataLab.LocalizedResources.uploadModuleDialogDescriptionText\"></span><a href=\"//go.microsoft.com/fwlink/?LinkId=524916\" target=\"_blank\">%uploadModuleDialogExample%</a>    <br>    <a href=\"//go.microsoft.com/fwlink/?LinkId=524876\" target=\"_blank\"> %uploadModuleDialogLearnMore%</a>    <br><br></p><div class=\"datalab-validation-wrapper\">    <div class=\"datalab-validation-icon\" data-bind=\"validate: { value: fileToUpload }\"></div>    <label>        %uploadModuleDialogDataToUpload%    </label>    <input type=\"file\" data-bind=\"file: fileToUpload\" accept=\"application/zip\" autofocus=\"autofocus\" /></div>"})(ExperimentEditor || (ExperimentEditor = {}));ExperimentEditor.typescriptResourceVariables = ExperimentEditor.typescriptResourceVariables || []; ExperimentEditor.typescriptResourceVariables.push("ExperimentEditor._uploadModuleDialogMarkup");
var ExperimentEditor;(function (ExperimentEditor) {ExperimentEditor._visualizationMarkup = "    <div class=\"visualizationContent\">        <hflexbox class=\"numberRowsColumnsContainer\">            <div class=\"numberRowsColumnsHeader\">                <div class=\"smallHeader\">                    %VisualizationRows%                </div>                <div data-bind=\"text: dataTableViewModel.numberOfRows\">                </div>            </div>            <div class=\"numberRowsColumnsHeader\">                <div class=\"smallHeader\">                    %VisualizationColumns%                </div>                <div data-bind=\"text: dataTableViewModel.numberOfColumns\">                </div>            </div>        </hflexbox>        <hflexbox class=\"visualizationTableWrapper\">            <div class=\"dataTableContainer\">                <table id=\"dataTable\" data-bind=\"event: { click: selectColumn }\">                    <tbody>                        <tr>                            <th class=\"emptyCell whiteCell\"></th>                            <!-- ko foreach: columns -->                            <th class=\"tableHeader\" data-bind=\"text: name, css: { 'selectedHeader': selected() }\"></th>                            <!-- /ko -->                        </tr>                        <tr>                            <td class=\"toggleCell\">                                <div class=\"toggleDiv\">                                    <div class=\"toggleLabelDiv\">                                        %VisualizationViewAs%                                    </div>                                    <div class=\"toggleIconDiv\">                                        <div data-bind=\"attr: { class: minimizedGraphsType() === 'Histogram' ? 'histogramSelectedImage' : 'histogramIdleImage' }, event: { 'click': setHistogramMode }\">                                        </div>                                        <div data-bind=\"attr: { class: minimizedGraphsType() !== 'Histogram' ? 'boxchartSelectedImage' : 'boxcharIdleImage' }, event: { 'click': setBoxchartMode }\">                                        </div>                                    </div>                                </div>                            </td>                            <!-- ko foreach: columns -->                            <td class=\"graphCell\" data-bind=\"d3graph: { data: $data.minimizedGraph, minWidth: 44, height: 30, padding: 0, minimized: true }\"></td>                            <!-- /ko -->                        </tr>                        <!-- ko foreach: dataTableViewModel.records -->                        <tr>                            <td class=\"emptyCell\"></td>                            <!-- ko foreach: $data -->                            <td data-bind=\"text: $data\"></td>                            <!-- /ko -->                        </tr>                        <!-- /ko -->                    </tbody>                </table>            </div>            <div data-bind=\"                resize: {                    direction: 'left',                    parentContainerSelector: '.visualizationTableWrapper',                    minSize: 447,                    id: 'statsAndGraphs'                },                collapsepanel: {                    collapseButtonSelector: '.statsAndGraphsExpander',                    collapsed: statsAndGraphsIsCollapsed,                    collapseFrom: 'left',                    collapsedSize: 36,                    id: 'statsAndGraphs'                }\"                 class=\"statsAndGraphs\">                <div class=\"statsAndGraphsExpander\"></div>                <div class=\"statsAndGraphsTitle\">%statsAndGraphsTitle%</div>                         <div class=\"statsAndGraphsContent\">                    <div class=\"statsContainer\" data-bind=\"                        collapsepanel: {                            collapseButtonSelector: '.statsAndGraphsSubExpander.statsExpander',                            collapsed: statsIsCollapsed,                            collapseFrom: 'bottom',                            collapsedSize: 33,                            id: 'stats'                        }\">                                 <hflexbox class=\"statsAndGraphsHeader\">                            <div class=\"statsAndGraphsSubExpander statsExpander\"></div>                            <div>%visualizationStatisticsHeader%</div>                        </hflexbox>                        <!-- ko if: currentSelectedColumnViewModel !== null -->                        <div class=\"statsTable\">                            <!-- ko with: currentSelectedColumnViewModel -->                            <table>                                <tbody>                                    <!-- ko foreach: columnStatistics -->                                    <tr>                                        <td data-bind=\"text: name\"></td>                                        <td data-bind=\"text: value\"></td>                                    </tr>                                    <!-- /ko -->                                </tbody>                            </table>                            <!-- /ko -->                        </div>                        <!-- /ko -->                    </div>                                    <div class=\"graphVisualizationContainer\" data-bind=\"                        collapsepanel: {                            collapseButtonSelector: '.statsAndGraphsSubExpander.visualizationExpander',                            collapsed: visualizationIsCollapsed,                            collapseFrom: 'bottom',                            collapsedSize: 33,                            id: 'visualization'                        }\">                        <hflexbox class=\"statsAndGraphsHeader\">                            <div class=\"statsAndGraphsSubExpander visualizationExpander\"></div>                            <div>%visualizationHeader%</div>                        </hflexbox>                        <div class=\"expandedView\">                            <div data-bind=\"style: { 'display': columnIsSelected() ? 'none' : '' }\" class=\"placeholderGraph graphDiv\">                                                <div class=\"placeholderImage\" >                                </div>                                <div class=\"placeholderText\">                                    %VisualizationToCreateAGraphSelectAFeatureInTheDataTableBelow%                                </div>                            </div>                            <div data-bind=\"style: { 'display': graphControl().isNull ? 'none' : 'block' }\" class=\"graphContainer\">                                <div>                                    <div class=\"graphSubheader\" data-bind=\"text: graphControl().feature\">                                    </div>                                </div>                                <div class=\"headerDiv\">                                    <div class=\"header graphHeader\" data-bind=\"text: graphControl().graphTypeString\">                                    </div>                                </div>                                <hflexbox class=\"compareToContainer\" data-bind=\"style: { 'display': entireDatasetIsPresent ? '' : 'none' }\">                                    <div class=\"compareTo\">                                        <div class=\"graphText inlineDiv\">                                            %VisualizationCompareTo%                                        </div>                                        <select data-bind=\"options: graphControl().compareToFeatures, value: graphControl().crossCompareFeature\"></select>                                    </div>                                    <div class=\"icons\">                                        <div title=\"Create Snapshot\" class=\"inlineDiv snapshotIdle\" data-bind=\"event: { click: takeSnapshot }\">                                        </div>                                                            </div>                                </hflexbox>                                <hflexbox id=\"bodyDiv\">                                    <div id=\"activeSvgDiv\" class=\"inlineDiv activeSvgContainer\" data-bind=\"d3graph: { data: graphControl().graph, minWidth: 380, height: 370, padding: 60, minimized: false, name: 'main' }\">                                    </div>                                    <!-- ko foreach: snapshots -->                                    <div class=\"graphDiv snapshotContainer\">                                        <div>                                            <div class=\"snapshotHeader\">                                                <div class=\"graphSubheader leftDiv\" data-bind=\"text: feature\">                                                </div>                                                <div title=\"Close\" class=\"snapshotClose closeIdle rightDiv\" data-bind=\"event: { click: $parent.closeSnapshot.bind($parent) }\">                                                </div>                                            </div>                                            <div data-bind=\"d3graphcopy: { name: 'main', visible: visible, animationDuration: animationDuration }\" class=\"svgcopy\">                                            </div>                                        </div>                                    </div>                                    <!-- /ko -->                                </hflexbox>                            </div>                                                    <div class=\"parameters\" data-bind=\"style: { 'display': parametersAreVisible() ? '' : 'none' }\">                                <div data-bind=\"style: { 'display': graphControl().scaleCheckboxesVisible() ? '' : 'none' }\">                                    <div class=\"logScaleDiv\" data-bind=\"style: { 'display': graphControl().xScaleCheckbox.visible() ? '' : 'none' }\">                                        <input type=\"checkbox\" data-bind=\"checked: graphControl().xScaleCheckbox.value\" class=\"inlineDiv\" />                                        <div data-bind=\"text: graphControl().xScaleCheckbox.label\" class=\"inlineDiv logScaleText\">                                        </div>                                    </div>                                    <div class=\"logScaleDiv\" data-bind=\"style: { 'display': graphControl().yScaleCheckbox.visible() ? '' : 'none' }\">                                        <input type=\"checkbox\" data-bind=\"checked: graphControl().yScaleCheckbox.value\" class=\"inlineDiv\" />                                        <div data-bind=\"text: graphControl().yScaleCheckbox.label\" class=\"inlineDiv logScaleText\">                                        </div>                                    </div>                                </div>                                <div data-bind=\"style: { 'display': graphControl().binCountVisible() ? '' : 'none' }\">                                    <div class=\"graphText binsLabel\">                                        bins                                    </div>                                    <input type=\"text\" class=\"bins\" data-bind=\"value: graphControl().binCount\" />                                </div>                                <div data-bind=\"style: { 'display': graphControl().categoriesVisible() ? '' : 'none' }\">                                    <div class=\"graphText binsLabel\">                                        %VisualizationCategories%                                    </div>                                    <input type=\"text\" class=\"bins\" data-bind=\"value: graphControl().categoriesCount\" />                                </div>                                <div class=\"probabilityFunctions\" data-bind=\"style: { 'display': graphControl().probabilityFunctionsVisible() ? '' : 'none' }\">                                    <div class=\"probabilityFunctionDiv\">                                        <input type=\"checkbox\" class=\"inlineDiv\" data-bind=\"checked: graphControl().cumulativeDistribution\" />                                        <div class=\"inlineDiv probabilityFunctionText\">                                            %VisualizationCumulativeDistribution%                                        </div>                                    </div>                                    <div class=\"probabilityFunctionDiv\">                                        <input type=\"checkbox\" class=\"inlineDiv\" data-bind=\"checked: graphControl().probabilityDensity\" />                                        <div class=\"inlineDiv probabilityFunctionText\">                                            %VisualizationProbabilityDensity%                                        </div>                                    </div>                                </div>                            </div>                        </div>                    </div>                </div>            </div>        </hflexbox>    </div>"})(ExperimentEditor || (ExperimentEditor = {}));ExperimentEditor.typescriptResourceVariables = ExperimentEditor.typescriptResourceVariables || []; ExperimentEditor.typescriptResourceVariables.push("ExperimentEditor._visualizationMarkup");
var ExperimentEditor;(function (ExperimentEditor) {ExperimentEditor._bubbleMarkup = "<div id=\"bubble-root\">    <div id=\"bubble-container\" data-bind=\"visible:overlayVisible, style: { left: bubbleX() + 'px' , top: bubbleY() + 'px' }\">        <div id=\"bubble-arrow\" data-bind=\"fadeVisible:visible, style: { left: arrowX() + 'px', top: arrowY() + 'px' }, css: arrowClassId()\"></div>        <div id=\"bubble\" data-bind=\"fadeVisible:visible, style: { width: width() + 'px', height: height() + 'px' }\">            <a class=\"bubble-close\" href=\"#\" id=\"bubble-close\" data-bind=\"click:close\"></a>            <div class=\"bubble-title\" data-bind=\"text: title()\"></div>            <div class=\"bubble-content\" data-bind=\"html: content()\"></div>            <div class=\"bubble-bottom\">                <a class=\"bubble-button left\" data-bind=\"visible: hasBack, click: backAsync\">%bubbleBackButtonText%</a>                <a class=\"bubble-button right\" data-bind=\"visible: hasNext, click: nextAsync\">%bubbleNextButtonText%</a>                <a class=\"bubble-button right\" data-bind=\"visible: !hasNext(), click: close\">%bubbleFinishedButtonText%</a>                <!-- ko if: totalSteps() > 1-->                <ul class=\"bubble-progress center\" data-bind=\"foreach: steps\">                    <li data-bind=\"css: $index() === $root.currentIndex() ? 'white' : '', click: function() { $root.gotoAsync($index()); }\"></li>                </ul>                <!-- /ko -->            </div>        </div>    </div>    <div class=\"bubble-transparent-overlay\" data-bind=\"visible:overlayVisible() && showOverlay()\">        <!-- ko if: hightlightRect() -->        <div class=\"bubble-overlay bubble-overlay-top\" data-bind=\"style: { height: hightlightRect().top + 'px' }\"></div>        <div class=\"bubble-overlay bubble-overlay-left\" data-bind=\"style: { top: hightlightRect().top + 'px', height: hightlightRect().height + 'px', width: hightlightRect().left + 'px' }\"></div>        <div class=\"bubble-overlay bubble-overlay-right\" data-bind=\"style: { top: hightlightRect().top + 'px', height: hightlightRect().height + 'px', left: hightlightRect().left + hightlightRect().width + 'px' }\"></div>        <div class=\"bubble-overlay bubble-overlay-bottom\" data-bind=\"style: { top: hightlightRect().top + hightlightRect().height + 'px' }\"></div>        <!-- /ko -->    </div></div>"})(ExperimentEditor || (ExperimentEditor = {}));ExperimentEditor.typescriptResourceVariables = ExperimentEditor.typescriptResourceVariables || []; ExperimentEditor.typescriptResourceVariables.push("ExperimentEditor._bubbleMarkup");
var ExperimentEditor;(function (ExperimentEditor) {ExperimentEditor._createWebServiceTutorialStep1Markup = "<div>    <h2>Welcome to web service creation</h2>    <div>        <p>            Placeholder        </p>    </div></div>"})(ExperimentEditor || (ExperimentEditor = {}));ExperimentEditor.typescriptResourceVariables = ExperimentEditor.typescriptResourceVariables || []; ExperimentEditor.typescriptResourceVariables.push("ExperimentEditor._createWebServiceTutorialStep1Markup");
var ExperimentEditor;(function (ExperimentEditor) {ExperimentEditor._createWebServiceTutorialStep2Markup = "<div>    <h2>Edit your workflow and complete the graph</h2>    <div>        <p>            Placeholder        </p>    </div></div>"})(ExperimentEditor || (ExperimentEditor = {}));ExperimentEditor.typescriptResourceVariables = ExperimentEditor.typescriptResourceVariables || []; ExperimentEditor.typescriptResourceVariables.push("ExperimentEditor._createWebServiceTutorialStep2Markup");
var ExperimentEditor;(function (ExperimentEditor) {ExperimentEditor._createWebServiceTutorialStep3Markup = "<div>    <h2>Specify Input and Output, Run and Publish</h2>    <div>        <p>            Placeholder        </p>    </div></div>"})(ExperimentEditor || (ExperimentEditor = {}));ExperimentEditor.typescriptResourceVariables = ExperimentEditor.typescriptResourceVariables || []; ExperimentEditor.typescriptResourceVariables.push("ExperimentEditor._createWebServiceTutorialStep3Markup");
var ExperimentEditor;(function (ExperimentEditor) {ExperimentEditor._binaryClassificationComparisonMarkup = "<!-- ko if: loaded --><vflexbox class=\"pageContainer\">    <!-- ko with: plotContainer -->    <div class=\"viewModelContainer\">        <div class=\"sectionContainer\">            <vflexbox>                <div class=\"tabHeaders\">                    <!-- ko foreach: chartNames -->                    <div data-bind=\"attr: { id: $data + '-tab' }, text: $data.toUpperCase(), click: $parent.setCurrentChart, css: { selected: $data === $parent.currentChart() }\" class=\"tab\"></div>                    <!-- /ko -->                </div>                <hflexbox class=\"chartContainer\">                    <div class=\"yAxisContainer\" data-bind=\"style: { 'marginTop': height() / 2 + 'px' }\">                        <div class=\"vertical-text yAxisLabel graphText\" data-bind=\"text: yAxisLabel\"></div>                    </div>                    <div class=\"graphContainer\">                        <svg class=\"chartArea\" data-bind=\"attr: { height: height(), width: width() }\">                            <g data-bind=\"d3Axes: { xScale: xScale(), yScale: yScale() }\" />                                               <!-- ko foreach: plotData -->                            <g data-bind=\"attr: { id: 'curve' + $index() }\">                                <path class=\"chartCurve\" data-bind=\"                                    attr: {                                        d: $parent.svgLineFunction()(data),                                        stroke: $parent.colors()[$index()],                                        'stroke-width': $index() === $root.currentViewModelIndex() ? 5 : 3,                                        opacity: $index() === $root.currentViewModelIndex() ? 1 : 0.8                                     },                                    click: function() {  $root.setCurrentViewModelIndex($index()) }\" >                                </path>                            </g>                            <!-- /ko -->                        </svg>                    </div>                    <div class=\"legendContainer\">                        <!-- ko foreach: plotData -->                        <hflexbox class=\"legendInstance\" data-bind=\"click: function() { $root.setCurrentViewModelIndex($index()) }, css: { selected: $index() === $root.currentViewModelIndex() }\">                            <div class=\"legendColor\" data-bind=\"style: { 'backgroundColor': $parent.colors()[$index()] }\"></div>                            <div class =\"legendLabel\" data-bind=\"text: label\"></div>                </hflexbox>                          <!-- /ko -->                    </div>                </hflexbox>                  <div class=\"xAxisContainer\" data-bind=\"style: { 'marginLeft': width() / 2 + 'px' }\">                    <div class=\"horz-text xAxisLabel graphText\" data-bind=\"text: xAxisLabel\"></div>                  </div>            </vflexbox>        </div>    </div>        <!-- /ko -->    <!-- ko with: currentViewModel -->        <div class=\"sectionContainer\">            <hflexbox>                <!-- ko with: confusionMatrixViewModel -->                <table class=\"confusionMatrixTable\">                    <tr>                        <td class=\"numeric-box\">                            <div class=\"numeric-header\">%rocTruePositive%</div>                            <div class=\"numeric-field\" data-bind=\"text: rows()[0].cells()[0]\"></div>                        </td>                            <td class=\"numeric-box\">                            <div class=\"numeric-header\">%rocFalseNegative%</div>                            <div class=\"numeric-field\" data-bind=\"text: rows()[0].cells()[1]\"></div>                        </td>                    </tr>                        <tr>                        <td class=\"numeric-box\">                            <div class=\"numeric-header\">%rocFalsePositive%</div>                            <div class=\"numeric-field\" data-bind=\"text: rows()[1].cells()[0]\"></div>                        </td>                            <td class=\"numeric-box\">                            <div class=\"numeric-header\">%rocTrueNegative%</div>                            <div class=\"numeric-field\" data-bind=\"text: rows()[1].cells()[1]\"></div>                        </td>                    </tr>                </table>                  <!-- /ko -->                 <!-- ko with: precisionRecallViewModel -->                <table class=\"confusionMatrixTable\">                    <tr>                        <td class=\"numeric-box\">                            <div class=\"numeric-header\">%rocAccuracy%</div>                            <div class=\"numeric-field\" data-bind=\"text: rows()[0].cells()[0]\"></div>                        </td>                        <td class=\"numeric-box\">                            <div class=\"numeric-header\">%rocPrecision%</div>                            <div class=\"numeric-field\" data-bind=\"text: rows()[0].cells()[1]\"></div>                        </td>                        <tr>                        <td class=\"numeric-box\">                            <div class=\"numeric-header\">%rocRecall%</div>                            <div class=\"numeric-field\" data-bind=\"text: rows()[1].cells()[0]\"></div>                        </td>                        <td class=\"numeric-box\">                            <div class=\"numeric-header\">%rocF1Score%</div>                            <div class=\"numeric-field\" data-bind=\"text: rows()[1].cells()[1]\"></div>                        </td>                    </tr>                </table>                  <!-- /ko -->                <div class=\"numeric-box thresholdBox\">                    <div class=\"numeric-header\">%rocThreshold%</div>                    <input class=\"numeric-field thresholdText\" data-bind=\"value: rawThreshold\"/>                </div>                <div>                    <input type=\"range\" min=\"0\" max=\"1\" step=\".01\" data-bind=\"value: threshold\" />                </div>                <div class =\"numeric-box\">                    <div class=\"numeric-header\">%rocCumulativeAuc%</div>                    <div class=\"numeric-field\" data-bind=\"text: auc\"></div>                </div>            </hflexbox>        </div>        <!-- ko with: binDataViewModel -->        <div class=\"sectionContainer\">            <table class=\"buckets-data\">                <tr data-bind=\"foreach: headerRow().cells\">                    <th data-bind=\"text: $data\"></th>                </tr>                <!-- ko foreach: rows() -->                <tr data-bind=\"foreach: cells\">                    <td data-bind=\"text: $data\"></td>                </tr>                <!-- /ko -->            </table>        </div>        <!-- /ko -->     <!-- /ko --></vflexbox><!-- /ko -->"})(ExperimentEditor || (ExperimentEditor = {}));ExperimentEditor.typescriptResourceVariables = ExperimentEditor.typescriptResourceVariables || []; ExperimentEditor.typescriptResourceVariables.push("ExperimentEditor._binaryClassificationComparisonMarkup");
var ExperimentEditor;(function (ExperimentEditor) {ExperimentEditor._clusteringMarkup = "<div class=\"clusterContainer\">    <hflexbox>        <svg class=\"clusterSvg\" data-bind=\"attr: { height: height, width: width }\">            <g class=\"axesContainer\" data-bind=\"clusteringAxes: { }\" />              <!-- ko foreach: clusterViewModels -->            <g>                <ellipse class=\"clusterEllipse\" stroke-width=\"2\" data-bind=\"                style: { fill: color },                attr: { cx: centroidX(), cy: centroidY(),                    rx: majorAxisLength(), ry: minorAxisLength(),                    transform: ellipseRotation(),                    stroke: color() }\">                </ellipse>            </g>            <!-- /ko -->        </svg>        <div class=\"clusterLegendContainer\">            <!-- ko foreach: clusterViewModels -->            <hflexbox class=\"clusterLegendInstance\">                <div class=\"clusterLegendColor\" data-bind=\"style: { 'backgroundColor': color }\"></div>                <div class=\"clusterLegendLabel\" data-bind=\"text: label\"></div>            </hflexbox>            <!-- /ko -->        </div>    </hflexbox></div>"})(ExperimentEditor || (ExperimentEditor = {}));ExperimentEditor.typescriptResourceVariables = ExperimentEditor.typescriptResourceVariables || []; ExperimentEditor.typescriptResourceVariables.push("ExperimentEditor._clusteringMarkup");
var ExperimentEditor;(function (ExperimentEditor) {ExperimentEditor._customUXContainerMarkup = "<div class=\"customUXWindow\" data-bind=\"style: { width: width(), height: height() }\">    <hflexbox class=\"visualizationTopHeader\">        <!-- ko with: breadcrumbHeader -->        <hflexbox class=\"breadcrumbHeader\">            <!-- ko if: $parent.showBreadcrumbHeader -->            <div class = \"breadcrumbHeaderText\" data-bind=\"text: experimentName\"></div>            <div class = \"breadcrumbHeaderSeparator\"></div>            <div class = \"breadcrumbHeaderText\" data-bind=\"text: moduleName\"></div>            <div class = \"breadcrumbHeaderSeparator\"></div>            <div class = \"breadcrumbHeaderText\" data-bind=\"text: portName\"></div>            <!-- /ko -->            <div class='icon close'></div>        </hflexbox>        <!-- /ko -->    </hflexbox></div>"})(ExperimentEditor || (ExperimentEditor = {}));ExperimentEditor.typescriptResourceVariables = ExperimentEditor.typescriptResourceVariables || []; ExperimentEditor.typescriptResourceVariables.push("ExperimentEditor._customUXContainerMarkup");
var ExperimentEditor;(function (ExperimentEditor) {ExperimentEditor._customUXMarkup = "<h1>This is customUX</h1><input type=\"range\" min=\"0\" max=\"1\" step=\"0.1\" />    <button data-bind=\"text:buttonText\"></button>    <input type=\"radio\" name=\"group1\" value=\"kiity\"/>    <input type=\"radio\" name=\"group1\" value=\"doggie\"/>    <img />    <h2>%SelectAColumnAndEllipsis%</h2><select></select>"})(ExperimentEditor || (ExperimentEditor = {}));ExperimentEditor.typescriptResourceVariables = ExperimentEditor.typescriptResourceVariables || []; ExperimentEditor.typescriptResourceVariables.push("ExperimentEditor._customUXMarkup");
var ExperimentEditor;(function (ExperimentEditor) {ExperimentEditor._genericMimeMarkup = "<div class=\"rOutputContainer\">    <!-- ko foreach: mimeSections -->    <div class=\"rOutputLogContainer\">        <hflexbox>            <vflexbox class=\"rExpanderContainer\">                <div class=\"rExpander\" data-bind=\"css: { 'expanded': show(), 'collapsed': !show() }, click: function () { $data.show(!$data.show()) }\"></div>            </vflexbox>            <div class=\"rLogHeader\" data-bind=\"text: title()\"> </div>        </hflexbox>        <div data-bind=\"style: { display: show() ? '' : 'none' }\">            <!-- ko foreach: values -->            <div data-bind=\"template: { name: $parents[1].getSectionTemplateByMimeType(dataType()) }\"></div>            <!-- /ko -->        </div>    </div>    <!-- /ko --></div><script id=\"mimeTextEntry\" type=\"text/html\">    <div class=\"rOutputLog\" data-bind=\"text: data()\"></div></script><script id=\"mimePngEntry\" type=\"text/html\">    <img class=\"rImage\" data-bind=\"attr: { src: 'data:image/png;base64,' + data() }\" /></script>"})(ExperimentEditor || (ExperimentEditor = {}));ExperimentEditor.typescriptResourceVariables = ExperimentEditor.typescriptResourceVariables || []; ExperimentEditor.typescriptResourceVariables.push("ExperimentEditor._genericMimeMarkup");
var ExperimentEditor;(function (ExperimentEditor) {ExperimentEditor._jSONMarkup = "<div class=\"JSONContainer\" data-bind=\"text: text\"></div>"})(ExperimentEditor || (ExperimentEditor = {}));ExperimentEditor.typescriptResourceVariables = ExperimentEditor.typescriptResourceVariables || []; ExperimentEditor.typescriptResourceVariables.push("ExperimentEditor._jSONMarkup");
var ExperimentEditor;(function (ExperimentEditor) {ExperimentEditor._learnerMarkup = "<div class=\"learnerContainer\">    <div class=\"learnerName\" data-bind=\"text: learnerName\"></div>    <!-- ko foreach: tables -->    <div class=\"learnerTableContainer\">        <div class=\"learnerTableHeader\" data-bind=\"text: headerLabel()\"></div>        <table>            <tr>                <!-- ko foreach: columnNames -->                <th data-bind=\"text: $data\"></th>                <!-- /ko -->            </tr>            <!-- ko foreach: table -->            <tr class=\"learnerTable\">                <!-- ko foreach: $data -->                <td data-bind=\"text: $data\"></td>                <!-- /ko -->            </tr>            <!-- /ko -->        </table>    </div>    <!-- /ko --></div>"})(ExperimentEditor || (ExperimentEditor = {}));ExperimentEditor.typescriptResourceVariables = ExperimentEditor.typescriptResourceVariables || []; ExperimentEditor.typescriptResourceVariables.push("ExperimentEditor._learnerMarkup");
var ExperimentEditor;(function (ExperimentEditor) {ExperimentEditor._multiclassClassificationMarkup = "<!-- ko if: loaded --><div class=\"multiclassViewModelContainer\">    <!-- ko foreach: viewModels -->    <div>        <!-- ko if: showMetrics -->        <div class=\"multiclassSection\">            <hflexbox class=\"multiclassSectionHeader\">                <vflexbox class=\"multiclassExpanderContainer\">                    <div class=\"multiclassExpander\" data-bind=\"                        css: { 'expanded': !metricsIsCollapsed(), 'collapsed': metricsIsCollapsed() },                        click: function () { $data.metricsIsCollapsed(!$data.metricsIsCollapsed()) }\">                    </div>                </vflexbox>                <div>%multiclassMetricsHeader%</div>            </hflexbox>            <div class=\"metricsTableContainer\" data-bind=\"style: { display: metricsIsCollapsed() ? 'none' : '' }\">                <table class=\"metricsTable\">                <tbody>                    <!-- ko foreach: metrics -->                    <tr>                        <!-- ko foreach: $data -->                        <td data-bind=\"text: $data\"></td>                        <!-- /ko -->                    </tr>                    <!-- /ko -->                </tbody>                </table>            </div>        </div>        <!-- /ko -->        <div class=\"multiclassSection\">            <hflexbox class=\"multiclassSectionHeader\">                <vflexbox class=\"multiclassExpanderContainer\">                    <div class=\"multiclassExpander\" data-bind=\"                        css: { 'expanded': !confusionMatrixIsCollapsed(), 'collapsed': confusionMatrixIsCollapsed() },                        click: function () { $data.confusionMatrixIsCollapsed(!$data.confusionMatrixIsCollapsed()) }\">                    </div>                </vflexbox>                <div>%multiclassConfusionMatrixHeader%</div>            </hflexbox>            <svg class=\"multiclassSvg\" data-bind=\"attr: { width: width, height: height }, style: { display: confusionMatrixIsCollapsed() ? 'none' : '' }\">                <g>                    <!-- ko foreach: superHeaders -->                    <text class=\"superHeaderText\" data-bind=\"text: label, attr: { x: xCoordinate, y: yCoordinate, transform: transform }\"></text>                    <!-- /ko -->                    <!-- ko foreach: xClassLabels -->                    <text class=\"labelHeaderText\" data-bind=\"text: label, attr: { x: xCoordinate, y: yCoordinate, transform: transform }\">                        <title data-bind=\"text: fullLabel\"></title>                    </text>                    <!-- /ko -->                    <!-- ko foreach: yClassLabels -->                    <text class=\"labelHeaderText\" data-bind=\"text: label, attr: { x: xCoordinate, y: yCoordinate, transform: transform }\">                        <title data-bind=\"text: fullLabel\"></title>                    </text>                    <!-- /ko -->                </g>                <g>                    <!-- ko foreach: instances -->                    <rect class=\"confusionMatrixEntry\" data-bind=\"style: { 'stroke-width': isMainDiagonalEntry() ? 5 : 1 },                    attr: { width: sideLength, height: sideLength, x: xCoordinate, y: yCoordinate, 'fill-opacity': fractionOfActualClass }\">                        <title data-bind=\"text: '%multiclassFrequency%: ' + frequency()\"></title>                    </rect>                    <text class=\"entryLabel\" data-bind=\"text: frequency() > 0 ? percentOfActualClass : '', attr: { x: xCoordinate() + (sideLength() / 2), y: yCoordinate() + (sideLength() / 2) }\">                        <title data-bind=\"text: '%multiclassFrequency%: ' + frequency()\"></title>                    </text>                    <!-- /ko -->                </g>            </svg>        </div>    </div>    <!-- /ko --></div><!-- /ko -->"})(ExperimentEditor || (ExperimentEditor = {}));ExperimentEditor.typescriptResourceVariables = ExperimentEditor.typescriptResourceVariables || []; ExperimentEditor.typescriptResourceVariables.push("ExperimentEditor._multiclassClassificationMarkup");
var ExperimentEditor;(function (ExperimentEditor) {ExperimentEditor._rOutputMarkup = "<div class=\"rOutputContainer\">    <!-- ko foreach: outputLogs -->    <div class=\"rOutputLogContainer\">        <hflexbox>            <vflexbox class=\"rExpanderContainer\">                <div class=\"rExpander\" data-bind=\"css: { 'expanded': show(), 'collapsed': !show() }, click: function () { $data.show(!$data.show()) }\"></div>            </vflexbox>            <div class=\"rLogHeader\" data-bind=\"text: label()\"> </div>        </hflexbox>        <div class=\"rOutputLog\" data-bind=\"text: content(), style: { display: show() ? '' : 'none' }\"></div>    </div>    <!-- /ko -->    <div class=\"rGraphicsDevice\">        <hflexbox>            <vflexbox class=\"rExpanderContainer\">                <div class=\"rExpander\" data-bind=\"css: { 'expanded': showGraphicsDevice(), 'collapsed': !showGraphicsDevice() }, click: function () { $data.showGraphicsDevice(!$data.showGraphicsDevice()) }\"></div>            </vflexbox>            <div class=\"rLogHeader\">%rOutputGraphicsDevice%</div>        </hflexbox>        <div data-bind=\"style: { display: showGraphicsDevice() ? '' : 'none' }\">            <!-- ko foreach: pngSrcs -->            <img class=\"rImage\" data-bind=\"attr: { src: $data }\" />            <!-- /ko -->        </div>    </div></div>"})(ExperimentEditor || (ExperimentEditor = {}));ExperimentEditor.typescriptResourceVariables = ExperimentEditor.typescriptResourceVariables || []; ExperimentEditor.typescriptResourceVariables.push("ExperimentEditor._rOutputMarkup");
var ExperimentEditor;(function (ExperimentEditor) {ExperimentEditor._treeEnsembleMarkup = "<div id=\"treeEnsembleViewContainer\" class=\"TreeEnsembleOutputContainer\">    <div id=\"sideBar\" data-bind=\"event: { scroll: onScroll }\">        <table>            <tbody>                <!-- ko foreach: treeThumbnailUrls -->                    <tr>                        <td>                            <img class=\"treeThumbnail\" data-bind=\"attr: { src: thumbnailUrl }, event: { click: select }\" />                        </td>                    </tr>                <!-- /ko -->                <!-- ko if: showLoadMore -->                <tr>                    <td>                        <div data-bind=\"event: { click: loadMore }\" id=\"showMoreLink\">Show more</div>                    </td>                </tr>                <!-- /ko -->            </tbody>        </table>    </div><!-- this comment gets rid of the gap between the two elements    --><div id=\"treeViewContainer\">        <!-- ko with: tree -->            <div id=\"treeInterface\" style=\"position:relative\">                <div id=\"treeView\">                    <div class=\"customElements\">                        <svg id=\"treeSvg\">                            <rect width=\"100%\" height=\"100%\" class=\"treeBackground\" data-bind=\"event: { click: clearSelection }\"/>                            <g id=\"transformElement\">                                <!-- ko foreach: leftEdges -->                                    <!-- ko if: highlight -->                                        <line class=\"treeHighlightEdge\" data-bind=\"attr: { x1: start.x, y1: start.y, x2: end.x, y2: end.y }\" />                                    <!-- /ko -->                                    <line class=\"treeEdge\" data-bind=\"attr: { x1: start.x, y1: start.y, x2: end.x, y2: end.y }\" />                                    <!-- ko if: text -->                                        <text class=\"trueEdgeCaption\" data-bind=\"attr: { x: start.x + (end.x - start.x) * ((end.y - start.y - 14) / (end.y - start.y)), y: end.y - 14 }, text: text\"></text>                                    <!-- /ko -->                                <!-- /ko -->                                <!-- ko foreach: rightEdges -->                                    <!-- ko if: highlight -->                                        <line class=\"treeHighlightEdge\" data-bind=\"attr: { x1: start.x, y1: start.y, x2: end.x, y2: end.y }\" />                                    <!-- /ko -->                                    <line class=\"treeEdge\" data-bind=\"attr: { x1: start.x, y1: start.y, x2: end.x, y2: end.y }\" />                                    <!-- ko if: text -->                                        <text class=\"falseEdgeCaption\" data-bind=\"attr: { x: start.x + (end.x - start.x) * ((end.y - start.y - (10 + 4)) / (end.y - start.y)), y: end.y - (10 + 4) }, text: text\"></text>                                    <!-- /ko -->                                <!-- /ko -->                                <!-- ko foreach: interiorNodes -->                                    <!-- ko if: highlight -->                                        <rect class=\"highlightTreeNode\" width=\"28\" height=\"28\" data-bind=\"attr: { x: x - 14, y: y - 14 }\" />                                    <!-- /ko -->                                    <rect class=\"treeNodeBackground\" width=\"20\" height=\"20\" data-bind=\"attr: { x: x - 10, y: y - 10 }\" />                                    <rect width=\"0\" height=\"0\" data-bind=\"attr: { x: x - 10 * r(), y: y - 10 * r(), width: 20 * r(), height: 20 * r(), fill: ('rgb(' + (255 * shade()).toFixed(0) + ',' + (255 * shade()).toFixed(0) + ',' + (255 * shade()).toFixed(0) + ')') }\" />                                    <rect class=\"treeMouseOverlay\" width=\"20\" height=\"20\" data-bind=\"attr: { x: x - 10, y: y - 10 }, event: { click: select, mouseover: openPreview, mouseout: closePreview }\" />                                    <!-- ko if: text -->                                        <text class=\"treeNodeCaption\" data-bind=\"attr: { x: x, y: y + 24 }, text: text, event: { click: selectText }\"></text>                                    <!-- /ko -->                                <!-- /ko -->                                <!-- ko foreach: leafNodes -->                                    <!-- ko if: highlight -->                                        <rect class=\"highlightTreeNode\" width=\"28\" height=\"28\" data-bind=\"attr: { x: x - 14, y: y - 14 }\" />                                    <!-- /ko -->                                    <rect class=\"treeNodeBackground\" width=\"20\" height=\"20\" data-bind=\"attr: { x: x - 10, y: y - 10 }\" />                                    <rect width=\"0\" height=\"0\" data-bind=\"attr: { x: x - 10 * r(), y: y - 10 * r(), width: 20 * r(), height: 20 * r(), fill: ('rgb(' + (255 * shade()).toFixed(0) + ',' + (255 * shade()).toFixed(0) + ',' + (255 * shade()).toFixed(0) + ')') }\" />                                    <rect class=\"treeMouseOverlay\" width=\"20\" height=\"20\" data-bind=\"attr: { x: x - 10, y: y - 10 }, event: { click: select, mouseover: openPreview, mouseout: closePreview }\" />                                <!-- /ko -->                            </g>                        </svg>                    </div>                </div>                <div id=\"treeToolbar\" class=\"controlPanel\">                </div>                <div id=\"hoverSummary\">                    <!-- ko if: hoverSummaryRows -->                    <table>                        <tbody>                            <!-- ko foreach: hoverSummaryRows -->                            <tr>                                <th data-bind=\"html: label\"></th>                                <td data-bind=\"html: value\"></td>                            </tr>                            <!-- /ko -->                            <!-- ko if: preview -->                                <!-- ko with: preview -->                                    <!-- ko if: (trainValues || predictValues) -->                                        <!-- ko foreach: labels -->                                            <tr data-bind=\"style: { 'line-height': (2 * $parent.columnWidth) + 'px' }\">                                                <th data-bind=\"html: $data, style: { 'font-size': (2 * $parent.columnWidth) + 'px' }\"></th>                                                <td>                                                    <svg class=\"hoverSummaryPreview\" data-bind=\"attr: { height: 2 * $parent.columnWidth }\">                                                        <!-- ko if: $parent.predictValues -->                                                        <rect class=\"treeSummaryPreviewPrediction\" height=\"0\" width=\"0\" x=\"0\" y=\"0\" data-bind=\"attr: { height: ($parent.columnWidth), width: $parent.predictValues[$index()] * 100 }\" />                                                        <!-- /ko -->                                                        <!-- ko if: $parent.trainValues -->                                                            <rect class=\"treeSummaryPreviewTraining\" height=\"0\" width=\"0\" x=\"0\" data-bind=\"attr: { height: ($parent.columnWidth), y: $parent.columnWidth, width: $parent.trainValues[$index()] * 100 }\" />                                                        <!-- /ko -->                                                    </svg>                                                </td>                                            </tr>                                        <!-- /ko -->                                    <!-- /ko -->                                <!-- /ko -->                            <!-- /ko -->                        </tbody>                    </table>                    <!-- /ko -->                </div>            </div>            <div id=\"nodeStackView\" data-bind=\"with: nodeStackInformation, attr: { height: nodeStackHeight }\">                <!-- ko if: leafRows -->                    <table id=\"nodeStackViewSummaryLeafTable\">                        <tbody>                            <!-- ko if: leafPreview -->                                <!-- ko with: leafPreview -->                                    <!-- ko foreach: labels -->                                        <tr data-bind=\"style: { 'line-height': (2 * $parent.columnWidth) + 'px' }\">                                            <th data-bind=\"html: $data, style: { 'font-size': (2 * $parent.columnWidth) + 'px' }\"></th>                                            <td title=\"Shows proportion of label in prediction (first bar) and training (second bar).\">                                                <svg width=\"150px\" data-bind=\"attr: { height: 2 * $parent.columnWidth }\">                                                    <!-- ko if: $parent.predictValues -->                                                        <rect class=\"treeSummaryPreviewPrediction\" height=\"0\" width=\"0\" x=\"0\" data-bind=\"attr: { height: ($parent.columnWidth), y: 0, width: $parent.predictValues[$index()] * 150 }\" />                                                    <!-- /ko -->                                                    <!-- ko if: $parent.trainValues -->                                                        <rect class=\"treeSummaryPreviewTraining\" height=\"0\" width=\"0\" x=\"0\" data-bind=\"attr: { height: ($parent.columnWidth), y: $parent.columnWidth, width: $parent.trainValues[$index()] * 150 }\" />                                                    <!-- /ko -->                                                </svg>                                            </td>                                        </tr>                                    <!-- /ko -->                                <!-- /ko -->                            <!-- /ko -->                            <!-- ko foreach: leafRows -->                                <tr>                                    <th data-bind=\"html: label\"></th>                                    <td>                                        <span data-bind=\"html: value, attr: { title: tooltip }\"></span>                                    </td>                                </tr>                            <!-- /ko -->                        </tbody>                    </table>                <!-- /ko -->                <!-- ko if: interiorRows -->                    <table id=\"nodeStackViewSummaryInteriorTable\">                        <tbody>                            <!-- ko if: interiorPreviews -->                                <!-- ko with: interiorPreviews -->                                    <!-- ko foreach: series -->                                        <tr data-bind=\"style: { 'line-height': (2 * $parent.columnWidth) + 'px' }\">                                            <th data-bind=\"html: label, style: { 'font-size': (2 * $parent.columnWidth) + 'px' }\"></th>                                            <!-- ko foreach: values -->                                                <td title=\"Shows proportion of label in prediction (first bar) and training (second bar).\">                                                    <svg width=\"150px\" data-bind=\"attr: { height: 2 * $parents[1].columnWidth }\">                                                        <!-- ko if: predict -->                                                            <rect class=\"treeSummaryPreviewPrediction\" height=\"0\" width=\"0\" x=\"0\" data-bind=\"attr: { height: ($parents[1].columnWidth), y: 0, width: predict * 150 }\" />                                                        <!-- /ko -->                                                        <!-- ko if: train -->                                                            <rect class=\"treeSummaryPreviewTraining\" height=\"0\" width=\"0\" x=\"0\" data-bind=\"attr: { height: ($parents[1].columnWidth), y: $parents[1].columnWidth, width: train * 150 }\" />                                                        <!-- /ko -->                                                    </svg>                                                </td>                                            <!-- /ko -->                                        </tr>                                    <!-- /ko -->                                <!-- /ko -->                            <!-- /ko -->                            <!-- ko foreach: interiorRows -->                                <tr>                                    <th data-bind=\"html: label\"></th>                                    <!-- ko foreach: series -->                                        <td>                                            <span data-bind=\"html: value, attr: { title: tooltip }\"></span>                                        </td>                                    <!-- /ko -->                                </tr>                            <!-- /ko -->                        </tbody>                    </table>                <!-- /ko -->            </div>        <!-- /ko -->    </div></div>"})(ExperimentEditor || (ExperimentEditor = {}));ExperimentEditor.typescriptResourceVariables = ExperimentEditor.typescriptResourceVariables || []; ExperimentEditor.typescriptResourceVariables.push("ExperimentEditor._treeEnsembleMarkup");
var ExperimentEditor;(function (ExperimentEditor) {ExperimentEditor._videoMarkup = "<video controls data-bind=\"attr: { src: url, width: width, height: height }, event: { playing: markAsWatched }\"></video>"})(ExperimentEditor || (ExperimentEditor = {}));ExperimentEditor.typescriptResourceVariables = ExperimentEditor.typescriptResourceVariables || []; ExperimentEditor.typescriptResourceVariables.push("ExperimentEditor._videoMarkup");
var ExperimentEditor;(function (ExperimentEditor) {ExperimentEditor._markdownEditorMarkup = "<div data-bind=\"attr:{id: buttonBarId}\"></div><textarea class=\"wmd-input\" data-bind=\"attr:{id: inputAreaId}, css: {'in-preview': inPreview}, value: value, placeholder: placeholder, click: toPreview.bind($data, false)\"></textarea><div class=\"wmd-preview\" data-bind=\"attr:{id: previewAreaId}, css: {'in-preview': inPreview}, click: toPreview.bind($data, true)\"></div>"})(ExperimentEditor || (ExperimentEditor = {}));ExperimentEditor.typescriptResourceVariables = ExperimentEditor.typescriptResourceVariables || []; ExperimentEditor.typescriptResourceVariables.push("ExperimentEditor._markdownEditorMarkup");
/// <reference path="../Global.ts" />
var ExperimentEditor;
(function (ExperimentEditor) {
    ExperimentEditor.DialogHost;
    function setDialogHost(host) {
        if (ExperimentEditor.DialogHost) {
            ExperimentEditor.DialogHost.closeActiveDialog();
        }
        ExperimentEditor.DialogHost = host;
    }
    ExperimentEditor.setDialogHost = setDialogHost;
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
/// <reference path="../ExperimentEditor/CustomUX.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var ExperimentEditor;
(function (ExperimentEditor) {
    var CustomUX;
    (function (CustomUX) {
        var PlotViewModel = (function (_super) {
            __extends(PlotViewModel, _super);
            function PlotViewModel(data, label) {
                _super.call(this);
                this.falsePositiveRate = "fpr";
                this.truePositiveRate = "tpr";
                this.precision = "precision";
                this.yRate = "yrate";
                this.truePositive = "truepositive";
                this.data = ko.observable(data);
                this.label = ko.observable(label);
                this.rocChartsFull = this.constructChart(data, this.falsePositiveRate, this.truePositiveRate);
                this.precisionRecallChartsFull = this.constructChart(data, this.truePositiveRate, this.precision);
                this.liftChartsFull = this.constructChart(data, this.yRate, this.truePositive);
            }
            PlotViewModel.prototype.getCurrentChart = function (currentChart) {
                var theChart;
                if (currentChart === "lift") {
                    theChart = this.liftChartsFull;
                }
                else {
                    theChart = currentChart === "roc" ? this.rocChartsFull : this.precisionRecallChartsFull;
                }
                return theChart;
            };
            PlotViewModel.prototype.constructChart = function (chartData, xField, yField) {
                var chart = chartData.chart ? chartData.chart : chartData.charts[0];
                var theData = chart.data;
                var line = [];
                var numPoints = theData.length;
                for (var j = 0; j < numPoints; j++) {
                    var thePoint = theData[j];
                    line.push([thePoint[xField], thePoint[yField]]);
                }
                var curve = {
                    data: line,
                    label: this.label()
                };
                return curve;
            };
            return PlotViewModel;
        })(DataLab.Util.Disposable);
        CustomUX.PlotViewModel = PlotViewModel;
    })(CustomUX = ExperimentEditor.CustomUX || (ExperimentEditor.CustomUX = {}));
})(ExperimentEditor || (ExperimentEditor = {}));

var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
/// <reference path="../../Global.ts" />
/// <reference path="../ExperimentEditor/CustomUX.ts" />
/// <reference path="../../../TypeScriptLib/flot.d.ts" />
var ExperimentEditor;
(function (ExperimentEditor) {
    var CustomUX;
    (function (CustomUX) {
        var Row = (function () {
            function Row(cells) {
                this.cells = ko.observableArray(cells);
            }
            return Row;
        })();
        CustomUX.Row = Row;
        var TableViewModel = (function (_super) {
            __extends(TableViewModel, _super);
            function TableViewModel(rows, headerRowArray) {
                var _this = this;
                if (headerRowArray === void 0) { headerRowArray = null; }
                _super.call(this);
                this.rows = ko.observableArray();
                DataLab.Util.forEach(rows, function (row) {
                    _this.rows.push(new Row(row));
                });
                this.headerRow = ko.observable(new Row(headerRowArray));
            }
            return TableViewModel;
        })(DataLab.Util.Disposable);
        CustomUX.TableViewModel = TableViewModel;
    })(CustomUX = ExperimentEditor.CustomUX || (ExperimentEditor.CustomUX = {}));
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
/// <reference path="../ExperimentEditor/CustomUX.ts" />
/// <reference path="PlotViewModel.ts" />
/// <reference path="TableViewModel.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var ExperimentEditor;
(function (ExperimentEditor) {
    var CustomUX;
    (function (CustomUX) {
        var BinaryClassificationUXViewModel = (function (_super) {
            __extends(BinaryClassificationUXViewModel, _super);
            function BinaryClassificationUXViewModel(parsedData) {
                _super.call(this);
                this.precision = 3;
                this.loaded = ko.observable(false);
                if (parsedData) {
                    this.initializeFromParsedJson(parsedData);
                }
            }
            BinaryClassificationUXViewModel.initializeFromEndpoint = function (experimentId, nodeId, portName, workspace) {
                var viewModel = new BinaryClassificationUXViewModel();
                DataLab.Util.then(workspace.getModuleOutput(experimentId, nodeId, portName), function (data) {
                    viewModel.initializeFromParsedJson(data);
                });
                return viewModel;
            };
            BinaryClassificationUXViewModel.prototype.initializeFromParsedJson = function (parsedJson) {
                var _this = this;
                this.data = parsedJson;
                this.name = ko.observable(this.getReportName(this.data.reportName));
                this.plotViewModel = new CustomUX.PlotViewModel(this.data, this.name());
                this.threshold = ko.observable(.5);
                var getChart = function () {
                    if (_this.data.chart !== undefined) {
                        return _this.data.chart;
                    }
                    else {
                        return _this.data.charts[0];
                    }
                };
                var getAuc = function () {
                    if (getChart().auc.roc !== undefined) {
                        return getChart().auc.roc;
                    }
                    else {
                        return getChart().auc;
                    }
                };
                var getMin = function () {
                    if (getChart().min !== undefined) {
                        return getChart().min;
                    }
                    else {
                        return 0;
                    }
                };
                var getMax = function () {
                    if (getChart().min !== undefined) {
                        return getChart().max;
                    }
                    else {
                        return 1;
                    }
                };
                this.rawThreshold = ko.computed(function () {
                    var rawValue = getMin() + _this.threshold() * (getMax() - getMin());
                    return rawValue.toFixed ? ExperimentEditor.Visualization.reduceToFixedPrecision(rawValue, _this.precision) : rawValue;
                });
                this.confusionMatrixViewModel = ko.computed(function () {
                    var bucket = _this.getBucket(getChart(), _this.rawThreshold());
                    return new CustomUX.TableViewModel([[bucket.confusionMatrix.tp.toString(), bucket.confusionMatrix.fn.toString()], [bucket.confusionMatrix.fp.toString(), bucket.confusionMatrix.tn.toString()]]);
                });
                this.precisionRecallViewModel = ko.computed(function () {
                    var bucket = _this.getBucket(getChart(), _this.rawThreshold());
                    return new CustomUX.TableViewModel([[bucket.accuracy.toFixed(_this.precision), bucket.precision.toFixed(_this.precision)], [bucket.recall.toFixed(_this.precision), bucket.f1.toFixed(_this.precision)]]);
                });
                this.binDataViewModel = this.initializeBinData(getChart().coarseData);
                var aucToFixed = getAuc().toFixed ? getAuc().toFixed(this.precision) : getAuc().toString();
                this.auc = ko.observable(aucToFixed);
                this.currentCmData = ko.observable();
                this.setCurrentCmData = function (cmData) {
                    _this.currentCmData(cmData);
                };
                this.threshold.subscribe(function () {
                    Shell.Diagnostics.Telemetry.customEvent("ThresholdChanged", "Visualize", _this.threshold());
                    if (_this.threshold() > 1) {
                        _this.threshold(1);
                    }
                    else if (_this.threshold() < 0) {
                        _this.threshold(0);
                    }
                });
                this.loaded(true);
            };
            BinaryClassificationUXViewModel.prototype.getReportName = function (reportName) {
                if (reportName === "Scored dataset" || reportName === "scoredData") {
                    return DataLab.LocalizedResources.binaryClassificationScoredDataset;
                }
                else if (reportName === "Scored dataset to compare" || reportName === "scoredDataToCompare") {
                    return DataLab.LocalizedResources.binaryClassificationScoredDatasetToCompare;
                }
                else {
                    return DataLab.LocalizedResources.binaryClassificationScoredDatasetDefault;
                }
            };
            BinaryClassificationUXViewModel.prototype.getBucket = function (chartInfo, threshold) {
                var index = this.getIndex(chartInfo, threshold);
                var bucket = chartInfo.data[index];
                return bucket;
            };
            BinaryClassificationUXViewModel.prototype.getIndex = function (chartInfo, threshold) {
                var data = chartInfo.data;
                var len = data.length;
                var idx = 0;
                for (var i = 0; i < len; i++) {
                    var prob = data[i].probability;
                    if (prob < threshold) {
                        idx = i;
                    }
                    else {
                        break;
                    }
                }
                return idx;
            };
            BinaryClassificationUXViewModel.prototype.initializeBinData = function (data) {
                var _this = this;
                var rows = [];
                var resources = DataLab.LocalizedResources;
                var header = [
                    resources.binaryClassificationScoreBin,
                    resources.binaryClassificationNumberOfPositiveExamples,
                    resources.binaryClassificationNumberOfNegativeExamples,
                    resources.binaryClassificationFractionAboveThreshold,
                    resources.binaryClassificationAccuracy,
                    resources.binaryClassificationF1Score,
                    resources.binaryClassificationPrecision,
                    resources.binaryClassificationRecall,
                    resources.binaryClassificationNegativePrecision,
                    resources.binaryClassificationNegativeRecall,
                    resources.binaryClassificationCumulativeAuc
                ];
                data = data.sort(function (instanceA, instanceB) {
                    return instanceB.BinStart - instanceA.BinStart;
                });
                DataLab.Util.forEach(data, function (bin) {
                    var row = [];
                    row.push("(" + bin.BinStart.toFixed(3) + "," + bin.BinEnd.toFixed(_this.precision) + "]");
                    row.push(bin.numPos);
                    row.push(bin.numNeg);
                    var fracPop = (bin.tp + bin.fp) / (bin.tp + bin.fp + bin.fn + bin.tn);
                    row.push(fracPop.toFixed(_this.precision));
                    row.push(bin.accuracy.toFixed(_this.precision));
                    row.push(bin.f1.toFixed(_this.precision));
                    row.push(bin.precision.toFixed(_this.precision));
                    row.push(bin.recall.toFixed(_this.precision));
                    row.push(bin.negPrecision.toFixed(_this.precision));
                    row.push(bin.negRecall.toFixed(_this.precision));
                    row.push(bin.AUC.toFixed(_this.precision));
                    rows.push(row);
                });
                return new CustomUX.TableViewModel(rows, header);
            };
            return BinaryClassificationUXViewModel;
        })(DataLab.Util.Disposable);
        CustomUX.BinaryClassificationUXViewModel = BinaryClassificationUXViewModel;
    })(CustomUX = ExperimentEditor.CustomUX || (ExperimentEditor.CustomUX = {}));
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
/// <reference path="../../../TypescriptResources.ts" />
/// <reference path="../../Common/DialogInterfaces.ts" />
/// <reference path="../CustomUX/BinaryClassificationUX.ts" />
var ExperimentEditor;
(function (ExperimentEditor) {
    var CustomUX;
    (function (CustomUX) {
        CustomUX.uxClass = ko.observable("customUX hidden");
        function open(markup, viewModel, height, width, onCloseAction, breadcrumbHeader) {
            if (height === void 0) { height = "100%"; }
            if (width === void 0) { width = "100%"; }
            var bindingElement;
            var keydownDisposableListener = new DataLab.Util.DisposableEventListener(document, "keydown", function (e) {
                var backspaceValid = $(document.activeElement).is('input[type="text"]:focus, textarea:focus') && !$(document.activeElement).attr("readonly");
                // 8 is backspace 
                if (e.keyCode === 8 && !backspaceValid) {
                    return e.preventDefault();
                }
                else if (e.keyCode === 27) {
                    return CustomUX.close(viewModel, onCloseAction);
                }
            });
            viewModel.registerForDisposal(keydownDisposableListener);
            $(".customUX").removeClass("hidden");
            if (breadcrumbHeader != null) {
                var containerMarkup = ExperimentEditor._customUXContainerMarkup;
                var containerViewModel = new CustomUXContainerViewModel(width, height, breadcrumbHeader);
                $(".customUX").append(containerMarkup);
                var containerBindingElement = document.querySelector(".customUX .customUXWindow");
                ko.applyBindings(containerViewModel, containerBindingElement);
                $(".customUXWindow").append("<div class='visualizationContentWrapper'>" + markup + "</div>");
                bindingElement = document.querySelector(".customUX .visualizationContentWrapper");
            }
            else {
                $(".customUX").append("<div class='customUXWindow' style='height: " + height + "; width: " + width + "'></div>");
                $(".customUXWindow").append("<div class='icon close'></div>");
                $(".customUXWindow").append("<div>" + markup + "</div>");
                bindingElement = document.querySelector(".customUX .customUXWindow");
            }
            // When the user mousedowns on the close button, close the window.
            $(".customUXWindow .icon.close").off("mousedown");
            $(".customUXWindow .icon.close").one("mousedown", function () {
                CustomUX.close(viewModel, onCloseAction);
            });
            ko.applyBindings(viewModel, bindingElement);
            if (viewModel["initialize"]) {
                viewModel["initialize"]();
            }
        }
        CustomUX.open = open;
        function close(viewModel, onCloseAction) {
            var bindingElement = document.querySelector(".customUX .customUXWindow");
            if (onCloseAction) {
                onCloseAction();
            }
            if (viewModel.dispose) {
                viewModel.dispose();
            }
            $(".customUX").addClass("hidden");
            if (bindingElement) {
                $(bindingElement).remove();
                ko.cleanNode(bindingElement);
            }
        }
        CustomUX.close = close;
        var CustomUXContainerViewModel = (function () {
            function CustomUXContainerViewModel(width, height, header) {
                this.width = ko.observable(width);
                this.height = ko.observable(height);
                this.breadcrumbHeader = ko.observable(header);
                this.showBreadcrumbHeader = ko.observable(header !== null);
            }
            return CustomUXContainerViewModel;
        })();
        CustomUX.CustomUXContainerViewModel = CustomUXContainerViewModel;
    })(CustomUX = ExperimentEditor.CustomUX || (ExperimentEditor.CustomUX = {}));
})(ExperimentEditor || (ExperimentEditor = {}));

var ExperimentEditor;
(function (ExperimentEditor) {
    function auxConfirm(title, text) {
        var deferred = $.Deferred();
        var viewModel = {
            title: title,
            text: text,
            dismissed: function (result) {
                if (result.accepted) {
                    deferred.resolve();
                }
                else {
                    deferred.reject();
                }
            }
        };
        ExperimentEditor.DialogViews.Confirmation.show(viewModel);
        return DataLab.Util.when(deferred.promise());
    }
    ExperimentEditor.auxConfirm = auxConfirm;
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../_ReferenceSupport/DataLabClient.d.ts" />
/// <reference path="../TypescriptLib/Knockout.d.ts" />
/// <reference path="../TypescriptLib/Knockout-extensions.d.ts" />
/// <reference path="../TypescriptLib/d3.d.ts" />
/// <reference path="../TypescriptLib/UxFxScript.d.ts" />
/// <reference path="../TypescriptLib/JsViews.d.ts" />
/// <reference path="../../../../External/Typescript/jquery.d.ts" />
/// <reference path="../TypescriptLib/jqueryui.d.ts" />
/// <reference path="../TypescriptLib/jqueryui.extension.d.ts" />
/// <reference path="../TypescriptResources.ts" />
/// <reference path="../_ReferenceSupport/MonacoAdditions.d.ts" />
/// <reference path="../typescriptlib/zopim.d.ts" />
/// <reference path="ViewModel/ExperimentEditor/CustomUX.ts" />
/// <reference path="Common/Confirm.ts" />
// TODO: load KO as AMD module from within STRADA [TFS #1025762]
var ExperimentEditor;
(function (ExperimentEditor) {
    var Constants;
    (function (Constants) {
        var EntityType;
        (function (EntityType) {
            EntityType.Module = "module";
            EntityType.Dataset = "dataset";
            EntityType.TrainedModel = "trainedmodel";
            EntityType.Transform = "transform";
            EntityType.Connection = "connection";
            EntityType.InputPort = "inputport";
            EntityType.OutputPort = "outputport";
            EntityType.Entity = "entity";
            EntityType.WebServicePort = "web service port";
        })(EntityType = Constants.EntityType || (Constants.EntityType = {}));
        (function (MouseButton) {
            MouseButton[MouseButton["Left"] = 0] = "Left";
            MouseButton[MouseButton["Center"] = 1] = "Center";
            MouseButton[MouseButton["Right"] = 2] = "Right";
        })(Constants.MouseButton || (Constants.MouseButton = {}));
        var MouseButton = Constants.MouseButton;
        (function (Browser) {
            Browser[Browser["Gecko"] = 0] = "Gecko";
            Browser[Browser["Webkit"] = 1] = "Webkit";
            Browser[Browser["IE9"] = 2] = "IE9";
            Browser[Browser["IE10"] = 3] = "IE10";
            Browser[Browser["IE11"] = 4] = "IE11";
            Browser[Browser["Unknown"] = 5] = "Unknown";
        })(Constants.Browser || (Constants.Browser = {}));
        var Browser = Constants.Browser;
        Constants.CurrentBrowser;
        if (/MSIE 9/.test(navigator.userAgent)) {
            Constants.CurrentBrowser = 2 /* IE9 */;
        }
        else if (/MSIE 10/.test(navigator.userAgent)) {
            Constants.CurrentBrowser = 3 /* IE10 */;
        }
        else if (/Trident/.test(navigator.userAgent) && /rv:11/.test(navigator.userAgent)) {
            Constants.CurrentBrowser = 4 /* IE11 */;
        }
        else if (/AppleWebKit/.test(navigator.userAgent)) {
            Constants.CurrentBrowser = 1 /* Webkit */;
        }
        else if (/Gecko/.test(navigator.userAgent) && !/Trident/.test(navigator.userAgent)) {
            Constants.CurrentBrowser = 0 /* Gecko */;
        }
        else {
            Constants.CurrentBrowser = 5 /* Unknown */;
        }
        Constants.errorHelpLinkGuidStart = "60822377-DA7A-40B8-";
        Constants.errorHelpLinkGuidEnd = "-D185D1509344";
        Constants.saveAsHelpLinkGuid = "e548ed9d-064b-42fd-a1b7-4c34eccb88f8";
        Constants.rScriptEditorFocusWidth = 600;
        Constants.rScriptEditorFocusHeight = 400;
        (function (Key) {
            Key[Key["Escape"] = 27] = "Escape";
            Key[Key["A"] = 65] = "A";
            Key[Key["Delete"] = 46] = "Delete";
            Key[Key["Minus"] = Constants.CurrentBrowser === 0 /* Gecko */ ? 173 : 189] = "Minus";
            Key[Key["KeypadMinus"] = 109] = "KeypadMinus";
            Key[Key["Equals"] = Constants.CurrentBrowser === 0 /* Gecko */ ? 61 : 187] = "Equals";
            Key[Key["KeypadPlus"] = 107] = "KeypadPlus";
            Key[Key["Zero"] = 48] = "Zero";
            Key[Key["KeypadZero"] = 96] = "KeypadZero";
            Key[Key["Nine"] = 57] = "Nine";
            Key[Key["KeypadNine"] = 105] = "KeypadNine";
            Key[Key["C"] = 67] = "C";
            Key[Key["S"] = 83] = "S";
            Key[Key["V"] = 86] = "V";
            Key[Key["X"] = 88] = "X";
            Key[Key["F2"] = 113] = "F2";
            Key[Key["Return"] = 13] = "Return";
            Key[Key["SpaceBar"] = 32] = "SpaceBar";
            Key[Key["F1"] = 112] = "F1";
        })(Constants.Key || (Constants.Key = {}));
        var Key = Constants.Key;
        var ContextMenuItem;
        (function (ContextMenuItem) {
            ContextMenuItem.Height = 20;
        })(ContextMenuItem = Constants.ContextMenuItem || (Constants.ContextMenuItem = {}));
        var ContextMenu;
        (function (ContextMenu) {
            ContextMenu.DefaultWidth = 140;
        })(ContextMenu = Constants.ContextMenu || (Constants.ContextMenu = {}));
        var Layout;
        (function (Layout) {
            Layout.zoomToFitPadding = 40;
        })(Layout = Constants.Layout || (Constants.Layout = {}));
        Constants.RectWidth = 280;
        Constants.RectHeight = 50;
        var Icon;
        (function (Icon) {
            Icon.Height = 24;
            Icon.Width = 24;
            Icon.XOffset = 10;
        })(Icon = Constants.Icon || (Constants.Icon = {}));
        var Port;
        (function (Port) {
            Port.Width = 10;
            Port.HalfWidth = Port.Width / 2;
            Port.Height = 5; //height of the circle
            Port.HalfHeight = Port.Height / 2;
            Port.InYPos = 6;
            Port.OutYPos = 16;
            Port.Offset = 12;
        })(Port = Constants.Port || (Constants.Port = {}));
        var Label;
        (function (Label) {
            Label.InPortYPos = 10;
            Label.OutPortYPos = -10;
            Label.PortOffset = 12;
            Label.MaxSize = 18;
            Label.ReducedLength = 15;
            Label.ModuleBuffer = 25;
            Label.ModuleXOffset = 45;
            Label.ModuleYOffset = 30;
            Label.RectYOffset = 3;
            Label.MaxWidth = 185;
        })(Label = Constants.Label || (Constants.Label = {}));
        var Tooltip;
        (function (Tooltip) {
            Tooltip.RectXOffset = -5;
            Tooltip.RectYOffset = -2;
            Tooltip.WidthOffset = 23;
            Tooltip.HeightOffset = 5;
            Tooltip.PortYOffset = 4;
            Tooltip.RectClass = "tooltipRect";
            Tooltip.Class = "staticText";
            Tooltip.XPos = "0";
        })(Tooltip = Constants.Tooltip || (Constants.Tooltip = {}));
        var Connector;
        (function (Connector) {
            Connector.SplinePointMax = Port.Height * 15;
            Connector.SplinePointMin = Port.Height * 3;
        })(Connector = Constants.Connector || (Constants.Connector = {}));
        var ExperimentDataFlowType;
        (function (ExperimentDataFlowType) {
            ExperimentDataFlowType.Experiment = "experiment";
            ExperimentDataFlowType.WebService = "webservice";
        })(ExperimentDataFlowType = Constants.ExperimentDataFlowType || (Constants.ExperimentDataFlowType = {}));
        Constants.maxModulePackageUploadSizeInBytes = 2093796557; // ~1.95 gigabytes
        Constants.maxModulePackageUploadSizeDescription = "1.95 gigabytes";
        Constants.maxUploadSizeInBytes = 2093796557; // 1.95 gigabytes
        Constants.maxUploadSizeInBytesNew = 10737418240 * 2; // 20 gigabytes
        Constants.maxUploadSizeDescription = "1.95 gigabytes";
        Constants.maxUploadSizeDescriptionNew = "20 gigabytes";
    })(Constants = ExperimentEditor.Constants || (ExperimentEditor.Constants = {}));
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../Global.ts" />

/// <reference path="ICommand.ts" />
var ExperimentEditor;
(function (ExperimentEditor) {
    var CallbackCommand = (function () {
        function CallbackCommand(executeCallback) {
            this.executeCallback = executeCallback;
            this.canExecute = ko.observable(true);
        }
        CallbackCommand.prototype.execute = function (targetObject) {
            this.executeCallback(targetObject);
        };
        return CallbackCommand;
    })();
    ExperimentEditor.CallbackCommand = CallbackCommand;
})(ExperimentEditor || (ExperimentEditor = {}));



/// <reference path="../../Global.ts" />
/// <reference path="ISprite.ts" />
var ExperimentEditor;
(function (ExperimentEditor) {
    // Entity type enum table
    ExperimentEditor.EntityTypes = {};
    ExperimentEditor.EntityTypes[0] = ExperimentEditor.Constants.EntityType.Entity;
    ExperimentEditor.EntityTypes[1] = ExperimentEditor.Constants.EntityType.Module;
    ExperimentEditor.EntityTypes[2] = ExperimentEditor.Constants.EntityType.Dataset;
    ExperimentEditor.EntityTypes[3] = ExperimentEditor.Constants.EntityType.InputPort;
    ExperimentEditor.EntityTypes[4] = ExperimentEditor.Constants.EntityType.OutputPort;
    ExperimentEditor.EntityTypes[5] = ExperimentEditor.Constants.EntityType.Connection;
    ExperimentEditor.EntityTypes[6] = ExperimentEditor.Constants.EntityType.TrainedModel;
    ExperimentEditor.EntityTypes[7] = ExperimentEditor.Constants.EntityType.WebServicePort;
    ExperimentEditor.EntityTypes[ExperimentEditor.Constants.EntityType.Entity] = 0;
    ExperimentEditor.EntityTypes[ExperimentEditor.Constants.EntityType.Module] = 1;
    ExperimentEditor.EntityTypes[ExperimentEditor.Constants.EntityType.Dataset] = 2;
    ExperimentEditor.EntityTypes[ExperimentEditor.Constants.EntityType.InputPort] = 3;
    ExperimentEditor.EntityTypes[ExperimentEditor.Constants.EntityType.OutputPort] = 4;
    ExperimentEditor.EntityTypes[ExperimentEditor.Constants.EntityType.Connection] = 5;
    ExperimentEditor.EntityTypes[ExperimentEditor.Constants.EntityType.TrainedModel] = 6;
    ExperimentEditor.EntityTypes[ExperimentEditor.Constants.EntityType.WebServicePort] = 7;
    // Base abstract class
    var Entity = (function () {
        function Entity(type) {
            this.type = type;
            // 250 ms for delay on showing the port label
            this.labelTimerDelay = 250;
            this.selected = ko.observable(false);
            this.hovered = ko.observable(false);
            this.showFullLabel = ko.observable(false);
            this.isTruncated = ko.observable(false);
            this.labelWidth = ko.observable(0);
            this.labelHeight = ko.observable(0);
            this.belongsToExperimentFlow = ko.observable(true);
            this.belongsToWebServiceFlow = ko.observable(false);
        }
        Entity.prototype.remove = function () {
        };
        Object.defineProperty(Entity.prototype, "x", {
            get: function () {
                throw "abstract property 'x' must be overriden";
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Entity.prototype, "y", {
            get: function () {
                throw "abstract property 'y' must be overriden";
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Entity.prototype, "width", {
            get: function () {
                throw "abstract property 'width' must be overriden";
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Entity.prototype, "height", {
            get: function () {
                throw "abstract property 'width' must be overriden";
            },
            enumerable: true,
            configurable: true
        });
        Entity.prototype.getType = function () {
            return this.type;
        };
        // Default rect collision detection which by default return false unless
        // it is overriden in the descendant class
        Entity.prototype.hit = function (ox1, oy1, ox2, oy2) {
            return false;
        };
        Entity.prototype.translate = function (dx, dy) {
            this.x(this.x() + dx);
            this.y(this.y() + dy);
        };
        Entity.prototype.isModule = function () {
            return (this.type == ExperimentEditor.EntityTypes[ExperimentEditor.Constants.EntityType.Module]);
        };
        Entity.prototype.isData = function () {
            return (this.type == ExperimentEditor.EntityTypes[ExperimentEditor.Constants.EntityType.Dataset]);
        };
        Entity.prototype.isTrainedModel = function () {
            return (this.type == ExperimentEditor.EntityTypes[ExperimentEditor.Constants.EntityType.TrainedModel]);
        };
        Entity.prototype.isTransform = function () {
            return (this.type == ExperimentEditor.EntityTypes[ExperimentEditor.Constants.EntityType.Transform]);
        };
        Entity.prototype.isConnection = function () {
            return (this.type == ExperimentEditor.EntityTypes[ExperimentEditor.Constants.EntityType.Connection]);
        };
        Entity.prototype.entityAtPoint = function (x, y) {
            return null;
        };
        Entity.prototype.containsPoint = function (x, y) {
            return false;
        };
        Entity.prototype.showLabel = function () {
            var _this = this;
            // Only show the label after the user has hovered for a period of time
            this.labelTimer = setTimeout(function () {
                _this.showFullLabel(true);
            }, this.labelTimerDelay);
        };
        Entity.prototype.hideLabel = function () {
            // kill the timer if it is still going. This prevents tooltips from being shown if the user mouses over the port quickly
            if (this.labelTimer) {
                clearTimeout(this.labelTimer);
            }
            this.showFullLabel(false);
        };
        Entity.prototype.onMouseIn = function () {
            this.hovered(true);
        };
        Entity.prototype.onMouseOut = function () {
            this.hovered(false);
        };
        Entity.prototype.startValidating = function () {
        };
        Entity.prototype.updateValidState = function () {
        };
        Entity.prototype.belongsToCurrentFlow = function (currentFlow) {
            if (currentFlow === ExperimentEditor.Constants.ExperimentDataFlowType.Experiment) {
                return this.belongsToExperimentFlow();
            }
            else {
                return this.belongsToWebServiceFlow();
            }
        };
        Entity.prototype.getClassId = function (currentFlow) {
            if (this.belongsToCurrentFlow(currentFlow)) {
                if (currentFlow === ExperimentEditor.Constants.ExperimentDataFlowType.Experiment) {
                    return this.classId();
                }
                else {
                    return this.classId() + " blueStroke";
                }
            }
            else if (currentFlow === ExperimentEditor.Constants.ExperimentDataFlowType.Experiment) {
                return this.classId() + " disabledFlow blueStroke";
            }
            else {
                return this.classId() + " disabledFlow";
            }
        };
        return Entity;
    })();
    ExperimentEditor.Entity = Entity;
    ;
    // custom binding handler to truncate text on labels
    // Works by placing text into a label, then using calculations on the label's bounding
    // box to truncate it to a fixed size since the font is not a monospace font.
    ko.bindingHandlers["truncatedText"] = {
        init: function (element, valueAccessor) {
            var parameters = ko.utils.unwrapObservable(valueAccessor());
            var label = ko.utils.unwrapObservable(parameters.label);
            element.textContent = label;
        },
        update: function (element, valueAccessor, allBindingsAcessor, viewModel) {
            var parameters = ko.utils.unwrapObservable(valueAccessor());
            var label = ko.utils.unwrapObservable(parameters.label);
            var maxWidth = ko.utils.unwrapObservable(parameters.maxWidth);
            element.textContent = label;
            if (element.getComputedTextLength() < maxWidth) {
                element.textContent = label;
                viewModel.isTruncated(false);
            }
            else {
                var curText = element.textContent;
                var left = 0;
                var right = curText.length;
                var mid = (left + right) / 2;
                while (left < mid) {
                    element.textContent = curText.substring(0, mid) + "...";
                    if (element.getComputedTextLength() >= maxWidth) {
                        right = mid;
                    }
                    else {
                        left = mid;
                    }
                    mid = Math.floor((left + right) / 2);
                }
                viewModel.isTruncated(true);
            }
            var textContainer = $(element).closest("text")[0];
            viewModel.labelHeight(textContainer.getBBox().height);
            viewModel.labelWidth(textContainer.getBBox().width);
        }
    };
    ko.bindingHandlers["portTextLabel"] = {
        init: function (element) {
            var rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            var text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            var image = document.createElementNS('http://www.w3.org/2000/svg', 'image');
            rect.setAttribute('class', ExperimentEditor.Constants.Tooltip.RectClass);
            element.setAttribute('class', 'portTextLabel');
            element.appendChild(rect);
            element.appendChild(text);
            element.appendChild(image);
        },
        update: function (element, valueAccessor) {
            var accessor = ko.utils.unwrapObservable(valueAccessor());
            var label = accessor.label;
            var portModel = accessor.model;
            var rect = $(element).children('rect')[0];
            var text = $(element).children('text')[0];
            var image = $(element).children('image')[0];
            text.textContent = label;
            text.setAttribute('class', ExperimentEditor.Constants.Tooltip.Class);
            text.setAttribute('x', (ExperimentEditor.Constants.Tooltip.RectXOffset + 21).toString());
            text.setAttribute('y', (ExperimentEditor.Constants.Tooltip.RectYOffset + 16).toString());
            rect.setAttribute('width', (text.getBBox().width + ExperimentEditor.Constants.Tooltip.WidthOffset).toString());
            rect.setAttribute('height', (text.getBBox().height + ExperimentEditor.Constants.Tooltip.HeightOffset).toString());
            rect.setAttribute('x', ExperimentEditor.Constants.Tooltip.RectXOffset.toString());
            rect.setAttribute('y', ExperimentEditor.Constants.Tooltip.RectYOffset.toString());
            var iconPath;
            if (portModel.parent.isData()) {
                iconPath = '/Libraries/Images/arrow_label_32.svg';
            }
            else if (portModel.parent.isTrainedModel()) {
                iconPath = '/Libraries/Images/TM_output_flask_32.svg';
            }
            else {
                iconPath = '/Libraries/Images/ArrowLabel.png';
            }
            image.setAttributeNS('http://www.w3.org/1999/xlink', 'href', iconPath);
            // TODO constants
            image.setAttribute('width', '32');
            image.setAttribute('height', '32');
            image.setAttribute('x', (ExperimentEditor.Constants.Tooltip.RectXOffset - 12).toString());
            image.setAttribute('y', (ExperimentEditor.Constants.Tooltip.RectYOffset - 4).toString());
        }
    };
    ko.bindingHandlers["anchorTransform"] = {
        init: function () {
        },
        update: function (element, valueAccessor) {
            var parameters = ko.utils.unwrapObservable(valueAccessor());
            var x = ko.utils.unwrapObservable(parameters.x);
            var y = ko.utils.unwrapObservable(parameters.y);
            var translation = "translate(" + x + "," + (y - ExperimentEditor.Constants.Tooltip.RectYOffset) + ")";
            element.setAttribute("transform", translation);
        }
    };
    ko.bindingHandlers["portTooltipTransform"] = {
        init: function () {
        },
        update: function (element, valueAccessor) {
            var parameters = ko.utils.unwrapObservable(valueAccessor());
            var x = ko.utils.unwrapObservable(parameters.x);
            var y = ko.utils.unwrapObservable(parameters.y);
            var name = parameters.name;
            var tooltip = $(element).children('text')[0];
            var tooltipText = tooltip.textContent;
            // Calculate the x transformation as though the tooltip only contains the port name, so the name is centered.
            tooltip.textContent = name;
            // y = y - Constants.Tooltip.PortYOffset;
            // Place the original tooltip text back into the tooltip.
            tooltip.textContent = tooltipText;
            var translation = "translate(" + x + "," + y + ")";
            element.setAttribute("transform", translation);
        }
    };
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
/// <reference path="Entity.ts" />
/// <reference path="PortViewModel.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var ExperimentEditor;
(function (ExperimentEditor) {
    // A class represents [directed] Connection entity.
    // A connection contains 2 endpoints: (a) input endpoint (b) output endpoint.
    var Connection = (function (_super) {
        __extends(Connection, _super);
        function Connection(inputPort, outputPort) {
            var _this = this;
            _super.call(this, ExperimentEditor.EntityTypes[ExperimentEditor.Constants.EntityType.Connection]);
            this.inputPort = inputPort;
            this.outputPort = outputPort;
            this.ix = ko.computed(function () {
                return this.inputPort.x() + ExperimentEditor.Constants.Port.HalfWidth;
            }, this);
            this.iy = ko.computed(function () {
                return this.inputPort.y();
            }, this);
            this.ox = ko.computed(function () {
                return this.outputPort.x() + ExperimentEditor.Constants.Port.HalfWidth;
            }, this);
            this.oy = ko.computed(function () {
                return this.outputPort.y() + ExperimentEditor.Constants.Port.Height;
            }, this);
            this.controlPointDistance = ko.computed(function () {
                return Math.min(ExperimentEditor.Constants.Connector.SplinePointMax, Math.max(ExperimentEditor.Constants.Connector.SplinePointMin, Math.abs(((this.inputPort.y() - (this.outputPort.y() + ExperimentEditor.Constants.Port.Height)) / 2))));
            }, this);
            this.path = ko.computed(function () {
                // The ports are even width in px. and paths are 2 px. wide. We therefore subtract 1 from the HalfWidth to have them appear centered -- center of the path lines up with center of the port.
                return ("M" + (this.inputPort.x() + ExperimentEditor.Constants.Port.HalfWidth - 1) + "," + (this.inputPort.y()) + "C " + (this.inputPort.x() + ExperimentEditor.Constants.Port.HalfWidth - 1) + "," + (this.inputPort.y() - this.controlPointDistance()) + "," + (this.outputPort.x() + ExperimentEditor.Constants.Port.HalfWidth - 1) + "," + (this.outputPort.y() + ExperimentEditor.Constants.Port.Height + this.controlPointDistance()) + "," + (this.outputPort.x() + ExperimentEditor.Constants.Port.HalfWidth - 1) + "," + (this.outputPort.y() + ExperimentEditor.Constants.Port.Height));
            }, this);
            this.classId = ko.computed(function () {
                var classId = "";
                if (this.inputPort.portModel.connectionIsInCycle()) {
                    classId += "error ";
                }
                classId += this.selected() ? "selectedConnection" : "defaultConnection";
                return classId;
            }, this);
            this.hidden = ko.observable(false);
            this.selected.subscribe(function (value) {
                if (value && _this.inputPort.classId() === "port connectedPort") {
                    _this.inputPort.portState(DataLab.Model.Constants.PortState.Selected);
                    _this.outputPort.portState(DataLab.Model.Constants.PortState.Selected);
                }
                else {
                    _this.inputPort.portState(DataLab.Model.Constants.PortState.Default);
                    _this.outputPort.portState(DataLab.Model.Constants.PortState.Default);
                }
            });
            this.belongsToExperimentFlow = ko.computed(function () { return _this.inputPort.parent.belongsToExperimentFlow() && _this.outputPort.parent.belongsToExperimentFlow(); });
            this.belongsToWebServiceFlow = ko.computed(function () { return _this.inputPort.parent.belongsToWebServiceFlow() && _this.outputPort.parent.belongsToWebServiceFlow(); });
        }
        Connection.createFromPorts = function (a, b) {
            if (a instanceof ExperimentEditor.InputPort && b instanceof ExperimentEditor.OutputPort) {
                return new Connection(a, b);
            }
            else if (a instanceof ExperimentEditor.OutputPort && b instanceof ExperimentEditor.InputPort) {
                return new Connection(b, a);
            }
            else {
                throw "Expected one InputPort and one OutputPort";
            }
        };
        Object.defineProperty(Connection.prototype, "key", {
            get: function () {
                return Connection.getConnectionKeyForPorts(this.inputPort, this.outputPort);
            },
            enumerable: true,
            configurable: true
        });
        Connection.getConnectionKeyForPorts = function (inputPort, outputPort) {
            // Returns a key which uniquely identifies a connection in a particular experiment.
            // This key is not necessarily unique globally (since there may be multiple views of the same experiment).
            return DataLab.Util.tuple(inputPort.portModel, outputPort.portModel).id;
        };
        Object.defineProperty(Connection.prototype, "x", {
            get: function () {
                return this.inputPort.x;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Connection.prototype, "y", {
            get: function () {
                return this.inputPort.y;
            },
            enumerable: true,
            configurable: true
        });
        Connection.prototype.remove = function () {
            _super.prototype.remove.call(this);
            this.inputPort.portModel.disconnectFrom(this.outputPort.portModel);
        };
        // The collision detection that returns true if all points of the 
        // Connection (p1, p2) are inside the selection rectangle P:(ox1,oy1) Q:(ox2,oy2)
        Connection.prototype.hit = function (ox1, oy1, ox2, oy2) {
            var p1 = { x: this.inputPort.x(), y: this.inputPort.y() };
            var p2 = { x: this.outputPort.x(), y: this.outputPort.y() };
            if ((p1.x >= ox1 && p2.x <= ox2 && p1.y >= oy1 && p2.y <= oy2) && (p2.x >= ox1 && p1.x <= ox2 && p2.y >= oy1 && p1.y <= oy2)) {
                return true;
            }
            return false;
        };
        return Connection;
    })(ExperimentEditor.Entity);
    ExperimentEditor.Connection = Connection;
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
/// <reference path="Entity.ts" />
/// <reference path="Connection.ts" />
/// <reference path="GraphNodeViewModel.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var ExperimentEditor;
(function (ExperimentEditor) {
    var PortViewModel = (function (_super) {
        __extends(PortViewModel, _super);
        function PortViewModel(parent, portModel, type) {
            var _this = this;
            _super.call(this, type);
            this.connections = ko.observableArray();
            this.portState = ko.observable(DataLab.Model.Constants.PortState.Default);
            // The 'host relative' coords are pushed down by the port layout algorithm in the hosting node. 
            this.hostRelativeX = ko.observable(0);
            this.hostRelativeY = ko.observable(0);
            if (!parent) {
                throw "'parent' parameter is required";
            }
            if (!portModel) {
                throw "'portModel' parameter is required";
            }
            this.portModel = portModel;
            this._parent = parent;
            this.balloonMessage = ko.observable(null);
            // Create a string listing all the types this port can connect to
            this.portTypes = "";
            for (var i = 0; i < this.portModel.descriptor.allowedDataTypes.length; i++) {
                var curType = this.portModel.descriptor.allowedDataTypes[i];
                this.portTypes += curType.toString();
                if (i < this.portModel.descriptor.allowedDataTypes.length - 1) {
                    this.portTypes += ', ';
                }
            }
            this.classId = ko.computed(function () {
                switch (this.portState()) {
                    case DataLab.Model.Constants.PortState.Compatible:
                        return DataLab.Model.Constants.PortClass + " " + DataLab.Model.Constants.PortState.Compatible;
                    case DataLab.Model.Constants.PortState.Incompatible:
                        return DataLab.Model.Constants.PortClass + " " + DataLab.Model.Constants.PortState.Incompatible;
                    case DataLab.Model.Constants.PortState.Default:
                        if (this.portModel.isConnected()) {
                            return DataLab.Model.Constants.PortClass + " " + DataLab.Model.Constants.PortState.Connected;
                        }
                        else {
                            return DataLab.Model.Constants.PortClass + " " + DataLab.Model.Constants.PortState.Default;
                        }
                    case DataLab.Model.Constants.PortState.Replaceable:
                        return DataLab.Model.Constants.PortClass + " " + DataLab.Model.Constants.PortState.Replaceable;
                    case DataLab.Model.Constants.PortState.Selected:
                        return DataLab.Model.Constants.PortClass + " " + DataLab.Model.Constants.PortState.Selected;
                    default:
                        throw "Unknown port compatibility type";
                }
            }, this);
            this._x = ko.computed(function () {
                return _this.parent.x() + _this.hostRelativeX();
            });
            this._y = ko.computed(function () {
                return _this.parent.y() + _this.hostRelativeY();
            });
            // Port label position on x-axis
            this.labelPosX = ko.computed(function () {
                return _this.x() + ExperimentEditor.Constants.Port.HalfWidth;
            });
            this.translation = ko.computed(function () {
                return "translate(" + _this.x() + "," + _this.y() + ")";
            });
            this.labelMaxWidth = ko.observable(Number.POSITIVE_INFINITY);
            this.labelYOffset = ko.observable(0);
            this.labelPosY = ko.computed(function () {
                return (_this.y() - ExperimentEditor.Constants.Label.InPortYPos);
            });
            this.tooltipPosX = ko.computed(function () {
                return _this.labelPosX();
            });
            this.tooltipPosY = ko.computed(function () {
                return _this.labelPosY();
            });
            this.tooltipBoxPosX = ko.computed(function () {
                return _this.tooltipPosX() - (_this.labelWidth() / 2);
            });
            this.infoIcon = "/Libraries/Images/ArrowLabel.png";
            this.belongsToExperimentFlow = ko.computed(function () { return _this.connections().length ? _this.connections().some(function (c) { return c.belongsToExperimentFlow(); }) : _this.parent.belongsToExperimentFlow(); });
            this.belongsToWebServiceFlow = ko.computed(function () { return _this.connections().length ? _this.connections().some(function (c) { return c.belongsToWebServiceFlow(); }) : _this.parent.belongsToWebServiceFlow(); });
        }
        Object.defineProperty(PortViewModel.prototype, "x", {
            get: function () {
                return this._x;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PortViewModel.prototype, "y", {
            get: function () {
                return this._y;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PortViewModel.prototype, "parent", {
            get: function () {
                return this._parent;
            },
            enumerable: true,
            configurable: true
        });
        // Get center x coordinate
        PortViewModel.prototype.getCX = function () {
            return this.x() + ExperimentEditor.Constants.Port.HalfWidth;
        };
        PortViewModel.prototype.getCY = function () {
            return this.y();
        };
        PortViewModel.prototype.entityAtPoint = function (x, y) {
            return (this.containsPoint(x, y) ? this : null);
        };
        // Return true if the point lies within this port's rectangle view
        PortViewModel.prototype.containsPoint = function (x, y) {
            var thisX = this.x();
            var thisY = this.y();
            return (x >= thisX && x <= thisX + (ExperimentEditor.Constants.Port.HalfWidth * 2)) && (y >= thisY && y <= thisY + ExperimentEditor.Constants.Port.Height);
        };
        PortViewModel.prototype.addConnection = function (connection) {
            if (this.connections().indexOf(connection) < 0) {
                this.connections.push(connection);
            }
        };
        PortViewModel.prototype.removeConnection = function (connection) {
            var index = this.connections().indexOf(connection);
            if (index >= 0) {
                this.connections.remove(connection);
            }
        };
        PortViewModel.prototype.getClassId = function (currentFlow) {
            var classId = _super.prototype.getClassId.call(this, currentFlow);
            if (this.belongsToCurrentFlow(currentFlow) && currentFlow !== ExperimentEditor.Constants.ExperimentDataFlowType.Experiment) {
                return classId + " whiteFill";
            }
            else if (!this.belongsToCurrentFlow(currentFlow) && currentFlow === ExperimentEditor.Constants.ExperimentDataFlowType.Experiment) {
                return classId + " whiteFill";
            }
            else {
                return classId;
            }
        };
        return PortViewModel;
    })(ExperimentEditor.Entity);
    ExperimentEditor.PortViewModel = PortViewModel;
    var InputPort = (function (_super) {
        __extends(InputPort, _super);
        function InputPort(host, portModel) {
            var _this = this;
            _super.call(this, host, portModel, ExperimentEditor.EntityTypes[ExperimentEditor.Constants.EntityType.InputPort]);
            this.labelPosY = ko.computed(function () {
                return (_this.y() - ExperimentEditor.Constants.Label.InPortYPos - _this.labelYOffset());
            });
        }
        return InputPort;
    })(PortViewModel);
    ExperimentEditor.InputPort = InputPort;
    var OutputPort = (function (_super) {
        __extends(OutputPort, _super);
        function OutputPort(host, portModel) {
            _super.call(this, host, portModel, ExperimentEditor.EntityTypes[ExperimentEditor.Constants.EntityType.OutputPort]);
            this.labelPosY = ko.computed(function () {
                return (this.y() + ExperimentEditor.Constants.Label.OutPortYPos + this.labelYOffset());
            }, this);
        }
        // Get center y coordinate
        OutputPort.prototype.getCY = function () {
            return this.y() + ExperimentEditor.Constants.Port.Height;
        };
        return OutputPort;
    })(PortViewModel);
    ExperimentEditor.OutputPort = OutputPort;
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
/// <reference path="Entity.ts" />
/// <reference path="PortViewModel.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var ExperimentEditor;
(function (ExperimentEditor) {
    var Model = DataLab.Model;
    var Comments;
    (function (Comments) {
        Comments.XOffset = 200;
        Comments.YOffset = 40;
        Comments.GraphNodeYOffset = 45 - Comments.YOffset;
        Comments.WidthBuffer = 17;
        Comments.HeightOffset = 45;
        Comments.LineHeight = 20;
        Comments.MaxLinesToShow = 3;
    })(Comments = ExperimentEditor.Comments || (ExperimentEditor.Comments = {}));
    var Growth;
    (function (Growth) {
        Growth.Rate = 75;
        Growth.Trigger = 3;
    })(Growth = ExperimentEditor.Growth || (ExperimentEditor.Growth = {}));
    // A graph node entity specified as GraphNodeViewModel:(x,y, width, height)
    var GraphNodeViewModel = (function (_super) {
        __extends(GraphNodeViewModel, _super);
        function GraphNodeViewModel(graphNode, type) {
            var _this = this;
            _super.call(this, type);
            this.portState = ko.observable(DataLab.Model.Constants.PortState.Default);
            this.iconClass = "";
            if (!graphNode) {
                throw "'graphNode' parameter is required to be non-null";
            }
            this.graphNode = graphNode;
            this.valid = ko.observable(true);
            this.labelPosX = ko.computed(function () {
                return _this.x() + ExperimentEditor.Constants.Label.ModuleXOffset;
            });
            this.labelPosY = ko.computed(function () {
                return _this.y() + ExperimentEditor.Constants.Label.ModuleYOffset;
            });
            this.forceBalloon = new ko.subscribable();
            this.graphNode.height(ExperimentEditor.Constants.RectHeight);
            this.ports = {};
            this.inputPorts = {};
            this.outputPorts = {};
            DataLab.Util.forEach(this.graphNode.ports, function (port) {
                var viewModel;
                if (port instanceof Model.InputPort) {
                    viewModel = _this.inputPorts[port.name] = new ExperimentEditor.InputPort(_this, port);
                }
                else if (port instanceof Model.OutputPort) {
                    viewModel = _this.outputPorts[port.name] = new ExperimentEditor.OutputPort(_this, port);
                }
                else {
                    throw "Unknown port type";
                }
                _this.ports[port.name] = viewModel;
            });
            this.statusIconURL = ko.computed(function () {
                return "/Content/Images/icon-none.svg";
            });
            // Port maps should be immutable after construction.
            Object.freeze(this.ports);
            Object.freeze(this.inputPorts);
            Object.freeze(this.outputPorts);
            this.relayout();
            this.labelMaxWidth = ExperimentEditor.Constants.Label.MaxWidth;
            this.tooltipPosX = ko.computed(function () {
                return _this.labelPosX();
            });
            this.tooltipPosY = ko.computed(function () {
                return _this.labelPosY() - ExperimentEditor.Constants.Tooltip.RectYOffset;
            });
            this.hasComment = ko.computed(function () {
                return _this.graphNode.comment() !== "";
            });
            this.commentPosX = ko.computed(function () {
                var posX = _this.labelPosX();
                return posX + "px";
            });
            this.commentPosY = ko.computed(function () {
                var posY = _this.labelPosY() + Comments.GraphNodeYOffset;
                return posY + "px";
            });
            this.commentWidth = ko.computed(function () {
                return (_this.width() - ExperimentEditor.Constants.Label.ModuleXOffset * 2) + "px";
            });
            this.linesToShow = ko.computed(function () {
                if (_this.graphNode.commentCollapsed()) {
                    return 0;
                }
                var commentLines = 1;
                while (commentLines <= Comments.MaxLinesToShow && _this.commentLargerThanDiv(Comments.LineHeight * (commentLines - 1), _this.comment())) {
                    commentLines = commentLines + 1;
                }
                // modify the height of the node rectangle
                var outputPorts = DataLab.Util.values(_this.outputPorts);
                _this.graphNode.height(ExperimentEditor.Constants.RectHeight + Comments.LineHeight * (commentLines - 1));
                _this.relayoutPorts(outputPorts, _this.width(), _this.height());
                return commentLines - 1;
            });
            this.commentCollapsedExpandedIconURL = ko.computed(function () {
                return _this.graphNode.commentCollapsed() ? "/Libraries/Images/icon-chevron-collapsed.svg" : "/Libraries/Images/icon-chevron-expanded.svg";
            });
            var collapsedSymbol = ExperimentEditor.GetIconSymbol("icon-properties_chevron_collapsed");
            var expandedSymbol = ExperimentEditor.GetIconSymbol("icon-properties_chevron_expanded");
            this.commentCollapsedExpandedIconSymbol = ko.computed(function () {
                return _this.graphNode.commentCollapsed() ? collapsedSymbol : expandedSymbol;
            });
            this.showHideComment = function () {
                var outputPorts = DataLab.Util.values(_this.outputPorts);
                _this.graphNode.commentCollapsed(!_this.graphNode.commentCollapsed());
                _this.graphNode.height(ExperimentEditor.Constants.RectHeight + Comments.LineHeight * _this.linesToShow());
                _this.relayoutPorts(outputPorts, _this.width(), _this.height());
            };
            this.commentToShow = ko.computed(function () {
                // if comment fits on MaxLinesToShow lines, display the full comment
                if (!_this.commentLargerThanDiv(Comments.LineHeight * Comments.MaxLinesToShow, _this.comment())) {
                    return _this.graphNode.comment();
                }
                var position = 0;
                while (!_this.commentLargerThanDiv(Comments.LineHeight * Comments.MaxLinesToShow, _this.comment().slice(0, position) + " ...")) {
                    position = position + 1;
                }
                return _this.comment().slice(0, position - 1) + " ...";
            });
            this.editingComment = ko.observable(false);
            this.commentClass = ko.computed(function () {
                var commentClass = "comment";
                var collapsedState = _this.graphNode.commentCollapsed() ? " collapsed" : "";
                var selectedState = _this.selected() ? " selected" : "";
                return commentClass + collapsedState + selectedState;
            });
            this.iconPosX = ko.computed(function () {
                return _this.x() + ExperimentEditor.Constants.Icon.XOffset;
            });
            this.iconPosY = ko.computed(function () {
                return _this.y() + ((ExperimentEditor.Constants.RectHeight - ExperimentEditor.Constants.Icon.Height) / 2);
            });
            this.textClassId = ko.computed(function () {
                return "staticText";
            });
            this.icon = "";
            this.iconSymbol = "";
        }
        Object.defineProperty(GraphNodeViewModel.prototype, "x", {
            // Getting / setting x or y forwards to the backing graph node.
            get: function () {
                return this.graphNode.x;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GraphNodeViewModel.prototype, "y", {
            get: function () {
                return this.graphNode.y;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GraphNodeViewModel.prototype, "width", {
            get: function () {
                return this.graphNode.width;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GraphNodeViewModel.prototype, "height", {
            get: function () {
                return this.graphNode.height;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GraphNodeViewModel.prototype, "comment", {
            get: function () {
                return this.graphNode.comment;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GraphNodeViewModel.prototype, "balloonMessage", {
            get: function () {
                return this.graphNode.balloonMessage;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GraphNodeViewModel.prototype, "label", {
            get: function () {
                throw "abstract property 'label' must be overriden";
                return null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GraphNodeViewModel.prototype, "tooltip", {
            get: function () {
                var text = "";
                text += this.graphNode.name + ". ";
                if (this.graphNode.description) {
                    text += (text !== "" ? "\n" : "") + this.graphNode.description;
                }
                return text;
            },
            enumerable: true,
            configurable: true
        });
        /**
          * Returns the closest input port on this graph node to the domain coordinates x, y
          * @param {number} x the x domain coordinate
          * @param {number} y the y domain coordinate
          * @return {PortViewModel} The closest input port on this graph node to the specified coordinates or null if this node has no inputs
         **/
        GraphNodeViewModel.prototype.findClosestInputPort = function (x, y) {
            return this.findClosestPort(this.inputPorts, x, y);
        };
        /**
          * Returns the closest output port on this graph node to the domain coordinates x, y
          * @param {number} x the x domain coordinate
          * @param {number} y the y domain coordinate
          * @return {PortViewModel} The closest output port on this graph node to the specified coordinates or null if this node has no outputs
         **/
        GraphNodeViewModel.prototype.findClosestOutputPort = function (x, y) {
            return this.findClosestPort(this.outputPorts, x, y);
        };
        GraphNodeViewModel.prototype.remove = function () {
            _super.prototype.remove.call(this);
            this.graphNode.remove();
        };
        // The version of the collision detection that returns true
        // if all points of the graph node (p1, p2) are inside the selection rectangle P:(ox1,oy1) Q:(ox2,oy2)
        GraphNodeViewModel.prototype.hit = function (ox1, oy1, ox2, oy2) {
            var p1 = { x: this.x(), y: this.y() };
            var p2 = { x: (this.x() + this.width()), y: (this.y() + this.height()) };
            if (p1.x < ox1) {
                return false;
            }
            if (p1.y < oy1) {
                return false;
            }
            if (p2.x > ox2) {
                return false;
            }
            if (p2.y > oy2) {
                return false;
            }
            return true;
        };
        // This function returns the child-most entity at the point x,y (or null if the point is outside)
        GraphNodeViewModel.prototype.entityAtPoint = function (x, y) {
            // Cheaply check if the point is in the bounding box of this entity and all its ports.
            // If not, return null.
            if (this.boundingBoxContainsPoint(x, y)) {
                for (var key in this.ports) {
                    var hitPort = this.ports[key].entityAtPoint(x, y);
                    if (hitPort !== null) {
                        return hitPort;
                    }
                }
                // If the inputs don't hit, return this if the point still hits this entity or null if it doesn't
                return (this.containsPoint(x, y) ? this : null);
            }
            else {
                return null;
            }
        };
        // This function returns true if this graph node (not necessarily its children) contains the point x, y     
        GraphNodeViewModel.prototype.containsPoint = function (x, y) {
            return (x >= this.x() && x <= this.x() + this.width()) && (y >= this.y() && y <= this.y() + this.height());
        };
        // This function returns true if the point x, y resides in a bounding box that encloses this entity
        // and all of its ports.
        GraphNodeViewModel.prototype.boundingBoxContainsPoint = function (x, y) {
            var boxY = y + ExperimentEditor.Constants.Port.HalfHeight;
            var boxHeight = this.height() + ExperimentEditor.Constants.Port.Height;
            return (x >= this.x() && x <= this.x() + this.width()) && (boxY >= this.y() && y <= this.y() + boxHeight);
        };
        GraphNodeViewModel.prototype.relayout = function () {
            var inputPorts = DataLab.Util.values(this.inputPorts);
            var outputPorts = DataLab.Util.values(this.outputPorts);
            var maxPortRowLength = Math.max(inputPorts.length, outputPorts.length);
            var extraWidth = Math.max(0, (maxPortRowLength - Growth.Trigger) * Growth.Rate);
            this.width(ExperimentEditor.Constants.RectWidth + extraWidth);
            this.relayoutPorts(inputPorts, this.width(), this.height());
            this.relayoutPorts(outputPorts, this.width(), this.height());
        };
        GraphNodeViewModel.prototype.getCompatibilityClass = function () {
            switch (this.portState()) {
                case DataLab.Model.Constants.PortState.Compatible:
                    return "compatible";
                case DataLab.Model.Constants.PortState.CompatibleSnapped:
                    return "compatible snapped";
                case DataLab.Model.Constants.PortState.Incompatible:
                    return "incompatible";
                case DataLab.Model.Constants.PortState.Default:
                    return "idle";
                case DataLab.Model.Constants.PortState.Replaceable:
                    return "replaceable";
                default:
                    throw new Error("Unknown node compatibility type");
            }
        };
        GraphNodeViewModel.prototype.findClosestPort = function (ports, x, y) {
            var distance = function (x1, y1, x2, y2) {
                return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
            };
            var closestPort = null;
            var minDistance = Number.MAX_VALUE;
            DataLab.Util.forEach(ports, function (port) {
                var curDistance = distance(x, y, port.getCX(), port.getCY());
                if (curDistance < minDistance) {
                    minDistance = curDistance;
                    closestPort = port;
                }
            });
            return closestPort;
        };
        GraphNodeViewModel.prototype.relayoutPorts = function (ports, hostWidth, hostHeight) {
            var spacing = (hostWidth / (ports.length + 1));
            ports.forEach(function (port) {
                //Calculate the X-coordinate to evenly space ports across the width of the rectangle.
                var posX = (port.portModel.ordinal + 1) * spacing - ExperimentEditor.Constants.Port.HalfWidth;
                var posY = (port instanceof ExperimentEditor.InputPort) ? 0 : hostHeight;
                port.hostRelativeX(posX);
                port.hostRelativeY(posY);
                port.labelMaxWidth(spacing * 2 - ExperimentEditor.Constants.Port.HalfWidth * 4);
            });
        };
        GraphNodeViewModel.prototype.editComment = function () {
            this.editingComment(true);
        };
        GraphNodeViewModel.prototype.commentLargerThanDiv = function (size, commentText) {
            var divArea = document.createElement("div");
            divArea.setAttribute("class", "comment");
            divArea.style.width = this.commentWidth();
            divArea.style.visibility = "hidden";
            var textArea = document.createElement("pre");
            textArea.setAttribute("class", "text");
            divArea.appendChild(textArea);
            document.body.appendChild(divArea);
            if (commentText) {
                $(textArea).text(commentText);
                if (divArea.clientHeight > (size)) {
                    document.body.removeChild(divArea);
                    return true;
                }
            }
            document.body.removeChild(divArea);
            return false;
        };
        return GraphNodeViewModel;
    })(ExperimentEditor.Entity);
    ExperimentEditor.GraphNodeViewModel = GraphNodeViewModel;
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
/// <reference path="../../../../MonacoEditor/Monaco.d.ts" />
var ExperimentEditor;
(function (ExperimentEditor) {
    var MonacoMimeTypes;
    (function (MonacoMimeTypes) {
        MonacoMimeTypes.R = "r";
        MonacoMimeTypes.Python = "text/x-python";
        MonacoMimeTypes.Hive = "hql";
        MonacoMimeTypes.Sql = "sql";
        MonacoMimeTypes.PlainText = "text/plain";
        MonacoMimeTypes.JavaScript = "text/javascript";
        MonacoMimeTypes.TypeScript = "text/typescript";
    })(MonacoMimeTypes = ExperimentEditor.MonacoMimeTypes || (ExperimentEditor.MonacoMimeTypes = {}));
    ko.bindingHandlers["monaco"] = {
        init: function (monacoDiv, valueAccessor, allBindingsAccessor, targetViewModel, bindingContext) {
            var bindingOptions = ko.utils.unwrapObservable(valueAccessor());
            var content = ko.utils.unwrapObservable(bindingOptions.value);
            var mimetype = ko.utils.unwrapObservable(bindingOptions.mimetype);
            content = (content === null) ? "" : content;
            var Constants = require("vs/editor/core/constants");
            var monacoOptions = {
                value: content,
                mode: mimetype,
                glyphMargin: false,
                readOnly: false,
                lineNumbersMinChars: 2,
                automaticLayout: true,
                scrollBeyondLastLine: false,
                insertSpaces: true
            };
            var editor = Monaco.Editor.create(monacoDiv, monacoOptions);
            ko.utils.domNodeDisposal.addDisposeCallback(monacoDiv, function () {
                if (editor) {
                    // in IE the disposal is triggered before the blur handler. So we manually trigger the resize before destroying the element.
                    setUnsetFocus();
                    editor.destroy();
                    editor = null;
                }
            });
            // this is needed so that fx-validation background image is visible in case of error (when script box is empty)
            // monaco sets the background of inner div to white which it doesn't seem necessary
            $(monacoDiv).find('.monaco-editor').css('background-color', 'transparent');
            // Update model
            var editorModel = editor.getModel();
            editorModel.addListener(Constants.EventType.ModelContentChanged, function (e) {
                bindingOptions.value(editorModel.getValue());
            });
            // These are used to remember the starting state on expanding the r script editor on focus so that we can contract it back on blur correctly.
            var propertyEditorWidthBeforeFocus = $(".propertyEditorContainer").parent().width();
            var propertyEditorWidthAfterFocus = ExperimentEditor.Constants.rScriptEditorFocusWidth;
            var setUnsetFocus = function () {
                // On focus we want to expand the text area where the r script can be edited.
                // This will be done by increasing the width of the property editor and increasing the height of the script element itself. 
                var propertyEditorElement = $(".propertyEditorContainer").parent();
                var experimentContainerRightElement = $(".experiment-container-right");
                var quickHelpContainer = $(".quickHelpContainer");
                var collapseResizeManager = monacoDiv.parentElement["collapseResizeManager"];
                if ($.contains(monacoDiv, document.activeElement)) {
                    if (propertyEditorElement.length > 0 && experimentContainerRightElement.length > 0) {
                        // Store the current size of the propertyEditor so as to be able to return to it upon blur.
                        propertyEditorWidthBeforeFocus = propertyEditorElement.width();
                        // Only change the width if it is smaller than the width desired for editing.
                        if (propertyEditorWidthBeforeFocus < ExperimentEditor.Constants.rScriptEditorFocusWidth) {
                            // Try to set the desired width. If too wide, try a smaller width, until it works or we've reached current width.
                            var width = ExperimentEditor.Constants.rScriptEditorFocusWidth;
                            propertyEditorElement.width(width);
                            while (propertyEditorElement[0].getBoundingClientRect().left < experimentContainerRightElement[0].getBoundingClientRect().left) {
                                width = width - 10;
                                if (width < propertyEditorWidthBeforeFocus) {
                                    propertyEditorElement.width(propertyEditorWidthBeforeFocus);
                                    break;
                                }
                                propertyEditorElement.width(width);
                            }
                        }
                        // Remember the width we set, so we can detect when the user modified the property editor width while focused on the script.
                        propertyEditorWidthAfterFocus = propertyEditorElement.width();
                    }
                    if (quickHelpContainer.length > 0 && collapseResizeManager) {
                        // Set the height to be maximum allowed without crossing over the quick help (with 25 pixel cushion)
                        var quickHelpTop = quickHelpContainer[0].getBoundingClientRect().bottom - quickHelpContainer[0].getBoundingClientRect().height - 25;
                        var height = ExperimentEditor.Constants.rScriptEditorFocusHeight;
                        collapseResizeManager.resize(height);
                        var quickHelpTop = quickHelpContainer[0].getBoundingClientRect().bottom - quickHelpContainer[0].getBoundingClientRect().height;
                        while (quickHelpTop < monacoDiv.parentElement.getBoundingClientRect().bottom) {
                            height = height - 10;
                            if (height < collapseResizeManager.minSize) {
                                collapseResizeManager.resize(collapseResizeManager.minSize);
                                break;
                            }
                            collapseResizeManager.resize(height);
                        }
                    }
                    targetViewModel.focus(true);
                }
                else {
                    if (collapseResizeManager) {
                        // Change the height to the starting value.
                        collapseResizeManager.resize(collapseResizeManager.minSize);
                    }
                    // Only change the width back to starting value if the user has not changed it while editing.
                    if (propertyEditorElement.length > 0 && propertyEditorElement.width() === propertyEditorWidthAfterFocus) {
                        propertyEditorElement.width(propertyEditorWidthBeforeFocus);
                    }
                    targetViewModel.focus(false);
                }
            };
            editor.addListener('focus', function () {
                setUnsetFocus();
            });
            editor.addListener('blur', function () {
                setUnsetFocus();
            });
        },
        update: function (monacoDiv, valueAccessor) {
        }
    };
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
/// <reference path="CustomUX.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var ExperimentEditor;
(function (ExperimentEditor) {
    var ColumnPicker;
    (function (ColumnPicker) {
        // Need this for mapping json id to the friendly display name
        var RuleType = (function () {
            function RuleType() {
            }
            RuleType.equals = function (rule1, rule2) {
                return rule1.id === rule2.id && rule1.exclude === rule2.exclude;
            };
            RuleType.findRule = function (excludeOrId, excludeOrColumnKind) {
                if (typeof excludeOrId === "string") {
                    var id = excludeOrId;
                    var exclude = excludeOrColumnKind;
                    var matchingRules = RuleType.all.filter(function (ruleId) {
                        return ruleId.id === id && ruleId.exclude === exclude;
                    });
                }
                else {
                    var exclude = excludeOrId;
                    var columnKind = excludeOrColumnKind;
                    var matchingRules = RuleType.all.filter(function (ruleId) {
                        return ruleId.exclude === exclude && ruleId.columnKind === columnKind;
                    });
                }
                if (matchingRules.length > 0) {
                    return matchingRules[0];
                }
                else {
                    return RuleType.ColumnNames;
                }
            };
            // @TODO name property needs localization - TFS Defect 2734858
            RuleType.AllColumns = {
                id: "AllColumns",
                name: "All columns",
                exclude: false,
                hidden: true,
                inSingleColumnMode: false,
                inAllowDuplicatesMode: false
            };
            RuleType.NoColumns = {
                id: "NoColumns",
                name: "No columns",
                exclude: true,
                hidden: true,
                inSingleColumnMode: false,
                inAllowDuplicatesMode: false
            };
            RuleType.ColumnNames = {
                id: "ColumnNames",
                name: "column names",
                exclude: false,
                hidden: false,
                inSingleColumnMode: true,
                inAllowDuplicatesMode: true
            };
            RuleType.ColumnIndices = {
                id: "ColumnIndexes",
                name: "column indices",
                exclude: false,
                hidden: false,
                inSingleColumnMode: true,
                inAllowDuplicatesMode: true
            };
            RuleType.ColumnTypes = {
                id: "ColumnTypes",
                name: "column type",
                exclude: false,
                hidden: false,
                inSingleColumnMode: true,
                inAllowDuplicatesMode: false
            };
            RuleType.ExcludeColumnNames = {
                id: "ColumnNames",
                name: "column names",
                exclude: true,
                hidden: false,
                inSingleColumnMode: false,
                inAllowDuplicatesMode: false
            };
            RuleType.ExcludeColumnIndices = {
                id: "ColumnIndexes",
                name: "column indices",
                exclude: true,
                hidden: false,
                inSingleColumnMode: false,
                inAllowDuplicatesMode: false
            };
            RuleType.ExcludeColumnTypes = {
                id: "ColumnTypes",
                name: "column type",
                exclude: true,
                hidden: false,
                inSingleColumnMode: false,
                inAllowDuplicatesMode: false
            };
            // These lie about their id to keep the serialized format unchanged. When a rule serializes 
            // itself (ColumnPickerRule.toJSON()) it will use the serializedId field instead of the id
            // field, if defined. I'm using this field to make sure that the following rules all serialize
            // themselves as ColumnByType rules, which is how users used to get equivalent functionality.
            // By not changing the JSON format we can keep this change relegated to just the view model.
            // In retrospect, updated the JSON would have been a better idea, but alas...
            RuleType.Features = {
                id: "Features",
                serializedId: "ColumnTypes",
                name: "all features",
                columnKind: "Feature",
                exclude: false,
                hidden: false,
                inSingleColumnMode: true,
                inAllowDuplicatesMode: false
            };
            RuleType.Scores = {
                id: "Scores",
                serializedId: "ColumnTypes",
                name: "all scores",
                columnKind: "Score",
                exclude: false,
                hidden: false,
                inSingleColumnMode: true,
                inAllowDuplicatesMode: false
            };
            RuleType.Labels = {
                id: "Labels",
                serializedId: "ColumnTypes",
                name: "all labels",
                columnKind: "Label",
                exclude: false,
                hidden: false,
                inSingleColumnMode: true,
                inAllowDuplicatesMode: false
            };
            RuleType.ExcludeFeatures = {
                id: "Features",
                serializedId: "ColumnTypes",
                name: "all features",
                columnKind: "Feature",
                exclude: true,
                hidden: false,
                inSingleColumnMode: false,
                inAllowDuplicatesMode: false
            };
            RuleType.ExcludeScores = {
                id: "Scores",
                serializedId: "ColumnTypes",
                name: "all scores",
                columnKind: "Score",
                exclude: true,
                hidden: false,
                inSingleColumnMode: false,
                inAllowDuplicatesMode: false
            };
            RuleType.ExcludeLabels = {
                id: "Labels",
                serializedId: "ColumnTypes",
                name: "all labels",
                columnKind: "Label",
                exclude: true,
                hidden: false,
                inSingleColumnMode: false,
                inAllowDuplicatesMode: false
            };
            RuleType.all = [
                RuleType.AllColumns,
                RuleType.NoColumns,
                RuleType.ColumnNames,
                RuleType.ColumnIndices,
                RuleType.ColumnTypes,
                RuleType.Features,
                RuleType.Scores,
                RuleType.Labels,
                RuleType.ExcludeColumnNames,
                RuleType.ExcludeColumnIndices,
                RuleType.ExcludeColumnTypes,
                RuleType.ExcludeFeatures,
                RuleType.ExcludeScores,
                RuleType.ExcludeLabels,
            ];
            return RuleType;
        })();
        ColumnPicker.RuleType = RuleType;
        var RuleCategory = (function () {
            function RuleCategory() {
            }
            RuleCategory.Include = { id: "include", name: "Include", exclude: false, inFirstRule: true };
            RuleCategory.Exclude = { id: "exclude", name: "Exclude", exclude: true, inFirstRule: false };
            RuleCategory.all = [RuleCategory.Include, RuleCategory.Exclude];
            return RuleCategory;
        })();
        var ColumnType = (function () {
            function ColumnType() {
            }
            ColumnType.String = "String";
            ColumnType.Integer = "Integer";
            ColumnType.Double = "Double";
            ColumnType.Boolean = "Boolean";
            ColumnType.DateTime = "DateTime";
            ColumnType.TimeSpan = "TimeSpan";
            ColumnType.Categorical = "Categorical";
            ColumnType.Numeric = "Numeric";
            ColumnType.All = "All";
            return ColumnType;
        })();
        ColumnPicker.ColumnType = ColumnType;
        var ColumnKind = (function () {
            function ColumnKind() {
            }
            ColumnKind.All = "All";
            ColumnKind.Feature = "Feature";
            ColumnKind.Score = "Score";
            ColumnKind.Label = "Label";
            return ColumnKind;
        })();
        ColumnPicker.ColumnKind = ColumnKind;
        // Returns the set of ColumnTypes that would match the given ColumnAttribute.
        function mapAttributeTypeToColumnTypes(attribute) {
            var typeName = attribute.elementType ? attribute.elementType.typeName : "";
            switch (attribute.type) {
                case "Binary":
                case "Categorical":
                case "String":
                    return [attribute.type];
                case "Numeric":
                    var colTypes = [ColumnType.Numeric];
                    if (["float", "double", "complex64", "complex128"].indexOf(typeName) >= 0) {
                        colTypes.push(ColumnType.Double);
                    }
                    else if (["sbyte", "byte", "short", "ushort", "int", "uint", "long", "ulong"].indexOf(typeName) >= 0) {
                        colTypes.push(ColumnType.Integer);
                    }
                    return colTypes;
                case "Ordinal":
                    return [ColumnType.Categorical];
                case "Object":
                    if (attribute.elementType) {
                        if (typeName === "timespan") {
                            return [ColumnType.TimeSpan];
                        }
                        else if (typeName === "datetime") {
                            return [ColumnType.DateTime];
                        }
                    }
                    return [];
                default:
                    // maybe should return error
                    return [];
            }
        }
        var ColumnPickerRule = (function (_super) {
            __extends(ColumnPickerRule, _super);
            function ColumnPickerRule(ruleType, viewModel, columns, invalidColumns, columnTypes, columnKinds, schema) {
                var _this = this;
                if (columns === void 0) { columns = []; }
                if (invalidColumns === void 0) { invalidColumns = []; }
                if (columnTypes === void 0) { columnTypes = []; }
                if (columnKinds === void 0) { columnKinds = []; }
                _super.call(this);
                this.ruleType = ko.observable(ruleType);
                this.ruleCategory = ko.observable(ruleType.exclude);
                this.selectedColumns = ko.observableArray(columns);
                this.invalidColumns = ko.observableArray(invalidColumns);
                this.columnTypes = ko.observableArray(columnTypes);
                this.columnKinds = ko.observableArray(columnKinds);
                this.hasRuleTypeError = ko.observable(false);
                this.hasIndexRuleError = ko.observable(false);
                this.hasNameRuleError = ko.observable(false);
                this.hasKinds = ko.computed(function () {
                    return _this.columnKinds().length > 0 && _this.columnKinds()[0] !== ColumnKind.All;
                });
                this.registerForDisposal(new DataLab.Util.DisposableKnockoutObject(this.typeChoices = ko.computed(function () {
                    if (_this.hasKinds()) {
                        return viewModel.typeChoices;
                    }
                    else {
                        return viewModel.typeChoices.filter(function (choice) {
                            return choice !== ColumnKind.All;
                        });
                    }
                }, this)));
                // Defining for symmetry with this.typeChoices()
                this.registerForDisposal(new DataLab.Util.DisposableKnockoutObject(this.kindChoices = ko.computed(function () {
                    return viewModel.kindChoices;
                }, this)));
                this.hasError = ko.computed(function () {
                    return _this.hasRuleTypeError() || _this.hasIndexRuleError() || _this.hasNameRuleError();
                }, this);
                this.registerForDisposal(new DataLab.Util.DisposableKnockoutObject(this.allowDuplicates = ko.computed(function () {
                    return viewModel.allowDuplicates();
                }, this)));
                this.nameInputFocused = ko.observable(true);
                this.setNameInputFocused = (function () {
                    _this.nameInputFocused(true);
                });
                this.placeholderText = ko.computed(function () {
                    // Check for selected columns AND focus.  Browsers differ on what they do when the input has focus but no content (Chrome shows it, IE doesn't)
                    if (!_this.nameInputFocused() && _this.selectedColumns().length === 0) {
                        return DataLab.LocalizedResources.pressEnterColumnName;
                    }
                    else {
                        return '';
                    }
                });
                this.columnIndexRegExp = new RegExp('^\\s*(-?\\d+)\\s*$');
                this.columnRangeRegExp = new RegExp('^\\s*(\\d+)\\s*-\\s*(\\d+)\\s*$');
                this.validateIndices = function () {
                    var indexArr = _this.indexList().split(',');
                    var error = null; // message for first error encountered
                    var errorFound = indexArr.some(function (indexStr) {
                        if (_this.columnIndexRegExp.test(indexStr)) {
                            var index = Number(_this.columnIndexRegExp.exec(indexStr)[1]);
                            error = ColumnPickerRule.validateColumnIndex(index, schema);
                        }
                        else if (_this.columnRangeRegExp.test(indexStr)) {
                            var regexpMatch = _this.columnRangeRegExp.exec(indexStr), fromIndex = Number(regexpMatch[1]), toIndex = Number(regexpMatch[2]);
                            error = ColumnPickerRule.validateColumnRange(fromIndex, toIndex, schema);
                        }
                        else {
                            error = DataLab.LocalizedResources.columnPickerInputMustBeAListOfPositiveIndicesOrRanges;
                        }
                        return !!error;
                    });
                    _this.hasIndexRuleError(errorFound);
                    return error;
                };
                var indexListValue = this.ruleType().id === RuleType.ColumnIndices.id ? columns.join(",") : "";
                this.indexList = DataLab.Validation.validatableObservable(indexListValue, this.validateIndices);
                if (this.ruleType().id === RuleType.ColumnIndices.id) {
                    this.indexList.startValidating();
                    this.indexList.validate();
                }
                this.validateRuleType = function (inputValue) {
                    var error;
                    if (_this.isFirstRule() && _this.allowDuplicates() && (_this.ruleType().exclude || !(_this.ruleType().id === RuleType.ColumnNames.id || _this.ruleType().id === RuleType.ColumnIndices.id))) {
                        error = DataLab.LocalizedResources.columnPickerSelectionRules;
                    }
                    if (_this.isFirstRule() && _this.ruleType().exclude) {
                        error = DataLab.LocalizedResources.columnPickerFirstRuleNoExlude;
                    }
                    error ? _this.hasRuleTypeError(true) : _this.hasRuleTypeError(false);
                    return error;
                };
                var isFirstRuleComputed;
                this.registerForDisposal(new DataLab.Util.DisposableKnockoutObject(isFirstRuleComputed = ko.computed(function () {
                    return viewModel.firstRule() === _this;
                })));
                this.isFirstRule = DataLab.Validation.validatableObservable(isFirstRuleComputed, this.validateRuleType);
                this.isFirstRule.startValidating();
                this.isFirstRule.validate();
                this.validateNamesSelection = function (inputValue) {
                    var error;
                    if (viewModel.singleColumnSelection()) {
                        if (_this.selectedColumns().length !== 1) {
                            error = DataLab.LocalizedResources.columnPickerInputNameList;
                        }
                    }
                    else {
                        if (_this.selectedColumns().length === 0) {
                            error = DataLab.LocalizedResources.columnPickerInputMultipleNamesList;
                        }
                    }
                    if (_this.invalidColumns().length > 0) {
                        error = DataLab.LocalizedResources.columnPickerInvalidNames;
                    }
                    error ? _this.hasNameRuleError(true) : _this.hasNameRuleError(false);
                    return error;
                };
                // The column currently being typed by the user in the input box.
                this.currentColumn = DataLab.Validation.validatableObservable("", this.validateNamesSelection);
                if (this.ruleType().id === RuleType.ColumnNames.id) {
                    this.currentColumn.startValidating();
                    this.currentColumn.validate();
                }
                this.currentColumn.subscribe(function () {
                    if (_this.currentColumn() !== "") {
                        var names = DataLab.Util.Str.getArrayFromCommaSeparatedString(_this.currentColumn());
                        names.forEach(function (trimmedName) {
                            if (trimmedName !== "") {
                                if (_this.selectedColumns().indexOf(trimmedName) === -1 || _this.allowDuplicates()) {
                                    _this.selectedColumns.push(trimmedName);
                                }
                                else {
                                    _this.invalidColumns.push(trimmedName);
                                }
                            }
                        });
                    }
                    _this.currentColumn.startValidating();
                    _this.currentColumn.validate();
                    // Clear the input
                    _this.currentColumn("");
                });
                this.allowDuplicates.subscribe(function () {
                    _this.isFirstRule.startValidating();
                    _this.isFirstRule.validate();
                });
                // Clear selections when rule changes
                // Set the default values of column types and kinds when rule changes to a type rule.
                this.ruleType.subscribe(function () {
                    _this.isFirstRule.startValidating();
                    _this.isFirstRule.validate();
                    _this.hasIndexRuleError(false);
                    _this.hasNameRuleError(false);
                    _this.selectedColumns.removeAll();
                    _this.invalidColumns.removeAll();
                    if (_this.ruleType().id === RuleType.ColumnNames.id) {
                        _this.currentColumn("");
                        _this.currentColumn.startValidating();
                        _this.currentColumn.validate();
                    }
                    if (_this.ruleType().id === RuleType.ColumnIndices.id) {
                        _this.indexList("");
                        _this.indexList.startValidating();
                        _this.indexList.validate();
                    }
                    if (_this.ruleType().id === RuleType.ColumnTypes.id) {
                        _this.columnTypes([_this.typeChoices()[0]]);
                        _this.columnKinds([_this.kindChoices()[0]]);
                    }
                    if (_this.ruleType().columnKind) {
                        _this.columnTypes([ColumnType.All]);
                        _this.columnKinds([_this.ruleType().columnKind]);
                    }
                });
                this.removeColumnName = function (columnName) {
                    _this.selectedColumns.remove(columnName);
                    _this.currentColumn.startValidating();
                    _this.currentColumn.validate();
                    Shell.Diagnostics.Telemetry.customEvent("RemoveColumnName", "ColumnPicker", JSON.stringify({ columns: columnName }));
                };
                this.removeInvalidColumnName = function (columnName) {
                    _this.invalidColumns.remove(columnName);
                    _this.currentColumn.startValidating();
                    _this.currentColumn.validate();
                    Shell.Diagnostics.Telemetry.customEvent("RemoveColumnNameInvalid", "ColumnPicker", JSON.stringify({ columns: columnName }));
                };
                this.indexList.subscribe(function () {
                    _this.selectedColumns.removeAll();
                    if (_this.indexList() !== "") {
                        var indexArr = _this.indexList().split(',');
                        // Verify it's a single index or a range
                        indexArr.forEach(function (indexStr) {
                            if (_this.columnIndexRegExp.test(indexStr)) {
                                _this.selectedColumns.push(_this.columnIndexRegExp.exec(indexStr)[1]);
                            }
                            else if (_this.columnRangeRegExp.test(indexStr)) {
                                var regexpMatch = _this.columnRangeRegExp.exec(indexStr);
                                _this.selectedColumns.push(regexpMatch[1] + "-" + regexpMatch[2]);
                            }
                        });
                    }
                });
                this.registerForDisposal(new DataLab.Util.DisposableKnockoutObject(this.ruleChoices = ko.computed(function () {
                    var choices = RuleType.all.filter(function (choice) {
                        if (viewModel.singleColumnSelection() && !choice.inSingleColumnMode) {
                            return false;
                        }
                        else if (viewModel.allowDuplicates() && !choice.inAllowDuplicatesMode) {
                            return false;
                        }
                        else if (choice.exclude !== _this.ruleCategory()) {
                            return false;
                        }
                        else if (choice.hidden && _this.ruleType() !== choice) {
                            return false;
                        }
                        else if (viewModel.hiddenRuleTypes.indexOf(choice) !== -1) {
                            return false;
                        }
                        return true;
                    });
                    var ruleTypes = choices.map(function (choice) {
                        return choice;
                    });
                    // If the updated ruleChoices don't include the current ruleType, change the ruleType to the first valid one
                    var ruleTypesIncludesCurrentRuleType = ruleTypes.some(function (ruleType) {
                        return RuleType.equals(ruleType, _this.ruleType());
                    });
                    if (!ruleTypesIncludesCurrentRuleType) {
                        _this.ruleType(ruleTypes[0]);
                    }
                    return ruleTypes;
                }, this)));
                this.registerForDisposal(new DataLab.Util.DisposableKnockoutObject(this.ruleCategoryChoices = ko.computed(function () {
                    return RuleCategory.all.filter(function (ruleCategory) {
                        return !_this.isFirstRule() || ruleCategory.inFirstRule;
                    });
                }, this)));
            }
            ColumnPickerRule.prototype.toJSON = function () {
                var serializeAsColumnTypes = (this.ruleType().id === RuleType.ColumnTypes.id || this.ruleType().serializedId === RuleType.ColumnTypes.id);
                return {
                    ruleType: this.ruleType().serializedId ? this.ruleType().serializedId : this.ruleType().id,
                    columns: (function (rule, ruleId) {
                        if (ruleId === RuleType.ColumnNames.id || ruleId === RuleType.ColumnIndices.id) {
                            return rule.selectedColumns();
                        }
                        else
                            return undefined;
                    })(this, this.ruleType().id),
                    exclude: this.ruleType().exclude,
                    columnTypes: serializeAsColumnTypes ? this.columnTypes() : undefined,
                    columnKinds: serializeAsColumnTypes ? this.columnKinds() : undefined,
                };
            };
            ColumnPickerRule.prototype.setWidthToStartingChoiceLabelWidth = function (element) {
                var widthOfStartingChoiceLabel = $("label[for='RulesStartingChoice']").first().outerWidth(true);
                $(element).css('min-width', widthOfStartingChoiceLabel);
            };
            // returns error string if validation fails
            // index is 1 based
            ColumnPickerRule.validateColumnIndex = function (index, schema) {
                if (schema === void 0) { schema = null; }
                return ColumnPickerRule.validateColumnRange(index, index, schema);
            };
            // returns error string if validation fails
            // indices are 1 based
            ColumnPickerRule.validateColumnRange = function (fromIndex, toIndex, schema) {
                if (schema === void 0) { schema = null; }
                var maxIndex = schema && schema.columnAttributes && schema.columnAttributes.length; // should be either undefined or 1+
                var error = null;
                if (fromIndex <= 0 || toIndex <= 0) {
                    error = DataLab.LocalizedResources.columnPickerIndicesMustBeGreaterThan;
                }
                else if (toIndex < fromIndex) {
                    error = DataLab.LocalizedResources.columnPickerInvalidRange;
                }
                else if (maxIndex && toIndex > maxIndex) {
                    error = DataLab.Util.format(DataLab.LocalizedResources.columnPickerIndicesOutOfRange, maxIndex.toString());
                }
                return error;
            };
            return ColumnPickerRule;
        })(DataLab.Util.Disposable);
        ColumnPicker.ColumnPickerRule = ColumnPickerRule;
        var ColumnPickerViewModel = (function (_super) {
            __extends(ColumnPickerViewModel, _super);
            function ColumnPickerViewModel(storedRules, singleColumnSelection, schema) {
                var _this = this;
                _super.call(this);
                // @TODO Needs to be localized?? - TFS Defect 2734858
                this.typeChoices = [
                    "String",
                    "Integer",
                    "Double",
                    "Boolean",
                    "DateTime",
                    "TimeSpan",
                    "Categorical",
                    "Numeric",
                    "All"
                ];
                // @TODO Needs to be localized?? - TFS Defect 2734858
                this.kindChoices = [
                    "All",
                    "Feature",
                    "Score",
                    "Label"
                ];
                this.hasSchema = ko.observable(schema ? true : false);
                this.hiddenRuleTypes = ko.observableArray([]);
                this.validColumnNamesFromSchema = [];
                if (schema) {
                    this.schemaIsInaccurate = ko.observable(schema.isInaccurate == 2 /* Inaccurate */);
                    this.autocompleteArray = ko.observableArray([]);
                    DataLab.Util.forEach(schema.columnAttributes, function (attribute) {
                        _this.validColumnNamesFromSchema.push(attribute.name);
                        _this.autocompleteArray.push({
                            label: DataLab.Util.encodeAsHtml(attribute.name),
                            value: "\"" + attribute.name + "\"",
                            isInaccurate: attribute.isInaccurate
                        });
                    });
                    // for inaccurate schemas, allow all column types and kinds.  Otherwise limit column types and kinds
                    // based on the schema.
                    if (!this.schemaIsInaccurate()) {
                        this.typeChoices = [ColumnType.All];
                        this.kindChoices = [ColumnKind.All];
                        var hasFeatures;
                        var typeChoicesSet = new DataLab.Util.StringSet();
                        DataLab.Util.forEach(schema.columnAttributes, function (attribute) {
                            typeChoicesSet.unionWith(mapAttributeTypeToColumnTypes(attribute));
                            if (!hasFeatures && attribute.isFeature) {
                                hasFeatures = true;
                            }
                        });
                        this.typeChoices.push.apply(this.typeChoices, typeChoicesSet.toArray());
                        if (hasFeatures) {
                            this.kindChoices.push("Feature");
                        }
                        else {
                            this.hiddenRuleTypes.push(RuleType.Features, RuleType.ExcludeFeatures);
                        }
                        if (Object.keys(schema.scoreColumns).length !== 0) {
                            this.kindChoices.push("Score");
                        }
                        else {
                            this.hiddenRuleTypes.push(RuleType.Scores, RuleType.ExcludeScores);
                        }
                        if (Object.keys(schema.labelColumns).length !== 0) {
                            this.kindChoices.push("Label");
                        }
                        else {
                            this.hiddenRuleTypes.push(RuleType.Labels, RuleType.ExcludeLabels);
                        }
                    }
                }
                this.validateColumns = function (cols) {
                    var validCols = [];
                    var invalidCols = [];
                    validCols = cols.filter(function (colName) {
                        return _this.validColumnNamesFromSchema.indexOf(colName) >= 0;
                    });
                    invalidCols = cols.filter(function (colName) {
                        return _this.validColumnNamesFromSchema.indexOf(colName) === -1;
                    });
                    return {
                        valid: validCols,
                        invalid: invalidCols
                    };
                };
                this.rules = DataLab.Util.Disposable.observableArrayOfDisposables([]);
                this.firstRule = ko.computed(function () {
                    return _this.rules()[0];
                });
                this.allowDuplicates = ko.observable(false);
                this.singleColumnSelection = ko.observable(singleColumnSelection);
                this.startingChoices = ko.observable([RuleType.AllColumns, RuleType.NoColumns]);
                this.startingChoice = ko.observable(RuleType.NoColumns);
                this.startingChoice.subscribe(function () {
                    var isFirstRuleAllColumns = _this.rules().length > 0 && _this.rules()[0].ruleType().id === RuleType.AllColumns.id;
                    if (_this.startingChoice() === RuleType.AllColumns) {
                        if (!isFirstRuleAllColumns) {
                            _this.rules.unshift(new ColumnPickerRule(RuleType.AllColumns, _this, [], [], [], [], schema));
                        }
                    }
                    else if (isFirstRuleAllColumns) {
                        _this.rules.shift();
                    }
                });
                this.firstRule.subscribe(function () {
                    if (_this.firstRule() && RuleType.equals(_this.firstRule().ruleType(), RuleType.AllColumns))
                        _this.startingChoice(RuleType.AllColumns);
                });
                this.allowMultipleRules = ko.computed(function () {
                    return !_this.allowDuplicates() && !_this.singleColumnSelection();
                }, this);
                this.allowDuplicates.subscribe(function () {
                    if (_this.allowDuplicates()) {
                        Shell.Diagnostics.Telemetry.featureUsage(31 /* EnableAllowDuplicates */, 27 /* ColumnPicker */, null, null, null, null);
                        // Change number of rules to 1 keeping only first rule.
                        if (_this.rules().length > 1) {
                            _this.rules.splice(1, _this.rules().length - 1);
                        }
                        if (_this.rules().length > 0 && _this.rules()[0].ruleType().id === RuleType.ColumnNames.id) {
                            // Find any duplicates and move them from invalid to selected columns
                            var position = 0;
                            while (position < _this.firstRule().invalidColumns().length) {
                                if (_this.firstRule().selectedColumns.indexOf(_this.firstRule().invalidColumns()[position]) >= 0) {
                                    _this.firstRule().selectedColumns.push(_this.firstRule().invalidColumns()[position]);
                                    _this.firstRule().invalidColumns.splice(position, 1);
                                    position = position - 1;
                                }
                                position = position + 1;
                            }
                        }
                    }
                    else {
                        Shell.Diagnostics.Telemetry.featureUsage(32 /* DisableAllowDuplicates */, 27 /* ColumnPicker */, null, null, null, null);
                        if (_this.rules().length > 0 && _this.firstRule().ruleType().id === RuleType.ColumnNames.id) {
                            var position = 0;
                            while (position < _this.firstRule().selectedColumns().length) {
                                for (var j = 0; j < position; j++) {
                                    if (_this.firstRule().selectedColumns()[position] === _this.firstRule().selectedColumns()[j]) {
                                        _this.firstRule().invalidColumns.push(_this.firstRule().selectedColumns()[position]);
                                        _this.firstRule().selectedColumns.splice(position, 1);
                                        position = position - 1;
                                    }
                                }
                                position = position + 1;
                            }
                        }
                    }
                    if (_this.rules().length > 0) {
                        _this.firstRule().currentColumn.startValidating();
                        _this.firstRule().currentColumn.validate();
                    }
                });
                try {
                    var rulesJSON = storedRules();
                    if (rulesJSON.length !== 0) {
                        var rulesObject = ColumnPickerViewModel.parseRules(rulesJSON, function (rule, ruleType) {
                            var columnsObject = _this.hasSchema() && ruleType.id === RuleType.ColumnNames.id && rule.columns ? _this.validateColumns(rule.columns) : { valid: rule.columns, invalid: [] };
                            var columnTypes = rule.columnTypes;
                            var columnKinds = rule.columnKinds;
                            _this.rules.push(new ColumnPickerRule(ruleType, _this, columnsObject.valid, columnsObject.invalid, columnTypes, columnKinds, schema));
                        });
                        if (rulesObject.isFilter !== null && rulesObject.isFilter !== undefined) {
                            this.allowDuplicates(!rulesObject.isFilter);
                        }
                    }
                }
                catch (e) {
                    DataLab.Log.exception(e, "Failed to parse column picker rules JSON when attempting ColumnPickerViewModel construction.");
                }
                if (this.rules().length === 0) {
                    this.rules([new ColumnPickerRule(RuleType.ColumnNames, this, [], [], [], [], schema)]);
                    this.allowDuplicates(false);
                }
                // This is a little weird, but we'll only hide the first hidden rule. If user's previously added 
                // rules like "include all columns" as their 3rd rule, we'll continue to show it as their third rule...
                this.visibleRules = ko.computed(function () {
                    if (_this.rules().length > 0 && _this.rules()[0].ruleType().hidden)
                        return _this.rules.slice(1);
                    else
                        return _this.rules();
                });
                this.createNewRule = function (previousRule, isTriggeredByUi) {
                    if (isTriggeredByUi === void 0) { isTriggeredByUi = false; }
                    var newRule = new ColumnPickerRule(RuleType.ColumnIndices, _this, [], [], [], [], schema);
                    if (previousRule) {
                        var previousRuleIndex = _this.rules().indexOf(previousRule);
                        var oldRules = _this.createRulesJSONString();
                        // Typescript isn't finding the right splice definition, so cast to any here
                        _this.rules.splice(previousRuleIndex + 1, 0, newRule);
                    }
                    else {
                        _this.rules.push(newRule);
                    }
                    var newRules = _this.createRulesJSONString();
                    if (isTriggeredByUi) {
                        // Needs to be updated when KnockoutJS 3 comes out to use "arrayChange" observe event on the array.
                        Shell.Diagnostics.Telemetry.featureUsage(28 /* AddRule */, 27 /* ColumnPicker */, null, null, null, JSON.stringify({ oldRules: oldRules, newRules: newRules, insertIndex: previousRuleIndex }));
                    }
                };
                this.removeRule = function (rule) {
                    var oldRules = _this.createRulesJSONString();
                    _this.rules.remove(rule);
                    var newRules = _this.createRulesJSONString();
                    Shell.Diagnostics.Telemetry.featureUsage(29 /* RemoveRule */, 27 /* ColumnPicker */, null, null, null, JSON.stringify({ oldRules: oldRules, newRules: newRules, ruleRemoved: rule }));
                };
                this.createRulesJSONString = function () {
                    return JSON.stringify({ isFilter: !_this.allowDuplicates(), rules: _this.rules() });
                };
                this.saveRulesAndClose = function () {
                    var rulesAsJSON = _this.createRulesJSONString();
                    storedRules(encodeURIComponent(rulesAsJSON));
                    ExperimentEditor.CustomUX.close(_this);
                    Shell.Diagnostics.Telemetry.featureUsage(30 /* CloseColumnPicker */, 27 /* ColumnPicker */, null, null, null, JSON.stringify({ rules: rulesAsJSON }));
                };
                this.hasErrors = ko.computed(function () {
                    var error = false;
                    _this.rules().forEach(function (rule) {
                        if (rule.hasError()) {
                            error = true;
                            return;
                        }
                    });
                    return error;
                }, this);
                // We must take care to not make this infinitely recursive.
                // (Had to cast to <any>... I can't get this.rules to be recognized as an KnockoutSubscribable for some reason)
                this.rules.subscribe(function () {
                    if (_this.rules().length === 0) {
                        _this.createNewRule();
                    }
                    else if (_this.rules().length > 1 && !_this.allowMultipleRules()) {
                        throw new Error(DataLab.LocalizedResources.onlyOneRuleAllowedError);
                    }
                });
            }
            ColumnPickerViewModel.parseRules = function (rules, forEachRuleCallback) {
                var rulesObject = JSON.parse(decodeURIComponent(rules));
                rulesObject.rules.forEach(function (rule) {
                    var ruleType = RuleType.findRule(rule.ruleType, rule.exclude);
                    var columnTypes = rule.columnTypes;
                    var columnKinds = rule.columnKinds;
                    // If necessary, convert RuleType.ColumnTypes.id rules back into RuleType.Features/RuleType.Scores/etc...
                    if (ruleType.id === RuleType.ColumnTypes.id) {
                        var hasNoType = !columnTypes || columnTypes.length === 0 || columnTypes[0] === ColumnType.All;
                        var hasSingleKind = columnKinds && columnKinds.length === 1 && columnKinds[0] !== ColumnKind.All;
                        if (hasSingleKind && hasNoType) {
                            var newRuleType = RuleType.findRule(rule.exclude, columnKinds[0]);
                            rule.ruleType = newRuleType.id;
                            ruleType = newRuleType;
                            rule.columnKinds = columnKinds;
                        }
                    }
                    // Convert ColumnTypes All All => All Columns
                    if (ruleType.id === RuleType.ColumnTypes.id) {
                        if (columnTypes && columnTypes.length === 1 && columnTypes[0] === ColumnType.All && columnKinds && columnKinds.length === 1 && columnKinds[0] === ColumnKind.All) {
                            var newRuleType = RuleType.findRule(RuleType.AllColumns.id, rule.exclude);
                            rule.ruleType = newRuleType.id;
                            ruleType = newRuleType;
                            rule.columnTypes = [];
                            rule.columnKinds = [];
                        }
                    }
                    forEachRuleCallback(rule, ruleType);
                });
                return rulesObject;
            };
            return ColumnPickerViewModel;
        })(DataLab.Util.Disposable);
        ColumnPicker.ColumnPickerViewModel = ColumnPickerViewModel;
    })(ColumnPicker = ExperimentEditor.ColumnPicker || (ExperimentEditor.ColumnPicker = {}));
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
/// <reference path="ColumnPickerViewModel.ts" />
/// <reference path="CustomUX.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var ExperimentEditor;
(function (ExperimentEditor) {
    var ColumnPicker;
    (function (ColumnPicker) {
        // Need this for mapping json id to the friendly display name
        var RuleTypeLegacy = (function () {
            function RuleTypeLegacy() {
            }
            RuleTypeLegacy.findRule = function (id, exclude) {
                if (exclude) {
                    if (id === RuleTypeLegacy.ColumnNames.id)
                        return RuleTypeLegacy.ExcludeColumnNames;
                    if (id === RuleTypeLegacy.ColumnIndices.id)
                        return RuleTypeLegacy.ExcludeColumnIndices;
                    if (id === RuleTypeLegacy.ColumnTypes.id)
                        return RuleTypeLegacy.ExcludeColumnTypes;
                }
                else {
                    if (id === RuleTypeLegacy.ColumnNames.id)
                        return RuleTypeLegacy.ColumnNames;
                    if (id === RuleTypeLegacy.ColumnIndices.id)
                        return RuleTypeLegacy.ColumnIndices;
                    if (id === RuleTypeLegacy.ColumnTypes.id)
                        return RuleTypeLegacy.ColumnTypes;
                }
                return RuleTypeLegacy.AllColumns;
            };
            RuleTypeLegacy.ColumnNames = { id: "ColumnNames", name: "Column names", exclude: false };
            RuleTypeLegacy.ColumnIndices = { id: "ColumnIndexes", name: "Column indices", exclude: false };
            RuleTypeLegacy.ColumnTypes = { id: "ColumnTypes", name: "Column types", exclude: false };
            RuleTypeLegacy.AllColumns = { id: "AllColumns", name: "All columns", exclude: false };
            RuleTypeLegacy.ExcludeColumnNames = { id: "ColumnNames", name: "Exclude column names", exclude: true };
            RuleTypeLegacy.ExcludeColumnIndices = { id: "ColumnIndexes", name: "Exclude column indices", exclude: true };
            RuleTypeLegacy.ExcludeColumnTypes = { id: "ColumnTypes", name: "Exclude column types", exclude: true };
            return RuleTypeLegacy;
        })();
        ColumnPicker.RuleTypeLegacy = RuleTypeLegacy;
        var ColumnType = (function () {
            function ColumnType() {
            }
            ColumnType.String = "String";
            ColumnType.Integer = "Integer";
            ColumnType.Double = "Double";
            ColumnType.Boolean = "Boolean";
            ColumnType.DateTime = "DateTime";
            ColumnType.TimeSpan = "TimeSpan";
            ColumnType.Categorical = "Categorical";
            ColumnType.Numeric = "Numeric";
            ColumnType.All = "All";
            return ColumnType;
        })();
        var ColumnKind = (function () {
            function ColumnKind() {
            }
            ColumnKind.All = "All";
            ColumnKind.Feature = "Feature";
            ColumnKind.Score = "Score";
            ColumnKind.Label = "Label";
            return ColumnKind;
        })();
        var RuleOptions = (function () {
            function RuleOptions(exclude, first) {
                this.exclude = exclude;
                this.first = first;
            }
            return RuleOptions;
        })();
        ColumnPicker.RuleOptions = RuleOptions;
        var ColumnPickerRuleLegacy = (function () {
            function ColumnPickerRuleLegacy(ruleType, columnTypesDefault, columnKindsDefault, firstRule, columns, invalidColumns, columnTypes, columnKinds, allowDuplicates) {
                var _this = this;
                if (columns === void 0) { columns = []; }
                if (invalidColumns === void 0) { invalidColumns = []; }
                if (columnTypes === void 0) { columnTypes = []; }
                if (columnKinds === void 0) { columnKinds = []; }
                if (allowDuplicates === void 0) { allowDuplicates = null; }
                this.ruleType = ko.observable(ruleType);
                this.oldRuleTypeId = ruleType.id;
                this.selectedColumns = ko.observableArray(columns);
                this.invalidColumns = ko.observableArray(invalidColumns);
                this.columnTypes = ko.observableArray(columnTypes);
                this.columnKinds = ko.observableArray(columnKinds);
                this.hasRuleTypeError = ko.observable(false);
                this.hasIndexRuleError = ko.observable(false);
                this.hasNameRuleError = ko.observable(false);
                this.hasError = ko.computed(function () {
                    return _this.hasRuleTypeError() || _this.hasIndexRuleError() || _this.hasNameRuleError();
                }, this);
                this.allowDuplicates = ko.computed(function () {
                    return allowDuplicates === null ? false : allowDuplicates();
                }, this);
                this.nameInputFocused = ko.observable(false);
                this.setNameInputFocused = (function () {
                    _this.nameInputFocused(true);
                });
                this.columnIndexRegExp = new RegExp('^\\s*(-?\\d+)\\s*$');
                this.columnRangeRegExp = new RegExp('^\\s*(\\d+)\\s*-\\s*(\\d+)\\s*$');
                this.validateIndices = function (inputValue) {
                    var indexArr = _this.indexList().split(',');
                    var error;
                    indexArr.forEach(function (indexStr) {
                        if (_this.columnIndexRegExp.test(indexStr)) {
                            var value = (_this.columnIndexRegExp.exec(indexStr)[1]);
                            if (Number(value) <= 0) {
                                error = DataLab.LocalizedResources.columnPickerIndicesMustBeGreaterThan;
                                return;
                            }
                        }
                        else if (_this.columnRangeRegExp.test(indexStr)) {
                            var regexpMatch = _this.columnRangeRegExp.exec(indexStr);
                            if (Number(regexpMatch[1]) <= 0 || Number(regexpMatch[2]) <= 0 || Number(regexpMatch[2]) < Number(regexpMatch[1])) {
                                error = DataLab.LocalizedResources.columnPickerInvalidRange;
                                return;
                            }
                        }
                        else {
                            error = DataLab.LocalizedResources.columnPickerInputMustBeAListOfPositiveIndicesOrRanges;
                            return;
                        }
                    });
                    error ? _this.hasIndexRuleError(true) : _this.hasIndexRuleError(false);
                    return error;
                };
                var indexListValue = this.ruleType().id === RuleTypeLegacy.ColumnIndices.id ? columns.join(",") : "";
                this.indexList = DataLab.Validation.validatableObservable(indexListValue, this.validateIndices);
                if (this.ruleType().id === RuleTypeLegacy.ColumnIndices.id) {
                    this.indexList.startValidating();
                    this.indexList.validate();
                }
                this.validateRuleType = function (inputValue) {
                    var error;
                    if (_this.firstRule() && _this.allowDuplicates() && (_this.ruleType().exclude || !(_this.ruleType().id === RuleTypeLegacy.ColumnNames.id || _this.ruleType().id === RuleTypeLegacy.ColumnIndices.id))) {
                        error = DataLab.LocalizedResources.columnPickerSelectionRules;
                    }
                    if (_this.firstRule() && _this.ruleType().exclude) {
                        error = DataLab.LocalizedResources.columnPickerFirstRuleNoExlude;
                    }
                    error ? _this.hasRuleTypeError(true) : _this.hasRuleTypeError(false);
                    return error;
                };
                this.firstRule = DataLab.Validation.validatableObservable(firstRule, this.validateRuleType);
                this.firstRule.startValidating();
                this.firstRule.validate();
                this.ruleChoicesObservable = ko.observableArray([
                    new RuleOptions(RuleTypeLegacy.AllColumns.exclude, this.firstRule),
                    new RuleOptions(RuleTypeLegacy.ColumnTypes.exclude, this.firstRule),
                    new RuleOptions(RuleTypeLegacy.ColumnNames.exclude, this.firstRule),
                    new RuleOptions(RuleTypeLegacy.ColumnIndices.exclude, this.firstRule),
                    new RuleOptions(RuleTypeLegacy.ExcludeColumnTypes.exclude, this.firstRule),
                    new RuleOptions(RuleTypeLegacy.ExcludeColumnNames.exclude, this.firstRule),
                    new RuleOptions(RuleTypeLegacy.ExcludeColumnIndices.exclude, this.firstRule)
                ]);
                this.validateNamesSelection = function (inputValue) {
                    var error;
                    if (_this.selectedColumns().length === 0) {
                        error = DataLab.LocalizedResources.columnPickerInputMultipleNamesList;
                    }
                    if (_this.invalidColumns().length > 0) {
                        error = DataLab.LocalizedResources.columnPickerInvalidNames;
                    }
                    error ? _this.hasNameRuleError(true) : _this.hasNameRuleError(false);
                    return error;
                };
                // The column currently being typed by the user in the input box.
                this.currentColumn = DataLab.Validation.validatableObservable("", this.validateNamesSelection);
                if (this.ruleType().id === RuleTypeLegacy.ColumnNames.id) {
                    this.currentColumn.startValidating();
                    this.currentColumn.validate();
                }
                this.currentColumn.subscribe(function () {
                    if (_this.currentColumn() !== "") {
                        var names = DataLab.Util.Str.getArrayFromCommaSeparatedString(_this.currentColumn());
                        names.forEach(function (trimmedName) {
                            if (trimmedName !== "") {
                                if (_this.selectedColumns().indexOf(trimmedName) === -1 || _this.allowDuplicates()) {
                                    _this.selectedColumns.push(trimmedName);
                                }
                                else {
                                    _this.invalidColumns.push(trimmedName);
                                }
                            }
                        });
                    }
                    _this.currentColumn.startValidating();
                    _this.currentColumn.validate();
                    // Clear the input
                    _this.currentColumn("");
                });
                this.allowDuplicates.subscribe(function () {
                    _this.firstRule.startValidating();
                    _this.firstRule.validate();
                });
                // Clear selections when rule id changes
                // Set the default values of column types and kinds when rule changes to a type rule.
                this.ruleType.subscribe(function () {
                    _this.firstRule.startValidating();
                    _this.firstRule.validate();
                    if (_this.oldRuleTypeId !== _this.ruleType().id) {
                        _this.hasIndexRuleError(false);
                        _this.hasNameRuleError(false);
                        _this.selectedColumns.removeAll();
                        _this.invalidColumns.removeAll();
                        if (_this.ruleType().id === RuleTypeLegacy.ColumnNames.id) {
                            _this.currentColumn("");
                            _this.currentColumn.startValidating();
                            _this.currentColumn.validate();
                        }
                        if (_this.ruleType().id === RuleTypeLegacy.ColumnIndices.id) {
                            _this.indexList("");
                            _this.indexList.startValidating();
                            _this.indexList.validate();
                        }
                        if (_this.ruleType().id === RuleTypeLegacy.ColumnTypes.id) {
                            _this.columnTypes(columnTypesDefault);
                            _this.columnKinds(columnKindsDefault);
                        }
                        _this.oldRuleTypeId = _this.ruleType().id;
                    }
                });
                this.removeColumnName = function (columnName) {
                    _this.selectedColumns.remove(columnName);
                    _this.currentColumn.startValidating();
                    _this.currentColumn.validate();
                    Shell.Diagnostics.Telemetry.customEvent("RemoveColumnName", "ColumnPicker", JSON.stringify({ columns: columnName }));
                };
                this.removeInvalidColumnName = function (columnName) {
                    _this.invalidColumns.remove(columnName);
                    _this.currentColumn.startValidating();
                    _this.currentColumn.validate();
                    Shell.Diagnostics.Telemetry.customEvent("RemoveColumnNameInvalid", "ColumnPicker", JSON.stringify({ columns: columnName }));
                };
                this.indexList.subscribe(function () {
                    _this.selectedColumns.removeAll();
                    if (_this.indexList() !== "") {
                        var indexArr = _this.indexList().split(',');
                        // Verify it's a single index or a range
                        indexArr.forEach(function (indexStr) {
                            if (_this.columnIndexRegExp.test(indexStr)) {
                                _this.selectedColumns.push(_this.columnIndexRegExp.exec(indexStr)[1]);
                            }
                            else if (_this.columnRangeRegExp.test(indexStr)) {
                                var regexpMatch = _this.columnRangeRegExp.exec(indexStr);
                                _this.selectedColumns.push(regexpMatch[1] + "-" + regexpMatch[2]);
                            }
                        });
                    }
                });
            }
            return ColumnPickerRuleLegacy;
        })();
        ColumnPicker.ColumnPickerRuleLegacy = ColumnPickerRuleLegacy;
        var ColumnPickerViewModelLegacy = (function (_super) {
            __extends(ColumnPickerViewModelLegacy, _super);
            function ColumnPickerViewModelLegacy(storedRules, singleColumnSelection, schema) {
                var _this = this;
                _super.call(this);
                this.typeChoices = [
                    "String",
                    "Integer",
                    "Double",
                    "Boolean",
                    "DateTime",
                    "TimeSpan",
                    "Categorical",
                    "Numeric",
                    "All"
                ];
                this.kindChoices = [
                    "All",
                    "Feature",
                    "Score",
                    "Label"
                ];
                this.hasSchema = ko.observable(schema ? true : false);
                this.validColumnNamesFromSchema = [];
                if (schema) {
                    this.autocompleteArray = ko.observableArray([]);
                    this.typeChoices = ["All"];
                    this.kindChoices = ["All"];
                    var hasFeatures;
                    DataLab.Util.forEach(schema.columnAttributes, function (attribute) {
                        _this.validColumnNamesFromSchema.push(attribute.name);
                        if (_this.typeChoices.indexOf(attribute.type) === -1) {
                            _this.typeChoices.push(attribute.type);
                        }
                        if (!hasFeatures && attribute.isFeature) {
                            hasFeatures = true;
                        }
                        _this.autocompleteArray.push(attribute.name);
                    });
                    if (hasFeatures) {
                        this.kindChoices.push("Feature");
                    }
                    if (Object.keys(schema.scoreColumns).length !== 0) {
                        this.kindChoices.push("Score");
                    }
                    if (Object.keys(schema.labelColumns).length !== 0) {
                        this.kindChoices.push("Label");
                    }
                }
                var defaultColumnTypes = [this.typeChoices[0]];
                var defaultColumnKinds = [this.kindChoices[0]];
                this.validateColumns = function (cols) {
                    var validCols = [];
                    var invalidCols = [];
                    validCols = cols.filter(function (colName) {
                        return _this.validColumnNamesFromSchema.indexOf(colName) >= 0;
                    });
                    invalidCols = cols.filter(function (colName) {
                        return _this.validColumnNamesFromSchema.indexOf(colName) === -1;
                    });
                    return {
                        valid: validCols,
                        invalid: invalidCols
                    };
                };
                this.rules = ko.observableArray([]);
                this.allowDuplicates = ko.observable(false);
                this.singleColumnSelection = ko.observable(singleColumnSelection);
                this.allowMultipleRules = ko.computed(function () {
                    return !_this.allowDuplicates() && !_this.singleColumnSelection();
                }, this);
                this.ruleChoices = ko.computed(function () {
                    var choices = ColumnPickerViewModelLegacy.allRuleChoicesAndUIConstraints.filter(function (choice) {
                        if (_this.singleColumnSelection() && !choice.inSingleColumnMode)
                            return false;
                        else if (_this.allowDuplicates() && !choice.inAllowDuplicatesMode)
                            return false;
                        return true;
                    });
                    return choices.map(function (choice) {
                        return choice.ruleIdentifier;
                    });
                }, this);
                try {
                    var rulesObject = JSON.parse(decodeURIComponent(storedRules()));
                    if (rulesObject.isFilter !== null && rulesObject.isFilter !== undefined) {
                        this.allowDuplicates(!rulesObject.isFilter);
                    }
                    rulesObject.rules.forEach(function (rule) {
                        var ruleType = RuleTypeLegacy.findRule(rule.ruleType, rule.exclude);
                        var columnsObject = _this.hasSchema() && ruleType.id === RuleTypeLegacy.ColumnNames.id && rule.columns ? _this.validateColumns(rule.columns) : { valid: rule.columns, invalid: [] };
                        var columnTypes = rule.columnTypes;
                        var columnKinds = rule.columnKinds;
                        _this.rules.push(new ColumnPickerRuleLegacy(ruleType, defaultColumnTypes, defaultColumnKinds, _this.rules().length === 0 ? true : false, columnsObject.valid, columnsObject.invalid, columnTypes, columnKinds, _this.allowDuplicates));
                    });
                }
                catch (e) {
                    this.allowDuplicates(false);
                    this.rules = ko.observableArray([new ColumnPickerRuleLegacy(RuleTypeLegacy.AllColumns, defaultColumnTypes, defaultColumnKinds, true, [], [], [], [], this.allowDuplicates)]);
                }
                this.addRule = function (previousRule) {
                    if (!_this.allowMultipleRules())
                        throw new Error(DataLab.LocalizedResources.onlyOneRuleAllowedError);
                    var previousRuleIndex = _this.rules.indexOf(previousRule);
                    var oldRules = _this.createRulesJSONString();
                    // Typescript isn't finding the right splice definition, so cast to any here
                    _this.rules.splice(previousRuleIndex + 1, 0, new ColumnPickerRuleLegacy(RuleTypeLegacy.ColumnIndices, defaultColumnTypes, defaultColumnKinds, _this.rules().length === 0 ? true : false, [], [], [], [], _this.allowDuplicates));
                    var newRules = _this.createRulesJSONString();
                    Shell.Diagnostics.Telemetry.customEvent("AddRule", "ColumnPicker", JSON.stringify({ oldRules: oldRules, newRules: newRules, insertIndex: previousRuleIndex }));
                };
                this.removeRule = function (rule) {
                    var oldRules = _this.createRulesJSONString();
                    _this.rules.remove(rule);
                    _this.rules()[0].firstRule(true);
                    var newRules = _this.createRulesJSONString();
                    Shell.Diagnostics.Telemetry.customEvent("RemoveRule", "ColumnPicker", JSON.stringify({ oldRules: oldRules, newRules: newRules, ruleRemoved: rule }));
                };
                this.createRulesJSONString = function () {
                    var rules = [];
                    _this.rules().forEach(function (rule) {
                        rules.push({
                            ruleType: rule.ruleType().id,
                            columns: (function (rule, ruleId) {
                                if (ruleId === RuleTypeLegacy.ColumnNames.id || ruleId === RuleTypeLegacy.ColumnIndices.id) {
                                    return rule.selectedColumns();
                                }
                                else
                                    return undefined;
                            })(rule, rule.ruleType().id),
                            exclude: rule.ruleType().exclude,
                            columnTypes: rule.ruleType().id === RuleTypeLegacy.ColumnTypes.id ? rule.columnTypes() : undefined,
                            columnKinds: rule.ruleType().id === RuleTypeLegacy.ColumnTypes.id ? rule.columnKinds() : undefined,
                        });
                    });
                    return JSON.stringify({ isFilter: !_this.allowDuplicates(), rules: rules });
                };
                this.saveRulesAndClose = function () {
                    var rulesAsJSON = _this.createRulesJSONString();
                    storedRules(encodeURIComponent(rulesAsJSON));
                    ExperimentEditor.CustomUX.close(_this);
                    Shell.Diagnostics.Telemetry.customEvent("Close", "ColumnPicker", rulesAsJSON);
                };
                this.hasErrors = ko.computed(function () {
                    var error = false;
                    _this.rules().forEach(function (rule) {
                        if (rule.hasError()) {
                            error = true;
                            return;
                        }
                    });
                    return error;
                }, this);
                this.allowDuplicates.subscribe(function () {
                    if (_this.allowDuplicates()) {
                        // Change number of rules to 1 keeping only first rule.
                        if (_this.rules().length > 1) {
                            _this.rules.splice(1, _this.rules().length - 1);
                        }
                        if (_this.rules()[0].ruleType().id === RuleTypeLegacy.ColumnNames.id) {
                            // Find any duplicates and move them from invalid to selected columns
                            var position = 0;
                            while (position < _this.rules()[0].invalidColumns().length) {
                                if (_this.rules()[0].selectedColumns.indexOf(_this.rules()[0].invalidColumns()[position]) >= 0) {
                                    _this.rules()[0].selectedColumns.push(_this.rules()[0].invalidColumns()[position]);
                                    _this.rules()[0].invalidColumns.splice(position, 1);
                                    position = position - 1;
                                }
                                position = position + 1;
                            }
                        }
                    }
                    else {
                        if (_this.rules()[0].ruleType().id === RuleTypeLegacy.ColumnNames.id) {
                            var position = 0;
                            while (position < _this.rules()[0].selectedColumns().length) {
                                for (var j = 0; j < position; j++) {
                                    if (_this.rules()[0].selectedColumns()[position] === _this.rules()[0].selectedColumns()[j]) {
                                        _this.rules()[0].invalidColumns.push(_this.rules()[0].selectedColumns()[position]);
                                        _this.rules()[0].selectedColumns.splice(position, 1);
                                        position = position - 1;
                                    }
                                }
                                position = position + 1;
                            }
                        }
                    }
                    _this.rules()[0].currentColumn.startValidating();
                    _this.rules()[0].currentColumn.validate();
                });
            }
            ColumnPickerViewModelLegacy.allRuleChoicesAndUIConstraints = [
                { ruleIdentifier: RuleTypeLegacy.AllColumns, inSingleColumnMode: false, inAllowDuplicatesMode: false },
                { ruleIdentifier: RuleTypeLegacy.ColumnTypes, inSingleColumnMode: true, inAllowDuplicatesMode: false },
                { ruleIdentifier: RuleTypeLegacy.ColumnNames, inSingleColumnMode: true, inAllowDuplicatesMode: true },
                { ruleIdentifier: RuleTypeLegacy.ColumnIndices, inSingleColumnMode: true, inAllowDuplicatesMode: true },
                { ruleIdentifier: RuleTypeLegacy.ExcludeColumnTypes, inSingleColumnMode: false, inAllowDuplicatesMode: false },
                { ruleIdentifier: RuleTypeLegacy.ExcludeColumnNames, inSingleColumnMode: false, inAllowDuplicatesMode: false },
                { ruleIdentifier: RuleTypeLegacy.ExcludeColumnIndices, inSingleColumnMode: false, inAllowDuplicatesMode: false },
            ];
            return ColumnPickerViewModelLegacy;
        })(DataLab.Util.Disposable);
        ColumnPicker.ColumnPickerViewModelLegacy = ColumnPickerViewModelLegacy;
    })(ColumnPicker = ExperimentEditor.ColumnPicker || (ExperimentEditor.ColumnPicker = {}));
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
/// <reference path="CustomUX.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var ExperimentEditor;
(function (ExperimentEditor) {
    var ModuleError;
    (function (ModuleError) {
        var ModuleErrorViewModel = (function (_super) {
            __extends(ModuleErrorViewModel, _super);
            function ModuleErrorViewModel(errorText, moduleName, moduleID) {
                var _this = this;
                _super.call(this);
                this.errorInfo = ko.observable(new DataLab.Model.ErrorLogInfo());
                this.errorInfo().updateErrorLogInfo(errorText, moduleName, moduleID);
                this.errorHelpLink = ko.observable("");
                this.errorLinkLabel = ko.observable("");
                this.dialogHeading = moduleName + DataLab.LocalizedResources.moduleErrorTitle;
                // Check if message begins with Error ID.
                if (this.errorInfo().errorId() !== "") {
                    this.errorLinkLabel(DataLab.LocalizedResources.moduleErrorHelpLink + this.errorInfo().errorId());
                    this.errorHelpLink(ExperimentEditor.Constants.errorHelpLinkGuidStart + this.errorInfo().errorId() + ExperimentEditor.Constants.errorHelpLinkGuidEnd);
                }
                this.launchErrorHelp = function () {
                    ExperimentEditor.Help.openHelpWindow(_this.errorHelpLink());
                };
            }
            return ModuleErrorViewModel;
        })(DataLab.Util.Disposable);
        ModuleError.ModuleErrorViewModel = ModuleErrorViewModel;
    })(ModuleError = ExperimentEditor.ModuleError || (ExperimentEditor.ModuleError = {}));
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
/// <reference path="../../View/CustomBindingHandlers/Monaco.ts" />
/// <reference path="../../Common/EntityDataDownloader.ts" />
/// <reference path="../../../TypescriptResources.ts" />
/// <reference path="../ExperimentEditor/ColumnPickerViewModel.ts" />
/// <reference path="../ExperimentEditor/ColumnPickerViewModelLegacy.ts" />
/// <reference path="../ExperimentEditor/ModuleErrorViewModel.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var ExperimentEditor;
(function (ExperimentEditor) {
    (function (PropertyItemType) {
        PropertyItemType[PropertyItemType["Textbox"] = 0] = "Textbox";
        PropertyItemType[PropertyItemType["Checkbox"] = 1] = "Checkbox";
        PropertyItemType[PropertyItemType["Textarea"] = 2] = "Textarea";
        PropertyItemType[PropertyItemType["Select"] = 3] = "Select";
        PropertyItemType[PropertyItemType["Link"] = 4] = "Link";
        PropertyItemType[PropertyItemType["Button"] = 5] = "Button";
        PropertyItemType[PropertyItemType["Credential"] = 6] = "Credential";
        PropertyItemType[PropertyItemType["ColumnPicker"] = 7] = "ColumnPicker";
        PropertyItemType[PropertyItemType["ParameterRange"] = 8] = "ParameterRange";
        PropertyItemType[PropertyItemType["EditableText"] = 9] = "EditableText";
        PropertyItemType[PropertyItemType["MultiSelect"] = 10] = "MultiSelect";
    })(ExperimentEditor.PropertyItemType || (ExperimentEditor.PropertyItemType = {}));
    var PropertyItemType = ExperimentEditor.PropertyItemType;
    var PropertyViewModel = (function () {
        /**
          * @constructor
          * THIS CLASS IS ABSTRACT. DO NOT INSTANTIATE IT.
         **/
        function PropertyViewModel(property) {
            this.childParameters = ko.observableArray();
            this.property = property;
            this.isStaticContent = ko.observable(false);
            this.type = null;
            this.currentError = ko.observable("");
            this._isExperimentLevel = ko.observable(property instanceof DataLab.Model.WebServiceParameter);
            var isModeParameter = property instanceof DataLab.Model.ModuleNodeParameter && property.descriptor instanceof DataLab.Model.ModeModuleParameterDescriptor;
            this.isLinkable = !isModeParameter;
            this.focus = ko.observable(false);
            this.templateType = function () {
                throw new Error("PropertyViewModel is abstract.");
            };
            this.linkedParameterName = ko.computed(function () {
                if (property instanceof DataLab.Model.ModuleNodeParameter) {
                    var linkedParameter = property.linkedWebServiceParameter();
                    if (linkedParameter) {
                        return linkedParameter.name;
                    }
                }
                return "";
            });
        }
        Object.defineProperty(PropertyViewModel.prototype, "isDisabled", {
            get: function () {
                throw new Error("PropertyViewModel is abstract.");
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PropertyViewModel.prototype, "isExperimentLevel", {
            get: function () {
                return this._isExperimentLevel;
            },
            enumerable: true,
            configurable: true
        });
        PropertyViewModel.experimentPropertyFactory = function (property) {
            if (property instanceof DataLab.Model.LinkProperty) {
                return new LinkPropertyViewModel(property);
            }
            else if (property instanceof DataLab.Model.StaticProperty) {
                return new StaticTextPropertyViewModel(property);
            }
            else if (property instanceof DataLab.Model.BooleanProperty) {
                return new CheckboxPropertyViewModel(property);
            }
            else {
                throw new Error("Unexpected property type on experiment");
            }
        };
        return PropertyViewModel;
    })();
    ExperimentEditor.PropertyViewModel = PropertyViewModel;
    var ParameterViewModel = (function (_super) {
        __extends(ParameterViewModel, _super);
        /**
          * @constructor
          * View model for editable parameters.
          * This class must be instantiated through the Factory method createParameterViewModel.
         **/
        function ParameterViewModel(property, workspace) {
            var _this = this;
            _super.call(this, property);
            this.autocompleteArray = property.autocompleteArray;
            if (property.descriptor instanceof DataLab.Model.BooleanModuleParameterDescriptor) {
                this.type = 1 /* Checkbox */;
            }
            else if (property.descriptor instanceof DataLab.Model.MultiChoiceModuleParameterDescriptor) {
                this.type = 10 /* MultiSelect */;
            }
            else if (property.descriptor instanceof DataLab.Model.ChoiceModuleParameterDescriptor) {
                this.type = 3 /* Select */;
                if (property.descriptor instanceof DataLab.Model.ModeModuleParameterDescriptor) {
                    if (property.childParameters) {
                        DataLab.Util.forEach(property.childParameters, function (value) {
                            DataLab.Util.forEach(value, function (childParameter) {
                                _this.childParameters.push(ParameterViewModel.createParameterViewModel(childParameter, workspace));
                            });
                        });
                    }
                }
            }
            else if (property.descriptor instanceof DataLab.Model.ScriptModuleParameterDescriptor) {
                if (!(this instanceof ExperimentEditor.MonacoParameterViewModel)) {
                    throw new Error("Attempted to instantiate PropertyViewModel for Script directly. Use factory method createParameterViewModel instead.");
                }
                this.type = 2 /* Textarea */;
            }
            else if (property.descriptor instanceof DataLab.Model.CredentialModuleParameterDescriptor) {
                this.type = 6 /* Credential */;
            }
            else if (property.descriptor instanceof DataLab.Model.ColumnPickerModuleParameterDescriptor) {
                this.type = 7 /* ColumnPicker */;
            }
            else if (property.descriptor instanceof DataLab.Model.ParameterRangeModuleParameterDescriptor) {
                this.type = 8 /* ParameterRange */;
            }
            else {
                this.type = 0 /* Textbox */;
            }
            this.linkClass = ko.computed(function () {
                var linkStatusClass = _this.property.isLinked() ? "parameterIsLinked " : "parameterIsNotLinked ";
                return linkStatusClass + "linkStatus propertyEditorButton";
            });
            this._isDisabled = ko.computed(function () {
                return false;
            });
            this.templateType = function () {
                switch (_this.type) {
                    case 1 /* Checkbox */:
                        return "checkboxParameter";
                    case 3 /* Select */:
                        return "selectParameter";
                    case 2 /* Textarea */:
                        return "textAreaParameter";
                    case 0 /* Textbox */:
                        return "inputParameter";
                    case 6 /* Credential */:
                        return "credentialParameter";
                    case 7 /* ColumnPicker */:
                        return "columnPickerParameter";
                    case 8 /* ParameterRange */:
                        return "parameterRangeParameter";
                    case 10 /* MultiSelect */:
                        return "multiSelectParameter";
                }
            };
        }
        /**
         * Factory Method returning the correct ParameterViewModel
        **/
        ParameterViewModel.createParameterViewModel = function (property, workspace) {
            if (property.descriptor instanceof DataLab.Model.ScriptModuleParameterDescriptor) {
                return new MonacoParameterViewModel(property, workspace);
            }
            else if (property.descriptor instanceof DataLab.Model.ColumnPickerModuleParameterDescriptor) {
                return new ColumnPickerParameterViewModel(property, workspace);
            }
            else if (property.descriptor instanceof DataLab.Model.ParameterRangeModuleParameterDescriptor) {
                return ParameterRangeViewModel.createParameterRangeViewModel(property, workspace);
            }
            else if (property.descriptor instanceof DataLab.Model.MultiChoiceModuleParameterDescriptor) {
                return new EnumSweepViewModel(property, workspace);
            }
            else {
                return new ParameterViewModel(property, workspace);
            }
        };
        Object.defineProperty(ParameterViewModel.prototype, "isDisabled", {
            get: function () {
                return this._isDisabled;
            },
            enumerable: true,
            configurable: true
        });
        ParameterViewModel.prototype.validate = function () {
            var parameter = this.property;
            return parameter.validate();
        };
        return ParameterViewModel;
    })(PropertyViewModel);
    ExperimentEditor.ParameterViewModel = ParameterViewModel;
    var ColumnPickerParameterViewModel = (function (_super) {
        __extends(ColumnPickerParameterViewModel, _super);
        function ColumnPickerParameterViewModel(property, workspace) {
            var _this = this;
            _super.call(this, property, workspace);
            this.isLinkable = false;
            this.launchDisabled = ko.observable(false);
            var descriptor = property.descriptor;
            // if there is a default value specified and none were saved using column picker yet we need to create rules string from the defaultValue string
            // property.value() will hold the defaultValue string and 
            // its decodeURIComponent() will not be a serialized JSON string -- first character will not be a '{' or '['.
            var decodedPropertyValue = decodeURIComponent(property.value());
            if (decodedPropertyValue[0] !== '{' && decodedPropertyValue[0] !== '[' && property.descriptor.defaultValue && property.descriptor.defaultValue !== "") {
                var columnPickerViewModelInstance;
                if (DataLab.Features.columnPickerRulesRedesignEnabled()) {
                    columnPickerViewModelInstance = new ExperimentEditor.ColumnPicker.ColumnPickerViewModel(property.value, descriptor.singleColumnSelection);
                }
                else {
                    columnPickerViewModelInstance = new ExperimentEditor.ColumnPicker.ColumnPickerViewModelLegacy(property.value, descriptor.singleColumnSelection);
                }
                var newRulesToSet = [];
                // remove all default rules that get created by the constructor of ColumnPickerViewModel
                columnPickerViewModelInstance.rules.removeAll();
                var defaultSelections = property.descriptor.defaultValue.split('|');
                defaultSelections.forEach(function (columnType) {
                    var selections = columnType.trim().replace(/([A-Z])/g, ",$1").split(",").slice(1);
                    if (selections.length === 1) {
                        if (selections[0] === "All") {
                            if (DataLab.Features.columnPickerRulesRedesignEnabled()) {
                                newRulesToSet.push(new ExperimentEditor.ColumnPicker.ColumnPickerRule(ExperimentEditor.ColumnPicker.RuleType.AllColumns, columnPickerViewModelInstance));
                            }
                            else {
                                columnPickerViewModelInstance.rules.push(new ExperimentEditor.ColumnPicker.ColumnPickerRuleLegacy(ExperimentEditor.ColumnPicker.RuleType.AllColumns, [], [], true));
                            }
                        }
                    }
                    else {
                        if (DataLab.Features.columnPickerRulesRedesignEnabled()) {
                            newRulesToSet.push(new ExperimentEditor.ColumnPicker.ColumnPickerRule(ExperimentEditor.ColumnPicker.RuleType.ColumnTypes, columnPickerViewModelInstance, [], [], [selections[0]], [selections[1]]));
                        }
                        else {
                            columnPickerViewModelInstance.rules.push(new ExperimentEditor.ColumnPicker.ColumnPickerRuleLegacy(ExperimentEditor.ColumnPicker.RuleType.ColumnTypes, [], [], true, [], [], [selections[0]], [selections[1]]));
                        }
                    }
                });
                if (newRulesToSet.length > 0) {
                    // With the new picker, we do this all at the end. That's because removeAll() doesn't 
                    // actually remove all the existing rules, as the new picker enforces that there be at 
                    // least one rule. So now we gather up all the new rules and swap out the existing rules 
                    // with the new rules, avoiding that issue completely.
                    columnPickerViewModelInstance.rules(newRulesToSet);
                    newRulesToSet = [];
                }
                if (columnPickerViewModelInstance.rules().length > 0) {
                    property.value(columnPickerViewModelInstance.createRulesJSONString());
                }
                columnPickerViewModelInstance.dispose();
            }
            this.openColumnPicker = function () {
                _this.launchDisabled(true);
                Shell.UI.Spinner.show();
                function MakeColumnPicker(schema) {
                    Shell.UI.Spinner.hide();
                    var viewModel, markup;
                    if (DataLab.Features.columnPickerRulesRedesignEnabled()) {
                        viewModel = new ExperimentEditor.ColumnPicker.ColumnPickerViewModel(property.value, descriptor.singleColumnSelection, schema);
                        markup = ExperimentEditor._columnPickerMarkup;
                    }
                    else {
                        viewModel = new ExperimentEditor.ColumnPicker.ColumnPickerViewModelLegacy(property.value, descriptor.singleColumnSelection, schema);
                        markup = ExperimentEditor._columnPickerLegacyMarkup;
                    }
                    ExperimentEditor.CustomUX.open(markup, viewModel, "350px", "710px");
                }
                // experiment level parameters do not have a parent. There will be no schema for these parameters.
                var columnPickerPort = null;
                var connectedPort = null;
                if (property.parent) {
                    columnPickerPort = property.parent.ports[descriptor.columnPickerFor];
                    connectedPort = columnPickerPort.connectedOutputPort;
                }
                var schemaPromise = DataLab.Util.when(null);
                if (DataLab.Features.schemaPropagationEnabled()) {
                    if (columnPickerPort) {
                        schemaPromise = DataLab.Model.computeSchemaOfInputPort(workspace, columnPickerPort);
                    }
                }
                else if (connectedPort && connectedPort.schemaEndpoint) {
                    if (connectedPort.parent instanceof DataLab.Model.DatasetNode) {
                        schemaPromise = workspace.getDatasetSchema(connectedPort.parent.dataset.id);
                    }
                    else if (connectedPort.parent instanceof DataLab.Model.ModuleNode) {
                        schemaPromise = workspace.getModuleOutputSchema(connectedPort.parent.executedExperimentId, connectedPort.parent.id, connectedPort.name);
                    }
                }
                schemaPromise.done(function (schema) {
                    MakeColumnPicker(schema);
                }).fail(function (error) {
                    MakeColumnPicker();
                }).always(function () {
                    _this.launchDisabled(false);
                });
            };
        }
        return ColumnPickerParameterViewModel;
    })(ParameterViewModel);
    ExperimentEditor.ColumnPickerParameterViewModel = ColumnPickerParameterViewModel;
    var ParameterRangeViewModel = (function (_super) {
        __extends(ParameterRangeViewModel, _super);
        function ParameterRangeViewModel(property, workspace) {
            var _this = this;
            _super.call(this, property, workspace);
            this.type = 8 /* ParameterRange */;
            var decodedPropertyValue = decodeURIComponent(this.property.value());
            var parameterRangeDescriptor = property.descriptor;
            this.title = property.descriptor.friendlyName;
            this.minLimit = parameterRangeDescriptor.minLimit;
            this.maxLimit = parameterRangeDescriptor.maxLimit;
            this.sliderMin = parameterRangeDescriptor.sliderMin;
            this.sliderMax = parameterRangeDescriptor.sliderMax;
            this.logCapable = parameterRangeDescriptor.isLog;
            this.hasIndexRuleError = ko.observable(false);
            //If being constructed without previous version being saved, use parameters passed in from services.
            //Otherwise, build viewModel off of previous values
            if (decodedPropertyValue[0] !== '{' && decodedPropertyValue[0] !== '[' && property.descriptor.defaultValue && property.descriptor.defaultValue !== "") {
                var sliderRange = parameterRangeDescriptor.sliderMax - parameterRangeDescriptor.sliderMin;
                if (parameterRangeDescriptor.isInt) {
                    this.minValue = ko.observable(Math.round(parameterRangeDescriptor.sliderMin + .1 * sliderRange));
                    this.maxValue = ko.observable(Math.round(parameterRangeDescriptor.sliderMax - .1 * sliderRange));
                }
                else {
                    this.minValue = ko.observable(parameterRangeDescriptor.sliderMin + .1 * sliderRange);
                    this.maxValue = ko.observable(parameterRangeDescriptor.sliderMax - .1 * sliderRange);
                }
                this.count = "3";
                this.isLogarithmic = ko.observable(false);
                this.defaultLiteralValue = parameterRangeDescriptor.defaultValue.replace(/;/g, ",");
                this.useRangeBuilder = ko.observable(false);
            }
            else {
                var savedVM = JSON.parse(decodedPropertyValue);
                this.minValue = ko.observable(savedVM.minValue);
                this.maxValue = ko.observable(savedVM.maxValue);
                this.count = savedVM.count;
                this.isLogarithmic = ko.observable(savedVM.isLogarithmic);
                this.defaultLiteralValue = savedVM.literal;
                this.useRangeBuilder = ko.observable(savedVM.useRangeBuilder);
            }
            if (this.sliderMin <= 0 && this.logCapable) {
                this.logMinLimit = 0.0001;
            }
            else {
                this.logMinLimit = Math.log(this.sliderMin);
            }
            this.logMaxLimit = Math.log(this.sliderMax);
            this.makeJsonString = function () {
                var result = encodeURIComponent(JSON.stringify({
                    ParameterType: _this.parameterType,
                    useRangeBuilder: _this.useRangeBuilder(),
                    literal: _this.literalList(),
                    isLogarithmic: _this.isLogarithmic(),
                    minValue: _this.minValue(),
                    maxValue: _this.maxValue(),
                    count: _this.countValidatable()
                }));
                _this.property.value(result);
            };
        }
        /**
         * Factory Method returning the correct ParameterViewModel
        **/
        ParameterRangeViewModel.createParameterRangeViewModel = function (property, workspace) {
            var parameterRangeDescriptor = property.descriptor;
            var prvm;
            if (parameterRangeDescriptor.isInt) {
                prvm = new IntegerParameterRangeViewModel(property, workspace);
            }
            else {
                prvm = new DoubleParameterRangeViewModel(property, workspace);
            }
            prvm.finishConstruction();
            return prvm;
        };
        ParameterRangeViewModel.prototype.finishConstruction = function () {
            var _this = this;
            var countRegExp = new RegExp('^\\s*(\\d+)\\s*$');
            this.validateCount = function (inputValue) {
                var error;
                if (countRegExp.test(_this.countValidatable())) {
                    var value = (countRegExp.exec(_this.countValidatable())[1]);
                    var range = 1 + _this.maxValue() - _this.minValue();
                    if (Number(value) >= range && _this.parameterType == "Integer") {
                        error = DataLab.Util.format(DataLab.LocalizedResources.parameterRangeErrorTooManyPoints, range.toString());
                    }
                    else if (Number(value) < 1) {
                        error = DataLab.LocalizedResources.parameterRangeCountMustBeInteger;
                    }
                }
                else {
                    error = DataLab.LocalizedResources.parameterRangeCountMustBeInteger;
                }
                error ? _this.hasIndexRuleError(true) : _this.hasIndexRuleError(false);
                return error;
            };
            this.countValidatable = DataLab.Validation.validatableObservable(this.count, this.validateCount);
            this.countValidatable.startValidating();
            this.countValidatable.validate();
            this.validateItems = function (inputValue) {
                var indexArr = _this.literalList().split(',');
                var error;
                indexArr.forEach(function (indexStr) {
                    if (_this.literalItemRegExp.test(indexStr)) {
                        var value = (_this.literalItemRegExp.exec(indexStr)[1]);
                        if (Number(value) < _this.minLimit) {
                            error = DataLab.Util.format(DataLab.LocalizedResources.parameterRangeErrorMustBeGreaterThan, _this.minLimit.toString());
                            return;
                        }
                        if (Number(value) > _this.maxLimit) {
                            error = DataLab.Util.format(DataLab.LocalizedResources.parameterRangeErrorMustBeLessThan, _this.maxLimit.toString());
                            return;
                        }
                    }
                    else if (_this.literalRangeRegExp.test(indexStr)) {
                        var regexpMatch = _this.literalRangeRegExp.exec(indexStr);
                        if (Number(regexpMatch[1]) < _this.minLimit) {
                            error = DataLab.Util.format(DataLab.LocalizedResources.parameterRangeErrorMustBeGreaterThan, _this.minLimit.toString());
                            return;
                        }
                        if (Number(regexpMatch[2]) > _this.maxLimit) {
                            error = DataLab.Util.format(DataLab.LocalizedResources.parameterRangeErrorMustBeLessThan, _this.maxLimit.toString());
                            return;
                        }
                        if (Number(regexpMatch[2]) < Number(regexpMatch[1])) {
                            error = DataLab.LocalizedResources.parameterRangeInvalidRange;
                            return;
                        }
                    }
                    else {
                        if (_this.parameterType === "Integer") {
                            error = DataLab.LocalizedResources.parameterRangeInputMustBeIntegersOrRanges;
                        }
                        else if (_this.parameterType === "Double") {
                            error = DataLab.LocalizedResources.parameterRangeInputMustBeDoubles;
                        }
                        return;
                    }
                });
                error ? _this.hasIndexRuleError(true) : _this.hasIndexRuleError(false);
                return error;
            };
            this.literalList = DataLab.Validation.validatableObservable(this.defaultLiteralValue, this.validateItems);
            this.literalList.startValidating();
            this.literalList.validate();
            this.rangeString = ko.computed(function () {
                var s;
                if (_this.parameterType === "Integer") {
                    s = "" + _this.minValue() + " - " + _this.maxValue();
                }
                else {
                    var min = (_this.minValue() < 1) ? _this.minValue().toExponential(2) : _this.minValue().toPrecision(3);
                    var max = (_this.maxValue() < 1) ? _this.maxValue().toExponential(2) : _this.maxValue().toPrecision(3);
                    s = "" + min + " - " + max;
                }
                return s;
            }, this);
            //Set up event listining
            this.minValue.subscribe(function () {
                _this.countValidatable.validate();
            });
            this.maxValue.subscribe(function () {
                _this.countValidatable.validate();
            });
            this.countValidatable.subscribe(function () {
                _this.makeJsonString();
            });
            this.literalList.subscribe(function () {
                _this.makeJsonString();
            });
            this.minValue.subscribe(function () {
                _this.makeJsonString();
            });
            this.maxValue.subscribe(function () {
                _this.makeJsonString();
            });
            this.useRangeBuilder.subscribe(function () {
                _this.makeJsonString();
            });
            this.isLogarithmic.subscribe(function () {
                _this.makeJsonString();
            });
        };
        return ParameterRangeViewModel;
    })(ParameterViewModel);
    ExperimentEditor.ParameterRangeViewModel = ParameterRangeViewModel;
    var EnumItemViewModel = (function () {
        function EnumItemViewModel(value, displayValue, selected) {
            var _this = this;
            this.value = value;
            this.displayValue = displayValue;
            this.isSelected = ko.observable(selected);
            this.classString = ko.computed(function () {
                return _this.isSelected() ? "multiselectSelected" : "multiselectNotSelected";
            }, this);
        }
        return EnumItemViewModel;
    })();
    ExperimentEditor.EnumItemViewModel = EnumItemViewModel;
    var EnumSweepViewModel = (function (_super) {
        __extends(EnumSweepViewModel, _super);
        function EnumSweepViewModel(property, workspace) {
            var _this = this;
            _super.call(this, property, workspace);
            property.value.validate = function () {
                return [];
            };
            var decodedPropertyValue = decodeURIComponent(this.property.value());
            this.type = 10 /* MultiSelect */;
            var descriptor = property.descriptor;
            this.enumItems = ko.observableArray([]);
            // This handles building a new enum viewmodel
            if (decodedPropertyValue[0] !== '{' && decodedPropertyValue[0] !== '[' && property.descriptor.defaultValue) {
                descriptor.choices().forEach(function (param) {
                    _this.enumItems().push(new EnumItemViewModel(param.value, param.displayValue, param.value === descriptor.defaultValue));
                });
            }
            else {
                var savedVM = JSON.parse(decodedPropertyValue);
                savedVM.enumItems.forEach(function (item) {
                    _this.enumItems.push(new EnumItemViewModel(item.value, item.displayValue, item.selected));
                });
            }
            this.buttonLabel = ko.computed(function () {
                var items = [];
                _this.enumItems().forEach(function (item) {
                    if (item.isSelected()) {
                        items.push(item.displayValue);
                    }
                });
                if (items.length === 0) {
                    return DataLab.LocalizedResources.MultiselectLabelNoneSelected;
                }
                else if (items.length === 1) {
                    return items[0];
                }
                else {
                    return DataLab.Util.format(DataLab.LocalizedResources.MultiselectLabelManySelected, items.length.toString());
                }
            });
            this.JSONString = ko.computed(function () {
                var items = [];
                _this.enumItems().forEach(function (item) {
                    items.push({ value: item.value, displayValue: item.displayValue, selected: item.isSelected() });
                });
                var result = encodeURIComponent(JSON.stringify({
                    enumItems: items
                }));
                _this.property.value(result);
                return result;
            });
        }
        return EnumSweepViewModel;
    })(ParameterViewModel);
    ExperimentEditor.EnumSweepViewModel = EnumSweepViewModel;
    var IntegerParameterRangeViewModel = (function (_super) {
        __extends(IntegerParameterRangeViewModel, _super);
        function IntegerParameterRangeViewModel(property, workspace) {
            var _this = this;
            _super.call(this, property, workspace);
            this.logMin = ko.computed({
                read: function () {
                    return Math.log(_this.minValue());
                },
                write: function (value) {
                    _this.minValue(Math.round(Math.exp(value)));
                },
                owner: this
            });
            this.logMax = ko.computed({
                read: function () {
                    return Math.log(_this.maxValue());
                },
                write: function (value) {
                    _this.maxValue(Math.round(Math.exp(value)));
                },
                owner: this
            });
            this.linSliderStep = 1;
            this.logSliderStep = (this.logMaxLimit - this.logMinLimit) * 0.005;
            this.parameterType = "Integer";
            this.literalItemRegExp = new RegExp('^\\s*(-?\\d+)\\s*$');
            this.literalRangeRegExp = new RegExp('^\\s*(-?\\d+)\\s*-\\s*(-?\\d+)\\s*$');
        }
        return IntegerParameterRangeViewModel;
    })(ParameterRangeViewModel);
    ExperimentEditor.IntegerParameterRangeViewModel = IntegerParameterRangeViewModel;
    var DoubleParameterRangeViewModel = (function (_super) {
        __extends(DoubleParameterRangeViewModel, _super);
        function DoubleParameterRangeViewModel(property, workspace) {
            var _this = this;
            _super.call(this, property, workspace);
            this.logMin = ko.computed({
                read: function () {
                    return Math.log(_this.minValue());
                },
                write: function (value) {
                    _this.minValue(Math.exp(value));
                },
                owner: this
            });
            this.logMax = ko.computed({
                read: function () {
                    return Math.log(_this.maxValue());
                },
                write: function (value) {
                    _this.maxValue(Math.exp(value));
                },
                owner: this
            });
            this.linSliderStep = (this.sliderMax - this.sliderMin) * .005;
            this.logSliderStep = (this.logMaxLimit - this.logMinLimit) * 0.005;
            this.parameterType = "Double";
            //Allow the use of decimal points, may need to come up with localized version
            //Also allows scientific notation of the form 3e-12
            this.literalItemRegExp = new RegExp('^\\s*((-?\\d+\\.?\\d*((e|E)-?\\d+))|(-?\\d*\\.?\\d+))\\s*$');
            //Not clear on what a range of doubles should be. Should all ranges be disallowed? Currently adds nothing
            this.literalRangeRegExp = new RegExp('^\\s*((-?\\d+\\.?\\d*((e|E)-?\\d+))|(-?\\d*\\.?\\d+))\\s*$');
        }
        return DoubleParameterRangeViewModel;
    })(ParameterRangeViewModel);
    ExperimentEditor.DoubleParameterRangeViewModel = DoubleParameterRangeViewModel;
    var MonacoParameterViewModel = (function (_super) {
        __extends(MonacoParameterViewModel, _super);
        /**
          * @constructor
          * View model for editable text area properties that will use the Monaco text editor
          * Additionally, this Property is able to resize vertically.
        **/
        function MonacoParameterViewModel(property, workspace) {
            _super.call(this, property, workspace);
            this.monacoMimeType = null;
            if (!(property.descriptor instanceof DataLab.Model.ScriptModuleParameterDescriptor)) {
                throw new Error("MonacoParameterViewModel must be passed a ScriptModuleParameterDescriptor");
            }
            // Convert here from parameter scriptName extension to mime type
            var scriptName = property.descriptor.scriptName.toLowerCase().trim();
            var scriptExtension = scriptName ? (scriptName.match(/\.[0-9a-z]+$/) || [""])[0] : "";
            switch (scriptExtension) {
                case ".r":
                    this.monacoMimeType = ExperimentEditor.MonacoMimeTypes.R;
                    break;
                case ".py":
                    this.monacoMimeType = ExperimentEditor.MonacoMimeTypes.Python;
                    break;
                case ".hql":
                    this.monacoMimeType = ExperimentEditor.MonacoMimeTypes.Hive;
                    break;
                case ".ql":
                    this.monacoMimeType = ExperimentEditor.MonacoMimeTypes.Hive;
                    break;
                case ".sql":
                    this.monacoMimeType = ExperimentEditor.MonacoMimeTypes.Sql;
                    break;
                case ".js":
                    this.monacoMimeType = ExperimentEditor.MonacoMimeTypes.JavaScript;
                    break;
                case ".ts":
                    this.monacoMimeType = ExperimentEditor.MonacoMimeTypes.TypeScript;
                    break;
                default:
                    this.monacoMimeType = ExperimentEditor.MonacoMimeTypes.PlainText;
                    break;
            }
        }
        return MonacoParameterViewModel;
    })(ParameterViewModel);
    ExperimentEditor.MonacoParameterViewModel = MonacoParameterViewModel;
    var StaticContentPropertyViewModel = (function (_super) {
        __extends(StaticContentPropertyViewModel, _super);
        /**
          * @constructor
          * THIS CLASS IS ABSTRACT. DO NOT INSTANTIATE IT.
         **/
        function StaticContentPropertyViewModel(property) {
            _super.call(this, property);
            this.isStaticContent(true);
            this._isDisabled = ko.computed(function () {
                return true;
            });
        }
        Object.defineProperty(StaticContentPropertyViewModel.prototype, "isDisabled", {
            get: function () {
                return this._isDisabled;
            },
            enumerable: true,
            configurable: true
        });
        return StaticContentPropertyViewModel;
    })(PropertyViewModel);
    ExperimentEditor.StaticContentPropertyViewModel = StaticContentPropertyViewModel;
    var LinkPropertyViewModel = (function (_super) {
        __extends(LinkPropertyViewModel, _super);
        /**
          * @constructor
          * View model for properties that should appear as HTML links
         **/
        function LinkPropertyViewModel(property, callback) {
            _super.call(this, property);
            this.type = 4 /* Link */;
            this.templateType = function () {
                return "linkProperty";
            };
            if (callback) {
                this.onClick = function (viewModel, e) {
                    e.preventDefault();
                    callback(e);
                };
            }
            else {
                this.onClick = function (viewModel, e) {
                };
            }
        }
        return LinkPropertyViewModel;
    })(StaticContentPropertyViewModel);
    ExperimentEditor.LinkPropertyViewModel = LinkPropertyViewModel;
    var EndpointPropertyViewModel = (function (_super) {
        __extends(EndpointPropertyViewModel, _super);
        /**
          * @constructor
          * View model for endpoint properties that should appear as HTML links
         **/
        function EndpointPropertyViewModel(property, endpointDownloader) {
            var _this = this;
            if (endpointDownloader) {
                _super.call(this, property, function (e) {
                    if (_this.endpoint() && _this.endpoint().Size !== -1) {
                        endpointDownloader.download(_this.endpoint());
                    }
                });
            }
            else {
                _super.call(this, property);
            }
            this.endpoint = property.endpoint;
        }
        Object.defineProperty(EndpointPropertyViewModel.prototype, "endpointDownloader", {
            // TODO 1614732: Remove EndpointDownloader
            set: function (endpointDownloader) {
                var _this = this;
                this.onClick = function (viewModel, e) {
                    e.preventDefault();
                    if (_this.endpoint() && _this.endpoint().Size !== -1) {
                        endpointDownloader.download(_this.endpoint());
                    }
                };
            },
            enumerable: true,
            configurable: true
        });
        return EndpointPropertyViewModel;
    })(LinkPropertyViewModel);
    ExperimentEditor.EndpointPropertyViewModel = EndpointPropertyViewModel;
    var ButtonPropertyViewModel = (function (_super) {
        __extends(ButtonPropertyViewModel, _super);
        /**
          * @constructor
          * View model for properties that should appear as buttons
         **/
        function ButtonPropertyViewModel(property, callback) {
            _super.call(this, property);
            this.type = 5 /* Button */;
            this.templateType = function () {
                return "buttonProperty";
            };
            if (callback) {
                this.onClick = function (viewModel, e) {
                    e.preventDefault();
                    callback(e);
                };
            }
            else {
                this.onClick = function (viewModel, e) {
                };
            }
        }
        return ButtonPropertyViewModel;
    })(StaticContentPropertyViewModel);
    ExperimentEditor.ButtonPropertyViewModel = ButtonPropertyViewModel;
    var EndpointDialogPropertyViewModel = (function (_super) {
        __extends(EndpointDialogPropertyViewModel, _super);
        /**
          * @constructor
          *  View model for endpoint properties that should appear as buttons and be displayed in a dialog
         **/
        function EndpointDialogPropertyViewModel(property, moduleName, moduleID, workspace, experimentId) {
            var _this = this;
            _super.call(this, property);
            this.endpoint = property.endpoint;
            this.moduleName = moduleName;
            this.clickDisabled = ko.observable(false);
            this.onClick = function (viewModel, e) {
                if (_this.clickDisabled()) {
                    return;
                }
                else {
                    _this.clickDisabled(true);
                }
                if (e) {
                    e.preventDefault();
                }
                if (_this.endpoint() && _this.endpoint().Size > 0) {
                    if (_this.property.id === 0 /* Error */) {
                        Shell.UI.Spinner.show();
                        Shell.Diagnostics.Telemetry.customEvent("TryingToLoadModuleErrorMessageOnUserClick", "ModuleErrorMessageLoad");
                        DataLab.Util.then(workspace.getModuleErrorLog(experimentId, moduleID), function (errorText) {
                            Shell.UI.Spinner.hide();
                            ExperimentEditor.CustomUX.open(ExperimentEditor._moduleErrorMarkup, new ExperimentEditor.ModuleError.ModuleErrorViewModel(errorText, moduleName, moduleID), "350px", "710px");
                        }).fail(function () {
                            Shell.UI.Spinner.hide();
                            var errorNotification = new Shell.UI.Notifications.Notification(DataLab.LocalizedResources.moduleErrorDialogCouldNotLoad, "error");
                            errorNotification.setActions([Shell.UI.Notifications.Buttons.close(function () {
                            })]);
                            Shell.UI.Notifications.add(errorNotification);
                            Shell.Diagnostics.Telemetry.customEvent("FailedToLoadModuleErrorMessageOnUserClick", "ModuleErrorMessageLoadFailed");
                        }).always(function () {
                            _this.clickDisabled(false);
                        });
                    }
                    else {
                        _this.clickDisabled(false);
                    }
                }
                else {
                    _this.clickDisabled(false);
                }
            };
        }
        return EndpointDialogPropertyViewModel;
    })(ButtonPropertyViewModel);
    ExperimentEditor.EndpointDialogPropertyViewModel = EndpointDialogPropertyViewModel;
    var StaticTextPropertyViewModel = (function (_super) {
        __extends(StaticTextPropertyViewModel, _super);
        /**
          * @constructor
          * View model for properties that should appear as static text
         **/
        function StaticTextPropertyViewModel(property) {
            _super.call(this, property);
            this.type = 0 /* Textbox */;
            this.templateType = function () {
                return "staticTextProperty";
            };
        }
        return StaticTextPropertyViewModel;
    })(StaticContentPropertyViewModel);
    ExperimentEditor.StaticTextPropertyViewModel = StaticTextPropertyViewModel;
    var CheckboxPropertyViewModel = (function (_super) {
        __extends(CheckboxPropertyViewModel, _super);
        function CheckboxPropertyViewModel(property) {
            _super.call(this, property);
            this.type = 1 /* Checkbox */;
            this.templateType = function () {
                return "checkboxProperty";
            };
        }
        return CheckboxPropertyViewModel;
    })(PropertyViewModel);
    ExperimentEditor.CheckboxPropertyViewModel = CheckboxPropertyViewModel;
    var EditableTextPropertyViewModel = (function (_super) {
        __extends(EditableTextPropertyViewModel, _super);
        function EditableTextPropertyViewModel(property) {
            _super.call(this, property);
            this.type = 9 /* EditableText */;
            this.templateType = function () {
                return "editableTextAreaProperty";
            };
        }
        return EditableTextPropertyViewModel;
    })(PropertyViewModel);
    ExperimentEditor.EditableTextPropertyViewModel = EditableTextPropertyViewModel;
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
var ExperimentEditor;
(function (ExperimentEditor) {
    // returns a font-icon's CSS class name
    function GetIconForCategory(category) {
        var defaultIconPath = "icon-module";
        if (!category) {
            return defaultIconPath;
        }
        var categoryComponents = category.split("\\");
        switch (categoryComponents[0]) {
            case "Saved Datasets":
                return "icon-data_set";
            case "Trained Models":
                return "icon-trained_model";
            case "Transforms":
                return "icon-custom_transform";
            case "Data Format Conversions":
                return "icon-data_format";
            case "Data Input and Output":
                return "icon-data_input";
            case "Data Transformation":
                return "icon-transformation";
            case "Feature Selection":
                return "icon-discover";
            case "Statistical Functions":
                return "icon-math_statistics";
            case "Time Series":
                return "icon-time_series";
            case "Machine Learning":
                return "icon-machine_learning";
            case "OpenCV Library Modules":
                return "icon-computer_vision";
            case "R Language Modules":
                return "icon-R_language";
            case "Python Language Modules":
                return "icon-python_module";
            case "Text Analytics":
                return "icon-text_analytics";
            case "Custom Modules":
                return "icon-custom_module";
            case DataLab.Constants.ResourceCategory.WebService:
                return "icon-web_service";
            case "Deprecated":
                return "icon-Deprecated";
            default:
                return defaultIconPath;
        }
    }
    ExperimentEditor.GetIconForCategory = GetIconForCategory;
    // gets the the symbol that represents the icon in our font
    function GetIconSymbol(icon) {
        var val = "";
        var tempIcon = document.createElement("span");
        tempIcon.className = icon;
        document.body.appendChild(tempIcon);
        val = window.getComputedStyle(tempIcon, ":before").getPropertyValue("content");
        // remove double-quotes added by browser
        if (val.length > 1 && val[0] === val[val.length - 1] && val[0] === '"') {
            val = val.slice(1, -1);
        }
        document.body.removeChild(tempIcon);
        return val;
    }
    ExperimentEditor.GetIconSymbol = GetIconSymbol;
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />

/// <reference path="IPaletteItem.ts" />

/// <reference path="../../Global.ts" />
/// <reference path="CustomUX.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var ExperimentEditor;
(function (ExperimentEditor) {
    var HelpSearch;
    (function (HelpSearch) {
        var SearchResult = (function () {
            function SearchResult(moduleName, guid, position) {
                this.moduleName = moduleName;
                this.guid = guid;
                this.position = position;
            }
            return SearchResult;
        })();
        var MenuState;
        (function (MenuState) {
            MenuState[MenuState["Opening"] = 0] = "Opening";
            MenuState[MenuState["Closing"] = 1] = "Closing";
            MenuState[MenuState["Opened"] = 2] = "Opened";
            MenuState[MenuState["Closed"] = 3] = "Closed";
        })(MenuState || (MenuState = {}));
        ;
        var HelpSearchViewModel = (function (_super) {
            __extends(HelpSearchViewModel, _super);
            function HelpSearchViewModel(helpSearchIsEnabled) {
                var _this = this;
                _super.call(this);
                this.helpSearchEnabled = ko.observable(helpSearchIsEnabled);
                this.queryInput = ko.observable("");
                this.currentQuery = ko.observable("");
                this.queuedQuery = ko.observable(null);
                this.searchResults = ko.observableArray([]);
                this.synonymResults = ko.observableArray([]);
                this.isLoading = ko.observable(false);
                this.hasErrors = ko.observable(false);
                this.isSearchResultsVisible = ko.observable(false);
                this.isSearchResultsAnimating = ko.observable(false);
                this.synonymResultClicked = this.synonymResultClicked.bind(this); // Override knockout calling event handler with different 'this'
                this.searchResultClicked = this.searchResultClicked.bind(this); // Override knockout calling event handler with different 'this'
                this.menuState = ko.computed(function () {
                    if (_this.isLoading()) {
                        return 0 /* Opening */;
                    }
                    else if (_this.isSearchResultsAnimating()) {
                        return _this.isSearchResultsVisible() ? 0 /* Opening */ : 1 /* Closing */;
                    }
                    else {
                        return _this.isSearchResultsVisible() ? 2 /* Opened */ : 3 /* Closed */;
                    }
                });
                // @TODO Move to Knockout observable extender
                var lastMenuState = null;
                this.menuState.subscribe(function () {
                    if (lastMenuState !== _this.menuState()) {
                        _this.onMenuStateChange(); // Don't trigger unless actually changed
                    }
                    lastMenuState = _this.menuState();
                });
                this.queuedQuery.subscribe(function (newQueuedQuery) {
                    if (newQueuedQuery && _this.menuState() === 2 /* Opened */) {
                        _this.hideResults();
                    }
                });
            }
            HelpSearchViewModel.prototype.onMenuStateChange = function () {
                switch (this.menuState()) {
                    case 3 /* Closed */:
                        if (this.queuedQuery()) {
                            var query = this.queuedQuery();
                            this.queuedQuery(null);
                            this.submitQuery(query);
                        }
                        break;
                    case 2 /* Opened */:
                        if (this.queuedQuery()) {
                            this.hideResults();
                        }
                    case 0 /* Opening */:
                    case 1 /* Closing */:
                        break;
                }
            };
            // Enter events are handled to submit help searches
            // A state machine determines the action to take with the query...
            // If the results are not shown, they are animated in with an ajax request,
            // if they are shown and there is a new query, we slide the events down and submit the ajax request
            // if the results are mid animation, we queue the requested search query.  These states
            // are to ensure behavior is consistent when animations happen, since when results are returned before the 
            // current results can slide down, ajaxing them in with KO is disorienting
            HelpSearchViewModel.prototype.onKeyDownEvent = function (input, event) {
                if (event.which == 13 /* Return */ && this.queryInput().length != 0) {
                    if (this.menuState() === 3 /* Closed */) {
                        this.submitQuery(this.queryInput());
                    }
                    else {
                        this.queuedQuery(this.queryInput());
                    }
                }
                return true;
            };
            HelpSearchViewModel.prototype.hideResults = function () {
                this.isSearchResultsVisible(false);
            };
            HelpSearchViewModel.prototype.searchResultClicked = function (data, event) {
                var logData = { searchQuery: this.currentQuery(), resultIndex: data.position, resultGUID: data.guid, moduleName: data.moduleName };
                Shell.Diagnostics.Telemetry.featureUsage(41 /* HelpSearchResultClicked */, 39 /* Help */, null, null, null, logData);
                ExperimentEditor.Help.openHelpWindow(data.guid);
            };
            HelpSearchViewModel.prototype.synonymResultClicked = function (data, event) {
                var logData = { searchQuery: this.currentQuery(), semanticSynonym: data };
                Shell.Diagnostics.Telemetry.featureUsage(42 /* HelpSemanticSynonymClicked */, 39 /* Help */, null, null, null, logData);
                this.queryInput(data);
                this.queuedQuery(data);
            };
            HelpSearchViewModel.prototype.submitQuery = function (query) {
                var _this = this;
                // log query
                var logData = { searchQuery: query };
                Shell.Diagnostics.Telemetry.featureUsage(40 /* HelpSearched */, 39 /* Help */, null, null, null, logData);
                this.isLoading(true);
                // nuke results and synonyms
                this.searchResults.removeAll();
                this.synonymResults.removeAll();
                this.hasErrors(false);
                // make search results ajax request
                $.ajax({
                    url: "/api/helpsearch/search/?query=" + encodeURIComponent(query)
                }).done(function (jsonResult) {
                    var position = 0;
                    jsonResult.QueryResults.map(function (result) {
                        _this.searchResults.push(new SearchResult(result.ModuleName, result.GUID, position++));
                    }); // oh yeah let's see
                    // get synonyms
                    $.ajax({
                        url: "/api/helpsearch/synonyms/?query=" + encodeURIComponent(query)
                    }).done(function (jsonResult) {
                        _this.synonymResults(jsonResult);
                    }).fail(function () {
                        /*swallow, synoynms are not critical*/
                    }).always(function () {
                        _this.isSearchResultsVisible(true); // It's important to set this before unsetting isLoading, so that we don't cause an incorrect menu state change.
                        _this.isLoading(false);
                        _this.currentQuery(query);
                    });
                }).fail(function () {
                    _this.hasErrors(true);
                    _this.currentQuery(query);
                    _this.isSearchResultsVisible(true);
                    _this.isLoading(false);
                });
            };
            return HelpSearchViewModel;
        })(DataLab.Util.Disposable);
        function Initialize() {
            var helpElement = $(ExperimentEditor._helpSearchMarkup).prependTo(".fxs-drawertaskbar-tray");
            ko.applyBindings(new HelpSearchViewModel(DataLab.Features.semanticHelpSearch()), helpElement[0]);
        }
        HelpSearch.Initialize = Initialize;
    })(HelpSearch = ExperimentEditor.HelpSearch || (ExperimentEditor.HelpSearch = {}));
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Common/ICommand.ts" />

/// <reference path="IMenuItem.ts" />

/// <reference path="../ViewModel/ContextMenuControl/IMenuData.ts" />

/// <reference path="../Global.ts" />
/// <reference path="../../TypeScriptLib/jquery.extension.d.ts" />
/// <reference path="../ViewModel/ContextMenuControl/MenuViewModel.ts" />
var ExperimentEditor;
(function (ExperimentEditor) {
    // A standard context menu control. The following are the list of supported features:
    // + MVVM based code structure with KnockoutJS as the data-binding library
    // + Support sub-menu
    // + Support displaying 16x16 icon
    // + Support divider menu item
    // + Mouse hover over effect on menu item
    // + Menu item can be enabled/disabled
    // + Css-based styling
    //
    // Dependencies:
    // + KnockoutJS
    // + jQuery UI position
    var MenuControl;
    (function (MenuControl) {
        MenuControl.menuIsOpen;
        /* The current target view model for whatever the user clicked */
        MenuControl.targetViewModel = null;
        function initialize() {
            DataLab.Util.initializeTemplateIfNecessary("datalab-contextMenuTemplate", ExperimentEditor._menuMarkup);
        }
        MenuControl.initialize = initialize;
        /**
          * Remove the menu currently on the page if open. Otherwise, do nothing.
         **/
        MenuControl.removeContextMenu = function () {
            if (MenuControl.menuIsOpen) {
                $(".datalab-contextMenu").remove();
                MenuControl.menuIsOpen = false;
            }
        };
        function spawnMenu(menu, targetLocation) {
            // See http://api.jqueryui.com/position/ for the typing and usage of "of" parameter. This gets
            // passed as the of parameter to jquery UI .position() down the road
            var context = {
                menu: null,
                of: null,
                zIndex: 0,
            };
            if (!menu) {
                throw new Error("menu is undefined or null.");
            }
            context.menu = menu;
            // Return immediately if there is no context menu items
            if (context.menu.items().length == 0) {
                return false;
            }
            context.of = targetLocation;
            // Pick a very high z-index so that the context menu will be on the topmost z-order
            context.zIndex = 100001;
            var rootparent = $('<div></div>').appendTo("body");
            ko.renderTemplate("datalab-contextMenuTemplate", context, null, rootparent, "replaceNode");
            var options = {
                my: 'right+1 top-1',
                at: 'right bottom',
                of: targetLocation,
                offset: '0 0',
                collision: "fit fit"
            };
            // Sets width of the element (context menu root container).
            // Without it collision doesn't work
            $(".datalab-contextMenu").position(options);
            MenuControl.menuIsOpen = true;
        }
        MenuControl.spawnMenu = spawnMenu;
    })(MenuControl = ExperimentEditor.MenuControl || (ExperimentEditor.MenuControl = {}));
    // The initialization that should be called once before one can use the ContextMenu
    MenuControl.initialize();
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
/// <reference path="MenuViewModel.ts" />
/// <reference path="IMenuItem.ts" />
/// <reference path="../../View/MenuControl.ts" />
var ExperimentEditor;
(function (ExperimentEditor) {
    var MenuItemViewModel = (function () {
        /**
          * @constructor
          * The view model for context and drop menus.
          * @param {IMenuData} menuData the list of items to put in the menu
          * @param {any} targetViewModel the viewModel corresponding to the thing the user clicked on
          * @param {MenuViewModel} parentMenu The menu containing this item
         **/
        function MenuItemViewModel(menuItemData, targetViewModel, parentMenu) {
            var _this = this;
            this.menuItem = {
                label: ko.observable(menuItemData.label || ''),
                divider: ko.observable(menuItemData.divider || false),
                iconClass: ko.observable(menuItemData.iconClass || ''),
                command: menuItemData.command,
                items: ko.observableArray(menuItemData.items || []),
            };
            this.parentMenu = parentMenu;
            this.targetViewModel = targetViewModel;
            // Create a submenu if we have items for one
            this.subMenu = menuItemData.items && menuItemData.items.length > 0 ? new ExperimentEditor.MenuViewModel({ items: menuItemData.items }, targetViewModel, parentMenu) : null;
            this.onMouseDown = function (sender, e) {
                e.preventDefault();
                e.stopPropagation();
            };
            this.onActivated = function (sender, e) {
                e.preventDefault();
                e.stopPropagation();
                if (_this.enabled() && _this.menuItem.command) {
                    ExperimentEditor.MenuControl.removeContextMenu();
                    _this.menuItem.command.execute(_this.targetViewModel);
                }
            };
            this.enabled = ko.computed(function () {
                return _this.subMenu !== null || (_this.menuItem.command && _this.menuItem.command.canExecute());
            });
        }
        return MenuItemViewModel;
    })();
    ExperimentEditor.MenuItemViewModel = MenuItemViewModel;
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
/// <reference path="../../Common/IMenuBuilder.ts" />
/// <reference path="IMenuData.ts" />
/// <reference path="MenuItemViewModel.ts" />
var ExperimentEditor;
(function (ExperimentEditor) {
    var MenuViewModel = (function () {
        /*
         * The view model for context and drop menus.
         * @constructor
         * @param {IMenuData} menuData the list of items to put in the menu
         * @param {any} targetViewModel the viewModel corresponding to the thing the user clicked on
         * @param {MenuViewModel} parentMenu If this menu is a submenu, the parent menu. Null otherwise.
        */
        function MenuViewModel(menuData, targetViewModel, parentMenu) {
            if (parentMenu === void 0) { parentMenu = null; }
            if (!menuData) {
                throw new Error("menuData cannot be null.");
            }
            this.classId = ko.observable("datalab-contextMenu");
            this.items = ko.observableArray();
            this.targetViewModel = targetViewModel;
            this.parentMenu = parentMenu;
            this.items([]);
            for (var i = 0; i < menuData.items.length; ++i) {
                var item = menuData.items[i];
                this.items.push(new ExperimentEditor.MenuItemViewModel(item, this.targetViewModel, this));
            }
        }
        /**
          * Yo dawg, I heard you don't like context menus on your context menus, so prevent default
          * on mouse up to stop that.
         **/
        MenuViewModel.prototype.contextMenuMouseUp = function (target, e) {
            e.preventDefault();
        };
        return MenuViewModel;
    })();
    ExperimentEditor.MenuViewModel = MenuViewModel;
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../Global.ts" />
/// <reference path="../Common/IMenuBuilder.ts" />
/// <reference path="../ViewModel/ExperimentEditor/Entity.ts" />
/// <reference path="../ViewModel/ExperimentEditor/Module.ts" />
/// <reference path="../ViewModel/ExperimentEditor/ExperimentEditorViewModel.ts" />
/// <reference path="../ViewModel/ExperimentEditor/PortViewModel.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var ExperimentEditor;
(function (ExperimentEditor) {
    // We extend Disposable so we can instantiate this in LeakMaster.
    var ExperimentEditorMenuBuilder = (function (_super) {
        __extends(ExperimentEditorMenuBuilder, _super);
        function ExperimentEditorMenuBuilder(experimentEditorViewModel, commands) {
            // TODO [1198137]: Create a generic command class for some of the following commands and have them passed in as constructor arguments
            _super.call(this);
            this.experimentEditorViewModel = experimentEditorViewModel;
            this.readOnlyMode = ko.observable(false);
            this.currentTarget = ko.observable(null);
            this.commands = commands;
            this.menuMap = Object.create(null);
            this.menuMap.portMenu = {
                name: "contextMenu",
                items: [
                    { label: DataLab.LocalizedResources.experimentEditorContextMenuDownload, iconClass: "file", command: this.commands.viewOutput },
                    { label: DataLab.LocalizedResources.experimentEditorContextMenuSaveAsDataset, iconClass: "view", command: this.commands.promoteOutput },
                    { label: DataLab.LocalizedResources.experimentEditorContextMenuSaveAsTrainedModel, iconClass: "view", command: this.commands.promoteTrainerOutput },
                    { label: DataLab.LocalizedResources.experimentEditorContextMenuSaveAsTransform, iconClass: "view", command: this.commands.promoteTransformOutput },
                    { label: DataLab.LocalizedResources.experimentEditorContextMenuVisualize, iconClass: "visualize", command: this.commands.visualizeData }
                ]
            };
            this.menuMap.inputPortMenu = {
                name: "contextMenu",
                items: []
            };
            this.menuMap.portDatasetMenu = {
                name: "contextMenu",
                items: [
                    { label: DataLab.LocalizedResources.experimentEditorContextMenuDownload, iconClass: "file", command: this.commands.downloadDataset },
                    { label: DataLab.LocalizedResources.experimentEditorContextMenuVisualize, iconClass: "visualize", command: this.commands.visualizeData }
                ]
            };
            if (DataLab.Features.iPythonNotebookEnabled()) {
                this.menuMap.portDatasetMenu.items.push.apply(this.menuMap.portDatasetMenu.items, [
                    { label: null, divider: true },
                    { label: "Open Notebook", iconClass: "python", command: this.commands.openPythonNotebook },
                    { label: "Open New Notebook", iconClass: "python", command: this.commands.openNewPythonNotebook },
                    { label: "View Notebooks", command: this.commands.listPythonNotebooks }
                ]);
            }
            if (DataLab.Features.enableOutputPortApiCodeEnabled()) {
                this.menuMap.portMenu.items.push.apply(this.menuMap.portMenu.items, [
                    { label: null, divider: true },
                    { label: DataLab.LocalizedResources.apiCodeDialogTopText + "...", iconClass: "copy", command: this.commands.showOutputPortApiCode }
                ]);
                this.menuMap.portDatasetMenu.items.push.apply(this.menuMap.portDatasetMenu.items, [
                    { label: null, divider: true },
                    { label: DataLab.LocalizedResources.apiCodeDialogTopText + "...", iconClass: "copy", command: this.commands.showOutputPortApiCode }
                ]);
            }
            this.menuMap.datasetMenu = {
                name: "contextMenu",
                items: [
                    { label: DataLab.LocalizedResources.experimentEditorContextMenuDelete, iconClass: "delete", command: this.commands.delete_ },
                    { label: DataLab.LocalizedResources.experimentEditorContextMenuCopy, iconClass: "copy", command: this.commands.copy },
                    { label: DataLab.LocalizedResources.experimentEditorContextMenuCut, iconClass: "cut", command: this.commands.cut },
                    { label: DataLab.LocalizedResources.experimentEditorContextMenuPaste, iconClass: "paste", command: this.commands.paste },
                    { label: null, divider: true },
                    { label: DataLab.LocalizedResources.experimentEditorContextMenuDownload, iconClass: "file", command: this.commands.downloadDataset }
                ]
            };
            this.menuMap.trainedModelMenu = {
                name: "contextMenu",
                items: [
                    { label: DataLab.LocalizedResources.experimentEditorContextMenuDelete, iconClass: "delete", command: this.commands.delete_ },
                    { label: DataLab.LocalizedResources.experimentEditorContextMenuCopy, iconClass: "copy", command: this.commands.copy },
                    { label: DataLab.LocalizedResources.experimentEditorContextMenuCut, iconClass: "cut", command: this.commands.cut },
                    { label: DataLab.LocalizedResources.experimentEditorContextMenuPaste, iconClass: "paste", command: this.commands.paste },
                ]
            };
            this.menuMap.transformMenu = {
                name: "contextMenu",
                items: [
                    { label: DataLab.LocalizedResources.experimentEditorContextMenuDelete, iconClass: "delete", command: this.commands.delete_ },
                    { label: DataLab.LocalizedResources.experimentEditorContextMenuCopy, iconClass: "copy", command: this.commands.copy },
                    { label: DataLab.LocalizedResources.experimentEditorContextMenuCut, iconClass: "cut", command: this.commands.cut },
                    { label: DataLab.LocalizedResources.experimentEditorContextMenuPaste, iconClass: "paste", command: this.commands.paste },
                ]
            };
            this.menuMap.moduleMenu = {
                name: "contextMenu",
                items: [
                    { label: DataLab.LocalizedResources.experimentEditorContextMenuDelete, iconClass: "delete", command: this.commands.delete_ },
                    { label: DataLab.LocalizedResources.experimentEditorContextMenuCopy, iconClass: "copy", command: this.commands.copy },
                    { label: DataLab.LocalizedResources.experimentEditorContextMenuCut, iconClass: "cut", command: this.commands.cut },
                    { label: DataLab.LocalizedResources.experimentEditorContextMenuPaste, iconClass: "paste", command: this.commands.paste },
                    { label: null, divider: true },
                    {
                        label: DataLab.LocalizedResources.experimentEditorContextMenuViewLog,
                        iconClass: "view",
                        items: [
                            { label: DataLab.LocalizedResources.experimentEditorContextMenuOutputLog, iconClass: "file", command: this.commands.viewStdOut },
                            { label: DataLab.LocalizedResources.experimentEditorContextMenuErrorLog, iconClass: "file", command: this.commands.viewStdErr }
                        ]
                    },
                    { label: null, divider: true },
                    { label: DataLab.LocalizedResources.experimentEditorContextMenuEditComment, command: this.commands.editComment },
                    { label: null, divider: true },
                    { label: DataLab.LocalizedResources.experimentEditorContextMenuHelp, command: this.commands.showHelp }
                ]
            };
            this.menuMap.mainMenu = {
                name: "contextMenu",
                items: [
                    { label: DataLab.LocalizedResources.experimentEditorContextMenuDelete, iconClass: "delete", command: this.commands.delete_ },
                    { label: DataLab.LocalizedResources.experimentEditorContextMenuCopy, iconClass: "copy", command: this.commands.copy },
                    { label: DataLab.LocalizedResources.experimentEditorContextMenuCut, iconClass: "cut", command: this.commands.cut },
                    { label: DataLab.LocalizedResources.experimentEditorContextMenuPaste, iconClass: "paste", command: this.commands.paste },
                    { label: null, divider: true },
                    { label: DataLab.LocalizedResources.experimentEditorContextMenuRefresh, iconClass: "refresh", command: this.commands.refreshExperiment },
                    { label: DataLab.LocalizedResources.experimentEditorContextMenuViewPriorRun, iconClass: "file", command: this.commands.navigateToParent },
                ]
            };
            this.menuMap.multiSelectMenu = {
                /* Special module menu for multi-select */
                name: "contextMenu",
                items: [
                    { label: DataLab.LocalizedResources.experimentEditorContextMenuDelete, iconClass: "delete", command: this.commands.delete_ },
                    { label: DataLab.LocalizedResources.experimentEditorContextMenuCopy, iconClass: "copy", command: this.commands.copy },
                    { label: DataLab.LocalizedResources.experimentEditorContextMenuCut, iconClass: "cut", command: this.commands.cut },
                    { label: DataLab.LocalizedResources.experimentEditorContextMenuPaste, iconClass: "paste", command: this.commands.paste }
                ]
            };
        }
        ExperimentEditorMenuBuilder.prototype.build = function (target) {
            this.currentTarget(target);
            var selectedEntityCount = this.experimentEditorViewModel.selectionManager.selectedEntities.count();
            if (selectedEntityCount > 1) {
                // Update the menu in the context of multi-selection
                return this.menuMap.multiSelectMenu;
            }
            else {
                if (target instanceof ExperimentEditor.InputPort) {
                    var inputPortMenuWithPublishOptions = {
                        name: this.menuMap.inputPortMenu.name,
                        items: this.menuMap.inputPortMenu.items.slice(0)
                    };
                    return inputPortMenuWithPublishOptions;
                }
                else if (target instanceof ExperimentEditor.Module) {
                    return this.menuMap.moduleMenu;
                }
                else if (target instanceof ExperimentEditor.Dataset) {
                    return this.menuMap.datasetMenu;
                }
                else if (target instanceof ExperimentEditor.TrainedModel) {
                    return this.menuMap.trainedModelMenu;
                }
                else if (target instanceof ExperimentEditor.Transform) {
                    return this.menuMap.transformMenu;
                }
                else if (target instanceof ExperimentEditor.OutputPort) {
                    if (target.parent instanceof ExperimentEditor.Module) {
                        var outputPortMenuWithPublishOptions = {
                            name: this.menuMap.portMenu.name,
                            items: this.menuMap.portMenu.items.slice(0)
                        };
                        return outputPortMenuWithPublishOptions;
                    }
                    else if (target.parent instanceof ExperimentEditor.Dataset) {
                        return this.menuMap.portDatasetMenu;
                    }
                }
                else if (target instanceof ExperimentEditor.ExperimentEditorViewModel) {
                    return this.menuMap.mainMenu;
                }
                else {
                    return null;
                }
                return null;
            }
        };
        return ExperimentEditorMenuBuilder;
    })(DataLab.Util.Disposable);
    ExperimentEditor.ExperimentEditorMenuBuilder = ExperimentEditorMenuBuilder;
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="ICommand.ts" />
var ExperimentEditor;
(function (ExperimentEditor) {
    /**
     A NullCommand is never enabled and cannot execute. It is useful for when a command
     is not available (e.g. not injected by some outer container).

     For substituting absent commands with NullCommands, see {@see optionalCommand}.
     */
    var NullCommand = (function () {
        function NullCommand() {
            this.canExecute = ko.observable(false);
        }
        NullCommand.prototype.execute = function (target) {
            throw new Error("Null command; cannot be executed");
        };
        return NullCommand;
    })();
    ExperimentEditor.NullCommand = NullCommand;
    /**
     Returns the given command if provided; otherwise, a NullCommand
    */
    function optionalCommand(command) {
        return command ? command : new NullCommand();
    }
    ExperimentEditor.optionalCommand = optionalCommand;
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
/// <reference path="Entity.ts" />
/// <reference path="ExperimentEditorViewModel.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var ExperimentEditor;
(function (ExperimentEditor) {
    // A class that provides support for item selection (single or multiple).
    // The multi selection works in the following way. The selection process 
    // is done by creating a selection rectangle R(P1, P2) in 2 steps. The first
    // step is to capture the P1 position and the second step is to capture P2.
    // Once P2 is captured, all 'entities' that intersect with the R(P1, P2) will
    // be selected. It assumes that each entity implements ISprite interface.
    //
    // This class also features a smart rectangle selection in that it detects
    // the vector direction of the P1->P2 points and know how to perform collision
    // detection correctly regardless of the direction of the P1->P2 points.
    var SelectionManager = (function (_super) {
        __extends(SelectionManager, _super);
        function SelectionManager(experimentViewModel) {
            var _this = this;
            _super.call(this);
            this.visible = ko.observable("hidden");
            // startXY is the coordinate of the first mouse capture
            this.startX = ko.observable(0);
            this.startY = ko.observable(0);
            // curXY is the coordinate of the current mouse pointer
            this.curX = ko.observable(0);
            this.curY = ko.observable(0);
            this.width = ko.observable(0);
            this.height = ko.observable(0);
            this.startCapture = false;
            this._selectedGraphNodes = DataLab.observableMap();
            this._selectedConnections = DataLab.observableMap();
            this.registerForDisposal(this._selectedEntities = DataLab.observableMapUnion(this._selectedGraphNodes, this._selectedConnections), this._selectedGraphNodeModels = this._selectedGraphNodes.transform(function (graphNode) {
                return graphNode.graphNode;
            }));
            this.selectionChangeCallback = null;
            this.experimentViewModel = experimentViewModel;
            function handleSelectableEntitiesChange(changeInfo) {
                switch (changeInfo.type) {
                    case 2 /* remove */:
                        this.deselectEntity(changeInfo.oldValue);
                        break;
                }
            }
            // We don't own the experimentViewModel, so we need to unsubscribe
            this.registerForDisposal(new DataLab.Util.DisposableSubscription(experimentViewModel.subscribe(function (experimentViewModel) {
                experimentViewModel.selectableEntities.subscribeToCollectionChanges(handleSelectableEntitiesChange.bind(_this));
            })));
            function handleSelectionSetChange(changeInfo) {
                switch (changeInfo.type) {
                    case 0 /* add */:
                        var entity = changeInfo.newValue;
                        entity.selected(true);
                        break;
                    case 2 /* remove */:
                        var entity = changeInfo.oldValue;
                        entity.selected(false);
                        break;
                }
            }
            // Update the selected observable on the actual node
            // We own selectedEntities, so we don't need to subscribe
            this._selectedEntities.subscribeToCollectionChanges(handleSelectionSetChange.bind(this));
        }
        SelectionManager.prototype.isVisible = function () {
            return (this.visible() === "visible");
        };
        Object.defineProperty(SelectionManager.prototype, "selectedGraphNodes", {
            get: function () {
                return this._selectedGraphNodes;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SelectionManager.prototype, "selectedConnections", {
            get: function () {
                return this._selectedConnections;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SelectionManager.prototype, "selectedEntities", {
            get: function () {
                return this._selectedEntities;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SelectionManager.prototype, "selectedGraphNodeModels", {
            get: function () {
                return this._selectedGraphNodeModels;
            },
            enumerable: true,
            configurable: true
        });
        /**
          * Deselect the given entity
          * @param {Entity} entity the entity to deselect
         **/
        SelectionManager.prototype.deselectEntity = function (entity) {
            if (entity instanceof ExperimentEditor.Connection) {
                var connection = entity;
                var key = ExperimentEditor.Connection.getConnectionKeyForPorts(connection.inputPort, connection.outputPort);
                this._selectedConnections.remove(key);
            }
            else {
                var graphNode = entity;
                this._selectedGraphNodes.remove(graphNode.graphNode.id);
            }
        };
        /**
          * Select all entities in the experiment
         **/
        SelectionManager.prototype.selectAll = function () {
            var _this = this;
            this.experimentViewModel().connections.forEach(function (connection) {
                var key = ExperimentEditor.Connection.getConnectionKeyForPorts(connection.inputPort, connection.outputPort);
                _this._selectedConnections.put(key, connection);
            });
            this.experimentViewModel().experimentNodes.forEach(function (graphNode) {
                _this._selectedGraphNodes.put(graphNode.graphNode.id, graphNode);
            });
        };
        /**
          * Remove all items from the selection
         **/
        SelectionManager.prototype.resetSelection = function () {
            var _this = this;
            // Arbitrarily lock one of the two maps so the union doesn't notify subscribers twice
            this._selectedConnections.modify(function () {
                _this._selectedConnections.clear();
                _this._selectedGraphNodes.clear();
            });
        };
        /**
          * Batch multiple selection updates to minimize the number of knockout updates
         **/
        SelectionManager.prototype.modifySelection = function (callback) {
            this.selectedEntities.modify(function () {
                callback();
            });
        };
        /**
          * Add an entity to the current selection
          * @param {Entity} entity the entity to select
         **/
        SelectionManager.prototype.selectEntity = function (entity) {
            if (entity instanceof ExperimentEditor.Connection) {
                var connection = entity;
                var key = ExperimentEditor.Connection.getConnectionKeyForPorts(connection.inputPort, connection.outputPort);
                this._selectedConnections.put(key, connection);
            }
            else {
                var graphNode = entity;
                this._selectedGraphNodes.put(graphNode.graphNode.id, graphNode);
            }
        };
        /**
          * Toggles an entity's selection state.
          * @param {Entity} entity the entity to toggle selection state
         **/
        SelectionManager.prototype.toggleEntitySelection = function (entity) {
            if (entity.selected()) {
                this.deselectEntity(entity);
            }
            else {
                this.selectEntity(entity);
            }
        };
        /**
          * Starts a drag multi-selection. Note that rect selections do not clear the current selection
          * @param {number} x the x domain coordinate to start the drag
          * @param {number} y the y domain coordinate to start the drag
         **/
        SelectionManager.prototype.beginRectSelection = function (x, y) {
            this.startCapture = true;
            // On select, capture the current mouseXY
            // and set startXY with the mouseXY
            // set visible=true
            this.width(0);
            this.height(0);
            this.startX(x);
            this.startY(y);
            this.curX(x);
            this.curY(y);
            this.visible("visible");
        };
        /**
          * Ends a drag multi-selection. All entities in 'entities' fully enclosed by the selection
          * rectangle are added to the current user selection.
          * @param {number} x the x domain coordinate to end the drag
          * @param {number} y the y domain coordinate to end the drag
          * @param {IEntityMap} entities a map of all entities to test for selection
         **/
        SelectionManager.prototype.endRectSelection = function (x, y, entities) {
            var _this = this;
            this.updateRectSelection(x, y);
            // A valid selection rectangle is created by 2-step commands (beginDragSelect() -> endDragSelect())
            // Check that the endDragSelect() call is preceded by the beginDragSelect() call
            if (this.startCapture) {
                // On unselect, makes the selection rectangle invisible
                // reset the width & height to 0
                // and set the last X, Y to current mouseXY
                this.visible("hidden");
                // Do hit testing on the entities
                this.modifySelection(function () {
                    DataLab.Util.forEach(entities, function (entity) {
                        if (entity.hit(_this.curX(), _this.curY(), (_this.curX() + _this.width()), (_this.curY() + _this.height()))) {
                            _this.selectEntity(entity);
                        }
                    });
                });
                this.width(0);
                this.height(0);
                this.startX(x);
                this.startY(y);
                this.curX(x);
                this.curY(y);
                this.startCapture = false;
            }
            return this.selectedEntities.count() > 0;
        };
        /**
          * Aborts a drag multi-selection. Nothing is added to the current user selection.
         **/
        SelectionManager.prototype.cancelRectSelection = function () {
            this.visible("hidden");
            this.width(0);
            this.height(0);
            this.startCapture = false;
        };
        /**
          * Updates the current drag selection rectangle. The rectangle will extend from the point
          * where start was called to the current mouse location.
          * @param {number} x the current x domain coordinate of the mouse
          * @param {number} y the current y domain coordinate of the mouse
         **/
        SelectionManager.prototype.updateRectSelection = function (x, y) {
            this.width(Math.abs(x - this.startX()));
            this.height(Math.abs(y - this.startY()));
            // Do not process if 
            if ((this.width() === 0) || (this.height() === 0)) {
                return;
            }
            // The following technique to create multi-directional selection rectangle
            // is to calculate the TopLeft and WidthHeight regardless of the vector direction
            // of P1 and P2.
            //
            // There are 4 conditions:
            // 1. ++ (positive-x, positive-y) => TopLeft: (startX, startY)
            // 2. +- (positive-x, negative-y) => TopLeft: (startX, y)
            // 3. -+ (negative-x, positive-y) => TopLeft: (x, y)
            // 4. -- (negative-x, negative-y) => TopLefT: (x, startY)
            if (x > this.startX() && y > this.startY()) {
            }
            else if (x > this.startX() && y < this.startY()) {
                // +-
                // For positive-x and negative-y, the current (curX, curY)
                // should become the TopLeft
                this.curY(y);
            }
            else if (x < this.startX() && y < this.startY()) {
                // --
                this.curX(x);
                this.curY(y);
            }
            else {
                // -+
                this.curX(x);
            }
        };
        return SelectionManager;
    })(DataLab.Util.Disposable);
    ExperimentEditor.SelectionManager = SelectionManager;
    ;
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
/// <reference path="Entity.ts" />
/// <reference path="GraphNodeViewModel.ts" />
/// <reference path="PortViewModel.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var ExperimentEditor;
(function (ExperimentEditor) {
    // A class represents Dataset entity.
    var Dataset = (function (_super) {
        __extends(Dataset, _super);
        function Dataset(datasetNode) {
            var _this = this;
            _super.call(this, datasetNode, ExperimentEditor.EntityTypes[ExperimentEditor.Constants.EntityType.Dataset]);
            this.datasetNode = datasetNode;
            this.graphNodeType = 1 /* Dataset */;
            // Definition of dataset shape:
            // when x = 0 and y = 0, path = "M 13,0 Q -13,30, 13,60 L 187,60 Q 213,30, 187,0 Z"
            this.path = ko.computed(function () {
                return ("M" + (_this.x() + 13) + "," + (_this.y()) + "Q" + (_this.x() - 13) + "," + (_this.y() + 30) + "," + (_this.x() + 13) + "," + (_this.y() + 60) + "L" + (_this.x() + 187) + "," + (_this.y() + 60) + "Q" + (_this.x() + 213) + "," + (_this.y() + 30) + "," + (_this.x() + 187) + "," + (_this.y()) + "Z");
            });
            this.classId = ko.computed(function () {
                var value = (_this.hovered() ? " hoveredEntity" : "") + (_this.selected() ? " selectedEntity" : "") + " " + _this.getCompatibilityClass();
                return "rectEntity data" + value;
            });
            this.author = new ExperimentEditor.StaticTextPropertyViewModel(this.datasetNode.author);
            this.size = new ExperimentEditor.StaticTextPropertyViewModel(this.datasetNode.size);
            this.format = new ExperimentEditor.StaticTextPropertyViewModel(this.datasetNode.format);
            this.createdOn = new ExperimentEditor.StaticTextPropertyViewModel(this.datasetNode.createdOn);
            this.viewDataset = new ExperimentEditor.EndpointPropertyViewModel(this.datasetNode.viewDataset);
            this.icon = ExperimentEditor.GetIconForCategory(datasetNode.dataset.category);
            this.iconSymbol = ExperimentEditor.GetIconSymbol(this.icon);
        }
        Object.defineProperty(Dataset.prototype, "datasetPort", {
            get: function () {
                return DataLab.Util.first(this.outputPorts, function () { return true; });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Dataset.prototype, "label", {
            get: function () {
                return this.datasetNode.dataset.name();
            },
            enumerable: true,
            configurable: true
        });
        return Dataset;
    })(ExperimentEditor.GraphNodeViewModel);
    ExperimentEditor.Dataset = Dataset;
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
/// <reference path="Entity.ts" />
/// <reference path="GraphNodeViewModel.ts" />
/// <reference path="PortViewModel.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var ExperimentEditor;
(function (ExperimentEditor) {
    // A class represents trained model entity.
    var TrainedModel = (function (_super) {
        __extends(TrainedModel, _super);
        function TrainedModel(trainedModelNode) {
            var _this = this;
            _super.call(this, trainedModelNode, ExperimentEditor.EntityTypes[ExperimentEditor.Constants.EntityType.TrainedModel]);
            this.trainedModelNode = trainedModelNode;
            this.graphNodeType = 2 /* TrainedModel */;
            // Definition of dataset shape:
            // when x = 0 and y = 0, path = "M 13,0 Q -13,30, 13,60 L 187,60 Q 213,30, 187,0 Z"
            this.path = ko.computed(function () {
                return ("M" + (_this.x() + 13) + "," + (_this.y()) + "Q" + (_this.x() - 13) + "," + (_this.y() + 30) + "," + (_this.x() + 13) + "," + (_this.y() + 60) + "L" + (_this.x() + 187) + "," + (_this.y() + 60) + "Q" + (_this.x() + 213) + "," + (_this.y() + 30) + "," + (_this.x() + 187) + "," + (_this.y()) + "Z");
            });
            this.classId = ko.computed(function () {
                var value = (_this.hovered() ? " hoveredEntity" : "") + (_this.selected() ? " selectedEntity" : "") + " " + _this.getCompatibilityClass();
                return "rectEntity data" + value;
            });
            this.author = new ExperimentEditor.StaticTextPropertyViewModel(this.trainedModelNode.author);
            this.format = new ExperimentEditor.StaticTextPropertyViewModel(this.trainedModelNode.format);
            this.createdOn = new ExperimentEditor.StaticTextPropertyViewModel(this.trainedModelNode.createdOn);
            this.trainingExperiment = new ExperimentEditor.LinkPropertyViewModel(this.trainedModelNode.trainingExperiment, function (event) {
                DataLabViews.navigateToExperiment(_this.trainedModelNode.trainedModel.experimentId);
            });
            this.icon = ExperimentEditor.GetIconForCategory(this.trainedModelNode.trainedModel.category);
            this.iconSymbol = ExperimentEditor.GetIconSymbol(this.icon);
        }
        Object.defineProperty(TrainedModel.prototype, "trainedModelPort", {
            get: function () {
                return DataLab.Util.first(this.outputPorts, function () { return true; });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TrainedModel.prototype, "label", {
            get: function () {
                return this.trainedModelNode.trainedModel.name();
            },
            enumerable: true,
            configurable: true
        });
        return TrainedModel;
    })(ExperimentEditor.GraphNodeViewModel);
    ExperimentEditor.TrainedModel = TrainedModel;
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
/// <reference path="Entity.ts" />
/// <reference path="GraphNodeViewModel.ts" />
/// <reference path="PortViewModel.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var ExperimentEditor;
(function (ExperimentEditor) {
    // A class represents transformation module entity.
    var Transform = (function (_super) {
        __extends(Transform, _super);
        function Transform(transformNode) {
            var _this = this;
            _super.call(this, transformNode, ExperimentEditor.EntityTypes[ExperimentEditor.Constants.EntityType.Transform]);
            this.transformNode = transformNode;
            this.graphNodeType = 4 /* Transform */;
            // Definition of dataset shape:
            // when x = 0 and y = 0, path = "M 13,0 Q -13,30, 13,60 L 187,60 Q 213,30, 187,0 Z"
            this.path = ko.computed(function () {
                return ("M" + (_this.x() + 13) + "," + (_this.y()) + "Q" + (_this.x() - 13) + "," + (_this.y() + 30) + "," + (_this.x() + 13) + "," + (_this.y() + 60) + "L" + (_this.x() + 187) + "," + (_this.y() + 60) + "Q" + (_this.x() + 213) + "," + (_this.y() + 30) + "," + (_this.x() + 187) + "," + (_this.y()) + "Z");
            });
            this.classId = ko.computed(function () {
                var value = (_this.hovered() ? " hoveredEntity" : "") + (_this.selected() ? " selectedEntity" : "") + " " + _this.getCompatibilityClass();
                return "rectEntity data" + value;
            });
            this.author = new ExperimentEditor.StaticTextPropertyViewModel(this.transformNode.author);
            this.format = new ExperimentEditor.StaticTextPropertyViewModel(this.transformNode.format);
            this.createdOn = new ExperimentEditor.StaticTextPropertyViewModel(this.transformNode.createdOn);
            this.trainingExperiment = new ExperimentEditor.LinkPropertyViewModel(this.transformNode.trainingExperiment, function (event) {
                DataLabViews.navigateToExperiment(_this.transformNode.transform.experimentId);
            });
            this.icon = ExperimentEditor.GetIconForCategory(this.transformNode.transform.category);
            this.iconSymbol = ExperimentEditor.GetIconSymbol(this.icon);
        }
        Object.defineProperty(Transform.prototype, "transformPort", {
            get: function () {
                return DataLab.Util.first(this.outputPorts, function () { return true; });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Transform.prototype, "label", {
            get: function () {
                return this.transformNode.transform.name();
            },
            enumerable: true,
            configurable: true
        });
        return Transform;
    })(ExperimentEditor.GraphNodeViewModel);
    ExperimentEditor.Transform = Transform;
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var ExperimentEditor;
(function (ExperimentEditor) {
    var WebServicePortParameter = (function (_super) {
        __extends(WebServicePortParameter, _super);
        function WebServicePortParameter(parameter) {
            _super.call(this, parameter);
            this.autocompleteArray = parameter.autocompleteArray;
            this.isLinkable = false;
            this.templateType = function () {
                return "inputParameter";
            };
            this._isDisabled = ko.computed(function () {
                return false;
            });
        }
        WebServicePortParameter.prototype.validate = function () {
            var parameter = this.property;
            return parameter.validate();
        };
        Object.defineProperty(WebServicePortParameter.prototype, "isDisabled", {
            get: function () {
                return this._isDisabled;
            },
            enumerable: true,
            configurable: true
        });
        return WebServicePortParameter;
    })(ExperimentEditor.PropertyViewModel);
    ExperimentEditor.WebServicePortParameter = WebServicePortParameter;
    var WebServicePort = (function (_super) {
        __extends(WebServicePort, _super);
        function WebServicePort(webServicePortNode) {
            var _this = this;
            _super.call(this, webServicePortNode, ExperimentEditor.EntityTypes[ExperimentEditor.Constants.EntityType.WebServicePort]);
            this.webServicePortNode = webServicePortNode;
            this.graphNodeType = 3 /* WebServicePort */;
            // when x = 0 and y = 0, path = "M 13,0 Q -13,30, 13,60 L 187,60 Q 213,30, 187,0 Z"
            this.path = ko.computed(function () {
                return ("M" + (_this.x() + 13) + "," + (_this.y()) + "Q" + (_this.x() - 13) + "," + (_this.y() + 30) + "," + (_this.x() + 13) + "," + (_this.y() + 60) + "L" + (_this.x() + 187) + "," + (_this.y() + 60) + "Q" + (_this.x() + 213) + "," + (_this.y() + 30) + "," + (_this.x() + 187) + "," + (_this.y()) + "Z");
            });
            this.classId = ko.computed(function () {
                var value = (_this.hovered() ? " hoveredEntity" : "") + (_this.selected() ? " selectedEntity" : "") + " " + _this.getCompatibilityClass();
                return "rectEntity data blueFill" + value;
            });
            if (webServicePortNode.type === 0 /* Input */) {
                this.iconSymbol = ExperimentEditor.GetIconSymbol('icon-data_input');
            }
            else {
                this.iconSymbol = ExperimentEditor.GetIconSymbol('icon-data_output');
            }
            this.iconClass = 'whiteFill';
            this.textClassId = ko.computed(function () {
                return "staticText whiteFill";
            });
        }
        Object.defineProperty(WebServicePort.prototype, "label", {
            get: function () {
                return this.webServicePortNode.name;
            },
            enumerable: true,
            configurable: true
        });
        return WebServicePort;
    })(ExperimentEditor.GraphNodeViewModel);
    ExperimentEditor.WebServicePort = WebServicePort;
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
/// <reference path="Entity.ts" />
/// <reference path="Module.ts" />
/// <reference path="Dataset.ts" />
/// <reference path="TrainedModel.ts" />
/// <reference path="Transform.ts" />
/// <reference path="PortViewModel.ts" />
/// <reference path="Connection.ts" />
/// <reference path="WebServicePort.ts" />
/// <reference path="../PropertyEditorControl/PropertyViewModel.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var ExperimentEditor;
(function (ExperimentEditor) {
    // The ExperimentViewModel is the model of the experiment view 
    // This should not be confused with the pure model which comes from 
    // backend service.
    var ExperimentViewModel = (function (_super) {
        __extends(ExperimentViewModel, _super);
        function ExperimentViewModel(experiment, workspace) {
            var _this = this;
            _super.call(this);
            this.displayFlowType = ko.observable(ExperimentEditor.Constants.ExperimentDataFlowType.Experiment);
            this.experiment = experiment;
            this.experimentLoaded = ko.observable(false);
            this.workspace = workspace;
            this.readOnlyMode = ko.observable(false);
            this.connections = DataLab.observableMap();
            this.tempNodes = DataLab.observableMap();
            if (DataLab.Features.experimentDescriptionEnabled()) {
                this.summary = new ExperimentEditor.EditableTextPropertyViewModel(this.experiment.summary);
                var details = new DataLab.Model.EditableTextProperty(DataLab.LocalizedResources.experimentDetailedDescription, DataLab.LocalizedResources.experimentDetailedDescriptionPlaceholder, ko.observable(""), null);
                this.details = new ExperimentEditor.EditableTextPropertyViewModel(details);
                var currentDetails;
                // Load the description for the experiment
                if (this.experiment.experimentId()) {
                    if (!this.isSampleExperiment()) {
                        workspace.getExperimentDetailsAsync(this.experiment.experimentId()).done(function (result) {
                            if (result) {
                                // TODO: Defect 4056855 -> Avoid Json serialization of strings in DataLabClient
                                currentDetails = /^"?(.+?)?"?$/g.exec(result)[1];
                                currentDetails = window.unescape(currentDetails);
                                details.value(currentDetails);
                            }
                        });
                    }
                }
                // If the experiment id changes (for example, cloning a sample) save the content of the details field using the new experimentId
                this.registerForDisposal(new DataLab.Util.DisposableSubscription(this.experiment.experimentId.subscribe(function (experimentId) {
                    if (experimentId && details.value()) {
                        workspace.updateExperimentDetailsAsync(experimentId, details.value());
                    }
                })));
                // Update the details when changed from studio
                details.value.subscribe(function (newValue) {
                    if (currentDetails !== newValue && _this.experiment.experimentId()) {
                        currentDetails = newValue;
                        // TODO: Defect 4056855 -> Avoid Json serialization of strings in DataLabClient
                        var valueToSave = window.escape(newValue);
                        workspace.updateExperimentDetailsAsync(_this.experiment.experimentId(), valueToSave);
                    }
                });
                this.detailsLink = new ExperimentEditor.LinkPropertyViewModel(this.experiment.originalExperimentDocumentation, function (e) {
                    window.open(_this.detailsLink.property.value(), "_blank");
                });
                this.displayFlowType.subscribe(function (value) {
                    Shell.Diagnostics.Telemetry.featureUsage(value === ExperimentEditor.Constants.ExperimentDataFlowType.Experiment ? 69 /* SwitchExperimentDataFlow */ : 70 /* SwitchWebServiceDataFlow */, 68 /* PrepareWebService */, _this.workspace.id, _this.experiment.experimentId());
                });
            }
            // We don't own the experiment, so we need to unsubscribe
            this.registerForDisposal(new DataLab.Util.DisposableSubscription(this.experiment.connectionAdded.subscribe(function (args) {
                _this.addConnection(_this.getViewModelForPort(args.input), _this.getViewModelForPort(args.output));
                var parentViewModel = _this.getViewModelForNode(args.input.parent);
                if (parentViewModel instanceof ExperimentEditor.Module) {
                    parentViewModel.updateValidState();
                }
            })), this.experimentNodes = experiment.nodes.transform(function (node) { return _this.createNodeViewModel(node); }), this.nodes = DataLab.observableMapUnion(this.tempNodes, this.experimentNodes), this.webServiceParameters = experiment.parameters.transform(function (parameter) { return ExperimentEditor.ParameterViewModel.createParameterViewModel(parameter, workspace); }), new DataLab.Util.DisposableSubscription(this.experiment.connectionRemoved.subscribe(function (args) {
                _this.removeConnection(_this.getViewModelForPort(args.input), _this.getViewModelForPort(args.output));
                var parentViewModel = _this.getViewModelForNode(args.input.parent);
                if (parentViewModel instanceof ExperimentEditor.Module) {
                    parentViewModel.startValidating();
                    parentViewModel.updateValidState();
                }
            })));
            // We have a subscription for future connection changes, but we may have been given a non-empty experiment with existing connections.
            this.experiment.forEachConnection(function (inputPort, outputPort) {
                _this.addConnection(_this.getViewModelForPort(inputPort), _this.getViewModelForPort(outputPort));
            });
            this.registerForDisposal(this.selectableEntities = DataLab.observableMapUnion(this.nodes, this.connections));
            var propertyArray = [];
            DataLab.Util.forEach(this.experiment.properties(), function (property) {
                propertyArray.push(ExperimentEditor.PropertyViewModel.experimentPropertyFactory(property));
            });
            this.experimentProperties = ko.observableArray(propertyArray);
            this.experimentStateUpdateRunningTime = function () {
                if (_this.experiment.statusCode() === DataLab.DataContract.State.Running && _this.experimentStateDisplay) {
                    var runningTimeMilliseconds = DataLab.Util.getElapsedTimeMilliseconds(new Date(_this.experiment.startTime()), new Date);
                    if (runningTimeMilliseconds >= 0) {
                        _this.experimentStateDisplay().statusLabel(DataLab.LocalizedResources.experimentStateRunning + " (" + DataLab.Util.formatElapsedTime(runningTimeMilliseconds, 0) + ")");
                    }
                    else {
                        _this.experimentStateDisplay().statusLabel(DataLab.LocalizedResources.experimentStateRunning);
                    }
                }
                else {
                    clearInterval(_this.experimentStateIntervalID);
                }
            };
            this.experimentStateDisplay = ko.computed(function () {
                if (_this.readOnlyMode() && _this.experiment.statusCode() !== DataLab.DataContract.State.Running && _this.experiment.statusCode() !== DataLab.DataContract.State.NotStarted) {
                    return {
                        statusLabel: ko.observable(DataLab.LocalizedResources.experimentStateLocked),
                        statusIconUrl: "/Content/Images/icon-locked_gray.svg",
                        iconHoverBalloon: DataLab.LocalizedResources.experimentStateLockedHover
                    };
                }
                switch (_this.experiment.statusCode()) {
                    case DataLab.DataContract.State.InDraft:
                        clearInterval(_this.experimentStateIntervalID);
                        if (_this.experiment.validate().length === 0 || _this.experiment.nodes.length === 0) {
                            return {
                                statusLabel: ko.observable(DataLab.LocalizedResources.experimentStateInDraft),
                                statusIconUrl: "/Content/Images/icon-none.svg",
                                iconHoverBalloon: ""
                            };
                        }
                        else {
                            return {
                                statusLabel: ko.observable(DataLab.LocalizedResources.experimentStateInDraft),
                                statusIconUrl: "/Content/Images/icon-validation-invalid.svg",
                                iconHoverBalloon: DataLab.LocalizedResources.experimentStateInDraftHoverErrors
                            };
                        }
                    case DataLab.DataContract.State.Finished:
                        clearInterval(_this.experimentStateIntervalID);
                        return {
                            statusLabel: ko.observable(DataLab.LocalizedResources.experimentStateFinishedRunning),
                            statusIconUrl: "/Content/Images/icon-complete.svg",
                            iconHoverBalloon: ""
                        };
                    case DataLab.DataContract.State.Running:
                        _this.experimentStateIntervalID = setInterval(_this.experimentStateUpdateRunningTime, 1000);
                        var runningTimeMilliseconds = DataLab.Util.getElapsedTimeMilliseconds(new Date(_this.experiment.startTime()), new Date);
                        if (runningTimeMilliseconds >= 0) {
                            return {
                                statusLabel: ko.observable(DataLab.LocalizedResources.experimentStateRunning + " (" + DataLab.Util.formatElapsedTime(runningTimeMilliseconds, 0) + ")"),
                                statusIconUrl: "/Content/Images/processing.gif",
                                iconHoverBalloon: DataLab.LocalizedResources.experimentStateRunningHover
                            };
                        }
                        else {
                            return {
                                statusLabel: ko.observable(DataLab.LocalizedResources.experimentStateRunning),
                                statusIconUrl: "/Content/Images/processing.gif",
                                iconHoverBalloon: DataLab.LocalizedResources.experimentStateRunningHover
                            };
                        }
                    case DataLab.DataContract.State.Failed:
                        clearInterval(_this.experimentStateIntervalID);
                        return {
                            statusLabel: ko.observable(DataLab.LocalizedResources.experimentStateFailed + " " + _this.experiment.endTime()),
                            statusIconUrl: "/Content/Images/icon-error.svg",
                            iconHoverBalloon: DataLab.LocalizedResources.experimentStateFailedHover
                        };
                    case DataLab.DataContract.State.NotStarted:
                        return {
                            statusLabel: ko.observable(DataLab.LocalizedResources.experimentStateQueued),
                            statusIconUrl: "/Content/Images/ajax-loader.gif",
                            iconHoverBalloon: DataLab.LocalizedResources.experimentStateQueuedHover
                        };
                    default:
                        return {
                            statusLabel: ko.observable(""),
                            statusIconUrl: "/Content/Images/icon-none.svg",
                            iconHoverBalloon: ""
                        };
                }
            }, this);
            this.registerForDisposal(new ExperimentEditor.ExperimentDataFlowWalker(this.nodes, this.connections));
        }
        ExperimentViewModel.prototype.addPublishOutputPort = function (outputPort) {
            this.experiment.addPublishOutputPort(outputPort.portModel);
        };
        ExperimentViewModel.prototype.addPublishInputPort = function (inputPort) {
            this.experiment.addPublishInputPort(inputPort.portModel);
        };
        ExperimentViewModel.prototype.removePublishOutputPort = function (outputPort) {
            this.experiment.removePublishOutputPort(outputPort.portModel);
        };
        ExperimentViewModel.prototype.removePublishInputPort = function (inputPort) {
            this.experiment.removePublishInputPort(inputPort.portModel);
        };
        ExperimentViewModel.prototype.createModule = function (module_, x, y) {
            if (x === void 0) { x = 0; }
            if (y === void 0) { y = 0; }
            if (this.readOnlyMode()) {
                return null;
            }
            var node = new DataLab.Model.ModuleNode(module_, this.workspace);
            node.x(x);
            node.y(y);
            var viewModel = new ExperimentEditor.Module(node, this.workspace);
            this.tempNodes.put(node.id, viewModel);
            return viewModel;
        };
        ExperimentViewModel.prototype.createDataset = function (dataset, x, y) {
            if (x === void 0) { x = 0; }
            if (y === void 0) { y = 0; }
            if (this.readOnlyMode()) {
                return null;
            }
            var node = new DataLab.Model.DatasetNode(dataset);
            node.x(x);
            node.y(y);
            var viewModel = new ExperimentEditor.Dataset(node);
            this.tempNodes.put(node.id, viewModel);
            return viewModel;
        };
        ExperimentViewModel.prototype.createTrainedModel = function (trainedModel, x, y) {
            if (x === void 0) { x = 0; }
            if (y === void 0) { y = 0; }
            if (this.readOnlyMode()) {
                return null;
            }
            var node = new DataLab.Model.TrainedModelNode(trainedModel);
            node.x(x);
            node.y(y);
            var viewModel = new ExperimentEditor.TrainedModel(node);
            this.tempNodes.put(node.id, viewModel);
            return viewModel;
        };
        ExperimentViewModel.prototype.createTransformModule = function (transform, x, y) {
            if (x === void 0) { x = 0; }
            if (y === void 0) { y = 0; }
            if (this.readOnlyMode()) {
                return null;
            }
            var node = new DataLab.Model.TransformNode(transform);
            node.x(x);
            node.y(y);
            var viewModel = new ExperimentEditor.Transform(node);
            this.tempNodes.put(node.id, viewModel);
            return viewModel;
        };
        ExperimentViewModel.prototype.createWebServicePort = function (type, x, y) {
            var _this = this;
            if (x === void 0) { x = 0; }
            if (y === void 0) { y = 0; }
            if (this.readOnlyMode()) {
                return null;
            }
            var node = new DataLab.Model.WebServicePortNode(type, null, function (portType) { return _this.experiment.getWebServicePortNodes(portType); }, this.workspace.applicationCache.dataTypeRegistry);
            node.x(x);
            node.y(y);
            var viewModel = new ExperimentEditor.WebServicePort(node);
            this.tempNodes.put(node.id, viewModel);
            return viewModel;
        };
        /**
          * Remove a graph node view model from the staging pool of view models and commit it to the experiment
          * @param {GraphNodeViewModel} node the view model for the node to commit
          * @return {GraphNodeViewModel} the view model for the committed node
         **/
        ExperimentViewModel.prototype.addNode = function (node) {
            // Add the node to the experiment model and remove it from the set of temporary
            // view models
            this.tempNodes.remove(node.graphNode.id);
            if (DataLab.Features.trialLimitationsEnabled() && node.graphNode instanceof DataLab.Model.ModuleNode) {
                var module_ = node.graphNode.module_;
                if (!DataLab.Trial.isNumberOfModulesUnrestricted() && this.experiment.getNumberOfModules() >= DataLab.Trial.getMaxNumberOfModules()) {
                    Shell.Diagnostics.Telemetry.featureUsage(60 /* ExceededModuleCountLimit */, 56 /* TrialFeature */, this.workspace.id, this.experiment.experimentId(), module_.id, module_.name());
                    ExperimentEditor.showExceededNumberOfModulesLimitDialog();
                    return null;
                }
                else if (!DataLab.Trial.isModuleEnabledById(module_.familyId)) {
                    Shell.Diagnostics.Telemetry.featureUsage(58 /* DisabledModule */, 56 /* TrialFeature */, this.workspace.id, this.experiment.experimentId(), module_.id, module_.name());
                    ExperimentEditor.showDisabledModuleDialog(module_.familyId, module_.name());
                    return null;
                }
            }
            this.experiment.addNode(node.graphNode);
            return this.getViewModelForNode(node.graphNode);
        };
        ExperimentViewModel.prototype.removeSelected = function () {
            var _this = this;
            if (this.readOnlyMode()) {
                return;
            }
            // Delete connections before modules and datasets so we don't get referenceing issues when
            // disconnecting modules. Also, do it using batch updates to make things faster.
            this.connections.modify(function () {
                DataLab.Util.forEach(_this.connections(), function (e) {
                    if (e.selected()) {
                        e.remove();
                    }
                });
            });
            this.connections.modify(function () {
                DataLab.Util.forEach(_this.nodes(), function (e) {
                    if (e.selected()) {
                        e.remove();
                    }
                });
            });
        };
        ExperimentViewModel.prototype.editSelected = function () {
            if (this.readOnlyMode()) {
                return;
            }
            DataLab.Util.forEach(this.nodes(), function (graphNode) {
                if (graphNode.selected()) {
                    graphNode.editComment();
                    return;
                }
            });
        };
        // This function returns the first entity it finds at the point (x,y) which is
        // not necessarily the entity with highest Z-level.
        ExperimentViewModel.prototype.findEntityAtPoint = function (x, y) {
            var entities = this.selectableEntities();
            for (var n in entities) {
                var h = entities[n].entityAtPoint(x, y);
                if (h !== null && h.containsPoint(x, y)) {
                    return h;
                }
            }
            return null;
        };
        ExperimentViewModel.prototype.getViewModelForNode = function (node) {
            var nodeViewModel = this.nodes.lookup(node.id);
            if (nodeViewModel.graphNode !== node) {
                throw "Node viewmodel does not wrap the expected model";
            }
            return nodeViewModel;
        };
        ExperimentViewModel.prototype.getViewModelForPort = function (port) {
            var portNodeViewModel = this.getViewModelForNode(port.parent);
            var portViewModel = portNodeViewModel.ports[port.name];
            if (portViewModel.portModel !== port) {
                throw "Port viewmodel does not wrap the expected model";
            }
            return portViewModel;
        };
        ExperimentViewModel.prototype.isSampleExperiment = function () {
            var environment = window.environment;
            if (environment && environment.globalWorkspaceId) {
                var regex = new RegExp("^" + window.environment.globalWorkspaceId);
                return regex.test(this.experiment.experimentId());
            }
            return false;
        };
        ExperimentViewModel.prototype.displayFlowToggle = function () {
            this.displayFlowType(this.displayFlowType() === ExperimentEditor.Constants.ExperimentDataFlowType.Experiment ? ExperimentEditor.Constants.ExperimentDataFlowType.WebService : ExperimentEditor.Constants.ExperimentDataFlowType.Experiment);
        };
        ExperimentViewModel.prototype.createNodeViewModel = function (node) {
            if (node instanceof DataLab.Model.ModuleNode) {
                return new ExperimentEditor.Module(node, this.workspace);
            }
            else if (node instanceof DataLab.Model.DatasetNode) {
                return new ExperimentEditor.Dataset(node);
            }
            else if (node instanceof DataLab.Model.TrainedModelNode) {
                return new ExperimentEditor.TrainedModel(node);
            }
            else if (node instanceof DataLab.Model.TransformNode) {
                return new ExperimentEditor.Transform(node);
            }
            else if (node instanceof DataLab.Model.WebServicePortNode) {
                return new ExperimentEditor.WebServicePort(node);
            }
            else {
                throw "Unknown graph node type.";
            }
        };
        ExperimentViewModel.prototype.addConnection = function (inputPort, outputPort) {
            var c = new ExperimentEditor.Connection(inputPort, outputPort);
            if (this.connections.lookup(c.key) !== undefined) {
                throw "Connection already exists for the given port pair";
            }
            this.connections.put(c.key, c);
            inputPort.addConnection(c);
            outputPort.addConnection(c);
            return c;
        };
        ExperimentViewModel.prototype.removeConnection = function (inputPort, outputPort) {
            var k = ExperimentEditor.Connection.getConnectionKeyForPorts(inputPort, outputPort);
            var c = this.connections.lookup(k);
            if (c === undefined) {
                throw "Connection doest not exist for the given port pair";
            }
            this.connections.remove(k);
            inputPort.removeConnection(c);
            outputPort.removeConnection(c);
            return c;
        };
        return ExperimentViewModel;
    })(DataLab.Util.Disposable);
    ExperimentEditor.ExperimentViewModel = ExperimentViewModel;
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
/// <reference path="PortViewModel.ts" />
var ExperimentEditor;
(function (ExperimentEditor) {
    // A utility class to create connection.
    // A connection is a virtual link created between two ports 
    // This class is instantiated when the user drags a connection between ports
    // This class may be hiding a connection from the user
    // (p0, p1) such that the ICompatible::isCompatible(p1, p2) is true.
    var Connector = (function () {
        /**
          * Creates a connector that manages state when connecting ports.
          * @constructor
         **/
        function Connector() {
            this.x1 = ko.observable(0);
            this.y1 = ko.observable(0);
            this.x2 = ko.observable(0);
            this.y2 = ko.observable(0);
            this.counter = ko.observable(0);
            this.visible = ko.observable(false);
            this.isPreview = ko.observable(true);
            this.translation = ko.computed(function () {
                return "translate(" + (this.x2() - ExperimentEditor.Constants.Port.HalfWidth) + "," + (this.y2()) + ")";
            }, this);
            this.controlPointDistance = ko.computed(function () {
                var d = Math.min(ExperimentEditor.Constants.Connector.SplinePointMax, Math.max(ExperimentEditor.Constants.Connector.SplinePointMin, Math.abs(((this.y2() - (this.y1())) / 2))));
                return (this.snappedPort instanceof ExperimentEditor.OutputPort) ? -d : d;
            }, this);
            this.path = ko.computed(function () {
                return ("M" + (this.x2()) + "," + this.y2() + "C " + (this.x2()) + "," + (this.y2() - this.controlPointDistance()) + "," + (this.x1()) + "," + (this.y1() + this.controlPointDistance()) + "," + (this.x1()) + "," + (this.y1()));
            }, this);
            this.p0 = null;
            this.p1 = null;
            this.hiddenConnection = null;
            this.snappedPort = null;
        }
        Connector.prototype.onMouseMove = function (x, y, entity) {
            var _this = this;
            // Update x2y2 position of the connector
            if (entity) {
                // Our candidate port is null when the user is over the canvas or a connection and a port
                // when the mouseover a port or graph node
                var candidatePort = null;
                if (entity instanceof ExperimentEditor.GraphNodeViewModel) {
                    candidatePort = this.p0 instanceof ExperimentEditor.InputPort ? entity.findClosestOutputPort(x, y) : entity.findClosestInputPort(x, y);
                }
                else if (entity instanceof ExperimentEditor.InputPort || entity instanceof ExperimentEditor.OutputPort) {
                    candidatePort = entity;
                }
                // Clear the balloon message on the last port we hovered over
                if (this.lastCandidatePort && this.lastCandidatePort !== candidatePort) {
                    this.lastCandidatePort.balloonMessage(null);
                }
                // If the port is compatible and legal, snap to it and stop processing. Otherwise, 
                // update the error balloon, unsnap any existing connection, and track the 
                // coordinates to the mouse
                if (candidatePort && candidatePort.portModel.isCompatible(this.p0.portModel)) {
                    this.snapToPort(candidatePort);
                    candidatePort.parent.portState(DataLab.Model.Constants.PortState.CompatibleSnapped);
                    return;
                }
                else if (candidatePort) {
                    this.setCandidatePort(candidatePort);
                    // No balloons when trying to connect to the same module or two ports of the same type.
                    if (candidatePort.portModel.parent === this.p0.portModel.parent || candidatePort instanceof ExperimentEditor.OutputPort && this.p0 instanceof ExperimentEditor.OutputPort || candidatePort instanceof ExperimentEditor.InputPort && this.p0 instanceof ExperimentEditor.InputPort) {
                        candidatePort.balloonMessage(null);
                    }
                    else {
                        candidatePort.parent.portState(DataLab.Model.Constants.PortState.Incompatible);
                        candidatePort.balloonMessage("Cannot connect " + this.p0.portTypes + " to " + candidatePort.portTypes + ".");
                    }
                }
            }
            else {
                if (this.snappedPort) {
                    this.snappedPort.parent.portState(DataLab.Model.Constants.PortState.Compatible);
                }
                if (this.lastCandidatePort) {
                    var firstCompatiblePort = DataLab.Util.first(this.lastCandidatePort.parent.ports, function (currentPort) {
                        return _this.p0.portModel.compatibilityWithPort(currentPort.portModel) === DataLab.Model.Constants.PortState.Compatible;
                    }, null);
                    if (firstCompatiblePort) {
                        this.lastCandidatePort.parent.portState(DataLab.Model.Constants.PortState.Compatible);
                    }
                    else {
                        this.lastCandidatePort.parent.portState(DataLab.Model.Constants.PortState.Default);
                    }
                }
                this.setCandidatePort(null);
            }
            this.unsnap();
            this.x2(x);
            this.y2(y - ExperimentEditor.Constants.Port.HalfHeight);
            this.isPreview(false);
        };
        Connector.prototype.reset = function () {
            this.p0 = null;
            this.p1 = null;
            this.visible(false);
            this.x1(0);
            this.y1(0);
            this.x2(0);
            this.y2(0);
            this.counter(0);
            this.isPreview(true);
            this.showHiddenConnection();
            this.setCandidatePort(null);
            this.lastCandidatePort = null;
        };
        /**
          * Starts a connection.
          * @param {PortViewModel} source The first port for the connection
         **/
        Connector.prototype.startConnection = function (source) {
            if (!source) {
                throw new Error("Source port isn't a port view model.");
            }
            this.p0 = source;
            // Update x1y1 position of the connector
            this.x1(source.getCX());
            this.y1(source.getCY());
            this.x2(source.getCX());
            this.y2(source.getCY());
            this.visible(true);
            this.counter(this.counter() + 1);
            this.snappedPort = null;
            this.showHiddenConnection();
            this.setCandidatePort(null);
        };
        /**
          * Ends a connection.
          * @param {Entity} destination The entity the user ended the connection on. If the entity is a valid
                            port or module with a valid port, the connection will finalize.
          * @param {number} x The domain x coordinate where the connection ended.
          * @param {number} y The domain y coordinate where the connection ended.
         **/
        Connector.prototype.endConnection = function (destination, x, y) {
            if (destination instanceof ExperimentEditor.GraphNodeViewModel || destination instanceof ExperimentEditor.PortViewModel) {
                if (destination instanceof ExperimentEditor.GraphNodeViewModel) {
                    this.p1 = this.p0 instanceof ExperimentEditor.InputPort ? destination.findClosestOutputPort(x, y) : destination.findClosestInputPort(x, y);
                }
                else {
                    this.p1 = destination;
                }
                if (this.p1) {
                    var compatibility = this.p0.portModel.compatibilityWithPort(this.p1.portModel);
                    if (this.p0.portModel.isWebServicePort || this.p1.portModel.isWebServicePort) {
                        var webServicePort = this.p0.portModel.isWebServicePort ? this.p0 : this.p1;
                        var connectedPort = webServicePort === this.p0 ? this.p1 : this.p0;
                        if (compatibility === DataLab.Model.Constants.PortState.Compatible || compatibility === DataLab.Model.Constants.PortState.Replaceable) {
                            webServicePort.portModel.disconnect(webServicePort.portModel.connectedNonWebServicePorts());
                            connectedPort.portModel.disconnect(connectedPort.portModel.connectedWebServicePorts());
                            webServicePort.portModel.connectTo(connectedPort.portModel);
                        }
                    }
                    else if (compatibility === DataLab.Model.Constants.PortState.Compatible) {
                        // Input ports can only have one thing connected at a time, so we should 
                        // see if our source port is an input port and already has a connection, removing
                        // it if so.
                        if (this.p0 instanceof ExperimentEditor.InputPort && this.p0.portModel.isConnected()) {
                            this.p0.portModel.disconnect(this.p0.portModel.connectedNonWebServicePorts());
                        }
                        this.p0.portModel.connectTo(this.p1.portModel);
                    }
                    else if (compatibility === DataLab.Model.Constants.PortState.Replaceable) {
                        this.p1.portModel.disconnect(this.p1.portModel.connectedNonWebServicePorts());
                        this.p0.portModel.connectTo(this.p1.portModel);
                    }
                }
            }
            this.reset();
        };
        Connector.prototype.snapToPort = function (port) {
            this.snappedPort = port;
            this.x2((this.snappedPort).getCX());
            this.y2((this.snappedPort).getCY());
            this.isPreview(true);
            // Skip hide connection for web service port
            if (this.p0.portModel.isWebServicePort || port.portModel.isWebServicePort) {
                return;
            }
            var connectionToHide = null;
            // input port only supports 1 non web service connection
            if (this.snappedPort instanceof ExperimentEditor.InputPort) {
                connectionToHide = this.snappedPort.connections()[0];
            }
            else {
                connectionToHide = this.p0.connections()[0];
            }
            if (connectionToHide) {
                this.hideConnection(connectionToHide);
            }
            else {
                this.showHiddenConnection();
            }
        };
        Connector.prototype.unsnap = function () {
            this.snappedPort = null;
            this.showHiddenConnection();
        };
        /**
          * Shows any existing hidden connection
         **/
        Connector.prototype.showHiddenConnection = function () {
            if (this.hiddenConnection) {
                this.hiddenConnection.hidden(false);
                this.hiddenConnection = null;
            }
        };
        /**
          * Shows the existing hidden connection and hides the specified connection.
          * @param {Connection} connection the connection to hide
         **/
        Connector.prototype.hideConnection = function (connection) {
            this.showHiddenConnection();
            this.hiddenConnection = connection;
            this.hiddenConnection.hidden(true);
        };
        Connector.prototype.setCandidatePort = function (port) {
            if (this.lastCandidatePort) {
                this.lastCandidatePort.balloonMessage(null);
            }
            this.lastCandidatePort = port;
        };
        return Connector;
    })();
    ExperimentEditor.Connector = Connector;
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="PortViewModel.ts" />
/// <reference path="Entity.ts" />
/// <reference path="../../Global.ts" />
/// <reference path="ExperimentEditorViewModel.ts" />
/// <reference path="SelectionManager.ts" />
/// <reference path="Help.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var ExperimentEditor;
(function (ExperimentEditor) {
    var XEInteractionClasses;
    (function (XEInteractionClasses) {
        XEInteractionClasses.PanMode = "panMode ";
        XEInteractionClasses.Panning = "panning ";
        XEInteractionClasses.Idle = "idle ";
        XEInteractionClasses.MovingEntities = "movingEntities ";
        XEInteractionClasses.MakingConnection = "makingConnection ";
        XEInteractionClasses.MultiSelecting = "multiSelecting ";
    })(XEInteractionClasses = ExperimentEditor.XEInteractionClasses || (ExperimentEditor.XEInteractionClasses = {}));
    (function (XEInteractionAction) {
        XEInteractionAction[XEInteractionAction["MouseDown"] = 0] = "MouseDown";
        XEInteractionAction[XEInteractionAction["MouseUp"] = 1] = "MouseUp";
        XEInteractionAction[XEInteractionAction["MouseMove"] = 2] = "MouseMove";
        XEInteractionAction[XEInteractionAction["PanButtonClicked"] = 3] = "PanButtonClicked";
        XEInteractionAction[XEInteractionAction["DeleteKeyPressed"] = 4] = "DeleteKeyPressed";
        XEInteractionAction[XEInteractionAction["EscapeKeyPressed"] = 5] = "EscapeKeyPressed";
        XEInteractionAction[XEInteractionAction["ShiftAPressed"] = 6] = "ShiftAPressed";
        XEInteractionAction[XEInteractionAction["F2KeyPressed"] = 7] = "F2KeyPressed";
        XEInteractionAction[XEInteractionAction["ControlXPressed"] = 8] = "ControlXPressed";
        XEInteractionAction[XEInteractionAction["SpacebarDown"] = 9] = "SpacebarDown";
        XEInteractionAction[XEInteractionAction["SpacebarUp"] = 10] = "SpacebarUp";
    })(ExperimentEditor.XEInteractionAction || (ExperimentEditor.XEInteractionAction = {}));
    var XEInteractionAction = ExperimentEditor.XEInteractionAction;
    (function (DraggingMode) {
        DraggingMode[DraggingMode["None"] = 0] = "None";
        DraggingMode[DraggingMode["Entities"] = 1] = "Entities";
        DraggingMode[DraggingMode["Connection"] = 2] = "Connection";
        DraggingMode[DraggingMode["SelectionRect"] = 3] = "SelectionRect";
    })(ExperimentEditor.DraggingMode || (ExperimentEditor.DraggingMode = {}));
    var DraggingMode = ExperimentEditor.DraggingMode;
    var Constants;
    (function (Constants) {
        var XEStateMachine;
        (function (XEStateMachine) {
            XEStateMachine.ConnectionPendingThreshhold = 5;
        })(XEStateMachine = Constants.XEStateMachine || (Constants.XEStateMachine = {}));
    })(Constants = ExperimentEditor.Constants || (ExperimentEditor.Constants = {}));
    // This is the state machine for handling user actions in the experiment editor. It tracks a user's intent,
    // such as making a connection or dragging a rectangle by handling actions, such as mouse up or down on various objects.
    // We extend disposable so we can use helicoptor mode in leakmaster to remove references to the XEViewModel.
    var XEInteractionStateMachine = (function (_super) {
        __extends(XEInteractionStateMachine, _super);
        function XEInteractionStateMachine(viewModel) {
            var _this = this;
            _super.call(this);
            this.viewModel = viewModel;
            this.lastMouseCoords = { x: 0, y: 0, matrixTransform: null };
            this.lastDomainCoords = { x: 0, y: 0, matrixTransform: null };
            this.mouseDownCoords = { x: 0, y: 0, matrixTransform: null };
            this.mouseDownEvent = null;
            this.panModeOn = ko.observable(false);
            this.leftMousePanning = ko.observable(false);
            this.centerMousePanning = ko.observable(false);
            this.spacebarHeld = ko.observable(false);
            this.dragging = ko.observable(0 /* None */);
            this.connectionDragPending = ko.observable(false);
            this.atRest = ko.computed(function () {
                return _this.centerMousePanning() === false && _this.dragging() === 0 /* None */ && _this.leftMousePanning() === false;
            });
            this.classes = ko.computed(function () {
                var result = (_this.panModeOn() || _this.spacebarHeld() ? XEInteractionClasses.PanMode : "") + (_this.centerMousePanning() || _this.leftMousePanning() ? XEInteractionClasses.Panning : "");
                switch (_this.dragging()) {
                    case 1 /* Entities */:
                        result += XEInteractionClasses.MovingEntities;
                        break;
                    case 2 /* Connection */:
                        result += XEInteractionClasses.MakingConnection;
                        break;
                    case 3 /* SelectionRect */:
                        result += XEInteractionClasses.MultiSelecting;
                        break;
                    default:
                        result += XEInteractionClasses.Idle;
                        break;
                }
                return result;
            });
        }
        XEInteractionStateMachine.prototype.handleAction = function (action, e, relevantEntity) {
            var _this = this;
            if (e === void 0) { e = null; }
            if (relevantEntity === void 0) { relevantEntity = null; }
            var domainCoords;
            var dx;
            var dy;
            var domainDx;
            var domainDy;
            if (e) {
                domainCoords = this.viewModel.coordinateConverter.clientToDomainCoordinates(e.clientX, e.clientY);
                dx = e.clientX - this.lastMouseCoords.x;
                dy = e.clientY - this.lastMouseCoords.y;
                domainDx = domainCoords.x - this.lastDomainCoords.x;
                domainDy = domainCoords.y - this.lastDomainCoords.y;
            }
            switch (action) {
                case 0 /* MouseDown */:
                    if (e.target && e.target.getAttribute("outputlabel") && !(e.button !== 0 /* Left */ || this.panModeOn() || this.spacebarHeld())) {
                        this.connectionDragPending(true); // This is to handle output port labels specifically
                    }
                    else {
                        this.connectionDragPending(false);
                    }
                    if (e.button === 1 /* Center */) {
                        this.centerMousePanning(true);
                    }
                    else if (e.button === 0 /* Left */) {
                        if (relevantEntity instanceof ExperimentEditor.Module) {
                            // familyId may not exist on all modules (particularly, built in ones like AzureBlobReference). As such,
                            // we get the family id from center element of the id.
                            ExperimentEditor.Help.setHelpContent(relevantEntity.moduleNode.module_.description(), DataLab.Util.resurrectDashesInGUID(relevantEntity.moduleNode.module_.id.split(".")[1]), relevantEntity.moduleNode.module_.name());
                        }
                        else if (relevantEntity instanceof ExperimentEditor.Dataset) {
                            ExperimentEditor.Help.setHelpContent(relevantEntity.datasetNode.dataset.description(), null, relevantEntity.datasetNode.dataset.name());
                        }
                        else if (relevantEntity instanceof ExperimentEditor.WebServicePort) {
                            ExperimentEditor.Help.setHelpContent(relevantEntity.webServicePortNode.description, null, relevantEntity.webServicePortNode.name);
                        }
                        else if (!relevantEntity) {
                            ExperimentEditor.Help.setHelpContent("");
                        }
                        if (this.panModeOn() || this.spacebarHeld()) {
                            this.leftMousePanning(true);
                        }
                        else if (this.dragging() === 0 /* None */) {
                            if (relevantEntity instanceof ExperimentEditor.PortViewModel) {
                                Shell.Diagnostics.Telemetry.customEvent("Port_StartConnection", "Dragging", JSON.stringify(relevantEntity.portModel.descriptor));
                                this.viewModel.startConnection(relevantEntity);
                                this.dragging(2 /* Connection */);
                            }
                            else if (relevantEntity instanceof ExperimentEditor.GraphNodeViewModel || relevantEntity instanceof ExperimentEditor.Connection) {
                                if (e.ctrlKey ? !e.shiftKey : e.shiftKey) {
                                    this.viewModel.selectionManager.toggleEntitySelection(relevantEntity);
                                }
                                else {
                                    if (!relevantEntity.selected()) {
                                        this.viewModel.selectionManager.modifySelection(function () {
                                            _this.viewModel.selectionManager.resetSelection();
                                            _this.viewModel.selectionManager.selectEntity(relevantEntity);
                                        });
                                    }
                                    else {
                                        this.viewModel.selectionManager.selectEntity(relevantEntity);
                                    }
                                }
                                this.dragging(1 /* Entities */);
                            }
                            else if (relevantEntity === null) {
                                if (!e.shiftKey) {
                                    this.viewModel.selectionManager.resetSelection();
                                }
                                this.viewModel.beginMultiSelect(domainCoords);
                                this.dragging(3 /* SelectionRect */);
                            }
                        }
                    }
                    else if (e.button === 2 /* Right */) {
                        if (relevantEntity instanceof ExperimentEditor.Module) {
                            // familyId may not exist on all modules (particularly, built in ones like AzureBlobReference). As such,
                            // we get the family id from center element of the id.
                            ExperimentEditor.Help.setHelpContent(relevantEntity.moduleNode.module_.description(), DataLab.Util.resurrectDashesInGUID(relevantEntity.moduleNode.module_.id.split(".")[1]), relevantEntity.moduleNode.module_.name());
                        }
                        else if (relevantEntity instanceof ExperimentEditor.Dataset) {
                            ExperimentEditor.Help.setHelpContent(relevantEntity.datasetNode.dataset.description(), null, relevantEntity.datasetNode.dataset.name());
                        }
                        else if (relevantEntity instanceof ExperimentEditor.GraphNodeViewModel || relevantEntity instanceof ExperimentEditor.Connection) {
                            if (!relevantEntity.selected()) {
                                this.viewModel.selectionManager.modifySelection(function () {
                                    _this.viewModel.selectionManager.resetSelection();
                                    _this.viewModel.selectionManager.selectEntity(relevantEntity);
                                });
                            }
                        }
                        else if (!relevantEntity) {
                            ExperimentEditor.Help.setHelpContent("");
                        }
                    }
                    else {
                        return;
                    }
                    this.mouseDownCoords = domainCoords;
                    this.mouseDownEvent = e;
                    this.mouseDownEntity = relevantEntity;
                    break;
                case 1 /* MouseUp */:
                    if (e.button === 1 /* Center */) {
                        this.centerMousePanning(false);
                    }
                    else if (e.button === 0 /* Left */) {
                        if (this.leftMousePanning()) {
                            this.leftMousePanning(false);
                        }
                        else {
                            switch (this.dragging()) {
                                case 2 /* Connection */:
                                    this.viewModel.endConnection(relevantEntity, domainCoords);
                                    break;
                                case 3 /* SelectionRect */:
                                    this.viewModel.endMultiSelect(domainCoords);
                                    break;
                            }
                            this.dragging(0 /* None */);
                        }
                    }
                    else {
                        return;
                    }
                    break;
                case 3 /* PanButtonClicked */:
                    this.panModeOn(!this.panModeOn());
                    break;
                case 2 /* MouseMove */:
                    if (this.leftMousePanning() || this.centerMousePanning() || this.spacebarHeld()) {
                        this.viewModel.panResponder.pan(dx, dy);
                        break;
                    }
                    else if (this.connectionDragPending()) {
                        var xDist = this.mouseDownEvent.clientX - e.clientX;
                        var yDist = this.mouseDownEvent.clientY - e.clientY;
                        // If we're more than k pixels from where the mousedown was, start dragging a connection.
                        if (Math.sqrt(xDist * xDist + yDist * yDist) > Constants.XEStateMachine.ConnectionPendingThreshhold) {
                            this.connectionDragPending(false);
                            this.viewModel.startConnection(this.mouseDownEntity);
                            this.dragging(2 /* Connection */);
                        }
                    }
                    switch (this.dragging()) {
                        case 1 /* Entities */:
                            this.viewModel.moveEntities(domainDx, domainDy);
                            break;
                        case 2 /* Connection */:
                            this.viewModel.moveConnection(domainCoords);
                            break;
                        case 3 /* SelectionRect */:
                            this.viewModel.updateMultiSelect(domainCoords);
                            break;
                    }
                    break;
                case 5 /* EscapeKeyPressed */:
                    switch (this.dragging()) {
                        case 3 /* SelectionRect */:
                            this.viewModel.selectionManager.cancelRectSelection();
                            this.dragging(0 /* None */);
                            break;
                        case 2 /* Connection */:
                            this.viewModel.cancelConnection();
                            this.dragging(0 /* None */);
                            break;
                        case 1 /* Entities */:
                            var originalCoords = {
                                x: this.mouseDownCoords.x - this.lastDomainCoords.x,
                                y: this.mouseDownCoords.y - this.lastDomainCoords.y,
                                matrixTransform: null
                            };
                            this.viewModel.moveEntities(originalCoords.x, originalCoords.y);
                            this.dragging(0 /* None */);
                            break;
                        default:
                            this.viewModel.selectionManager.resetSelection();
                    }
                    break;
                case 6 /* ShiftAPressed */:
                    this.viewModel.selectionManager.selectAll();
                    break;
                case 4 /* DeleteKeyPressed */:
                    if (this.atRest()) {
                        this.viewModel.removeSelected();
                    }
                    break;
                case 7 /* F2KeyPressed */:
                    if (this.atRest()) {
                        this.viewModel.editSelected();
                    }
                    break;
                case 8 /* ControlXPressed */:
                    if (this.atRest()) {
                        this.viewModel.cut();
                    }
                    break;
                case 9 /* SpacebarDown */:
                    this.spacebarHeld(true);
                    break;
                case 10 /* SpacebarUp */:
                    this.spacebarHeld(false);
                    break;
                default:
            }
            if (e) {
                domainCoords = this.viewModel.coordinateConverter.clientToDomainCoordinates(e.clientX, e.clientY);
                this.lastMouseCoords = { x: e.clientX, y: e.clientY, matrixTransform: null };
                this.lastDomainCoords = { x: domainCoords.x, y: domainCoords.y, matrixTransform: null };
            }
        };
        return XEInteractionStateMachine;
    })(DataLab.Util.Disposable);
    ExperimentEditor.XEInteractionStateMachine = XEInteractionStateMachine;
})(ExperimentEditor || (ExperimentEditor = {}));





/// <reference path="../../../Global.ts" />
var ExperimentEditor;
(function (ExperimentEditor) {
    var Command = (function () {
        function Command(experimentViewModel) {
            if (!experimentViewModel) {
                throw "Commands must operate on an experiment";
            }
            this.experimentEditorViewModel = experimentViewModel;
            this.experiment = this.experimentEditorViewModel.experimentViewModel().experiment;
        }
        Command.prototype.run = function () {
            throw "Command doesn't have a defined run function";
        };
        Command.prototype.undo = function () {
            throw "Command doesn't have a defined undo function";
        };
        return Command;
    })();
    ExperimentEditor.Command = Command;
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="Command.ts" />
/// <reference path="../../../Global.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var ExperimentEditor;
(function (ExperimentEditor) {
    var AddNodesCommand = (function (_super) {
        __extends(AddNodesCommand, _super);
        function AddNodesCommand(nodesToAdd, experimentViewModel) {
            _super.call(this, experimentViewModel);
            this.nodesToAdd = nodesToAdd;
        }
        AddNodesCommand.prototype.run = function () {
            var _this = this;
            this.experiment.nodes.modify(function () {
                _this.nodesToAdd.forEach(function (node) {
                    _this.experiment.addNode(node, node.x(), node.y());
                });
            });
        };
        AddNodesCommand.prototype.undo = function () {
            var _this = this;
            this.experiment.nodes.modify(function () {
                _this.nodesToAdd.forEach(function (node) {
                    node.remove();
                });
            });
        };
        return AddNodesCommand;
    })(ExperimentEditor.Command);
    ExperimentEditor.AddNodesCommand = AddNodesCommand;
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="Command.ts" />
/// <reference path="../ExperimentEditorViewModel.ts" />
/// <reference path="../../../Global.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var ExperimentEditor;
(function (ExperimentEditor) {
    var AddConnectionsCommand = (function (_super) {
        __extends(AddConnectionsCommand, _super);
        function AddConnectionsCommand(connections, experimentViewModel) {
            _super.call(this, experimentViewModel);
            this._connections = connections;
        }
        Object.defineProperty(AddConnectionsCommand.prototype, "connections", {
            get: function () {
                return this._connections;
            },
            enumerable: true,
            configurable: true
        });
        AddConnectionsCommand.prototype.run = function () {
            var _this = this;
            var viewModel = this.experimentEditorViewModel.experimentViewModel();
            viewModel.connections.modify(function () {
                _this._connections.forEach(function (connectionTuple) {
                    connectionTuple.inputPort.connectTo(connectionTuple.outputPort);
                    var experimentViewModel = _this.experimentEditorViewModel.experimentViewModel();
                    var key = ExperimentEditor.Connection.getConnectionKeyForPorts(experimentViewModel.getViewModelForPort(connectionTuple.inputPort), experimentViewModel.getViewModelForPort(connectionTuple.outputPort));
                });
            });
        };
        AddConnectionsCommand.prototype.undo = function () {
            var _this = this;
            var viewModel = this.experimentEditorViewModel.experimentViewModel();
            viewModel.connections.modify(function () {
                _this._connections.forEach(function (connectionTuple) {
                    connectionTuple.inputPort.disconnectFrom(connectionTuple.outputPort);
                });
            });
        };
        return AddConnectionsCommand;
    })(ExperimentEditor.Command);
    ExperimentEditor.AddConnectionsCommand = AddConnectionsCommand;
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="Command.ts" />
/// <reference path="AddNodesCommand.ts" />
/// <reference path="AddConnectionsCommand.ts" />
/// <reference path="../../../Global.ts" />
/// <reference path="../Clipboard.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var ExperimentEditor;
(function (ExperimentEditor) {
    var DataContractV2 = DataLab.DataContract.v2;
    var Model = DataLab.Model;
    var Constants;
    (function (Constants) {
        Constants.PasteCascadeX = Constants.RectWidth / 5;
        Constants.PasteCascadeY = Constants.RectHeight * 2 / 4;
        Constants.PasteBoundary = Constants.RectWidth * 2;
    })(Constants = ExperimentEditor.Constants || (ExperimentEditor.Constants = {}));
    var PasteCommand = (function (_super) {
        __extends(PasteCommand, _super);
        function PasteCommand(clipboardSubgraph, experimentViewModel, experimentBounds, viewTopLeft, workspace, validate) {
            var _this = this;
            if (validate === void 0) { validate = null; }
            _super.call(this, experimentViewModel);
            this.clipboard = clipboardSubgraph;
            this.pastedItemCount = 0;
            this.viewTopLeft = viewTopLeft;
            this.experimentBounds = experimentBounds;
            // Lazily create connection and node commands so it works properly with deferreds.
            this.addConnectionsCommand = null;
            this.addNodesCommand = null;
            this.itemsPasted = new ko.subscribable();
            this.nodesAddedPromise = DataContractV2.createNodes(clipboardSubgraph, experimentViewModel.moduleCache, experimentViewModel.datasetCache, experimentViewModel.trainedModelCache, experimentViewModel.transformModulesCache, 
            // Node lookup failure
            function (contractNode) {
                return;
            }, 
            // Generate a new node ID only when needed
            function (contractNode) {
                return _this.experimentEditorViewModel.experiment.nodes.lookup(contractNode.Id) ? null : contractNode.Id;
            }, workspace);
            if (DataLab.Features.trialLimitationsEnabled() && validate) {
                this.validate = validate;
            }
        }
        PasteCommand.prototype.run = function () {
            var _this = this;
            // When all the datasets and modules have been loaded (or not), paste them
            this.nodesAddedPromise.done(function (nodesAddedInfo) {
                if (_this.validate && !_this.validate(nodesAddedInfo)) {
                    return;
                }
                if (!_this.addNodesCommand) {
                    _this.createAddNodesCommand(nodesAddedInfo);
                }
                _this.addNodesCommand.run();
                if (!_this.addConnectionsCommand) {
                    _this.createAddConnectionsCommand(nodesAddedInfo);
                }
                _this.addConnectionsCommand.run();
                _this.selectPastedContent();
                // Notify subscribers that we pasted something
                if (_this.addNodesCommand.nodesToAdd.length > 0) {
                    _this.itemsPasted.notifySubscribers(_this.placementRect);
                }
                else {
                    _this.itemsPasted.notifySubscribers(null);
                }
            });
        };
        PasteCommand.prototype.undo = function () {
            if (this.addConnectionsCommand && this.addNodesCommand) {
                this.addConnectionsCommand.undo();
                this.addNodesCommand.undo();
            }
        };
        PasteCommand.prototype.calculatePlacement = function (nodes) {
            var preferredLocation = null;
            var topMostNode = null;
            var minHeight = Infinity;
            // Find the top most node that will be placed
            nodes.forEach(function (node) {
                if (node.y() < minHeight) {
                    minHeight = node.y();
                    topMostNode = node;
                }
            });
            var experimentRect = {
                x: this.experimentBounds.x - Constants.PasteBoundary,
                y: this.experimentBounds.y - Constants.PasteBoundary,
                width: this.experimentBounds.width + 2 * Constants.PasteBoundary,
                height: this.experimentBounds.height + 2 * Constants.PasteBoundary
            };
            // If the experiment bounds overlaps the bounds of the content to paste, paste at the native coordinates.
            // Otherwise, paste at the top-left corner of the screen.
            if (experimentRect.x < this.clipboard.X + this.clipboard.Width && experimentRect.y < this.clipboard.Y + this.clipboard.Height && experimentRect.x + experimentRect.width >= this.clipboard.X && experimentRect.y + experimentRect.height >= this.clipboard.Y) {
                preferredLocation = { x: this.clipboard.X, y: this.clipboard.Y, matrixTransform: null };
            }
            else {
                // Deep copy the top left corner
                preferredLocation = {
                    x: this.viewTopLeft.x,
                    y: this.viewTopLeft.y,
                    matrixTransform: null
                };
            }
            preferredLocation.x += topMostNode.x();
            preferredLocation.y += topMostNode.y();
            var placementPoint = this.experimentEditorViewModel.calculatePlacement(preferredLocation);
            return { x: placementPoint.x - topMostNode.x(), y: placementPoint.y - topMostNode.y(), width: this.clipboard.Width, height: this.clipboard.Height };
        };
        PasteCommand.prototype.createAddNodesCommand = function (nodesAddedInfo) {
            var _this = this;
            // Remove datasets, trained models, and transforms from the pasted set that already exist in the experiment
            DataLab.Util.forEach(nodesAddedInfo.contractToNodes, function (node) {
                if (node instanceof Model.DatasetNode && _this.experiment.getDatasetNode(node.dataset.id)) {
                    var contractId = nodesAddedInfo.nodesToContract[node.id].Id;
                    delete nodesAddedInfo.nodesToContract[node.id];
                    delete nodesAddedInfo.contractToNodes[contractId];
                }
                if (node instanceof Model.TrainedModelNode && _this.experiment.getTrainedModelNode(node.trainedModel.id)) {
                    var contractId = nodesAddedInfo.nodesToContract[node.id].Id;
                    delete nodesAddedInfo.nodesToContract[node.id];
                    delete nodesAddedInfo.contractToNodes[contractId];
                }
                if (node instanceof Model.TransformNode && _this.experiment.getTrainedModelNode(node.transform.id)) {
                    var contractId = nodesAddedInfo.nodesToContract[node.id].Id;
                    delete nodesAddedInfo.nodesToContract[node.id];
                    delete nodesAddedInfo.contractToNodes[contractId];
                }
            });
            var nodes = DataLab.Util.values(nodesAddedInfo.contractToNodes);
            if (nodes.length > 0) {
                this.placementRect = this.calculatePlacement(nodes);
                // Move all pasted nodes to the preferred location
                DataLab.Util.forEach(nodes, function (graphNode) {
                    var curNodeX = graphNode.x();
                    var curNodeY = graphNode.y();
                    graphNode.x(curNodeX + _this.placementRect.x);
                    graphNode.y(curNodeY + _this.placementRect.y);
                });
            }
            this.addNodesCommand = new ExperimentEditor.AddNodesCommand(nodes, this.experimentEditorViewModel);
        };
        PasteCommand.prototype.createAddConnectionsCommand = function (nodesAddedInfo) {
            var _this = this;
            var ingressEgressConnections = [];
            var subgraphConnections = DataContractV2.createConnections(nodesAddedInfo, function (contractPort, contractConnection) {
                var thisNode = nodesAddedInfo.contractToNodes[contractConnection.InputNodeId];
                var otherNode = _this.experiment.nodes.lookup(contractConnection.OutputNodeId);
                // If the other node exists, try to connect to it according to copy and paste rules
                if (otherNode) {
                    // Ingress connections
                    if (contractPort.IsInput) {
                        var thisPort = thisNode.inputPorts[contractPort.PortName];
                        var otherPort = otherNode.outputPorts[contractConnection.OutputPortName];
                        if (otherPort) {
                            ingressEgressConnections.push({
                                inputPort: thisPort,
                                outputPort: otherPort
                            });
                        }
                    }
                }
            });
            // Add egress connections
            this.clipboard.EgressConnections.forEach(function (connection) {
                var thisNode = nodesAddedInfo.contractToNodes[connection.OutputNodeId];
                // thisNode may not exist if it was omitted in the paste opertation due to being a redundant
                // dataset
                if (thisNode) {
                    var thisPort = thisNode.outputPorts[connection.OutputPortName];
                    var otherNode = _this.experiment.nodes.lookup(connection.InputNodeId);
                    if (otherNode) {
                        var otherPort = otherNode.inputPorts[connection.InputPortName];
                        if (otherPort && !otherPort.isConnected()) {
                            ingressEgressConnections.push({
                                inputPort: otherPort,
                                outputPort: thisPort
                            });
                        }
                    }
                }
            });
            this.addConnectionsCommand = new ExperimentEditor.AddConnectionsCommand(ingressEgressConnections.concat(subgraphConnections), this.experimentEditorViewModel);
        };
        PasteCommand.prototype.selectPastedContent = function () {
            var _this = this;
            var experimentViewModel = this.experimentEditorViewModel.experimentViewModel();
            this.experimentEditorViewModel.selectionManager.resetSelection();
            this.addNodesCommand.nodesToAdd.forEach(function (graphNode) {
                var nodeViewModel = experimentViewModel.getViewModelForNode(graphNode);
                _this.experimentEditorViewModel.selectionManager.selectEntity(nodeViewModel);
            });
            this.addConnectionsCommand.connections.forEach(function (connection) {
                var inputPortViewModel = experimentViewModel.getViewModelForPort(connection.inputPort);
                var outputPortViewModel = experimentViewModel.getViewModelForPort(connection.outputPort);
                var connectionKey = ExperimentEditor.Connection.getConnectionKeyForPorts(inputPortViewModel, outputPortViewModel);
                var connectionViewModel = experimentViewModel.connections.lookup(connectionKey);
                _this.experimentEditorViewModel.selectionManager.selectEntity(connectionViewModel);
            });
        };
        return PasteCommand;
    })(ExperimentEditor.Command);
    ExperimentEditor.PasteCommand = PasteCommand;
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="Command.ts" />
/// <reference path="../../../Global.ts" />
/// <reference path="../ExperimentEditorViewModel.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var ExperimentEditor;
(function (ExperimentEditor) {
    var DeleteConnectionCommand = (function (_super) {
        __extends(DeleteConnectionCommand, _super);
        function DeleteConnectionCommand(inputPort, outputPort, experimentViewModel) {
            _super.call(this, experimentViewModel);
            this.inputPort = inputPort;
            this.outputPort = outputPort;
        }
        DeleteConnectionCommand.prototype.run = function () {
            if (this.inputPort.isConnectedTo(this.outputPort)) {
                this.inputPort.disconnectFrom(this.outputPort);
            }
        };
        DeleteConnectionCommand.prototype.undo = function () {
            this.inputPort.connectTo(this.outputPort);
            var experimentViewModel = this.experimentEditorViewModel.experimentViewModel();
            var key = ExperimentEditor.Connection.getConnectionKeyForPorts(experimentViewModel.getViewModelForPort(this.inputPort), experimentViewModel.getViewModelForPort(this.outputPort));
            this.experimentEditorViewModel.selectionManager.selectEntity(experimentViewModel.connections.lookup[key]);
        };
        return DeleteConnectionCommand;
    })(ExperimentEditor.Command);
    ExperimentEditor.DeleteConnectionCommand = DeleteConnectionCommand;
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="DeleteConnectionCommand.ts" />
/// <reference path="../../../Global.ts" />
/// <reference path="../ExperimentEditorViewModel.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var ExperimentEditor;
(function (ExperimentEditor) {
    var DeleteNodesCommand = (function (_super) {
        __extends(DeleteNodesCommand, _super);
        function DeleteNodesCommand(nodesToDelete, experimentEditorViewModel) {
            var _this = this;
            _super.call(this, experimentEditorViewModel);
            this.deletedNodes = [];
            this.deleteConnectionCommands = [];
            nodesToDelete.forEach(function (node) {
                DataLab.Util.forEach(node.inputPorts, function (inputPort) {
                    DataLab.Util.forEach(inputPort.connectedPorts(), function (outputPort) {
                        _this.deleteConnectionCommands.push(new ExperimentEditor.DeleteConnectionCommand(inputPort, outputPort, _this.experimentEditorViewModel));
                    });
                });
                DataLab.Util.forEach(node.outputPorts, function (outputPort) {
                    DataLab.Util.forEach(outputPort.connectedPorts(), function (inputPort) {
                        _this.deleteConnectionCommands.push(new ExperimentEditor.DeleteConnectionCommand(inputPort, outputPort, _this.experimentEditorViewModel));
                    });
                });
                _this.deletedNodes.push(node);
            });
        }
        DeleteNodesCommand.prototype.run = function () {
            this.deleteConnectionCommands.forEach(function (command) {
                command.run();
            });
            this.deletedNodes.forEach(function (node) {
                node.remove();
            });
        };
        DeleteNodesCommand.prototype.undo = function () {
            var _this = this;
            this.deletedNodes.forEach(function (node) {
                _this.experiment.addNode(node);
            });
            this.deleteConnectionCommands.forEach(function (command) {
                command.undo();
            });
        };
        return DeleteNodesCommand;
    })(ExperimentEditor.Command);
    ExperimentEditor.DeleteNodesCommand = DeleteNodesCommand;
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="Commands/PasteCommand.ts" />
/// <reference path="Commands/DeleteNodesCommand.ts" />
/// <reference path="ExperimentEditorViewModel.ts" />
/// <reference path="../../Global.ts" />
var ExperimentEditor;
(function (ExperimentEditor) {
    var Constants;
    (function (Constants) {
        Constants.ClipboardName = "DataLabClipboard";
    })(Constants = ExperimentEditor.Constants || (ExperimentEditor.Constants = {}));
    var Clipboard;
    (function (Clipboard) {
        // Lie to IE running local pages and just use a map.
        var clipboardStorage = localStorage ? localStorage : new Object();
        /**
          * Write data to the clipboard (usually serialized objects)
          * @param {string} data the string to write into the clipboard
         **/
        function write(data) {
            clipboardStorage[Constants.ClipboardName] = data;
        }
        Clipboard.write = write;
        /**
          * Reads the clipboard contents.
          * @return {string} the string contents of the clipboard
         **/
        function read() {
            return clipboardStorage[Constants.ClipboardName];
        }
        Clipboard.read = read;
        /**
          * Removes all contents from the clipboard. Useful for testing.
          * However, this function should never be called on the actual page due
          * to assumptions we make about the clipboard lifetime.
         **/
        function clear() {
            delete clipboardStorage[Constants.ClipboardName];
        }
        Clipboard.clear = clear;
    })(Clipboard = ExperimentEditor.Clipboard || (ExperimentEditor.Clipboard = {}));
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../Global.ts" />
// There can only ever be one balloon on the canvas at any given time. Showing a new balloon 
// always hides any existing balloon.
var ExperimentEditor;
(function (ExperimentEditor) {
    var Balloon;
    (function (Balloon) {
        var balloonElement = null;
        var lastElement;
        /**
          * Show a balloon with message at the specified bounding box. Will hide the existing balloon
          * if present.
          * @param {string} message The message to display.
          * @param {SVGRect} bounds The bounding box of the object to render balloon on
         **/
        function show(message, element) {
            Balloon.hide();
            if (balloonElement !== null) {
                throw new Error("Expected balloon element to be unset after hiding");
            }
            // We create a new balloon element each time since the balloon picks a topmost z-order on creation. If we instead
            // held onto a single balloon element created at startup, it might have a lower z-order than e.g. a dialog.
            // This wouldn't be needed if balloons could properly be anchored to their owning elements.
            balloonElement = $("<div class='datalab-moduleBalloon validation'></div>").appendTo("body").fxBalloon({ position: "top" });
            if (message) {
                lastElement = element;
                balloonElement.children("div.fx-balloon-content").text(message);
                balloonElement.fxBalloon("show", element.getBoundingClientRect());
            }
        }
        Balloon.show = show;
        /**
          * Hides the current balloon, if present.
         **/
        function hide(element) {
            if (element === void 0) { element = lastElement; }
            // The second condition is for the case when mouse and keyboard have focus on different items, one with a balloon one without.
            // If one input creates the balloon, changing focus of the other should not hide the balloon unless creating another balloon.
            if (balloonElement && element === lastElement) {
                balloonElement.fxBalloon("destroy");
                balloonElement.remove();
                balloonElement = null;
            }
        }
        Balloon.hide = hide;
    })(Balloon = ExperimentEditor.Balloon || (ExperimentEditor.Balloon = {}));
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
var ExperimentEditor;
(function (ExperimentEditor) {
    var PythonNotebook;
    (function (PythonNotebook) {
        function openNotebook(workspace, targetObject, alwaysCreateNew) {
            var portModel;
            if (targetObject instanceof ExperimentEditor.OutputPort) {
                portModel = targetObject.portModel;
            }
            else if (targetObject instanceof ExperimentEditor.Dataset) {
                portModel = targetObject.datasetPort.portModel;
            }
            if (portModel == undefined) {
            }
            else {
                // TODO: Show processing message
                openNotebookForOutputPort(workspace, portModel, alwaysCreateNew, function (notebookUrl) {
                    // TODO: Hide processing message
                    var w = window.open(notebookUrl);
                    if (w) {
                        w.focus();
                    }
                    else {
                    }
                }, function (message) {
                    // TODO: Show error message
                });
            }
        }
        PythonNotebook.openNotebook = openNotebook;
        function openNotebookList(workspace) {
            // TODO: Show processing message
            authenticate(workspace.id, workspace.getUserName(), function (data) {
                // TODO: Hide processing message
                var w = window.open(data.tree_url);
                if (w) {
                    w.focus();
                }
                else {
                }
            }, function (message) {
                // TODO: Show error message
            });
        }
        PythonNotebook.openNotebookList = openNotebookList;
        function authenticate(workspaceId, userName, success, error) {
            // Post to open the notebook, once the notebook is created we post to the
            // auth url with the auth token.  Once we're authorized on the notebook (it 
            // sets a cookie) we can then successfully open the notebook.
            $.ajax({
                type: "POST",
                url: '/Notebooks/Open',
                dataType: "json",
                data: {
                    workspace: workspaceId,
                    user: userName
                }
            }).done(function (data) {
                $.ajax({
                    type: "POST",
                    url: data.auth_url,
                    dataType: "json",
                    contentType: 'text/plain',
                    xhrFields: {
                        withCredentials: true // enable setting the cookie on the cross site request...
                    }
                }).done(function () {
                    success(data);
                }).fail(function (jqXHR, textStatus, errorThrown) {
                    // TODO: this is currently necessary so that the user can access are self-signed cert, it can
                    // go away and report an error once that cert is no longer required.
                    success(data);
                    error("authenticating with the notebook server");
                });
            });
        }
        function makeDefaultNotebook(name) {
            // Returns notebook data that will be JSON'd and uploaded
            var nb = {
                metadata: { name: name },
                nbformat: 3,
                nbformat_minor: 0,
                worksheets: [{
                    cells: [{
                        cell_type: "code",
                        collapsed: false,
                        input: [
                            ""
                        ],
                        language: "python",
                        metadata: {},
                        outputs: [],
                        prompt_number: 1
                    }]
                }]
            };
            return JSON.stringify(nb);
        }
        function createOrOverwriteNotebook(apiUrl, notebooksUrl, name, success, error) {
            $.ajax({
                type: "PUT",
                url: apiUrl + "/" + name + ".ipynb",
                data: makeDefaultNotebook(name),
                contentType: "application/json",
                xhrFields: {
                    withCredentials: true // enable setting the cookie on the cross site request...
                }
            }).done(function () {
                success(notebooksUrl + "/" + encodeURIComponent(name) + ".ipynb");
            }).fail(function () {
                error("creating " + notebooksUrl + "/" + encodeURIComponent(name) + ".ipynb");
            });
        }
        function createNotebookWithUniqueName(apiUrl, notebooksUrl, notebookName, success, error) {
            // This function must have the same signature as ensureNotebookExists()
            var notebooks = $.ajax({
                type: "GET",
                dataType: "text",
                url: apiUrl,
                xhrFields: {
                    withCredentials: true // enable setting the cookie on the cross site request...
                }
            }).done(function (data) {
                var known = JSON.parse(data);
                var name = decodeURIComponent(notebookName);
                known.forEach(function (i) {
                    if (name && i.type == "notebook" && i.name == name + ".ipynb") {
                        name = null;
                    }
                });
                for (var suffix = 1; name == null; ++suffix) {
                    name = decodeURIComponent(notebookName) + " " + suffix;
                    known.forEach(function (i) {
                        if (name && i.type == "notebook" && i.name == name + ".ipynb") {
                            name = null;
                        }
                    });
                }
                createOrOverwriteNotebook(apiUrl, notebooksUrl, name, success, error);
            }).fail(function (jqHXR) {
                if (jqHXR.status == 404) {
                    // No listing, so we must be the first notebook
                    createOrOverwriteNotebook(apiUrl, notebooksUrl, notebookName, success, error);
                }
                else {
                    error("getting existing notebooks");
                }
            });
        }
        function ensureNotebookExists(apiUrl, notebooksUrl, notebookName, success, error) {
            // This function must have the same signature as createNotebookWithUniqueName()
            var notebooks = $.ajax({
                type: "GET",
                dataType: "text",
                url: apiUrl,
                xhrFields: {
                    withCredentials: true // enable setting the cookie on the cross site request...
                }
            }).done(function (data) {
                var known = JSON.parse(data);
                var name = decodeURIComponent(notebookName);
                known.forEach(function (i) {
                    if (name && i.type == "notebook" && i.name == name + ".ipynb") {
                        success(notebooksUrl + "/" + name + ".ipynb");
                        name = null;
                    }
                });
                if (name != null) {
                    // Notebook was not found so we need to create it.
                    createOrOverwriteNotebook(apiUrl, notebooksUrl, name, success, error);
                }
            }).fail(function (jqHXR) {
                if (jqHXR.status == 404) {
                    // No listing, so we must be the first notebook
                    createOrOverwriteNotebook(apiUrl, notebooksUrl, notebookName, success, error);
                }
                else {
                    error("getting existing notebooks");
                }
            });
        }
        function openNotebookForOutputPort(workspace, port, alwaysCreateNew, success, error) {
            workspace.getWorkspaceSettingsAsync().done(function (settings) {
                var userName = workspace.getUserName();
                var endpoint = port.outputEndpoint;
                var dataSet = endpoint.AccessCredential.split("%22")[1].split(".")[0];
                authenticate(workspace.id, userName, function (data) {
                    (alwaysCreateNew ? createNotebookWithUniqueName : ensureNotebookExists)(data.api_url, data.notebooks_url, dataSet, success, error);
                }, function (message) {
                    error(message);
                });
            }).fail(function () {
                error("accessing workspace information");
            }).always(function () {
                //TODO Add an always case?
                /*code that executes for both fail and done cases*/
            });
        }
        PythonNotebook.openNotebookForOutputPort = openNotebookForOutputPort;
    })(PythonNotebook = ExperimentEditor.PythonNotebook || (ExperimentEditor.PythonNotebook = {}));
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../ContextMenuControl/MenuViewModel.ts" />
/// <reference path="../ContextMenuControl/IMenuData.ts" />
/// <reference path="../../MenuBuilders/ExperimentEditorMenuBuilder.ts" />
/// <reference path="../../Common/ICommand.ts" />
/// <reference path="../../Common/CallbackCommand.ts" />
/// <reference path="../../Common/NullCommand.ts" />
/// <reference path="SelectionManager.ts" />
/// <reference path="ExperimentViewModel.ts" />
/// <reference path="Connector.ts" />
/// <reference path="XEStateMachine.ts" />
/// <reference path="../../View/ICoordinateConverter.ts" />
/// <reference path="../../View/IPanResponder.ts" />
/// <reference path="Clipboard.ts" />
/// <reference path="Commands/DeleteNodesCommand.ts" />
/// <reference path="Commands/PasteCommand.ts" />
/// <reference path="../PaletteControl/IPaletteItem.ts" />
/// <reference path="../../Common/EntityDataDownloader.ts" />
/// <reference path="../../View/Balloon.ts" />
/// <reference path="CustomUX.ts" />
/// <reference path="../../../_ReferenceSupport/DataLabClient.d.ts" />
/// <reference path="PythonNotebook.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var ExperimentEditor;
(function (ExperimentEditor) {
    var Model = DataLab.Model;
    (function (UserActionState) {
        UserActionState[UserActionState["IsMultiSelecting"] = 0] = "IsMultiSelecting";
        UserActionState[UserActionState["IsMovingEntity"] = 1] = "IsMovingEntity";
        UserActionState[UserActionState["IsConnecting"] = 2] = "IsConnecting";
        UserActionState[UserActionState["None"] = 3] = "None";
    })(ExperimentEditor.UserActionState || (ExperimentEditor.UserActionState = {}));
    var UserActionState = ExperimentEditor.UserActionState;
    ;
    // The class that represents the control root View Model
    var ExperimentEditorViewModel = (function (_super) {
        __extends(ExperimentEditorViewModel, _super);
        function ExperimentEditorViewModel(moduleCache, datasetCache, trainedModelCache, transformModulesCache, endpointDownloader, commands, workspace, events) {
            var _this = this;
            if (commands === void 0) { commands = {}; }
            if (workspace === void 0) { workspace = null; }
            if (events === void 0) { events = {}; }
            _super.call(this);
            this.paletteDragItem = null;
            // We want to show a help watermark until the current experiment becomes non-empty (and never again for this same experiment).
            this.currentExperimentHasBeenNonEmpty = ko.observable(false);
            this.isBeingResized = ko.observable(false);
            this.refreshStatusLabel = ko.observable("");
            this.newExperimentLoaded = new ko.subscribable();
            this.parentExperimentId = ko.observable();
            this.experimentOrViewBoundsChanged = new ko.subscribable();
            this.experimentViewModel = ko.observable();
            this.experimentDirty = ko.observable();
            this.workspace = workspace;
            this.experimentDisposable = null;
            this.events = events;
            this.saveStatus = ko.observable({ state: 0 /* None */, lastSave: null });
            this.draftSaveLabel = ko.computed(function () {
                switch (_this.saveStatus().state) {
                    case 0 /* None */:
                        return "";
                    case 3 /* SaveFailed */:
                        return DataLab.LocalizedResources.DraftState_SaveFailedRetrying;
                    case 2 /* Saving */:
                        return DataLab.LocalizedResources.DraftState_Saving;
                    case 1 /* Saved */:
                        return DataLab.Util.format(DataLab.LocalizedResources.DraftState_SavedAt, _this.saveStatus().lastSave.toLocaleTimeString());
                }
            });
            // We create these disposables, so we'll need to dispose of them
            this.registerForDisposal(this.experiment = new Model.Experiment(), this.selectionManager = new ExperimentEditor.SelectionManager(this.experimentViewModel), this.stateMachine = new ExperimentEditor.XEInteractionStateMachine(this), this.statusRefresher = new DataLab.Util.Repeater(function () {
                return _this._experiment.refresh(_this.workspace).done(function () {
                    _this.refreshStatusLabel("");
                }).fail(function (err) {
                    if (err instanceof DataLab.Util.AjaxError && err.xmlHttpRequest.status === 404) {
                        _this.refreshStatusLabel("");
                        _this.statusRefresher.stop();
                    }
                    else {
                        _this.refreshStatusLabel(DataLab.LocalizedResources.RefreshStatus_FailedRetrying);
                    }
                });
            }, 5000));
            this.connector = new ExperimentEditor.Connector();
            this.entityActivationCallback = null;
            this.moduleCache = moduleCache;
            this.datasetCache = datasetCache;
            this.trainedModelCache = trainedModelCache;
            this.transformModulesCache = transformModulesCache;
            this.endpointDownloader = endpointDownloader;
            this.lastMouseCoords = { x: 0, y: 0, matrixTransform: null };
            // Add subscribables
            this.needsAnimationToContent = new ko.subscribable();
            this.needsAnimationToNode = new ko.subscribable();
            this.experimentOrViewPerturbed = new ko.subscribable();
            // We own this. No need to unsubscribe.
            this.experimentOrViewPerturbed.subscribe(function () {
                ExperimentEditor.Balloon.hide();
            });
            // We own the selection manager. No need to unsubscribe.
            this.selectionManager.selectedEntities.subscribe(function () {
                _this.experimentOrViewPerturbed.notifySubscribers(null);
            });
            var viewModelCommands = this.createContextMenuCommands(commands);
            this.registerForDisposal(this.menuBuilder = new ExperimentEditor.ExperimentEditorMenuBuilder(this, viewModelCommands));
            this.setCommandAvailabilities(viewModelCommands);
            this.animationComplete = new ko.subscribable();
            // This will update the this.menuBuilder appropriate commands 'canExecute'
            // observable upon the readOnlyMode on/off
            ko.computed(function () {
                return _this.experimentViewModel().readOnlyMode();
            }).subscribe(function (value) {
                _this.menuBuilder.readOnlyMode(value);
            }, this.menuBuilder, "change");
            // We want to show a help watermark until the current experiment becomes non-empty (and never again for this same experiment).
            this.shouldShowHelpWatermark = ko.computed(function () {
                return !_this.currentExperimentHasBeenNonEmpty() && _this._experiment.isDraft();
            });
            // When entity is null, then the user mouse downed on the canvas
            this.entityMouseDown = function (source, e) {
                e.preventDefault();
                e.stopPropagation();
                // if the comment is spilled and you click on it, it should go into edit comment mode
                if (($(e.target).closest(".expanded .text").length === 1) && source.selected()) {
                    source.editComment();
                }
                else {
                    _this.stateMachine.handleAction(0 /* MouseDown */, e, source);
                }
            };
            // When entity is null, then the user mouse upped on the canvas or off the window.
            this.entityMouseUp = function (source, e) {
                e.preventDefault();
                e.stopPropagation();
                if (source instanceof ExperimentEditor.OutputPort || source instanceof ExperimentEditor.InputPort) {
                    if (_this.stateMachine.dragging() !== 2 /* Connection */ || _this.connector.p0 === source) {
                        ExperimentEditor.ContextMenuEventHandler(e, source, _this.menuBuilder);
                    }
                }
                _this.stateMachine.handleAction(1 /* MouseUp */, e, source);
            };
            this.entityDoubleClick = function (source, event) {
                // disabling comments for datasets
                if (source instanceof ExperimentEditor.Module) {
                    if (!_this.experimentViewModel().readOnlyMode()) {
                        if (!_this.experiment.isDraft()) {
                            _this.cloneHandler();
                        }
                        source.editComment();
                        return;
                    }
                }
                _this.activate(source, event.ctrlKey || event.shiftKey);
            };
            this.commentsEventHandler = function (source, event) {
                event.stopPropagation();
                if (event.keyCode === 27 /* Escape */) {
                    event.target.blur();
                    return false;
                }
                else {
                    return true;
                }
            };
            this.panButtonClicked = function (e) {
                e.preventDefault();
                e.stopPropagation();
                _this.stateMachine.handleAction(3 /* PanButtonClicked */, e, null);
            };
            this.classId = ko.computed(function () {
                var classId = "xe-surface";
                if (_this.experimentViewModel().readOnlyMode()) {
                    classId += " readOnly";
                }
                classId += " " + _this.stateMachine.classes();
                return classId;
            });
            this.setLastPositionForExperiment = new ko.subscribable();
        }
        Object.defineProperty(ExperimentEditorViewModel.prototype, "experiment", {
            get: function () {
                return this._experiment;
            },
            set: function (newExperiment) {
                var _this = this;
                if (this._experiment !== newExperiment) {
                    ExperimentEditor.Help.setHelpContent("");
                    this._experiment = newExperiment;
                    this.parentExperimentId(this._experiment.parentExperimentId);
                    // Throw away the old experimentDisposable. Destroys unneeded subscriptions.
                    if (this.experimentDisposable) {
                        this.experimentDisposable.dispose();
                    }
                    this.registerForDisposal(this.experimentDisposable = new DataLab.Util.Disposable());
                    var experimentViewModel = new ExperimentEditor.ExperimentViewModel(this._experiment, this.workspace);
                    this.experimentViewModel(experimentViewModel);
                    this.draftStateMachine = new Model.DraftStateMachine(this.workspace, this._experiment);
                    // We don't own the experiment, so we need to unsubscribe. Our experimentDisposal will do that
                    // for us.
                    this.experimentDisposable.registerForDisposal(new DataLab.Util.DisposableSubscription(this.draftStateMachine.dirty.subscribe(function (isDirty) {
                        _this.experimentDirty(isDirty);
                    })), new DataLab.Util.DisposableSubscription(this.draftStateMachine.saveStatus.subscribe(function (status) {
                        _this.saveStatus(status);
                    })), experimentViewModel, this.draftStateMachine);
                    if (this.isAutoRefreshing) {
                        var code = this._experiment.statusCode();
                        if (code === DataLab.DataContract.State.InDraft && this.experiment.parentExperimentId) {
                            this.workspace.getExperimentAsync(this.experiment.parentExperimentId).done(function (parentExperiment) {
                                _this._experiment.dirtyIfNeeded(parentExperiment);
                                if (parentExperiment.statusCode() === DataLab.DataContract.State.Failed || parentExperiment.statusCode() === DataLab.DataContract.State.Finished) {
                                    // If the parent is done executing we update status information once and do not start autorefresh
                                    _this._experiment.refresh(_this.workspace);
                                }
                                else {
                                    _this.setRefreshConditions(parentExperiment);
                                }
                            }).fail(function (err) {
                                _this.refreshStatusLabel(DataLab.LocalizedResources.RefreshStatus_Failed);
                            });
                        }
                        else {
                            this.setRefreshConditions(this._experiment);
                        }
                    }
                    this.observeEmptinessOfNewExperiment();
                    this.experimentOrViewBoundsChanged.notifySubscribers(null);
                    this.newExperimentLoaded.notifySubscribers(null);
                    if (this.dirtySubscription) {
                        this.dirtySubscription.dispose();
                    }
                    // We don't want to subscribe to the dirtySubscription if we're in read only mode and not queued up to be run or running
                    if (!this.experimentViewModel().readOnlyMode() || this.experimentViewModel().experiment.statusCode() === DataLab.DataContract.State.NotStarted || this.experimentViewModel().experiment.statusCode() === DataLab.DataContract.State.Running) {
                        this.dirtySubscription = this._experiment.dirtyStatus.isDirty.subscribe(function (dirty) {
                            if (dirty && !_this._experiment.isDraft()) {
                                _this.cloneHandler();
                            }
                        });
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        ExperimentEditorViewModel.prototype.stopAutoRefresh = function () {
            if (this.isAutoRefreshing) {
                this.isAutoRefreshing = false;
                this.statusRefresher.stop();
            }
        };
        ExperimentEditorViewModel.prototype.rememberExperimentPosition = function (experimentId) {
            this.setLastPositionForExperiment.notifySubscribers(experimentId);
        };
        ExperimentEditorViewModel.prototype.registerEntityActivationEvent = function (callback) {
            if (this.entityActivationCallback !== null) {
                throw new Error("Activation callback already registered");
            }
            this.entityActivationCallback = callback;
        };
        ExperimentEditorViewModel.prototype.registerCloneHandler = function (callback) {
            this.cloneHandler = callback;
        };
        ExperimentEditorViewModel.prototype.removeSelected = function () {
            if (this.experimentViewModel().readOnlyMode()) {
                return;
            }
            if (!this._experiment.isDraft() && this._experiment) {
                this.cloneHandler();
            }
            this.experimentViewModel().removeSelected();
            this.selectionManager.resetSelection();
            this.experimentOrViewBoundsChanged.notifySubscribers(null);
            this.experimentOrViewPerturbed.notifySubscribers(null);
        };
        ExperimentEditorViewModel.prototype.editSelected = function () {
            this.experimentViewModel().editSelected();
            this.experimentOrViewPerturbed.notifySubscribers(null);
        };
        ExperimentEditorViewModel.prototype.startConnection = function (source) {
            if (this.experimentViewModel().readOnlyMode()) {
                return;
            }
            if (!this._experiment.isDraft()) {
                this.cloneHandler();
            }
            this.highlightNodesAndPorts(source);
            this.connector.startConnection(source);
            this.experimentOrViewPerturbed.notifySubscribers(null);
        };
        ExperimentEditorViewModel.prototype.moveConnection = function (domainCoords) {
            if (this.experimentViewModel().readOnlyMode()) {
                return;
            }
            if (!this._experiment.isDraft()) {
                this.cloneHandler();
            }
            var mouseOverEntity = this.experimentViewModel().findEntityAtPoint(domainCoords.x, domainCoords.y);
            this.connector.onMouseMove(domainCoords.x, domainCoords.y, mouseOverEntity);
        };
        ExperimentEditorViewModel.prototype.cancelConnection = function () {
            this.connector.reset();
            this.highlightNodesAndPorts(null);
        };
        ExperimentEditorViewModel.prototype.endConnection = function (destination, domainCoords) {
            if (this.experimentViewModel().readOnlyMode()) {
                return;
            }
            if (!this._experiment.isDraft()) {
                this.cloneHandler();
            }
            this.connector.endConnection(destination, domainCoords.x, domainCoords.y);
            this.highlightNodesAndPorts(null);
            this.experimentOrViewPerturbed.notifySubscribers(null);
        };
        ExperimentEditorViewModel.prototype.activate = function (entity, secondaryActivation) {
            if (secondaryActivation === void 0) { secondaryActivation = false; }
            if (this.entityActivationCallback) {
                this.entityActivationCallback(entity, secondaryActivation);
            }
        };
        ExperimentEditorViewModel.prototype.onMouseMove = function (e) {
            e.preventDefault();
            this.stateMachine.handleAction(2 /* MouseMove */, e);
        };
        ExperimentEditorViewModel.prototype.beginMultiSelect = function (domainCoords) {
            this.selectionManager.beginRectSelection(domainCoords.x, domainCoords.y);
            this.experimentOrViewPerturbed.notifySubscribers(null);
        };
        ExperimentEditorViewModel.prototype.updateMultiSelect = function (domainCoords) {
            this.selectionManager.updateRectSelection(domainCoords.x, domainCoords.y);
        };
        ExperimentEditorViewModel.prototype.endMultiSelect = function (domainCoords) {
            this.selectionManager.endRectSelection(domainCoords.x, domainCoords.y, this.experimentViewModel().selectableEntities());
            this.experimentOrViewPerturbed.notifySubscribers(null);
        };
        ExperimentEditorViewModel.prototype.moveEntities = function (dx, dy) {
            if (this.experimentViewModel().readOnlyMode()) {
                return;
            }
            // Nodes are the top-level movable thing. Ports and connections will move consequently.
            var entities = this.experimentViewModel().nodes();
            DataLab.Util.forEach(entities, function (entity) {
                if (entity.selected()) {
                    entity.translate(dx, dy);
                }
            });
            this.experimentOrViewBoundsChanged.notifySubscribers(null);
            this.experimentOrViewPerturbed.notifySubscribers(null);
        };
        ExperimentEditorViewModel.prototype.addModuleById = function (guid, x, y) {
            if (x === void 0) { x = 0; }
            if (y === void 0) { y = 0; }
            var module_ = this.createModule(guid, x, y);
            var moduleId = module_.graphNode.id;
            this.experimentViewModel().addNode(module_);
            this.experimentOrViewBoundsChanged.notifySubscribers(null);
            return this.experimentViewModel().nodes.lookup(moduleId);
        };
        ExperimentEditorViewModel.prototype.addDatasetById = function (guid, x, y) {
            if (x === void 0) { x = 0; }
            if (y === void 0) { y = 0; }
            var dataset = this.createDataset(guid, x, y);
            var datasetId = dataset.graphNode.id;
            this.experimentViewModel().addNode(dataset);
            this.experimentOrViewBoundsChanged.notifySubscribers(null);
            return this.experimentViewModel().nodes.lookup(datasetId);
        };
        ExperimentEditorViewModel.prototype.addTrainedModelById = function (guid, x, y) {
            if (x === void 0) { x = 0; }
            if (y === void 0) { y = 0; }
            var trainedModel = this.createTrainedModel(guid, x, y);
            var trainedModelId = trainedModel.graphNode.id;
            this.experimentViewModel().addNode(trainedModel);
            this.experimentOrViewBoundsChanged.notifySubscribers(null);
            return this.experimentViewModel().nodes.lookup(trainedModelId);
        };
        ExperimentEditorViewModel.prototype.addTransformById = function (guid, x, y) {
            if (x === void 0) { x = 0; }
            if (y === void 0) { y = 0; }
            var transform = this.createTransformModule(guid, x, y);
            var transformId = transform.graphNode.id;
            this.experimentViewModel().addNode(transform);
            this.experimentOrViewBoundsChanged.notifySubscribers(null);
            return this.experimentViewModel().nodes.lookup(transformId);
        };
        ExperimentEditorViewModel.prototype.createModule = function (guid, x, y) {
            if (x === void 0) { x = 0; }
            if (y === void 0) { y = 0; }
            var module_ = this.moduleCache.getItemIfCached(guid);
            if (!module_) {
                throw "No module found with the given id.";
            }
            return this.experimentViewModel().createModule(module_, x, y);
        };
        ExperimentEditorViewModel.prototype.createDataset = function (guid, x, y) {
            if (x === void 0) { x = 0; }
            if (y === void 0) { y = 0; }
            var dataset = this.datasetCache.getItemIfCached(guid);
            if (!dataset) {
                throw "No dataset found with the given id.";
            }
            return this.experimentViewModel().createDataset(dataset, x, y);
        };
        ExperimentEditorViewModel.prototype.createTrainedModel = function (guid, x, y) {
            if (x === void 0) { x = 0; }
            if (y === void 0) { y = 0; }
            var trainedModel = this.trainedModelCache.getItemIfCached(guid);
            if (!trainedModel) {
                throw "No trained model found with the given id.";
            }
            return this.experimentViewModel().createTrainedModel(trainedModel, x, y);
        };
        ExperimentEditorViewModel.prototype.createTransformModule = function (guid, x, y) {
            if (x === void 0) { x = 0; }
            if (y === void 0) { y = 0; }
            var transform = this.transformModulesCache.getItemIfCached(guid);
            if (!transform) {
                throw "No transform found with the given id.";
            }
            return this.experimentViewModel().createTransformModule(transform, x, y);
        };
        ExperimentEditorViewModel.prototype.createWebServicePort = function (type, x, y) {
            if (x === void 0) { x = 0; }
            if (y === void 0) { y = 0; }
            return this.experimentViewModel().createWebServicePort(DataLab.Model.WebServicePortType[type], x, y);
        };
        ExperimentEditorViewModel.prototype.createNode = function (entityType, guid, x, y) {
            if (entityType === ExperimentEditor.Constants.EntityType.Module) {
                return this.createModule(guid, x, y);
            }
            else if (entityType === ExperimentEditor.Constants.EntityType.Dataset) {
                return this.createDataset(guid, x, y);
            }
            else if (entityType === ExperimentEditor.Constants.EntityType.TrainedModel) {
                return this.createTrainedModel(guid, x, y);
            }
            else if (entityType === ExperimentEditor.Constants.EntityType.Transform) {
                return this.createTransformModule(guid, x, y);
            }
            else if (entityType === ExperimentEditor.Constants.EntityType.WebServicePort) {
                return this.createWebServicePort(guid, x, y);
            }
            throw "Unknown node entity type";
        };
        ExperimentEditorViewModel.prototype.paletteDragStart = function (paletteItem) {
            this.paletteItem = paletteItem;
            this.experimentOrViewPerturbed.notifySubscribers(null);
        };
        ExperimentEditorViewModel.prototype.paletteDragEnter = function (domainCoords) {
            if (this.paletteItem) {
                var x = domainCoords.x - ExperimentEditor.Constants.RectWidth / 2;
                var y = domainCoords.y - ExperimentEditor.Constants.RectHeight / 2;
                this.paletteDragItem = this.createNode(this.paletteItem.type(), this.paletteItem.id(), x, y);
            }
            this.lastMouseCoords = domainCoords;
        };
        ExperimentEditorViewModel.prototype.paletteDragMove = function (domainCoords) {
            if (this.paletteDragItem) {
                var dx = domainCoords.x - this.lastMouseCoords.x;
                var dy = domainCoords.y - this.lastMouseCoords.y;
                this.paletteDragItem.translate(dx, dy);
            }
            this.lastMouseCoords = domainCoords;
            this.experimentOrViewBoundsChanged.notifySubscribers(null);
        };
        ExperimentEditorViewModel.prototype.paletteDragLeave = function () {
            if (this.paletteDragItem) {
                this.experimentViewModel().tempNodes.remove(this.paletteDragItem.graphNode.id);
                this.paletteDragItem.remove();
                this.paletteDragItem = null;
                this.experimentOrViewBoundsChanged.notifySubscribers(null);
            }
        };
        ExperimentEditorViewModel.prototype.paletteDragEnd = function () {
            var graphNodeToAnimateTo = null;
            if (this.paletteDragItem) {
                if (!this._experiment.isDraft()) {
                    this.cloneHandler();
                }
                if (this.paletteDragItem instanceof ExperimentEditor.Dataset) {
                    var existingDataset = this.experiment.getDatasetNode(this.paletteDragItem.datasetNode.dataset.id);
                    if (existingDataset) {
                        graphNodeToAnimateTo = this.experimentViewModel().getViewModelForNode(existingDataset);
                        this.experimentViewModel().tempNodes.remove(this.paletteDragItem.graphNode.id);
                    }
                }
                if (this.paletteDragItem instanceof ExperimentEditor.TrainedModel) {
                    var existingTrainedModel = this.experiment.getTrainedModelNode(this.paletteDragItem.trainedModelNode.trainedModel.id);
                    if (existingTrainedModel) {
                        graphNodeToAnimateTo = this.experimentViewModel().getViewModelForNode(existingTrainedModel);
                        this.experimentViewModel().tempNodes.remove(this.paletteDragItem.graphNode.id);
                    }
                }
                else if (this.paletteDragItem instanceof ExperimentEditor.Module) {
                    // Instrumentation scenario: User adds a Module
                    // For privacy reasons, log the name of the node only if the author is "Microsoft Corporation"
                    var canInstrumentNodeName = true; // newModuleNode.owner === "Microsoft Corporation";
                    if (canInstrumentNodeName) {
                        Shell.Diagnostics.Telemetry.featureUsage(36 /* AddModuleByDragging */, 38 /* ExperimentEditor */, this.workspace && this.workspace.id, this._experiment && this._experiment.experimentId(), this.paletteDragItem.moduleNode.module_.id, this.paletteDragItem.moduleNode.module_.name());
                    }
                }
                else if (this.paletteDragItem instanceof ExperimentEditor.WebServicePort) {
                    var webServicePort = this.paletteDragItem;
                    Shell.Diagnostics.Telemetry.featureUsage(53 /* DragNewPort */, 52 /* WebServicePort */, this.workspace && this.workspace.id, this._experiment && this._experiment.experimentId());
                    if (webServicePort.webServicePortNode.type === 0 /* Input */ && this.experiment.getWebServicePortNodes(webServicePort.webServicePortNode.type).length > 0) {
                        this.experimentViewModel().tempNodes.remove(this.paletteDragItem.graphNode.id);
                        if (this.events.onAlert) {
                            this.events.onAlert(DataLab.LocalizedResources.multipleWebServicePortNotSupported);
                        }
                        return;
                    }
                }
                // If the dataset doesn't already exist or the drag item was a module, add it
                if (!graphNodeToAnimateTo) {
                    var nodeViewModel = this.experimentViewModel().addNode(this.paletteDragItem);
                    if (nodeViewModel) {
                        // Do not trigger any validation when dragging the palette item for the first time
                        this.selectionManager.resetSelection();
                        this.selectionManager.selectEntity(nodeViewModel);
                    }
                }
                this.experimentOrViewBoundsChanged.notifySubscribers(null);
            }
            this.paletteDragItem = null;
            this.experimentOrViewPerturbed.notifySubscribers(null);
            return graphNodeToAnimateTo;
        };
        ExperimentEditorViewModel.prototype.copy = function () {
            var selectedNodes = this.selectionManager.selectedGraphNodeModels;
            if (selectedNodes.count() > 0) {
                var data = JSON.stringify(DataLab.DataContract.v2.SerializedSubgraph(selectedNodes));
                ExperimentEditor.Clipboard.write(data);
            }
        };
        ExperimentEditorViewModel.prototype.cut = function () {
            if (this.experimentViewModel().readOnlyMode()) {
                return;
            }
            if (!this._experiment.isDraft()) {
                this.cloneHandler();
            }
            var selectedNodes = this.selectionManager.selectedGraphNodeModels;
            if (selectedNodes.count() > 0) {
                var data = JSON.stringify(DataLab.DataContract.v2.SerializedSubgraph(selectedNodes));
                ExperimentEditor.Clipboard.write(data);
            }
            var deleteCommand = new ExperimentEditor.DeleteNodesCommand(DataLab.Util.values(selectedNodes()), this);
            deleteCommand.run();
            this.experimentOrViewBoundsChanged.notifySubscribers(null);
            this.experimentOrViewPerturbed.notifySubscribers(null);
        };
        ExperimentEditorViewModel.prototype.paste = function () {
            var _this = this;
            var viewInfo = this.experimentView.getViewInfo();
            var clipboardContents = ExperimentEditor.Clipboard.read();
            if (this.experimentViewModel().readOnlyMode()) {
                return;
            }
            if (!this._experiment.isDraft()) {
                this.cloneHandler();
            }
            if (clipboardContents) {
                var clipboardData = JSON.parse(clipboardContents);
                var validate;
                validate = function (nodesAddedInfo) {
                    // DataLab.Util.values(nodesAddedInfo.contractToNodes)[0] instanceof DataLab.Model.ModuleNode
                    if (DataLab.Features.trialLimitationsEnabled()) {
                        var modulesToPaste = DataLab.Util.values(nodesAddedInfo.contractToNodes).filter(function (node) { return node instanceof DataLab.Model.ModuleNode; });
                        if (!DataLab.Trial.isNumberOfModulesUnrestricted()) {
                            var numberOfModulesAfterPaste = modulesToPaste.length + _this._experiment.getNumberOfModules();
                            if (numberOfModulesAfterPaste > DataLab.Trial.getMaxNumberOfModules()) {
                                Shell.Diagnostics.Telemetry.featureUsage(60 /* ExceededModuleCountLimit */, 56 /* TrialFeature */, _this.workspace && _this.workspace.id, _this._experiment && _this._experiment.experimentId());
                                ExperimentEditor.showExceededNumberOfModulesLimitDialog();
                                return false;
                            }
                        }
                        // check for restricted modules
                        var firstDisabledModuleNode = DataLab.Util.first(modulesToPaste, function (node) { return !DataLab.Trial.isModuleEnabledById(node.module_.familyId); }, null);
                        if (firstDisabledModuleNode) {
                            Shell.Diagnostics.Telemetry.featureUsage(58 /* DisabledModule */, 56 /* TrialFeature */, _this.workspace && _this.workspace.id, _this._experiment && _this._experiment.experimentId(), firstDisabledModuleNode.module_.name());
                            ExperimentEditor.showDisabledModuleDialog(firstDisabledModuleNode.module_.familyId, firstDisabledModuleNode.module_.name());
                            return false;
                        }
                    }
                    return true;
                };
                var pasteCommand = new ExperimentEditor.PasteCommand(clipboardData, this, viewInfo.experimentBounds, viewInfo.topLeft, this.workspace, validate);
                // For now, we'll assume paste commands are one-shot. This assumption will change if/when
                // we get undo/redo
                var subscription = pasteCommand.itemsPasted.subscribe(function (contentRect) {
                    if (contentRect) {
                        _this.needsAnimationToContent.notifySubscribers(contentRect);
                    }
                    subscription.dispose();
                });
                pasteCommand.run();
                this.experimentOrViewBoundsChanged.notifySubscribers(null);
            }
            this.experimentOrViewPerturbed.notifySubscribers(null);
        };
        ExperimentEditorViewModel.prototype.refreshExperiment = function () {
            var _this = this;
            return this.statusRefresher.doActionNow().fail(function () {
                _this.refreshStatusLabel(DataLab.LocalizedResources.RefreshStatus_Failed);
            });
        };
        ExperimentEditorViewModel.prototype.startAutoRefresh = function () {
            this.isAutoRefreshing = true;
        };
        /** Sets the {@see currentExperimentHasBeenNonEmpty} flag based on the current experiment's isEmpty state.
            The current experiment is assumed to have been newly installed, so an empty experiment will result in
            currentExperimentHasBeenNonEmpty being unset. */
        ExperimentEditorViewModel.prototype.observeEmptinessOfNewExperiment = function () {
            var _this = this;
            this.currentExperimentHasBeenNonEmpty(!this._experiment.isEmpty());
            if (this._experiment.isEmpty()) {
                var subscription = new DataLab.Util.DisposableSubscription(this._experiment.isEmpty.subscribe(function (empty) {
                    if (!empty) {
                        _this.currentExperimentHasBeenNonEmpty(true);
                    }
                    subscription.dispose();
                }));
                // We need to also, add the subscription to the experimentDisposable so if the user changes
                // experiment before dragging something out, we don't leak
                this.experimentDisposable.registerForDisposal(subscription);
            }
        };
        ExperimentEditorViewModel.prototype.createContextMenuCommands = function (commands) {
            var _this = this;
            var returnedCommands = {
                promoteOutput: null,
                promoteTrainerOutput: null,
                promoteTransformOutput: null,
                openPythonNotebook: null,
                openNewPythonNotebook: null,
                listPythonNotebooks: null,
                editComment: null,
                viewOutput: null,
                viewStdOut: null,
                viewStdErr: null,
                downloadDataset: null,
                visualizeData: null,
                setPublishPort: null,
                unsetPublishPort: null,
                delete_: null,
                refreshExperiment: null,
                navigateToParent: null,
                copy: null,
                cut: null,
                paste: null,
                showHelp: null,
                promoteCreateWebService: null,
                showOutputPortApiCode: null
            };
            returnedCommands.promoteOutput = ExperimentEditor.optionalCommand(commands.promoteOutput);
            returnedCommands.promoteTrainerOutput = ExperimentEditor.optionalCommand(commands.promoteTrainerOutput);
            returnedCommands.promoteTransformOutput = ExperimentEditor.optionalCommand(commands.promoteTransformOutput);
            returnedCommands.promoteCreateWebService = ExperimentEditor.optionalCommand(commands.promoteCreateWebService);
            returnedCommands.editComment = new ExperimentEditor.CallbackCommand(function (target) {
                target.editComment();
            });
            returnedCommands.viewOutput = new ExperimentEditor.CallbackCommand(function (targetObject) {
                _this.endpointDownloader.download(targetObject.portModel.outputEndpoint);
            });
            returnedCommands.viewStdOut = new ExperimentEditor.CallbackCommand(function (targetObject) {
                _this.endpointDownloader.download(targetObject.moduleNode.outputLog.endpoint());
            });
            returnedCommands.viewStdErr = new ExperimentEditor.CallbackCommand(function (targetObject) {
                targetObject.errorLog.onClick(targetObject.errorLog, null);
            });
            returnedCommands.showHelp = new ExperimentEditor.CallbackCommand(function (targetObject) {
                ExperimentEditor.Help.QuickHelpMoreInfo();
            });
            if (DataLab.Features.iPythonNotebookEnabled()) {
                returnedCommands.openPythonNotebook = new ExperimentEditor.CallbackCommand(function (targetObject) {
                    ExperimentEditor.PythonNotebook.openNotebook(_this.workspace, targetObject, false);
                });
                returnedCommands.openNewPythonNotebook = new ExperimentEditor.CallbackCommand(function (targetObject) {
                    ExperimentEditor.PythonNotebook.openNotebook(_this.workspace, targetObject, true);
                });
                returnedCommands.listPythonNotebooks = new ExperimentEditor.CallbackCommand(function (targetObject) {
                    ExperimentEditor.PythonNotebook.openNotebookList(_this.workspace);
                });
            }
            if (DataLab.Features.enableOutputPortApiCodeEnabled()) {
                returnedCommands.showOutputPortApiCode = new ExperimentEditor.CallbackCommand(function (targetObject) {
                    var port = targetObject.portModel;
                    _this.workspace.getWorkspaceSettingsAsync().done(function (settings) {
                        var dlg = new ExperimentEditor.ApiCodeDialogViewModel(port, settings.id, settings.authorizationToken);
                        // Have to use showDialog helper rather than DialogViews
                        // because the latter won't execute the JS we need.
                        dlg.showDialog();
                    }).fail(function () {
                        var dlg = new ExperimentEditor.ApiCodeDialogViewModel(port, undefined, undefined);
                        // Have to use showDialog helper rather than DialogViews
                        // because the latter won't execute the JS we need.
                        dlg.showDialog();
                    });
                });
            }
            returnedCommands.downloadDataset = new ExperimentEditor.CallbackCommand(function (targetObject) {
                if (targetObject instanceof ExperimentEditor.OutputPort) {
                    _this.endpointDownloader.download(targetObject.portModel.outputEndpoint);
                }
                else if (targetObject instanceof ExperimentEditor.Dataset) {
                    _this.endpointDownloader.download(targetObject.datasetNode.datasetPort.outputEndpoint);
                }
                else {
                    throw new Error("Unknown view model type when trying to view a dataset");
                }
            });
            returnedCommands.visualizeData = new ExperimentEditor.CallbackCommand(function (targetObject) {
                if (targetObject instanceof ExperimentEditor.OutputPort) {
                    var outputPort = targetObject;
                    // incase of datasource we need to get initialize the port
                    _this.endpointDownloader.visualize(targetObject.portModel, _this.workspace, outputPort.parent.isModule());
                }
            });
            returnedCommands.setPublishPort = new ExperimentEditor.CallbackCommand(function (targetObject) {
                if (targetObject instanceof ExperimentEditor.OutputPort) {
                    _this.experimentViewModel().addPublishOutputPort(targetObject);
                }
                else if (targetObject instanceof ExperimentEditor.InputPort) {
                    _this.experimentViewModel().addPublishInputPort(targetObject);
                }
            });
            returnedCommands.unsetPublishPort = new ExperimentEditor.CallbackCommand(function (targetObject) {
                if (targetObject instanceof ExperimentEditor.OutputPort) {
                    _this.experimentViewModel().removePublishOutputPort(targetObject);
                }
                else if (targetObject instanceof ExperimentEditor.InputPort) {
                    _this.experimentViewModel().removePublishInputPort(targetObject);
                }
            });
            returnedCommands.delete_ = new ExperimentEditor.CallbackCommand(function () {
                _this.removeSelected();
            });
            returnedCommands.refreshExperiment = ExperimentEditor.optionalCommand(commands.refreshExperiment);
            returnedCommands.navigateToParent = ExperimentEditor.optionalCommand(commands.navigateToParent);
            returnedCommands.copy = new ExperimentEditor.CallbackCommand(function () {
                _this.copy();
            });
            returnedCommands.cut = new ExperimentEditor.CallbackCommand(function () {
                _this.cut();
            });
            returnedCommands.paste = new ExperimentEditor.CallbackCommand(function () {
                _this.paste();
            });
            return returnedCommands;
        };
        ExperimentEditorViewModel.prototype.setCommandAvailabilities = function (commands) {
            var _this = this;
            commands.viewStdErr.canExecute = ko.computed(function () {
                var currentTarget = _this.menuBuilder.currentTarget();
                if (currentTarget instanceof ExperimentEditor.Module) {
                    var currentModule = currentTarget;
                    if (currentModule.moduleNode.statusCode.value() === DataLab.DataContract.State.Finished || currentModule.moduleNode.statusCode.value() === DataLab.DataContract.State.Failed) {
                        if (currentModule.moduleNode.errorLog.value()) {
                            return true;
                        }
                    }
                }
                return false;
            });
            commands.viewOutput.canExecute = ko.computed(function () {
                var currentTarget = _this.menuBuilder.currentTarget();
                if (currentTarget instanceof ExperimentEditor.OutputPort) {
                    var currentPort = currentTarget;
                    if (currentPort.parent instanceof ExperimentEditor.Module && currentPort.portModel.outputEndpoint && currentPort.portModel.outputEndpoint.Size >= 0 && !currentPort.portModel.isVisualizable()) {
                        var currentModule = currentPort.parent;
                        // Do not allow download if the type of the output port is ILearnerDotNet or IClusterDotNet or ITransformDotNet
                        // NOTE DataLab.Features.authorizeDownloadITransformEnabled() will return an error as this setting does not exist. I'm not using a check for it here.
                        if (currentPort.portModel.descriptor.allowedDataTypes.some(function (value, index, array) {
                            return value.dataTypeId === "ILearnerDotNet" || value.dataTypeId === "ITransformDotNet" || value.dataTypeId === "IClusterDotNet";
                        }) === false || (DataLab.Features.authorizeDownloadILearnerEnabled() && (currentPort.portTypes === "ILearnerDotNet" || currentPort.portTypes === "IClusterDotNet"))) {
                            if (currentModule.moduleNode.statusCode.value() === DataLab.DataContract.State.Finished) {
                                return true;
                            }
                        }
                    }
                }
                return false;
            });
            commands.setPublishPort.canExecute = ko.computed(function () {
                if (_this.experimentViewModel().readOnlyMode()) {
                    return false;
                }
                var currentTarget = _this.menuBuilder.currentTarget();
                if (currentTarget instanceof ExperimentEditor.PortViewModel) {
                    var currentPort = currentTarget;
                    return currentPort.portModel.isDatasetDataType();
                }
                else {
                    return false;
                }
            });
            commands.unsetPublishPort.canExecute = ko.computed(function () {
                if (_this.experimentViewModel().readOnlyMode()) {
                    return false;
                }
                else {
                    return true;
                }
            });
            if (DataLab.Features.enableOutputPortApiCodeEnabled()) {
                commands.showOutputPortApiCode.canExecute = ko.computed(function () {
                    var currentTarget = _this.menuBuilder.currentTarget();
                    if (currentTarget instanceof ExperimentEditor.OutputPort) {
                        var currentPort = currentTarget;
                        var portType = currentPort.portTypes;
                        var supportPortTypes = [
                            DataLab.DataContract.TestData.DataTypes.GenericCSV.Id,
                            DataLab.DataContract.TestData.DataTypes.GenericTSV.Id,
                            DataLab.DataContract.TestData.DataTypes.GenericCSV.Id + "NoHeader",
                            DataLab.DataContract.TestData.DataTypes.GenericTSV.Id + "NoHeader",
                            DataLab.DataContract.TestData.DataTypes.PlainText.Id
                        ];
                        if ($.inArray(portType, supportPortTypes) !== -1) {
                            if (currentPort.parent.isData()) {
                                return true;
                            }
                            var currentModule = currentPort.parent;
                            if (currentModule.moduleNode.statusCode.value() === DataLab.DataContract.State.Finished) {
                                return true;
                            }
                            else {
                                return false;
                            }
                        }
                        else {
                            return false;
                        }
                    }
                });
            }
            commands.visualizeData.canExecute = ko.computed(function () {
                var currentTarget = _this.menuBuilder.currentTarget();
                if (currentTarget instanceof ExperimentEditor.OutputPort) {
                    var currentPort = currentTarget;
                    // if the data is visualizable and is a dataset then we may have a schema.
                    if (currentPort.parent.isData()) {
                        var currentDataset = currentPort.parent;
                        if (currentDataset.datasetNode.dataset.visualizeEndPoint != undefined) {
                            return true;
                        }
                    }
                    var currentModule = currentPort.parent;
                    if (currentPort.portModel.isVisualizable()) {
                        if (currentModule.moduleNode && currentModule.moduleNode.statusCode.value() === DataLab.DataContract.State.Finished) {
                            return true;
                        }
                    }
                }
                return false;
            });
            commands.promoteOutput.canExecute = ko.computed(function () {
                var currentTarget = _this.menuBuilder.currentTarget();
                if (currentTarget instanceof ExperimentEditor.OutputPort) {
                    var currentPort = currentTarget;
                    if (currentPort.parent instanceof ExperimentEditor.Module && currentPort.portModel.outputEndpoint && currentPort.portModel.outputEndpoint.Size >= 0) {
                        // Disable output promotion if the upload of the output port's datatype is disallowed.
                        if (currentPort.portModel.descriptor.allowedDataTypes.filter(function (outputDataType) {
                            return !outputDataType.allowPromotion;
                        }).length === 0) {
                            var currentModule = currentPort.parent;
                            if (currentModule.moduleNode.statusCode.value() === DataLab.DataContract.State.Finished) {
                                return true;
                            }
                        }
                    }
                }
                return false;
            });
            commands.promoteTrainerOutput.canExecute = ko.computed(function () {
                var currentTarget = _this.menuBuilder.currentTarget();
                if (currentTarget instanceof ExperimentEditor.OutputPort) {
                    var currentPort = currentTarget;
                    if (currentPort.parent instanceof ExperimentEditor.Module && currentPort.portModel.outputEndpoint && currentPort.portModel.outputEndpoint.Size >= 0) {
                        // Disable output promotion if the upload of the output port's datatype is disallowed.
                        if (currentPort.portModel.descriptor.allowedDataTypes.filter(function (outputDataType) {
                            return !outputDataType.allowModelPromotion;
                        }).length === 0) {
                            var currentModule = currentPort.parent;
                            if (currentModule.moduleNode.statusCode.value() === DataLab.DataContract.State.Finished && currentPort.portModel.descriptor.allowedDataTypes.some(function (value, index, array) {
                                return value.dataTypeId === "ILearnerDotNet" || value.dataTypeId === "IClusterDotNet";
                            })) {
                                return true;
                            }
                        }
                    }
                }
                return false;
            });
            commands.promoteTransformOutput.canExecute = ko.computed(function () {
                var currentTarget = _this.menuBuilder.currentTarget();
                if (currentTarget instanceof ExperimentEditor.OutputPort) {
                    var currentPort = currentTarget;
                    if (currentPort.parent instanceof ExperimentEditor.Module && currentPort.portModel.outputEndpoint && currentPort.portModel.outputEndpoint.Size >= 0) {
                        // Disable output promotion if the upload of the output port's datatype is disallowed.
                        if (currentPort.portModel.descriptor.allowedDataTypes.filter(function (outputDataType) {
                            return !outputDataType.allowModelPromotion;
                        }).length === 0) {
                            var currentModule = currentPort.parent;
                            if (currentModule.moduleNode.statusCode.value() === DataLab.DataContract.State.Finished && currentPort.portModel.descriptor.allowedDataTypes.some(function (value, index, array) {
                                return value.dataTypeId === "ITransformDotNet";
                            })) {
                                return true;
                            }
                        }
                    }
                }
                return false;
            });
            // Create web service has same context as saved trained model or saved transform
            commands.promoteCreateWebService.canExecute = null != commands.promoteTrainerOutput.canExecute ? commands.promoteTrainerOutput.canExecute : commands.promoteTransformOutput.canExecute;
            commands.viewStdOut.canExecute = ko.computed(function () {
                var currentTarget = _this.menuBuilder.currentTarget();
                if (currentTarget instanceof ExperimentEditor.Module) {
                    var currentModule = currentTarget;
                    if (currentModule.moduleNode.statusCode.value() === DataLab.DataContract.State.Finished || currentModule.moduleNode.statusCode.value() === DataLab.DataContract.State.Failed) {
                        if (currentModule.moduleNode.outputLog.value()) {
                            return true;
                        }
                    }
                }
                return false;
            });
            commands.editComment.canExecute = ko.computed(function () {
                return !_this.experimentViewModel().readOnlyMode();
            });
            commands.delete_.canExecute = ko.computed(function () {
                return _this.selectionManager.selectedEntities.count() > 0 && !_this.experimentViewModel().readOnlyMode();
            });
            commands.navigateToParent.canExecute = ko.computed(function () {
                return _this.parentExperimentId() !== null;
            });
            commands.copy.canExecute = ko.computed(function () {
                return _this.selectionManager.selectedGraphNodes.count() > 0;
            });
            commands.cut.canExecute = ko.computed(function () {
                return _this.selectionManager.selectedGraphNodes.count() > 0 && !_this.experimentViewModel().readOnlyMode();
            });
            commands.paste.canExecute = ko.computed(function () {
                return !_this.experimentViewModel().readOnlyMode();
            });
        };
        // Scan each rect's ports and update their compatibility type
        ExperimentEditorViewModel.prototype.highlightNodesAndPorts = function (port) {
            DataLab.Util.forEach(this.experimentViewModel().nodes(), function (rect) {
                // We colorize input ports when connecting from an output port and vice versa. 
                // Ports of the same type (input or output) are cleared to the default color.
                var nodeHighlightingResult = DataLab.Model.Constants.PortState.Default;
                DataLab.Util.forEach(rect.ports, function (candidatePort) {
                    var samePortDirection = (port instanceof ExperimentEditor.OutputPort && candidatePort instanceof ExperimentEditor.OutputPort) || (port instanceof ExperimentEditor.InputPort && candidatePort instanceof ExperimentEditor.InputPort);
                    if (port == null || port === candidatePort || samePortDirection) {
                        candidatePort.portState(Model.Constants.PortState.Default);
                    }
                    else {
                        candidatePort.portState(port.portModel.compatibilityWithPort(candidatePort.portModel));
                    }
                    if (port === null || port === candidatePort) {
                        nodeHighlightingResult = DataLab.Model.Constants.PortState.Default;
                    }
                    else {
                        var compatiblityType = port.portModel.compatibilityWithPort(candidatePort.portModel);
                        if (compatiblityType === DataLab.Model.Constants.PortState.Compatible || compatiblityType === DataLab.Model.Constants.PortState.Replaceable) {
                            nodeHighlightingResult = DataLab.Model.Constants.PortState.Compatible;
                        }
                    }
                });
                rect.portState(nodeHighlightingResult);
            });
        };
        ExperimentEditorViewModel.prototype.setRefreshConditions = function (experiment) {
            var _this = this;
            var code = experiment.statusCode();
            if (code === DataLab.DataContract.State.NotStarted || code === DataLab.DataContract.State.Running) {
                this.statusRefresher.start();
                var subscription;
                this.experimentDisposable.registerForDisposal(subscription = new DataLab.Util.DisposableSubscription(experiment.statusCode.subscribe(function () {
                    var updatedCode = experiment.statusCode();
                    if (updatedCode === DataLab.DataContract.State.Failed || updatedCode === DataLab.DataContract.State.Finished || updatedCode === DataLab.DataContract.State.Canceled) {
                        _this.statusRefresher.stop();
                        subscription.dispose();
                    }
                    // check for trial restriction response
                    if (DataLab.Features.trialLimitationsEnabled() && updatedCode === DataLab.DataContract.State.Canceled) {
                        switch (experiment.statusDetails()) {
                            case DataLab.DataContract.CancellationReason.ExceededRuntimeLimit:
                                Shell.Diagnostics.Telemetry.featureUsage(63 /* ExceededModuleRuntimeLimit */, 56 /* TrialFeature */, _this.workspace && _this.workspace.id, _this._experiment && _this._experiment.experimentId());
                                ExperimentEditor.showExceededRuntimeLimitDialog();
                                break;
                            default:
                                break;
                        }
                    }
                })));
            }
        };
        /**
         *  Calculate placement for new or pasted nodes
         *  @param {SVGPoint} preferredLocation the initial preferred location.
         *  @return {SVGRect} the computed placement position
         **/
        ExperimentEditorViewModel.prototype.calculatePlacement = function (preferredLocation) {
            var foundSuitablePlacement;
            do {
                foundSuitablePlacement = true;
                this.experiment.nodes.forEach(function (node) {
                    if (preferredLocation.x === node.x() && preferredLocation.y === node.y()) {
                        preferredLocation.x += ExperimentEditor.Constants.PasteCascadeX;
                        preferredLocation.y += ExperimentEditor.Constants.PasteCascadeY;
                        foundSuitablePlacement = false;
                    }
                });
            } while (!foundSuitablePlacement);
            return { x: preferredLocation.x, y: preferredLocation.y, matrixTransform: null };
        };
        ExperimentEditorViewModel.prototype.getNumberOfModulesToBePasted = function (clipboardData) {
            if (clipboardData && clipboardData.Nodes) {
                return DataLab.Util.filter(clipboardData.Nodes, function (node) { return node.NodeType === 0 /* Module */; }).length;
            }
            return 0;
        };
        return ExperimentEditorViewModel;
    })(DataLab.Util.Disposable);
    ExperimentEditor.ExperimentEditorViewModel = ExperimentEditorViewModel;
})(ExperimentEditor || (ExperimentEditor = {}));

var ExperimentEditor;
(function (ExperimentEditor) {
    // Test if the specified HTML <input> type is supported
    function isInputSupported(type) {
        var input = document.createElement("input");
        input.setAttribute("type", type);
        return (input.type !== "text");
    }
    ExperimentEditor.isInputSupported = isInputSupported;
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../Global.ts" />
/// <reference path="../Common/FeatureDetection.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var ExperimentEditor;
(function (ExperimentEditor) {
    var Constants;
    (function (Constants) {
        var ZoomControl;
        (function (ZoomControl) {
            ZoomControl.SliderZoomIncrement = 0.25;
        })(ZoomControl = Constants.ZoomControl || (Constants.ZoomControl = {}));
    })(Constants = ExperimentEditor.Constants || (ExperimentEditor.Constants = {}));
    // A zoom control class that handles mouse wheel zoomin/out and mouse click on the -/+  div/img element.
    // The output of the control is a scale value (default min/max: 0.2 - 4).
    // The scale is a KO observable. The other output is an SVG scale transform string; a ko.Computed of scale.
    // The default step value is 0.1 (harcoded until there is an obvious need that one needs to make this configurable).
    // The scale value starts with 1;
    var ZoomControl = (function (_super) {
        __extends(ZoomControl, _super);
        function ZoomControl(containerDiv, canvasDiv, minScale, maxScale) {
            var _this = this;
            _super.call(this);
            this.containerDiv = containerDiv;
            this.canvasDiv = canvasDiv;
            this.minScale = (minScale !== undefined) ? minScale : 0.2;
            if (this.minScale <= 0) {
                throw "Minimum zoom value must be positive";
            }
            this.maxScale = (maxScale !== undefined) ? maxScale : 4;
            if (this.maxScale <= this.minScale) {
                throw "Maximum zoom value must be greater than the minimum";
            }
            this.zoomSteps = 0;
            this.scale = 1;
            this.zoomFactor = 1.1;
            this.minZoomSteps = Math.log(this.minScale) / Math.log(this.zoomFactor);
            this.maxZoomSteps = Math.log(this.maxScale) / Math.log(this.zoomFactor);
            this.zoomWithoutAnimation = new ko.subscribable();
            this.zoomWithAnimation = new ko.subscribable();
            this.zoomToFit = new ko.subscribable();
            var eventsCanvasDiv = this.canvasDiv.querySelector(".customElements");
            eventsCanvasDiv.addEventListener(eventsCanvasDiv.onmousewheel === undefined ? "DOMMouseScroll" : "mousewheel", function (e) {
                return _this.handleMouseWheelZoom(e);
            });
            // TODO: TFS#1064768 move this markup to .html file and bind the data using MVVM pattern similar to the other controls.
            var populateControl = function (containerDiv, minZoomSteps, maxZoomSteps, zoomInImage, zoomOutImage, actualSizeImage) {
                // The control prescribes that the following markup with id='parentContainerId'
                // has to exist in the view layer (in this case the HTML page).
                if ($(".xe-zoomControl").length != 0) {
                    throw "Element with class .xe-zoomControl exists before it is created!, possible of name collision ";
                }
                // Detect if HTML5 slider is supported
                var sliderMarkup = "&nbsp;";
                if (ExperimentEditor.isInputSupported("range")) {
                    sliderMarkup = "<input class='xe-zoomControlSlider' type='range' min='" + minZoomSteps + "' max='" + maxZoomSteps + "' value='1.0' step='" + Constants.ZoomControl.SliderZoomIncrement + "'></input>";
                }
                var innerHTML = "<div class='xe-zoomOut xe-zoomIcon' title='Zoom out (- key)'></div>" + sliderMarkup + "<div class='xe-zoomIn xe-zoomIcon' title='Zoom in (= key)'></div>" + "<div class='xe-actualSize xe-zoomIcon' title='Zoom to actual size (9 key)'></div>" + "<div class='xe-zoomToFit xe-zoomIcon' title='Zoom to fit (0 key)'></div>";
                // We have to remove our DOM mess when this control is disposed
                _this.registerForDisposal(new DataLab.Util.DisposableSetHTML(containerDiv, innerHTML));
            };
            populateControl(containerDiv, this.minZoomSteps, this.maxZoomSteps, this.zoomInImage, this.zoomOutImage, this.actualSizeImage);
            this.zoominButton = this.containerDiv.querySelector(".xe-zoomIn");
            this.zoomoutButton = this.containerDiv.querySelector(".xe-zoomOut");
            this.actualSizeButton = this.containerDiv.querySelector(".xe-actualSize");
            this.zoomSlider = this.containerDiv.querySelector(".xe-zoomControlSlider");
            this.zoomToFitButton = this.containerDiv.querySelector(".xe-zoomToFit");
            // These buttons are things we added, so they'll get cleaned up when we remove
            // our innerHTML DOM tree
            this.actualSizeButton.addEventListener("click", function (e) {
                e.preventDefault();
                _this.handleReset();
            });
            this.zoominButton.addEventListener("click", function (e) {
                e.preventDefault();
                _this.handleZoomIn();
            });
            this.zoomoutButton.addEventListener("click", function (e) {
                e.preventDefault();
                _this.handleZoomOut();
            });
            this.zoomToFitButton.addEventListener("click", function (e) {
                e.preventDefault();
                _this.handleZoomToFit();
            });
            if (this.zoomSlider !== null) {
                var initialChangeFired = false;
                // We should only animate the first change event resulting from mouseDown. If
                // the user then decides to drag the slider, it should zoom in lockstep with the
                // slider.
                var mouseCapture = new ExperimentEditor.MouseCapture(this.zoomSlider, function () {
                }, function () {
                    initialChangeFired = false;
                });
                // We create this disposable, so we dispose it.
                this.registerForDisposal(mouseCapture);
                // We added the slider, so we can let DOM removal clean up this guy
                this.zoomSlider.addEventListener("change", function (e) {
                    e.preventDefault();
                    var newSliderValue = parseFloat(e.currentTarget.value);
                    var delta = newSliderValue - _this.zoomSteps;
                    var newZoom = _this.calculateNewZoom(delta);
                    if (initialChangeFired) {
                        _this.zoomWithoutAnimation.notifySubscribers({ scale: newZoom });
                        _this.scale = newZoom;
                    }
                    else {
                        _this.zoomWithAnimation.notifySubscribers({ scale: newZoom });
                        initialChangeFired = true;
                    }
                });
            }
            // Handle key down for '-'/'=|+'
            // We have to dispose of this, because we don't own this.canvasDiv
            this.registerForDisposal(new DataLab.Util.DisposableEventListener(this.canvasDiv, "keydown", function (e) {
                switch (e.keyCode) {
                    case Constants.Key.Minus:
                    case 109 /* KeypadMinus */:
                        _this.handleZoomOut();
                        break;
                    case Constants.Key.Equals:
                    case 107 /* KeypadPlus */:
                        _this.handleZoomIn();
                        break;
                    case 48 /* Zero */:
                    case 96 /* KeypadZero */:
                        _this.handleZoomToFit();
                        break;
                    case 57 /* Nine */:
                    case 105 /* KeypadNine */:
                        _this.handleReset();
                        break;
                    default:
                        break;
                }
            }));
        }
        // For a given input scale, return the closest scale that is:
        // A) minScale <= requestedScale <= maxScale
        // B) zoomSteps is a multiple of SliderZoomIncrement
        ZoomControl.prototype.getClosestValidScale = function (requestedScale) {
            var zoomSteps = this.computeZoomStepForScale(requestedScale);
            return Math.pow(this.zoomFactor, zoomSteps);
        };
        // Returns the actual scale you got
        ZoomControl.prototype.setScale = function (requestedScale, x, y) {
            var newZoomSteps = this.computeZoomStepForScale(requestedScale);
            var newScale = Math.pow(this.zoomFactor, newZoomSteps);
            if (this.zoomSlider) {
                this.zoomSlider.value = newZoomSteps.toString();
            }
            this.zoomSteps = newZoomSteps;
            this.scale = newScale;
            return newScale;
        };
        ZoomControl.prototype.getScale = function () {
            return this.scale;
        };
        ZoomControl.prototype.computeZoomStepForScale = function (requestedScale) {
            var scale;
            scale = requestedScale > this.maxScale ? this.maxScale : requestedScale;
            scale = requestedScale < this.minScale ? this.minScale : scale;
            var requestedZoomSteps = Math.log(scale) / Math.log(this.zoomFactor);
            return requestedZoomSteps;
        };
        ZoomControl.prototype.handleReset = function () {
            this.zoomWithAnimation.notifySubscribers({ scale: this.calculateNewZoom(-this.zoomSteps) });
        };
        ZoomControl.prototype.handleZoomIn = function () {
            this.zoomWithoutAnimation.notifySubscribers({ scale: this.calculateNewZoom(1) });
        };
        ZoomControl.prototype.handleZoomOut = function () {
            this.zoomWithoutAnimation.notifySubscribers({ scale: this.calculateNewZoom(-1) });
        };
        ZoomControl.prototype.handleMouseWheelZoom = function (e) {
            var wheelUnits;
            if (e.detail) {
                // In Firefox, the wheel delta is a multiple of 3 and is opposite in direction
                // of other browsers
                // http://help.dottoro.com/ljrxdxdw.php
                wheelUnits = -e.detail / 3;
            }
            else {
                // For typical devices, wheelDelta is a multiple of 120
                // http://msdn.microsoft.com/en-us/library/ie/ms535142(v=vs.85).aspx
                wheelUnits = e.wheelDelta / 120;
            }
            this.zoomWithoutAnimation.notifySubscribers({
                scale: this.calculateNewZoom(wheelUnits),
                x: e.clientX,
                y: e.clientY
            });
        };
        ZoomControl.prototype.handleZoomToFit = function () {
            this.zoomToFit.notifySubscribers(true);
        };
        ZoomControl.prototype.calculateNewZoom = function (steps) {
            var targetZoomSteps = Math.max(this.minZoomSteps, Math.min(this.zoomSteps + steps, this.maxZoomSteps));
            return Math.pow(this.zoomFactor, targetZoomSteps);
        };
        return ZoomControl;
    })(DataLab.Util.Disposable);
    ExperimentEditor.ZoomControl = ZoomControl;
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../Global.ts" />
/// <reference path="../Common/FeatureDetection.ts" />
var ExperimentEditor;
(function (ExperimentEditor) {
    var Constants;
    (function (Constants) {
        Constants.ScrollbarSizeTestDimensions = 100;
    })(Constants = ExperimentEditor.Constants || (ExperimentEditor.Constants = {}));
    (function (ScrollOrientation) {
        ScrollOrientation[ScrollOrientation["Vertical"] = 0] = "Vertical";
        ScrollOrientation[ScrollOrientation["Horizontal"] = 1] = "Horizontal";
    })(ExperimentEditor.ScrollOrientation || (ExperimentEditor.ScrollOrientation = {}));
    var ScrollOrientation = ExperimentEditor.ScrollOrientation;
    var ScrollControl = (function () {
        /**
         *  @constructor
         *  Construct a new scollbar.
         *
         * @param {HTMLDivElement} scrollDiv The DIV element, of class 'verticalScroll' or class 'horizontalScroll' which is to become the scrollbar.
         * @param getPositionInAttachedView A callback function which returns a ScrollPosition object for this scroll bar.
         * @param {ScrollOrientation} The scrollbar orientation, vertical or horizontal.
         * @param {IScrollbarSizeInfo} Browser and DPI-dependent scrollbar size info.
         **/
        function ScrollControl(scrollDiv, getPositionInAttachedView, orientation, sizeInfo) {
            var _this = this;
            this.scrollDiv = scrollDiv;
            this.positionReference = getPositionInAttachedView;
            this.viewScrolled = ko.observable();
            this.orientation = orientation;
            this.scrollRange = document.createElement("div");
            if (orientation === 1 /* Horizontal */) {
                this.scrollDiv.setAttribute("class", "horizontalScroll scrollUI");
                this.scrollRange.setAttribute("class", "horizontalScrollRange");
                this.scrollDiv.style.right = sizeInfo.verticalScrollbarWidth.toFixed() + "px";
                this.clientLength = "clientWidth";
                this.clientOffset = "scrollLeft";
                this.styleLength = "width";
            }
            else {
                this.scrollDiv.setAttribute("class", "verticalScroll scrollUI");
                this.scrollRange.setAttribute("class", "verticalScrollRange");
                this.scrollDiv.style.bottom = sizeInfo.horizontalScrollbarHeight.toFixed() + "px";
                this.clientLength = "clientHeight";
                this.clientOffset = "scrollTop";
                this.styleLength = "height";
            }
            this.scrollDiv.appendChild(this.scrollRange);
            this.scrollDiv.addEventListener("scroll", function (e) {
                if (!_this.suppressScrollEvent) {
                    _this.viewScrolled.notifySubscribers(_this.scrollDiv[_this.clientOffset] / _this.scrollRange[_this.clientLength]);
                }
                else {
                    _this.suppressScrollEvent = false;
                }
            });
            this.sizeUpdated();
        }
        /**
         *  Notifies the scrollbar that it should requery for elevatorLength and elevatorOffset
         **/
        ScrollControl.prototype.sizeUpdated = function () {
            var scrollRangeLength;
            var scrollPos = this.positionReference(this.orientation);
            scrollRangeLength = this.scrollDiv[this.clientLength] / scrollPos.elevatorLength;
            this.scrollRange.style[this.styleLength] = scrollRangeLength.toFixed() + "px";
            this.suppressScrollEvent = true;
            $(this.scrollDiv)[this.clientOffset](scrollRangeLength * scrollPos.elevatorOffset);
        };
        /**
         *  Computes the width of vertical scrollbars and the height of horizontal scollbars.
         *
         * @return {IScrollbarSizeInfo} the scrollbar dimensions.
         **/
        ScrollControl.computeDimensions = function () {
            var outerDiv = document.createElement("div");
            var innerDiv = document.createElement("div");
            outerDiv.setAttribute("style", "width: " + Constants.ScrollbarSizeTestDimensions.toFixed() + "px;height: " + Constants.ScrollbarSizeTestDimensions.toFixed() + "px;overflow: scroll;position: absolute;opacity: 0;");
            innerDiv.setAttribute("style", "width:100%;height: 100%;position: absolute;top: 0px;left: 0px;");
            document.body.appendChild(outerDiv);
            outerDiv.appendChild(innerDiv);
            var scrollbarWidth = Constants.ScrollbarSizeTestDimensions - innerDiv.clientWidth;
            var scrollbarHeight = Constants.ScrollbarSizeTestDimensions - innerDiv.clientHeight;
            document.body.removeChild(outerDiv);
            return { verticalScrollbarWidth: scrollbarWidth, horizontalScrollbarHeight: scrollbarHeight };
        };
        return ScrollControl;
    })();
    ExperimentEditor.ScrollControl = ScrollControl;
})(ExperimentEditor || (ExperimentEditor = {}));

var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var ExperimentEditor;
(function (ExperimentEditor) {
    var MouseCapture = (function (_super) {
        __extends(MouseCapture, _super);
        function MouseCapture(mouseDownOrigin, mouseMoveHandler, mouseUpHandler) {
            var _this = this;
            _super.call(this);
            this.mouseMoveHandler = mouseMoveHandler;
            this.mouseUpHandler = mouseUpHandler;
            this.buttonsDown = 0;
            this.mouseDownOrigin = mouseDownOrigin;
            var countMouseDowns = function () {
                _this.buttonsDown++;
            };
            this.beginCapture = function () {
                if (_this.buttonsDown === 0) {
                    _this.registerForDisposal(_this.mouseMoveDisposableListener = new DataLab.Util.DisposableEventListener(document, "mousemove", _this.mouseMoveHandler, true), _this.mouseUpDisposableListener = new DataLab.Util.DisposableEventListener(document, "mouseup", _this.mouseUpHandler, true), _this.endCapturesDisposableListener = new DataLab.Util.DisposableEventListener(document, "mouseup", _this.endCapture, true), _this.countMouseDownsDisposableListener = new DataLab.Util.DisposableEventListener(document, "mousedown", countMouseDowns, true));
                    _this.buttonsDown++;
                }
            };
            this.endCapture = function () {
                _this.buttonsDown--;
                if (_this.buttonsDown === 0) {
                    _this.mouseMoveDisposableListener.dispose();
                    _this.mouseUpDisposableListener.dispose();
                    _this.endCapturesDisposableListener.dispose();
                    _this.countMouseDownsDisposableListener.dispose();
                }
            };
            // We don't know who the caller is attaching this event to, so we have to dispose of this
            // event listener
            this.registerForDisposal(new DataLab.Util.DisposableEventListener(this.mouseDownOrigin, "mousedown", this.beginCapture, true));
        }
        return MouseCapture;
    })(DataLab.Util.Disposable);
    ExperimentEditor.MouseCapture = MouseCapture;
    ko.bindingHandlers["mouseCapture"] = {
        init: function (element, valueAccessor, allBindingsAccessor, viewModel) {
            var options = valueAccessor();
            if (!(options.mouseMove && options.mouseUp)) {
                throw "MouseCapture requires mouseMove and mouseUp handlers in binding";
            }
            // Here we mimic the KO convention of passing in the viewModel as the first parameter to event handlers.
            var mouseMove = function (e) {
                options.mouseMove(viewModel, e);
            };
            var mouseUp = function (e) {
                options.mouseUp(viewModel, e);
            };
            var capture = new MouseCapture(element, mouseMove, mouseUp);
            // We need to exempt this MouseCapture from disposal registration assertion,
            // since we're responsible for disposing of the mouse capture
            DataLab.Util.Disposable.exemptFromDiposablesInContextAssertion(capture);
            ko.utils.domNodeDisposal.addDisposeCallback(element, function () {
                capture.dispose();
            });
        },
        update: function () {
        }
    };
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
var ExperimentEditor;
(function (ExperimentEditor) {
    var Constants;
    (function (Constants) {
        Constants.SixtyFPS = 1000 / 60;
    })(Constants = ExperimentEditor.Constants || (ExperimentEditor.Constants = {}));
    var requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;
    window.requestAnimationFrame = requestAnimationFrame;
    var Animation = (function () {
        function Animation(stepFunction, animatedProperties, duration, easingFunction) {
            if (duration === void 0) { duration = 800; }
            if (easingFunction === void 0) { easingFunction = Animation.defaultEasing; }
            this.easingFunction = easingFunction;
            this.duration = duration;
            this.startTime = Date.now();
            this.endTime = this.startTime + duration;
            this.stepFunction = stepFunction;
            this.animatedProperties = animatedProperties;
            this.animationEnded = new ko.subscribable();
            this._animationStopped = false;
            this.ignoreFrames = false;
            for (var key in this.animatedProperties) {
                if (isNaN(Number(animatedProperties[key].start))) {
                    throw "The property " + key + " lacks a numerical animation start value";
                }
                if (isNaN(Number(animatedProperties[key].end))) {
                    throw "The property " + key + " lacks a numerical animation end value";
                }
            }
        }
        // We use this to avoid versioning issues with jquery's swing function
        Animation.defaultEasing = function (percentTime) {
            return (Math.sin((percentTime - 0.5) * Math.PI) + 1) / 2;
        };
        Animation.prototype.start = function () {
            var _this = this;
            if (this._animationStopped) {
                throw new Error("Cannot start a previously stopped animation.");
            }
            if (window.requestAnimationFrame) {
                window.requestAnimationFrame(function () {
                    _this.step();
                });
            }
            else {
                this.legacyIntervalAnimationId = window.setTimeout(function () {
                    _this.step();
                }, Constants.SixtyFPS);
            }
        };
        Animation.prototype.stop = function () {
            if (this._animationStopped) {
                throw new Error("Cannot stop an animation twice.");
            }
            this._animationStopped = true;
            // Immediately fire the last frame so subscribers get notified immediately.
            this.step();
        };
        Object.defineProperty(Animation.prototype, "animationStopped", {
            get: function () {
                return this._animationStopped;
            },
            enumerable: true,
            configurable: true
        });
        Animation.prototype.step = function () {
            var _this = this;
            // This prevents a race condition where we may have called requestAnimationFrame before calling stop
            // meaning step will get called again. This ensures that the last frame that does anything is
            // the one immediately proceeding .stop()
            if (this.ignoreFrames) {
                return;
            }
            var percentTimeComplete = (Date.now() - this.startTime) / (this.endTime - this.startTime);
            var percentAnimationComplete = percentTimeComplete < 1.0 ? this.easingFunction(percentTimeComplete) : 1.0;
            var currentAnimationState = new Object();
            for (var key in this.animatedProperties) {
                var start = Number(this.animatedProperties[key].start);
                var end = Number(this.animatedProperties[key].end);
                currentAnimationState[key] = start + (end - start) * percentAnimationComplete;
            }
            // If we stopped the animation (for completion or otherwise), make sure we don't call step again
            // and notify subscribers that the animation ended
            if (this._animationStopped) {
                this.animationEnded.notifySubscribers(currentAnimationState);
                this.ignoreFrames = true;
                return;
            }
            this.stepFunction(currentAnimationState);
            if (percentTimeComplete < 1.0) {
                if (window.requestAnimationFrame) {
                    window.requestAnimationFrame(function () {
                        _this.step();
                    });
                }
                else {
                    window.setTimeout(function () {
                        _this.step();
                    }, Constants.SixtyFPS);
                }
            }
            else {
                this.stop();
            }
        };
        return Animation;
    })();
    ExperimentEditor.Animation = Animation;
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
var ExperimentEditor;
(function (ExperimentEditor) {
    var LocalStorageCache = (function () {
        /**
          * Constructs a cache stored in localStorage. An LRU policy is used to
          * evict old items from the cache.
          * @param {string} name The name of the cache
          * @param {number} cacheLines The max number of lines to be stored in
          * the cache. If max is reached, LRU is used to evict old items.
          * @param {ILRUDate} An object used to generate timestamps, by default
          * the Date object is used.
         **/
        function LocalStorageCache(name, cacheLines, date) {
            if (date === void 0) { date = Date; }
            // IE10 does not instantiate localStorage when running from a local file,
            // so we create an empty object in that case
            this.name = name;
            this.cacheLines = cacheLines;
            this.LRUDate = date;
            if (LocalStorageCache.localStorageWrapper[name]) {
                this.items = JSON.parse(LocalStorageCache.localStorageWrapper[name]);
            }
            else {
                this.items = Object.create(null);
            }
        }
        /**
          * Adds an item to the cache. If the cache is full, an LRU policy is
          * used to remove old items. A current timestamp is attached to an item
          * when it is added into the cache, and updated if it is re-added.
          * @param {T} item The item to be added to the cache
          * @param {string} key The key used to lookup the item in the cache
         **/
        LocalStorageCache.prototype.add = function (item, key) {
            if (this.items[key]) {
                this.items[key] = { item: item, timeStamp: this.LRUDate.now() };
                LocalStorageCache.localStorageWrapper[this.name] = JSON.stringify(this.items);
                return;
            }
            if (Object.keys(this.items).length < this.cacheLines) {
                this.items[key] = { item: item, timeStamp: this.LRUDate.now() };
            }
            else {
                var oldest = Infinity;
                var oldestItemKey = null;
                DataLab.Util.forEach(this.items, function (value, key) {
                    if (value.timeStamp < oldest) {
                        oldestItemKey = key;
                        oldest = value.timeStamp;
                    }
                });
                delete this.items[oldestItemKey];
                this.items[key] = { item: item, timeStamp: this.LRUDate.now() };
            }
            LocalStorageCache.localStorageWrapper[this.name] = JSON.stringify(this.items);
        };
        /**
          * Fetches an item from the cache using the key for lookup.
          * The timestamp of an item is updated when it is fetched.
          * @param {string} key The key used for lookup
          * @return {T} The item from the cache, or undefined if the key is not
          * found
         **/
        LocalStorageCache.prototype.fetch = function (key) {
            var fetchedItem = this.items[key];
            if (fetchedItem) {
                fetchedItem.timeStamp = this.LRUDate.now();
                LocalStorageCache.localStorageWrapper[this.name] = JSON.stringify(this.items);
            }
            return fetchedItem ? fetchedItem.item : undefined;
        };
        LocalStorageCache.prototype.clear = function () {
            this.items = Object.create(null);
        };
        LocalStorageCache.localStorageWrapper = (localStorage ? localStorage : Object.create(null));
        return LocalStorageCache;
    })();
    ExperimentEditor.LocalStorageCache = LocalStorageCache;
})(ExperimentEditor || (ExperimentEditor = {}));

var ExperimentEditor;
(function (ExperimentEditor) {
    var CoordinateHelper = (function () {
        function CoordinateHelper(svgRoot, getViewDimensions, svgTransformElement) {
            this.svgRoot = svgRoot;
            this.getViewDimensions = getViewDimensions;
            this.svgTransformElement = svgTransformElement;
        }
        CoordinateHelper.prototype.clientToDomainCoordinates = function (x, y) {
            // Here we transform client coordinates (i.e. clientX/Y on a mouse event) to domain coordinates. Using the bounding
            // rect of the experiment canvas div provides the top left corner of the experiment editor, and works as expected,
            // unlike the svg root, which causes strange behavior in IE and chrome when the browser is zoomed and always in FF.
            var offsetCoordinate = this.svgRoot.createSVGPoint();
            var svgBounds = this.getViewDimensions();
            offsetCoordinate.x = x - svgBounds.x;
            offsetCoordinate.y = y - svgBounds.y;
            var transformInverse;
            try {
                transformInverse = this.svgTransformElement.getCTM().inverse();
            }
            catch (Exception) {
                Shell.Diagnostics.Telemetry.customEvent("SVGMatrixInverseFailed", "SVGInteraction", JSON.stringify({ "CTMMatrix": this.svgTransformElement.getCTM(), "x": x, "y": y }));
                throw Exception;
            }
            return offsetCoordinate.matrixTransform(transformInverse);
        };
        return CoordinateHelper;
    })();
    ExperimentEditor.CoordinateHelper = CoordinateHelper;
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="CoordinateHelper.ts" />
/// <reference path="IPanResponder.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var ExperimentEditor;
(function (ExperimentEditor) {
    // This class exists to emulate the C# "readonly" functionality; by making sure these fields are not reassigned.
    var ReadOnlyZoomHelperMembers = (function () {
        function ReadOnlyZoomHelperMembers(svgRoot, coordinateHelper, zoomControl, getViewDimensions, changeCallback, getTopLeft, animationComplete, svgTransformElement, updateScrollbars, overlayDivs, getBounds, matrixTransform) {
            this._svgRoot = svgRoot;
            this._coordinateHelper = coordinateHelper;
            this._zoomControl = zoomControl;
            this._getViewDimensions = getViewDimensions;
            this._changeCallback = changeCallback;
            this._getTopLeft = getTopLeft;
            this._animationComplete = animationComplete;
            this._svgTransformElement = svgTransformElement;
            this._updateScrollbars = updateScrollbars;
            this._overlayDivs = overlayDivs;
            this._getBounds = getBounds;
            this._matrixTransform = matrixTransform;
        }
        Object.defineProperty(ReadOnlyZoomHelperMembers.prototype, "svgRoot", {
            get: function () {
                return this._svgRoot;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ReadOnlyZoomHelperMembers.prototype, "coordinateHelper", {
            get: function () {
                return this._coordinateHelper;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ReadOnlyZoomHelperMembers.prototype, "zoomControl", {
            get: function () {
                return this._zoomControl;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ReadOnlyZoomHelperMembers.prototype, "getViewDimensions", {
            get: function () {
                return this._getViewDimensions;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ReadOnlyZoomHelperMembers.prototype, "changeCallback", {
            get: function () {
                return this._changeCallback;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ReadOnlyZoomHelperMembers.prototype, "getTopLeft", {
            get: function () {
                return this._getTopLeft;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ReadOnlyZoomHelperMembers.prototype, "animationComplete", {
            get: function () {
                return this._animationComplete;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ReadOnlyZoomHelperMembers.prototype, "svgTransformElement", {
            get: function () {
                return this._svgTransformElement;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ReadOnlyZoomHelperMembers.prototype, "updateScrollbars", {
            get: function () {
                return this._updateScrollbars;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ReadOnlyZoomHelperMembers.prototype, "overlayDivs", {
            get: function () {
                return this._overlayDivs;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ReadOnlyZoomHelperMembers.prototype, "getBounds", {
            get: function () {
                return this._getBounds;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ReadOnlyZoomHelperMembers.prototype, "matrixTransform", {
            get: function () {
                return this._matrixTransform;
            },
            enumerable: true,
            configurable: true
        });
        return ReadOnlyZoomHelperMembers;
    })();
    var ZoomHelper = (function (_super) {
        __extends(ZoomHelper, _super);
        function ZoomHelper(svgTransformElement, svgRoot, coordinateHelper, zoomControl, getViewDimensions, changeCallback, getTopLeft, animationComplete, updateScrollbars, overlayDivs, getBounds) {
            _super.call(this);
            // We capture the return value of appendItem since IE9 likes to append copies rather than references.
            var transformList = svgTransformElement.transform.baseVal;
            var transform = transformList.appendItem(svgRoot.createSVGTransform());
            this.initOnly = new ReadOnlyZoomHelperMembers(svgRoot, coordinateHelper, zoomControl, getViewDimensions, changeCallback, getTopLeft, animationComplete, svgTransformElement, updateScrollbars, overlayDivs, getBounds, transform);
            this.currentPanZoomAnimation = null;
            this.lastAnimatedScale = this.initOnly.zoomControl.getScale();
            this.topLeftDest = null;
            var self = this;
            // We own the zoomControl, so we don't need to unsubscribe
            var zoomWithoutAnimationSubscription = this.initOnly.zoomControl.zoomWithoutAnimation.subscribe(function (e) {
                self.zoomToEventWithoutAnimation(e);
            });
            this.registerForDisposal(new DataLab.Util.DisposableKnockoutObject(zoomWithoutAnimationSubscription));
            var zoomWithAnimationSubscription = this.initOnly.zoomControl.zoomWithAnimation.subscribe(function (e) {
                self.zoomToEventWithAnimation(e);
            });
            this.registerForDisposal(new DataLab.Util.DisposableKnockoutObject(zoomWithAnimationSubscription));
            var zoomToFitSubscription = this.initOnly.zoomControl.zoomToFit.subscribe(function () {
                self.zoomToFitWithAnimation();
            });
            this.registerForDisposal(new DataLab.Util.DisposableKnockoutObject(zoomToFitSubscription));
        }
        Object.defineProperty(ZoomHelper.prototype, "currentAnimation", {
            get: function () {
                return this.currentPanZoomAnimation;
            },
            enumerable: true,
            configurable: true
        });
        /**
         *  Computes the experiment pan limits which are used both for scroll bar elevator sizing and to prevent the user from getting lost while they are panning.
         *
         * @return {SVGRect} the pan limits denoted by the top left corner (x,y) and the panning area (width,height)
         */
        ZoomHelper.prototype.getPanLimits = function (scale) {
            if (scale === void 0) { scale = this.initOnly.zoomControl.getScale(); }
            var experimentBounds = this.initOnly.getBounds();
            var viewDimensions = this.initOnly.getViewDimensions();
            var viewWidth = viewDimensions.width / scale;
            var viewHeight = viewDimensions.height / scale;
            if (experimentBounds.width === 0 && experimentBounds.height === 0) {
                // Normally the pan limits are the experiment bounds plus a viewport-relative buffer area on all sides, this results in
                // even null experiments exceeding the viewport bounds, however. In this case, we set the pan limits to the viewport size
                // to avoid scrolling.
                return {
                    x: this.initOnly.getTopLeft().x / scale,
                    y: this.initOnly.getTopLeft().y / scale,
                    width: viewWidth,
                    height: viewHeight
                };
            }
            return {
                x: Math.min(experimentBounds.x - (viewWidth - ExperimentEditor.Constants.RectWidth), this.initOnly.getTopLeft().x / scale),
                y: Math.min(experimentBounds.y - (viewHeight - ExperimentEditor.Constants.RectHeight), this.initOnly.getTopLeft().y / scale),
                width: Math.max(experimentBounds.width + (viewWidth - ExperimentEditor.Constants.RectWidth) * 2, viewWidth),
                height: Math.max(experimentBounds.height + (viewHeight - ExperimentEditor.Constants.RectHeight) * 2, viewHeight)
            };
        };
        ZoomHelper.prototype.zoom = function (scale) {
            var domainCenterView = this.initOnly.coordinateHelper.clientToDomainCoordinates(this.viewCenter.x, this.viewCenter.y);
            this.zoomToPoint(scale, domainCenterView.x, domainCenterView.y);
        };
        ZoomHelper.prototype.zoomToEventWithoutAnimation = function (e) {
            var x = e.x ? e.x : this.viewCenter.x;
            var y = e.y ? e.y : this.viewCenter.y;
            var domainCoords = this.initOnly.coordinateHelper.clientToDomainCoordinates(x, y);
            this.zoomToPointWithoutAnimation(e.scale, domainCoords.x, domainCoords.y);
        };
        ZoomHelper.prototype.zoomToEventWithAnimation = function (e) {
            var x = e.x ? e.x : this.viewCenter.x;
            var y = e.y ? e.y : this.viewCenter.y;
            var domainCoords = this.initOnly.coordinateHelper.clientToDomainCoordinates(x, y);
            this.zoomToPointWithAnimation(e.scale, domainCoords.x, domainCoords.y);
        };
        Object.defineProperty(ZoomHelper.prototype, "viewCenter", {
            get: function () {
                var viewDimensions = this.initOnly.getViewDimensions();
                return {
                    x: viewDimensions.x + viewDimensions.width / 2,
                    y: viewDimensions.y + viewDimensions.height / 2,
                    matrixTransform: null
                };
            },
            enumerable: true,
            configurable: true
        });
        // targetX and targetY are in client space. This is convenient as the scale will be changing continuously
        // until the animation ends.
        ZoomHelper.prototype.animateToLocation = function (targetX, targetY, targetScale) {
            var _this = this;
            if (targetScale === void 0) { targetScale = this.initOnly.zoomControl.getScale(); }
            var startScale = this.initOnly.zoomControl.getScale();
            this.topLeftDest = {
                x: targetX,
                y: targetY,
                matrixTransform: null
            };
            // If we're interrupting an existing animation, we need to get our startScale from
            // the last animated scale
            if (this.currentPanZoomAnimation && !this.currentPanZoomAnimation.animationStopped) {
                this.currentPanZoomAnimation.stop();
                startScale = this.lastAnimatedScale;
            }
            var animationParameters = new Object();
            animationParameters.x = { start: this.initOnly.getTopLeft().x, end: targetX };
            animationParameters.y = { start: this.initOnly.getTopLeft().y, end: targetY };
            animationParameters.scale = { start: startScale, end: targetScale };
            this.currentPanZoomAnimation = new ExperimentEditor.Animation(function (animationState) {
                _this.setOriginAndZoom(animationState.x, animationState.y, animationState.scale);
                _this.lastAnimatedScale = animationState.scale;
                _this.initOnly.zoomControl.setScale(animationState.scale);
            }, animationParameters, ExperimentEditor.Constants.AnimatedZoomDuration);
            this.currentPanZoomAnimation.start();
            // This is a one shot, so we'll dispose when called.
            var subscription = this.currentPanZoomAnimation.animationEnded.subscribe(function (animationState) {
                _this.initOnly.zoomControl.setScale(animationState.scale);
                _this.initOnly.animationComplete();
                subscription.dispose();
            });
        };
        ZoomHelper.prototype.getDestinationOrigin = function () {
            if (this.currentPanZoomAnimation && !this.currentPanZoomAnimation.animationStopped) {
                return this.topLeftDest;
            }
            else {
                return this.initOnly.getTopLeft();
            }
        };
        ZoomHelper.prototype.zoomToPointWithoutAnimation = function (targetScale, domainX, domainY) {
            var zoomInfo = this.zoomToPoint(targetScale, domainX, domainY);
            // Stop the current animation if it exists it won't be conflicting with our update
            if (this.currentPanZoomAnimation && !this.currentPanZoomAnimation.animationStopped) {
                this.currentPanZoomAnimation.stop();
            }
            this.setOriginAndZoom(zoomInfo.x, zoomInfo.y, zoomInfo.scale);
            this.initOnly.zoomControl.setScale(zoomInfo.scale);
            this.initOnly.updateScrollbars();
        };
        ZoomHelper.prototype.zoomToPointWithAnimation = function (targetScale, domainX, domainY) {
            var zoomInfo = this.zoomToPoint(targetScale, domainX, domainY);
            this.animateToLocation(zoomInfo.x, zoomInfo.y, zoomInfo.scale);
        };
        ZoomHelper.prototype.zoomToPoint = function (targetScale, domainX, domainY) {
            var experimentBounds = this.initOnly.getBounds();
            var zoomed = this.initOnly.svgRoot.createSVGPoint();
            zoomed.x = Math.min(experimentBounds.x + experimentBounds.width, Math.max(experimentBounds.x, domainX));
            zoomed.y = Math.min(experimentBounds.y + experimentBounds.height, Math.max(experimentBounds.y, domainY));
            // zoomed -> unzoomed with the current matrix, and we wish to preserve that in the new one.
            // To determine the unzoomed point, we cannot simply divide by the current scale, since there
            // is also a translation component (fully determined by the _previous_ zoom center point)
            var unzoomed = zoomed.matrixTransform(this.initOnly.matrixTransform.matrix);
            var targetX = -(unzoomed.x - zoomed.x * targetScale);
            var targetY = -(unzoomed.y - zoomed.y * targetScale);
            return {
                scale: targetScale,
                x: targetX,
                y: targetY
            };
        };
        /**
          * Performs a zoom to fit with animation
         **/
        ZoomHelper.prototype.zoomToFitWithAnimation = function () {
            var targetLocation = this.computeZoomToFitLocation();
            this.animateToLocation(targetLocation.domainX, targetLocation.domainY, targetLocation.scale);
        };
        ZoomHelper.prototype.computeZoomToFitLocation = function () {
            var experimentBounds = this.initOnly.getBounds();
            var viewBounds = this.initOnly.getViewDimensions();
            var scaleX = (viewBounds.width - 2 * ExperimentEditor.Constants.Layout.zoomToFitPadding) / experimentBounds.width;
            var scaleY = (viewBounds.height - 2 * ExperimentEditor.Constants.Layout.zoomToFitPadding) / experimentBounds.height;
            var targetScale = this.initOnly.zoomControl.getClosestValidScale(Math.min(scaleX, scaleY));
            var targetX = experimentBounds.x * targetScale - (viewBounds.width - experimentBounds.width * targetScale) / 2;
            ;
            var targetY = experimentBounds.y * targetScale - (viewBounds.height - experimentBounds.height * targetScale) / 2;
            ;
            return { domainX: targetX, domainY: targetY, scale: targetScale };
        };
        /**
          * This is our primitive for setting view. The user passes the domainX and Y of the top
          * left corner of the screen they want and the zoom level they want. This should be the only
          * function that writes to the transform matrix.
          * @param {number} domainX The X value of the desired top left corner of the screen
          * @param {number} domainX The Y value of the desired top left corner of the screen
          * @param {number} scale The desired scale
          * @param {number} fromScrollBars Whether or not to update the size of the scroll bars
         **/
        ZoomHelper.prototype.setOriginAndZoom = function (domainX, domainY, scale, fromScrollbars) {
            if (scale === void 0) { scale = this.initOnly.zoomControl.getScale(); }
            if (fromScrollbars === void 0) { fromScrollbars = false; }
            var newX = domainX;
            var newY = domainY;
            var viewDimensions = this.initOnly.getViewDimensions();
            var panLimits = this.getPanLimits(scale);
            newX = scale * Math.max(newX / scale, panLimits.x);
            newY = scale * Math.max(newY / scale, panLimits.y);
            newX = (scale * Math.min((newX + viewDimensions.width) / scale, panLimits.x + panLimits.width)) - viewDimensions.width;
            newY = (scale * Math.min((newY + viewDimensions.height) / scale, panLimits.y + panLimits.height)) - viewDimensions.height;
            var newTransform = this.initOnly.svgRoot.createSVGMatrix().translate(-newX, -newY).scale(scale);
            this.initOnly.getTopLeft().x = newX;
            this.initOnly.getTopLeft().y = newY;
            this.initOnly.matrixTransform.setMatrix(newTransform);
            var m = this.initOnly.svgTransformElement.getCTM();
            var transformString = "matrix(" + m.a + "," + m.b + "," + m.c + "," + m.d + "," + m.e + "," + m.f + ")";
            for (var i = 0; i < this.initOnly.overlayDivs.length; i++) {
                $(this.initOnly.overlayDivs.item(i)).css("-webkit-transform", transformString);
                $(this.initOnly.overlayDivs.item(i)).css("transform", transformString);
                $(this.initOnly.overlayDivs.item(i)).css("-ms-transform", transformString);
                $(this.initOnly.overlayDivs.item(i)).css("-moz-transform", transformString);
            }
            if (!fromScrollbars) {
                this.initOnly.updateScrollbars();
            }
            this.initOnly.changeCallback({ domainX: domainX, domainY: domainY, scale: scale });
        };
        ZoomHelper.prototype.pan = function (clientdx, clientdy) {
            // We're effectively panning in client space since it's the outermost transform.
            this.setOriginAndZoom(this.initOnly.getTopLeft().x - clientdx, this.initOnly.getTopLeft().y - clientdy);
        };
        /**
          * Fits the experiment without animation. If the computed best fit scale
          * is greater than 1, scale is set to 1 and experiment is centered.
         **/
        ZoomHelper.prototype.fitExperimentWithoutAnimation = function () {
            var targetLocation = this.computeZoomToFitLocation();
            if (targetLocation.scale > 1) {
                targetLocation.scale = 1;
                targetLocation.domainX = this.initOnly.getBounds().x - ((this.initOnly.getViewDimensions().width - this.initOnly.getBounds().width) / 2);
                targetLocation.domainY = this.initOnly.getBounds().y - ExperimentEditor.Constants.InitialZoomToFitYOffSet;
            }
            this.setOriginAndZoom(targetLocation.domainX, targetLocation.domainY, targetLocation.scale, true);
            this.initOnly.zoomControl.setScale(targetLocation.scale);
        };
        return ZoomHelper;
    })(DataLab.Util.Disposable);
    ExperimentEditor.ZoomHelper = ZoomHelper;
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../Global.ts" />
/// <reference path="../ViewModel/ExperimentEditor/ExperimentEditorViewModel.ts" />
/// <reference path="ZoomControl.ts" />
/// <reference path="ScrollControl.ts" />
/// <reference path="../ViewModel/PaletteControl/IPaletteDragResponder.ts" />
/// <reference path="ICoordinateConverter.ts" />
/// <reference path="../Common/MouseCapture.ts" />
/// <reference path="../ViewModel/ExperimentEditor/Animation.ts" />
/// <reference path="Balloon.ts" />
/// <reference path="../ViewModel/ExperimentEditor/LocalStorageCache.ts" />
/// <reference path="ZoomHelper.ts" />
/// <reference path="CoordinateHelper.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var ExperimentEditor;
(function (ExperimentEditor) {
    var Constants;
    (function (Constants) {
        Constants.ModuleFromPaletteAnimationDuration = 350;
        Constants.AnimatedZoomDuration = 400;
        Constants.InitialZoomToFitYOffSet = 50;
        Constants.NumberOfCacheLines = 50;
    })(Constants = ExperimentEditor.Constants || (ExperimentEditor.Constants = {}));
    var ReadOnlyExperimentEditorMembers = (function () {
        function ReadOnlyExperimentEditorMembers(svgTransformElement, svgRoot, coordinateHelper, zoomControl, overlayDivs, zoomHelper) {
            this._svgTransformElement = svgTransformElement;
            this._svgRoot = svgRoot;
            this._coordinateHelper = coordinateHelper;
            this._zoomControl = zoomControl;
            this._overlayDivs = overlayDivs;
            this._zoomHelper = zoomHelper;
        }
        Object.defineProperty(ReadOnlyExperimentEditorMembers.prototype, "svgTransformElement", {
            get: function () {
                return this._svgTransformElement;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ReadOnlyExperimentEditorMembers.prototype, "svgRoot", {
            get: function () {
                return this._svgRoot;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ReadOnlyExperimentEditorMembers.prototype, "coordinateHelper", {
            get: function () {
                return this._coordinateHelper;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ReadOnlyExperimentEditorMembers.prototype, "zoomControl", {
            get: function () {
                return this._zoomControl;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ReadOnlyExperimentEditorMembers.prototype, "zoomHelper", {
            get: function () {
                return this._zoomHelper;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ReadOnlyExperimentEditorMembers.prototype, "overlayDivs", {
            get: function () {
                return this._overlayDivs;
            },
            enumerable: true,
            configurable: true
        });
        return ReadOnlyExperimentEditorMembers;
    })();
    // The ExperimentEditor control class
    var ExperimentEditorControl = (function (_super) {
        __extends(ExperimentEditorControl, _super);
        function ExperimentEditorControl(rootContainerDiv, viewModel) {
            var _this = this;
            _super.call(this);
            var me = this;
            if (!rootContainerDiv) {
                throw new Error("Experiment editor control must have a div for its view.");
            }
            this.rootContainerDiv = rootContainerDiv;
            // Mark our mess for disposal
            this.registerForDisposal(new DataLab.Util.DisposableSetHTML(this.rootContainerDiv, ExperimentEditor._editorSurfaceMarkup));
            // We use experimentCanvas div for the Drag 'N Drop container, since svg element does not support Drag 'N Drop.
            this.experimentCanvasDiv = this.rootContainerDiv.querySelector(".experimentEditorContainer");
            this.registerForDisposal(new DataLab.Util.DisposableKOApplyBindings(viewModel, this.experimentCanvasDiv));
            if (!this.experimentCanvasDiv) {
                throw new Error("Experiment editor control's root container div is missing experiment editor container");
            }
            this.canvasEventDiv = this.experimentCanvasDiv.querySelector(".customElements");
            var svgRoot = this.experimentCanvasDiv.querySelector("svg");
            if (svgRoot === null) {
                throw new Error("The required root <svg> element does not exist");
            }
            var svgTransformElement = svgRoot.querySelector("g");
            if (svgTransformElement === null) {
                throw new Error("The required root <svg><g> element does not exist");
            }
            // We don't own the view model, so we need to dispose of these subscriptions.
            this.registerForDisposal(new DataLab.Util.DisposableSubscription(viewModel.needsAnimationToNode.subscribe(function (node) {
                _this.animateToGraphNode(node);
            })), new DataLab.Util.DisposableSubscription(viewModel.needsAnimationToContent.subscribe(function (contentRect) {
                _this.bringRectIntoView(contentRect);
            })));
            this.viewModel = viewModel;
            this.viewModel.coordinateConverter = this;
            this.topLeft = svgRoot.createSVGPoint();
            this.viewModel.experimentView = this;
            this.controlPanelDiv = this.rootContainerDiv.querySelector("#controlPanel");
            if (!this.controlPanelDiv) {
                throw new Error("Required control panel div does not exist.");
            }
            // We create this disposable, so we dispose of it.
            var zoomControl = new ExperimentEditor.ZoomControl(this.controlPanelDiv, this.rootContainerDiv);
            this.registerForDisposal(zoomControl);
            var overlayDivs = this.experimentCanvasDiv.querySelectorAll(".xe-overlay");
            var panHelper = new ExperimentEditor.PanHelper(this.controlPanelDiv, function (e) {
                me._viewModel.panButtonClicked(e);
            });
            var getViewDimensions = function () {
                return me.getViewDimensions();
            };
            var coordinateHelper = new ExperimentEditor.CoordinateHelper(svgRoot, getViewDimensions, svgTransformElement);
            var onZoomChange = function (change) {
                me.viewModel.experimentOrViewPerturbed.notifySubscribers(null);
                me.rememberPositionForExperiment(change, me.viewModel.experiment.experimentId());
            };
            var getTopLeft = function () {
                return me.topLeft;
            };
            var onAnimationComplete = function () {
                me.viewModel.animationComplete.notifySubscribers(null);
                DataLab.TestMessaging.postMessage({ type: DataLab.TestMessaging.Constants.AnimationComplete });
            };
            var updateScrollbars = function () {
                me.updateScrollbars();
            };
            var getExperimentBounds = function () {
                return me.getExperimentBounds();
            };
            var zoomHelper = new ExperimentEditor.ZoomHelper(svgTransformElement, svgRoot, coordinateHelper, zoomControl, getViewDimensions, onZoomChange, getTopLeft, onAnimationComplete, updateScrollbars, overlayDivs, getExperimentBounds);
            this.initOnly = new ReadOnlyExperimentEditorMembers(svgTransformElement, svgRoot, coordinateHelper, zoomControl, overlayDivs, zoomHelper);
            this.viewModel.panResponder = this.initOnly.zoomHelper;
            var horizontalScrollDiv = this.rootContainerDiv.querySelector(".xe-surface").appendChild(document.createElement("div"));
            var verticalScrollDiv = this.rootContainerDiv.querySelector(".xe-surface").appendChild(document.createElement("div"));
            var scrollSpacer = this.rootContainerDiv.querySelector(".xe-surface").appendChild(document.createElement("div"));
            scrollSpacer.setAttribute("class", "scrollSpacer scrollUI");
            var scrollbarSize = ExperimentEditor.ScrollControl.computeDimensions();
            scrollSpacer.style.width = scrollbarSize.verticalScrollbarWidth.toFixed() + "px";
            scrollSpacer.style.height = scrollbarSize.horizontalScrollbarHeight.toFixed() + "px";
            this.calculateScrollPosition = function (orientation) {
                var axis = orientation == 0 /* Vertical */ ? "y" : "x";
                var length = orientation == 0 /* Vertical */ ? "height" : "width";
                var viewInfo = _this.viewModel.experimentView.getViewInfo();
                var viewDimensions = _this.getViewDimensions();
                var viewLength = viewDimensions[length] / me.initOnly.zoomControl.getScale();
                var panLimits = me.initOnly.zoomHelper.getPanLimits();
                var viewOffset = (viewInfo.topLeft[axis] / me.initOnly.zoomControl.getScale()) - panLimits[axis];
                return { elevatorLength: viewLength / panLimits[length], elevatorOffset: viewOffset / panLimits[length] };
            };
            this.scrollVertical = new ExperimentEditor.ScrollControl(verticalScrollDiv, this.calculateScrollPosition, 0 /* Vertical */, scrollbarSize);
            this.scrollVertical.viewScrolled.subscribe(function (elevatorOffset) {
                var panLimits = me.initOnly.zoomHelper.getPanLimits();
                me.initOnly.zoomHelper.setOriginAndZoom(me.topLeft.x, ((elevatorOffset * panLimits.height) + panLimits.y) * me.initOnly.zoomControl.getScale(), me.initOnly.zoomControl.getScale(), true);
            });
            this.scrollHorizontal = new ExperimentEditor.ScrollControl(horizontalScrollDiv, this.calculateScrollPosition, 1 /* Horizontal */, scrollbarSize);
            this.scrollHorizontal.viewScrolled.subscribe(function (elevatorOffset) {
                if (!_this.viewModel.isBeingResized()) {
                    var panLimits = me.initOnly.zoomHelper.getPanLimits();
                    me.initOnly.zoomHelper.setOriginAndZoom(((elevatorOffset * panLimits.width) + panLimits.x) * me.initOnly.zoomControl.getScale(), me.topLeft.y, me.initOnly.zoomControl.getScale(), true);
                }
            });
            this.registerForDisposal(new DataLab.Util.DisposableEventListener(window, "resize", function () {
                me.updateScrollbars();
            }), new DataLab.Util.DisposableSubscription(this.viewModel.isBeingResized.subscribe(function (isResizing) {
                me.scrollHorizontal.sizeUpdated();
            })), new DataLab.Util.DisposableSubscription(this.viewModel.experimentOrViewBoundsChanged.subscribe(function () {
                me.scrollHorizontal.sizeUpdated();
            })));
            this.setupEventHandlers(this.canvasEventDiv);
            this.isDraggingNewEntity = false;
            this.experimentPositionCache = new ExperimentEditor.LocalStorageCache("experimentPosition", Constants.NumberOfCacheLines);
            this.registerForDisposal(new DataLab.Util.DisposableSubscription(this.viewModel.newExperimentLoaded.subscribe(function () {
                var fetchedItem = _this.experimentPositionCache.fetch(me.viewModel.experimentViewModel().experiment.experimentId());
                if (fetchedItem) {
                    me.initOnly.zoomControl.setScale(fetchedItem.scale);
                    me.initOnly.zoomHelper.setOriginAndZoom(fetchedItem.domainX, fetchedItem.domainY);
                }
                else {
                    var parentZoom = _this.experimentPositionCache.fetch(me.viewModel.experiment.parentExperimentId);
                    if (parentZoom) {
                        me.initOnly.zoomControl.setScale(parentZoom.scale);
                        me.initOnly.zoomHelper.setOriginAndZoom(parentZoom.domainX, parentZoom.domainY);
                    }
                    else {
                        me.initOnly.zoomHelper.fitExperimentWithoutAnimation();
                    }
                }
            })), new DataLab.Util.DisposableSubscription(this.viewModel.setLastPositionForExperiment.subscribe(function (experimentId) {
                me.rememberPositionForExperiment({ domainX: me.topLeft.x, domainY: me.topLeft.y, scale: me.initOnly.zoomControl.getScale() }, experimentId);
            })));
        }
        ExperimentEditorControl.prototype.clearPositionCache = function () {
            this.experimentPositionCache.clear();
        };
        ExperimentEditorControl.prototype.updateScrollbars = function () {
            this.scrollHorizontal.sizeUpdated();
            this.scrollVertical.sizeUpdated();
        };
        Object.defineProperty(ExperimentEditorControl.prototype, "currentPanZoomAnimation", {
            get: function () {
                return this.initOnly.zoomHelper.currentAnimation;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExperimentEditorControl.prototype, "viewModel", {
            get: function () {
                return this._viewModel;
            },
            set: function (newViewModel) {
                if (this._viewModel !== newViewModel) {
                    this._viewModel = newViewModel;
                    // Throw away the old viewModelDisposable. Destroys unneeded subscriptions.
                    if (this.viewModelDisposable) {
                        this.viewModelDisposable.dispose();
                    }
                    this.registerForDisposal(this.viewModelDisposable = new DataLab.Util.Disposable());
                    // We don't own the view model, so we need to unsubscribe. Our viewModelDisposal will
                    // do that for us.
                    this.viewModelDisposable.registerForDisposal(new DataLab.Util.DisposableSubscription(this.viewModel.experimentDirty.subscribe(function (dirty) {
                        if (dirty) {
                            if (!window["isExperimentEditorTestPage"]) {
                                var navigationMessage = "You have unsaved changes in this experiment, which will be lost if you leave this page.";
                                Shell.UI.Navigation.setConfirmNavigateAway(navigationMessage);
                                $(window).bind("onbeforeunload", function () {
                                    return navigationMessage;
                                });
                            }
                        }
                        else {
                            Shell.UI.Navigation.removeConfirmNavigateAway();
                            $(window).unbind("onbeforeunload");
                        }
                    })));
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         *  Computes the experiment pan limits which are used both for scroll bar elevator sizing and to prevent the user from getting lost while they are panning.
         *
         * @return {SVGRect} the pan limits denoted by the top left corner (x,y) and the panning area (width,height)
         */
        ExperimentEditorControl.prototype.getPanLimits = function (scale) {
            if (scale === void 0) { scale = this.initOnly.zoomControl.getScale(); }
            return this.initOnly.zoomHelper.getPanLimits(scale);
        };
        ExperimentEditorControl.prototype.getScale = function () {
            return this.initOnly.zoomControl.getScale();
        };
        ExperimentEditorControl.prototype.paletteDragMoved = function (e) {
            e.preventDefault();
            var viewBounds = this.getViewDimensions();
            var domainCoords = this.initOnly.coordinateHelper.clientToDomainCoordinates(e.clientX, e.clientY);
            // If the cursor is in the view bounds, we either need to create or move the drag item. If not,
            // we need to destroy the drag item or do nothing.
            if (e.clientX >= viewBounds.x && e.clientY >= viewBounds.y && e.clientX < viewBounds.x + viewBounds.width && e.clientY < viewBounds.y + viewBounds.height) {
                if (this.isDraggingNewEntity === false) {
                    this.isDraggingNewEntity = true;
                    this.viewModel.paletteDragEnter(domainCoords);
                }
                else {
                    this.viewModel.paletteDragMove(domainCoords);
                }
            }
            else {
                this.paletteDragCancel();
            }
        };
        ExperimentEditorControl.prototype.rememberPositionForExperiment = function (position, experimentId) {
            this.experimentPositionCache.add(position, experimentId);
        };
        ExperimentEditorControl.prototype.paletteDragStart = function (e, paletteItem) {
            this.viewModel.paletteDragStart(paletteItem);
        };
        ExperimentEditorControl.prototype.paletteDragEnd = function (e) {
            this.isDraggingNewEntity = false;
            var datasetToAnimateTo = this.viewModel.paletteDragEnd();
            var coords = this.initOnly.coordinateHelper.clientToDomainCoordinates(e.clientX, e.clientY);
            var m = this.initOnly.svgTransformElement.getCTM();
            var transformString = "matrix(" + m.a + "," + m.b + "," + m.c + "," + m.d + "," + m.e + "," + m.f + ")";
            for (var i = 0; i < this.initOnly.overlayDivs.length; i++) {
                $(this.initOnly.overlayDivs.item(i)).css("-webkit-transform", transformString);
                $(this.initOnly.overlayDivs.item(i)).css("transform", transformString);
                $(this.initOnly.overlayDivs.item(i)).css("-ms-transform", transformString);
                $(this.initOnly.overlayDivs.item(i)).css("-moz-transform", transformString);
            }
            // If the dataset already exists on the canvas, animate to it
            if (datasetToAnimateTo) {
                var scale = this.initOnly.zoomControl.getScale();
                // The final result should be in client coordinates
                var x = (datasetToAnimateTo.x() - (coords.x - this.topLeft.x / scale - datasetToAnimateTo.width() / 2)) * scale;
                var y = (datasetToAnimateTo.y() - (coords.y - this.topLeft.y / scale - datasetToAnimateTo.height() / 2)) * scale;
                this.initOnly.zoomHelper.animateToLocation(x, y);
                this.viewModel.selectionManager.resetSelection();
                this.viewModel.selectionManager.selectEntity(datasetToAnimateTo);
            }
        };
        ExperimentEditorControl.prototype.paletteDragCancel = function () {
            this.viewModel.paletteDragLeave();
            this.isDraggingNewEntity = false;
        };
        ExperimentEditorControl.prototype.zoom = function (scale) {
            this.initOnly.zoomHelper.zoom(scale);
        };
        ExperimentEditorControl.prototype.pan = function (clientdx, clientdy) {
            this.initOnly.zoomHelper.pan(clientdx, clientdy);
        };
        // Get the global page x and y coordinates of the canvas with no ifs ands or buts. Also return height and width.
        ExperimentEditorControl.prototype.getViewDimensions = function () {
            var boundingClientRect = null;
            try {
                boundingClientRect = this.experimentCanvasDiv.getBoundingClientRect();
            }
            catch (exception) {
                boundingClientRect = null;
                Shell.Diagnostics.Telemetry.customEvent("ExceptionTelemetry", "getBoundingClientRectThrewException", JSON.stringify(exception));
            }
            var rect = {
                // Do not use the bounding box of svgRoot, as it causes bizarre behavior in FF and can mess things up in
                // Chrome and IE as well when the browser is zoomed.
                x: boundingClientRect ? boundingClientRect.left : 0,
                y: boundingClientRect ? boundingClientRect.top : 0,
                width: this.experimentCanvasDiv.clientWidth,
                height: this.experimentCanvasDiv.clientHeight
            };
            // The footer overlaps the canvas by x pixels, where x is the height of the experiment title header. If the
            // DOM element exists, subtract this off the height to only get the visible part of the canvas
            var titleHeader = document.querySelector(".experiment-header");
            if (titleHeader) {
                rect.height -= titleHeader.clientHeight;
            }
            return rect;
        };
        Object.defineProperty(ExperimentEditorControl.prototype, "viewCenter", {
            get: function () {
                return this.initOnly.zoomHelper.viewCenter;
            },
            enumerable: true,
            configurable: true
        });
        // Used for double-click on a palette item
        ExperimentEditorControl.prototype.addEntityToCenter = function (paletteItem, e) {
            var _this = this;
            // If the selected palette item is a dataset or trained model and it already exists, animate to the existing one
            // instead of adding a copy
            var existingDataset = this.viewModel.experimentViewModel().experiment.getDatasetNode(paletteItem.id());
            var existingTrainedModel = this.viewModel.experimentViewModel().experiment.getTrainedModelNode(paletteItem.id());
            var existingTransform = this.viewModel.experimentViewModel().experiment.getTransformNode(paletteItem.id());
            var animateToExisingNode = function (existingNode) {
                var nodeToAnimateTo = _this.viewModel.experimentViewModel().getViewModelForNode(existingNode);
                _this.animateToGraphNode(nodeToAnimateTo);
                _this.viewModel.selectionManager.resetSelection();
                _this.viewModel.selectionManager.selectEntity(nodeToAnimateTo);
            };
            if (existingDataset) {
                animateToExisingNode(existingDataset);
                return;
            }
            else if (existingTrainedModel) {
                animateToExisingNode(existingTrainedModel);
                return;
            }
            else if (existingTransform) {
                animateToExisingNode(existingTransform);
                return;
            }
            var viewCenter = this.initOnly.zoomHelper.viewCenter;
            var startPoint = this.initOnly.coordinateHelper.clientToDomainCoordinates(e.clientX, e.clientY);
            var addingEntity = this.viewModel.createNode(paletteItem.type(), paletteItem.id(), startPoint.x, startPoint.y);
            var endPoint = this.initOnly.coordinateHelper.clientToDomainCoordinates(viewCenter.x - addingEntity.width() / 2, viewCenter.y - addingEntity.height() / 2);
            endPoint = this.viewModel.calculatePlacement(endPoint);
            var animationParameters = new Object();
            animationParameters.x = { start: startPoint.x, end: endPoint.x };
            animationParameters.y = { start: startPoint.y, end: endPoint.y };
            var animation = new ExperimentEditor.Animation(function (animationState) {
                addingEntity.x(animationState.x);
                addingEntity.y(animationState.y);
            }, animationParameters, Constants.ModuleFromPaletteAnimationDuration);
            // This is a one-shot, so we'll dispose when this fires.
            var subscription = animation.animationEnded.subscribe(function () {
                var addedViewModel = _this.viewModel.experimentViewModel().addNode(addingEntity);
                if (addedViewModel) {
                    if (addingEntity instanceof ExperimentEditor.Module) {
                        // Instrumentation scenario: User adds a Module
                        // For privacy reasons, log the name of the node only if the author is "Microsoft Corporation"
                        var canInstrumentNodeName = true; // newModuleNode.owner === "Microsoft Corporation";
                        if (canInstrumentNodeName) {
                            Shell.Diagnostics.Telemetry.featureUsage(37 /* AddModuleByDoubleClick */, 38 /* ExperimentEditor */, null, _this._viewModel.experiment.experimentId(), addingEntity.moduleNode.module_.id, addingEntity.moduleNode.module_.name());
                        }
                    }
                    _this.viewModel.selectionManager.resetSelection();
                    _this.viewModel.selectionManager.selectEntity(addedViewModel);
                }
                _this.bringRectIntoView({ x: endPoint.x, y: endPoint.y, width: addingEntity.width(), height: addingEntity.height() });
                DataLab.TestMessaging.postMessage({ type: DataLab.TestMessaging.Constants.AnimationComplete });
                subscription.dispose();
            });
            animation.start();
        };
        ExperimentEditorControl.prototype.clientToDomainCoordinates = function (x, y) {
            return this.initOnly.coordinateHelper.clientToDomainCoordinates(x, y);
        };
        /**
          * Returns the dimensions of the entire experiment in domain coordinates
         **/
        ExperimentEditorControl.prototype.getExperimentBounds = function () {
            var experimentBounds = DataLab.Util.clone(this.initOnly.svgTransformElement.getBBox());
            var comments = this.experimentCanvasDiv.querySelectorAll("div.comment");
            for (var i = 0; i < comments.length; i++) {
                var bottom = comments.item(i).getBoundingClientRect().bottom;
                var bottomPoint = this.initOnly.coordinateHelper.clientToDomainCoordinates(0, bottom);
                if (bottomPoint.y > (experimentBounds.y + experimentBounds.height)) {
                    experimentBounds.height = bottomPoint.y - experimentBounds.y;
                }
            }
            return experimentBounds;
        };
        /**
          * Performs a zoom to fit with animation
         **/
        ExperimentEditorControl.prototype.zoomToFitWithAnimation = function () {
            this.initOnly.zoomHelper.zoomToFitWithAnimation();
        };
        ExperimentEditorControl.prototype.getViewInfo = function () {
            return {
                topLeft: this.topLeft,
                experimentBounds: this.getExperimentBounds()
            };
        };
        ExperimentEditorControl.prototype.getDestinationOrigin = function () {
            return this.initOnly.zoomHelper.getDestinationOrigin();
        };
        /**
          * Brings graph node into view (wrapping bringRectIntoView).
          * @param {GraphNodeViewModel} graphNode
         **/
        ExperimentEditorControl.prototype.animateToGraphNode = function (graphNode) {
            this.bringRectIntoView({
                x: graphNode.x(),
                y: graphNode.y(),
                width: graphNode.width(),
                height: graphNode.height()
            });
        };
        /**
          * A constructor helper function that adds event listeners. Assume bindingElement is something we created
         **/
        ExperimentEditorControl.prototype.setupEventHandlers = function (bindingElement) {
            var _this = this;
            var canvasMouseUp = function (e) {
                // null => we didn't mouse up on an entity
                _this.viewModel.entityMouseUp(null, e);
            };
            // We don't need to unregister event listeners on bindingElement, because we own it
            bindingElement.addEventListener("mouseup", canvasMouseUp);
            var mouseUpOutsideOfCanvas = function (e) {
                // For the time being, the behavior is the same regardless of where we mouse up, so
                // just call the on canvas handler.
                canvasMouseUp(e);
            };
            // We don't need to unregister event listeners on bindingElement, because we own it
            bindingElement.addEventListener("mousedown", function (e) {
                // null => we didn't mouse up on an entity
                _this.viewModel.entityMouseDown(null, e);
            });
            var mouseMove = function (e) {
                _this.viewModel.onMouseMove(e);
            };
            // This is the capture handler for mouse up. If we land in the canvas, then we let the bubble
            // handler do its magic. If we don't land in the canvas, then we immediately send a canvas mouse up,
            // since the behavior is the same at this point.
            var mouseUp = function (e) {
                e.preventDefault();
                // Check and see if we're going to get a bubble event in canvas. If not, call the handler
                // for mouse upping outside of the canvas.
                if ($(e.target).closest(".experimentCanvas").length === 0) {
                    e.stopPropagation();
                    mouseUpOutsideOfCanvas(e);
                }
            };
            // We need to register this so we can pass registration assertions
            this.registerForDisposal(new ExperimentEditor.MouseCapture(bindingElement, mouseMove, mouseUp));
            // We don't need to unregister event listeners on bindingElement, because we own it
            bindingElement.addEventListener("mousedown", function (e) {
                _this.rootContainerDiv.focus();
            }, true);
            // We don't own rootContainerDiv, so we DO need to unregister our handlers
            this.registerForDisposal(new DataLab.Util.DisposableEventListener(this.rootContainerDiv, "keydown", function (event) {
                switch (event.keyCode) {
                    case 46 /* Delete */:
                        _this.viewModel.stateMachine.handleAction(4 /* DeleteKeyPressed */);
                        event.stopImmediatePropagation();
                        event.preventDefault();
                        break;
                    case 65 /* A */:
                        if (event.shiftKey) {
                            _this.viewModel.stateMachine.handleAction(6 /* ShiftAPressed */);
                        }
                        break;
                    case 27 /* Escape */:
                        _this.viewModel.stateMachine.handleAction(5 /* EscapeKeyPressed */);
                        break;
                    case 113 /* F2 */:
                        _this.viewModel.stateMachine.handleAction(7 /* F2KeyPressed */);
                        break;
                    case 67 /* C */:
                        if (event.ctrlKey) {
                            event.preventDefault();
                            _this.viewModel.copy();
                        }
                        break;
                    case 83 /* S */:
                        if (event.ctrlKey) {
                            event.preventDefault();
                            _this.viewModel.draftStateMachine.saveDraft();
                        }
                        break;
                    case 88 /* X */:
                        if (event.ctrlKey) {
                            event.preventDefault();
                            _this.viewModel.stateMachine.handleAction(8 /* ControlXPressed */);
                        }
                        break;
                    case 86 /* V */:
                        if (event.ctrlKey) {
                            event.preventDefault();
                            var scale = _this.initOnly.zoomControl.getScale();
                            var scaledTopLeft = {
                                x: _this.topLeft.x / scale,
                                y: _this.topLeft.y / scale,
                                matrixTransform: null
                            };
                            _this.viewModel.paste();
                        }
                        break;
                    case 32 /* SpaceBar */:
                        if (!event.altKey && !event.shiftKey && !event.ctrlKey) {
                            _this.viewModel.stateMachine.handleAction(9 /* SpacebarDown */);
                        }
                        break;
                }
            }), new DataLab.Util.DisposableEventListener(this.rootContainerDiv, "keyup", function (event) {
                if (event.keyCode === 32 /* SpaceBar */) {
                    _this.viewModel.stateMachine.handleAction(10 /* SpacebarUp */);
                }
            }));
        };
        /**
          * Brings the desired rectangle into view
          * @param {SVGRect} rect the rectangle to bring into view
         **/
        ExperimentEditorControl.prototype.bringRectIntoView = function (rect) {
            var viewBounds = this.getViewDimensions();
            // we want domain view bounds
            var scale = this.initOnly.zoomControl.getScale();
            viewBounds.x = this.topLeft.x / scale;
            viewBounds.y = this.topLeft.y / scale;
            viewBounds.width /= scale;
            viewBounds.height /= scale;
            // Animate to content if the center of the content is off screen
            if (rect) {
                var targetX = this.topLeft.x / scale;
                var targetY = this.topLeft.y / scale;
                var shouldAnimate = false;
                rect.width = Math.min(viewBounds.width, rect.width);
                rect.height = Math.min(viewBounds.height, rect.height);
                if (rect.x < viewBounds.x) {
                    targetX = rect.x;
                    shouldAnimate = true;
                }
                else if (rect.x + rect.width > viewBounds.x + viewBounds.width) {
                    targetX += (rect.x + rect.width) - (viewBounds.x + viewBounds.width);
                    shouldAnimate = true;
                }
                if (rect.y < viewBounds.y) {
                    targetY = rect.y;
                    shouldAnimate = true;
                }
                else if (rect.y + rect.height > viewBounds.y + viewBounds.height) {
                    targetY += (rect.y + rect.height) - (viewBounds.y + viewBounds.height);
                    shouldAnimate = true;
                }
                if (shouldAnimate) {
                    this.initOnly.zoomHelper.animateToLocation(targetX * scale, targetY * scale, scale);
                }
                else {
                    this.viewModel.animationComplete.notifySubscribers(null);
                }
            }
        };
        return ExperimentEditorControl;
    })(DataLab.Util.Disposable);
    ExperimentEditor.ExperimentEditorControl = ExperimentEditorControl;
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../Global.ts" />
/// <reference path="../ViewModel/PaletteControl/PaletteViewModel.ts" />
/// <reference path="../ViewModel/PaletteControl/IPaletteDragResponder.ts" />
/// <reference path="../Common/MouseCapture.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var ExperimentEditor;
(function (ExperimentEditor) {
    // A listbox control for experiment editor 'module' and 'dataset' palette. The control features draggable palette item. 
    var PaletteControl = (function (_super) {
        __extends(PaletteControl, _super);
        /**
          * Constructor for PaletteControl
          * @constructor
          * @param rootContainerDiv {HTMLDivElement} the div onto which to apply the palette control's apply knockout bindings
          * @param paletteViewModel {PaletteViewModel} the backing view model for the control
         **/
        function PaletteControl(rootContainerDiv, paletteViewModel) {
            var _this = this;
            _super.call(this);
            if (!rootContainerDiv) {
                throw new Error("Palette control has no backing div.");
            }
            this.rootContainerDiv = rootContainerDiv;
            if (!paletteViewModel) {
                throw new Error("Palette control must have a backing view model.");
            }
            this.paletteViewModel = paletteViewModel;
            var keyDownDisposable;
            // We need to clean up our mess when this control gets destroyed
            this.registerForDisposal(new DataLab.Util.DisposableSetHTML(this.rootContainerDiv, ExperimentEditor._paletteMarkup), new DataLab.Util.DisposableKOApplyBindings(this.paletteViewModel, this.rootContainerDiv), new DataLab.Util.DisposableSubscription(this.paletteViewModel.isDragging.subscribe(function (dragging) {
                if (dragging) {
                    _this.registerForDisposal(keyDownDisposable = new DataLab.Util.DisposableEventListener(document.body, "keydown", function (e) {
                        if (e.keyCode === 27 /* Escape */) {
                            _this.paletteViewModel.cancelDrag();
                            keyDownDisposable.dispose();
                        }
                    }));
                }
                else {
                    if (keyDownDisposable) {
                        keyDownDisposable.dispose();
                    }
                }
            })));
        }
        return PaletteControl;
    })(DataLab.Util.Disposable);
    ExperimentEditor.PaletteControl = PaletteControl;
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Common/IMenuBuilder.ts" />
/// <reference path="../ExperimentEditor/ExperimentEditorViewModel.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var ExperimentEditor;
(function (ExperimentEditor) {
    // We extends Disposable so we can use helicopter mode in leakmaster
    var PropertyEditorMenuBuilder = (function (_super) {
        __extends(PropertyEditorMenuBuilder, _super);
        function PropertyEditorMenuBuilder(experimentEditorViewModel) {
            var _this = this;
            _super.call(this);
            this.currentTarget = ko.observable(null);
            this.experimentEditorViewModel = experimentEditorViewModel;
            this.unlinkCommand = new ExperimentEditor.CallbackCommand(function (target) {
                target.property.ensureUnlinked();
                _this.featureUsage(46 /* UnlinkParameter */);
            });
            this.unlinkCommand.canExecute = ko.computed(function () {
                if (_this.currentTarget() && !_this.experimentEditorViewModel.experimentViewModel().readOnlyMode()) {
                    var parameterViewModel = _this.currentTarget();
                    var moduleParameter = parameterViewModel.property;
                    return moduleParameter.isLinked();
                }
                return false;
            });
            this.newLinkCommand = new ExperimentEditor.CallbackCommand(function (target) {
                if (target.property instanceof DataLab.Model.ModuleNodeParameter) {
                    var experiment = _this.experimentEditorViewModel.experimentViewModel().experiment;
                    experiment.promoteModuleParameter(target.property);
                    _this.featureUsage(44 /* CreateNewParameter */);
                }
                else {
                    throw new Error("Can't link parameter " + target.property.name);
                }
            });
            this.newLinkCommand.canExecute = ko.computed(function () {
                return !_this.experimentEditorViewModel.experimentViewModel().readOnlyMode();
            });
        }
        PropertyEditorMenuBuilder.prototype.build = function (moduleNodeParameterViewModel) {
            var _this = this;
            this.currentTarget(moduleNodeParameterViewModel);
            var menu = {
                width: 120,
                name: "propertyMenu",
                items: []
            };
            //Add the new experiment command  
            menu.items.push({
                label: DataLab.LocalizedResources.setAsWebServiceParameter,
                command: this.newLinkCommand
            });
            menu.items.push({
                label: null,
                divider: true,
                command: null
            });
            var moduleNodeParameter = moduleNodeParameterViewModel.property;
            DataLab.Util.forEach(this.experimentEditorViewModel.experiment.parameters(), function (webServiceParameter) {
                if (moduleNodeParameter.parameterType != webServiceParameter.parameterType) {
                    return;
                }
                var command = new ExperimentEditor.CallbackCommand(function (target) {
                    moduleNodeParameter.ensureUnlinked();
                    moduleNodeParameter.linkToWebServiceParameter(webServiceParameter);
                    _this.featureUsage(45 /* LinkExistingParameter */);
                });
                command.canExecute = ko.computed(function () {
                    return !_this.experimentEditorViewModel.experimentViewModel().readOnlyMode();
                });
                var menuItem = {
                    label: DataLab.Util.format(DataLab.LocalizedResources.setToWebServiceParameter, webServiceParameter.name),
                    command: command
                };
                if (moduleNodeParameter.linkedWebServiceParameter() === webServiceParameter) {
                    menuItem.iconClass = "check";
                }
                menu.items.push(menuItem);
            });
            if (menu.items.length > 2) {
                menu.items.push({
                    label: null,
                    divider: true,
                    command: null
                });
            }
            // Add the unlink command
            menu.items.push({
                label: DataLab.LocalizedResources.unsetWebServiceParameter,
                command: this.unlinkCommand
            });
            return menu;
        };
        PropertyEditorMenuBuilder.prototype.featureUsage = function (featureId) {
            Shell.Diagnostics.Telemetry.featureUsage(featureId, 43 /* WebServiceParameter */, this.experimentEditorViewModel.experimentViewModel().workspace.id, this.experimentEditorViewModel.experiment.experimentId());
        };
        return PropertyEditorMenuBuilder;
    })(DataLab.Util.Disposable);
    ExperimentEditor.PropertyEditorMenuBuilder = PropertyEditorMenuBuilder;
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
/// <reference path="PropertyViewModel.ts" />
/// <reference path="PropertyEditorMenuBuilder.ts" />
/// <reference path="../ExperimentEditor/ExperimentEditorViewModel.ts" />
/// <reference path="../../View/MenuControl.ts" />
/// <reference path="../ExperimentEditor/CustomUX.ts" />
/// <reference path="../ExperimentEditor/Help.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var ExperimentEditor;
(function (ExperimentEditor) {
    var PropertyEditorViewModel = (function (_super) {
        __extends(PropertyEditorViewModel, _super);
        /**
          * Creates the view model for the property editor
          * @constructor
          * @param {string} rootContainerId the id of the container div for the property editor
          * @param {ExperimentEditorViewModel} experimentEditorViewModel the viewmodel for the experiment editor.
          *        needed for experiment parameters
         **/
        function PropertyEditorViewModel(experimentEditorViewModel, endpointDownloader, workspace) {
            var _this = this;
            _super.call(this);
            this.graphNode = ko.observable();
            this.nodeParameters = ko.observableArray();
            // We own graphNode, so we don't need to unsubscribe
            this.graphNode.subscribe(function () {
                _this.nodeParameters.removeAll();
                if (_this.graphNode()) {
                    var nodeViewModel = _this.graphNode();
                    var nodeModel = nodeViewModel.graphNode;
                    var propertyArray = [];
                    // Only module nodes have parameters.
                    if (nodeModel instanceof DataLab.Model.ModuleNode) {
                        DataLab.Util.forEach(nodeModel.parameters, function (property) {
                            if (property instanceof DataLab.Model.ModuleNodeParameter) {
                                propertyArray.push(ExperimentEditor.ParameterViewModel.createParameterViewModel(property, workspace));
                            }
                            else {
                                throw new Error("Unexpected parameter type on module " + nodeModel.id);
                            }
                        });
                        nodeViewModel.outputLog.endpointDownloader = endpointDownloader;
                        DataLab.Util.forEach(nodeViewModel.outputEndpoints, function (endpointViewModel, name) {
                            endpointViewModel.endpointDownloader = endpointDownloader;
                        });
                    }
                    else if (nodeModel instanceof DataLab.Model.WebServicePortNode) {
                        propertyArray.push(new ExperimentEditor.WebServicePortParameter(nodeModel.nameParameter));
                    }
                    else if (nodeModel instanceof DataLab.Model.DatasetNode) {
                        nodeViewModel.viewDataset.endpointDownloader = endpointDownloader;
                    }
                    else if (!(nodeModel instanceof DataLab.Model.TrainedModelNode) && !(nodeModel instanceof DataLab.Model.TransformNode)) {
                        throw new Error("Unexpected node type. Node Id: " + nodeModel.id);
                    }
                    _this.nodeParameters(propertyArray);
                }
            });
            this.openColumnPicker = function (target) {
                if (target instanceof ExperimentEditor.ColumnPickerParameterViewModel) {
                    target.openColumnPicker();
                }
            };
            this.getModuleHelp = function () {
                ExperimentEditor.Help.QuickHelpMoreInfo();
            };
            // We create this disposable, so we have to dispose it.
            this.registerForDisposal(this.menuBuilder = new ExperimentEditor.PropertyEditorMenuBuilder(experimentEditorViewModel));
            this.registerForDisposal(this.webServiceParameterMenuBuilder = new ExperimentEditor.WebServiceParameterMenuBuilder(experimentEditorViewModel));
            // Expand/collapse state for drawers and panes
            this.quickHelpCollapsed = ko.observable(false);
            this.drawerIsCollapsed = ko.observable(false);
            this.globalParamsCollapsed = ko.observable(false);
            this.entityParamsCollapsed = ko.observable(false);
            this.experimentPropertiesCollapsed = ko.observable(false);
            this.experimentSummaryCollapsed = ko.observable(false);
            this.experimentDetailsCollapsed = ko.observable(false);
            this.competitionPropertiesCollapsed = ko.observable(false);
            this.openCloseAnimationEnded = new ko.subscribable();
            this.experimentEditorViewModel = experimentEditorViewModel;
            this.readOnlyMode = ko.observable(false);
            this.lastVisitedParameter = null;
            this.animatingDrawer = ko.observable(false);
            this.animatingDrawer.subscribe(function (animating) {
                _this.experimentEditorViewModel.isBeingResized(animating);
            });
            this.experiment = ko.observable(null);
            this.navigateToParent = new ko.subscribable();
            this.navigateToWebService = new ko.subscribable();
            this.experimentEditorViewModel.experimentViewModel.subscribe(function () {
                var evm = _this.experimentEditorViewModel.experimentViewModel();
                $.each(evm.experimentProperties(), function (index, propertyVM) {
                    if (propertyVM instanceof ExperimentEditor.LinkPropertyViewModel) {
                        var linkPropertyVM = propertyVM;
                        if (linkPropertyVM.property === evm.experiment.publishedWebServiceLinkProperty) {
                            linkPropertyVM.onClick = function (viewModel, e) {
                                e.preventDefault();
                                _this.navigateToWebServiceHandler();
                            };
                        }
                        else if (linkPropertyVM.property === evm.experiment.priorRunLinkProperty) {
                            linkPropertyVM.onClick = function (viewModel, e) {
                                e.preventDefault();
                                _this.navigateToParentHandler();
                            };
                        }
                    }
                });
            });
            this.lastX = 0;
            this.hasParentExperiment = ko.computed(function () {
                var parentExperimentId = _this.experiment() ? _this.experiment().parentExperimentId : null;
                return parentExperimentId !== null;
            });
            this.setupEventHandlers();
        }
        Object.defineProperty(PropertyEditorViewModel.prototype, "selectedGraphNodeName", {
            get: function () {
                if (this.graphNode().graphNode instanceof DataLab.Model.ModuleNode) {
                    return this.graphNode().graphNode.module_.name();
                }
                else if (this.graphNode().graphNode instanceof DataLab.Model.DatasetNode) {
                    return this.graphNode().graphNode.dataset.name();
                }
                else if (this.graphNode().graphNode instanceof DataLab.Model.TrainedModelNode) {
                    return this.graphNode().graphNode.trainedModel.name();
                }
                else if (this.graphNode().graphNode instanceof DataLab.Model.TransformNode) {
                    return this.graphNode().graphNode.transform.name();
                }
                else if (this.graphNode().graphNode instanceof DataLab.Model.WebServicePortNode) {
                    return this.graphNode().graphNode.name;
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
          * Sets the node that is newly selected, so its properties and/or parameters can be
          * displayed in the property editor.
          * @param {DataLab.Model.GraphNode} node the newly selected node
         **/
        PropertyEditorViewModel.prototype.setNode = function (node) {
            this.graphNode(node);
        };
        PropertyEditorViewModel.prototype.onCommit = function (propertyItem, e) {
            if (e.type === "blur" || (e.type === "keyup" && e.which === 13 /* Return */)) {
                var target = e.currentTarget;
                if (target.value !== propertyItem.property.value()) {
                    propertyItem.property.value(target.value);
                }
            }
        };
        /**
          * Removes all properties from the property editor and clears the heading for the
          * module parameters section
         **/
        PropertyEditorViewModel.prototype.clearModuleParameters = function () {
            this.graphNode(null);
        };
        PropertyEditorViewModel.prototype.navigateToParentHandler = function () {
            this.navigateToParent.notifySubscribers(null);
        };
        PropertyEditorViewModel.prototype.navigateToWebServiceHandler = function () {
            this.navigateToWebService.notifySubscribers(null);
        };
        /**
          * Ensure the specified parameter is visible. This may require moving entities into view, opening the drawer, etc.
          * Sends focus to the specified parameter, will cause any error balloons to appear.
          * @param {DataLab.Model.Parameter} parameter The parameter to show
         **/
        PropertyEditorViewModel.prototype.navigateToParameter = function (parameter) {
            var _this = this;
            if (parameter instanceof DataLab.Model.ModuleNodeParameter) {
                var moduleNode = parameter.parent;
                var moduleNodeViewModel = this.experimentEditorViewModel.experimentViewModel().getViewModelForNode(moduleNode);
                var nodeAnimationSubscription = this.experimentEditorViewModel.animationComplete.subscribe(function () {
                    _this.experimentEditorViewModel.selectionManager.modifySelection(function () {
                        _this.experimentEditorViewModel.selectionManager.resetSelection();
                        _this.experimentEditorViewModel.selectionManager.selectEntity(moduleNodeViewModel);
                    });
                    var parameterViewModel = _this.viewModelForProperty(parameter);
                    parameterViewModel.focus(true);
                    nodeAnimationSubscription.dispose();
                });
                // We navigate things in the following order:
                // 1. If the drawer is closed, open it
                // 2. When the drawer is open, bring the node into view
                // 3. Select the node
                // 4. Send focus to the parameter
                if (this.drawerIsCollapsed()) {
                    var drawerAnimationSubscription = this.openCloseAnimationEnded.subscribe(function () {
                        _this.experimentEditorViewModel.needsAnimationToNode.notifySubscribers(moduleNodeViewModel);
                        drawerAnimationSubscription.dispose();
                    });
                    this.toggleDrawer();
                }
                else {
                    this.experimentEditorViewModel.needsAnimationToNode.notifySubscribers(moduleNodeViewModel);
                }
            }
            else if (parameter instanceof DataLab.Model.WebServiceParameter) {
                var parameterViewModel = this.viewModelForProperty(parameter);
                // For experiment parameters, we just open the drawer if needed and send focus
                if (this.drawerIsCollapsed()) {
                    var drawerAnimationSubscription = this.openCloseAnimationEnded.subscribe(function () {
                        parameterViewModel.focus(true);
                        drawerAnimationSubscription.dispose();
                    });
                    this.toggleDrawer();
                }
                else {
                    parameterViewModel.focus(true);
                }
            }
            else {
                throw new Error("Unknown parameter type to navigate.");
            }
        };
        /**
         * Handler for the submit-to-competition-entry button click event.
         */
        PropertyEditorViewModel.prototype.submitCompetitionEntry = function () {
            // todo: implement the actual handler logic
            alert("publish to competition is under construction");
        };
        PropertyEditorViewModel.prototype.toggleDrawer = function () {
            this.animatingDrawer(true);
            this.drawerIsCollapsed(!this.drawerIsCollapsed());
        };
        PropertyEditorViewModel.prototype.setupEventHandlers = function () {
            var _this = this;
            var lastClickedLinkItem = null;
            this.removeParameterClicked = function (target, e) {
                e.preventDefault();
                e.stopPropagation();
                if (e.button === 0 /* Left */) {
                    _this.experimentEditorViewModel.experiment.removeWebServiceParameter(target.property);
                }
            };
            this.focusLinkedWebServiceParameter = function (target, e) {
                e.preventDefault();
                e.stopPropagation();
                if (e.button === 0 /* Left */) {
                    var webServiceParameter = target.property.linkedWebServiceParameter();
                    var webServiceParameterViewModel = _this.viewModelForProperty(webServiceParameter);
                    webServiceParameterViewModel.focus(true);
                }
            };
            this.nextParameterClicked = function (target, e) {
                if (e.button === 0 /* Left */) {
                    var nextParameter = null;
                    var previousParameter = null;
                    var linkedParameters = target.property.linkedParameters;
                    DataLab.Util.forEach(linkedParameters, function (parameter) {
                        // Ignore linked parameters which are not relevant at the time.
                        if (parameter.isRelevant()) {
                            if (previousParameter === _this.lastVisitedParameter) {
                                nextParameter = parameter;
                            }
                            previousParameter = parameter;
                        }
                    });
                    // If the last visited parameter doesn't exist in this list, just chose the first relevant one.
                    // This can happen if you visit a parameter from a disjoint list or focus on an unlinked
                    // parameter.
                    if (!nextParameter) {
                        nextParameter = DataLab.Util.first(linkedParameters, function (parameter) {
                            return parameter.isRelevant();
                        }, null);
                    }
                    // If there are no relevant linked parameters, firstParameter, and thus nextParameter will be null
                    if (nextParameter) {
                        _this.navigateToParameter(nextParameter);
                    }
                }
            };
            this.prevParameterClicked = function (target, e) {
                if (e.button === 0 /* Left */) {
                    var prevParameter = null;
                    var previousParameter = null;
                    var linkedParameters = target.property.linkedParameters;
                    DataLab.Util.forEach(linkedParameters, function (parameter) {
                        // Ignore linked parameters which are not relevant at the time.
                        if (parameter.isRelevant()) {
                            if (parameter === _this.lastVisitedParameter) {
                                prevParameter = previousParameter;
                            }
                            previousParameter = parameter;
                        }
                    });
                    // If the last visited parameter doesn't exist in this list, just chose the first relevant one.
                    // This can happen if you visit a parameter from a disjoint list or focus on an unlinked
                    // parameter.
                    if (!prevParameter) {
                        prevParameter = previousParameter;
                    }
                    // If there are no relevant linked parameters, prevParameter will be null
                    if (prevParameter) {
                        _this.navigateToParameter(prevParameter);
                    }
                }
            };
            this.onParameterFocus = function (target, e) {
                _this.lastVisitedParameter = target.property;
            };
            this.onParameterReturn = function (target, e) {
                e.stopPropagation();
                if (e.keyCode === 13 /* Return */) {
                    target.focus(false);
                }
                return true;
            };
        };
        PropertyEditorViewModel.prototype.viewModelForProperty = function (propertyToFind) {
            var _this = this;
            var viewModel = null;
            if (propertyToFind instanceof DataLab.Model.WebServiceParameter) {
                viewModel = this.experimentEditorViewModel.experimentViewModel().webServiceParameters.lookup(propertyToFind.id);
            }
            else {
                this.nodeParameters().forEach(function (curProperty) {
                    if (!viewModel) {
                        if (curProperty.property === propertyToFind) {
                            viewModel = curProperty;
                        }
                        else if (curProperty.childParameters().length > 0) {
                            viewModel = _this.findModePropertyViewModel(curProperty.childParameters(), propertyToFind);
                        }
                    }
                });
            }
            if (!viewModel) {
                throw new Error("Could not find view model for property.");
            }
            return viewModel;
        };
        PropertyEditorViewModel.prototype.findModePropertyViewModel = function (properties, propertyToFind) {
            var _this = this;
            var viewModel = null;
            properties.forEach(function (curProperty) {
                if (!viewModel) {
                    if (curProperty.property === propertyToFind) {
                        viewModel = curProperty;
                    }
                    else if (curProperty.childParameters().length > 0) {
                        viewModel = _this.findModePropertyViewModel(curProperty.childParameters(), propertyToFind);
                    }
                }
            });
            return viewModel;
        };
        return PropertyEditorViewModel;
    })(DataLab.Util.Disposable);
    ExperimentEditor.PropertyEditorViewModel = PropertyEditorViewModel;
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../Global.ts" />
/// <reference path="../Common/DialogInterfaces.ts" />
var ExperimentEditor;
(function (ExperimentEditor) {
    /** IDialog implementation which renders a Knockout template and view-model.
        The view-model must implement {IDialogViewModel} to facilitate dismissal
        notification (i.e. so the viewmodel can perform some action if the user
        dismisses the dialog affirmatively). */
    var DialogView = (function () {
        function DialogView(koTemplate, viewModel, optionsOverrides) {
            if (viewModel === void 0) { viewModel = null; }
            if (optionsOverrides === void 0) { optionsOverrides = null; }
            this.optionsOverrides = optionsOverrides;
            this.hasBeenShown = false;
            this.dialogResult = $.Deferred();
            this.dialogHostResultSubscription = null;
            if (!koTemplate && koTemplate !== "") {
                throw new Error("koTemplate must be provided");
            }
            this.koTemplate = koTemplate;
            this.viewModel = viewModel;
        }
        DialogView.createFactoryForTemplate = function (koTemplate, optionsOverrides) {
            var f = function (viewModel) {
                return new DialogView(koTemplate, viewModel, optionsOverrides);
            };
            f.show = function (viewModel) {
                var v = new this(viewModel);
                return v.show();
            };
            return f;
        };
        DialogView.prototype.show = function () {
            var _this = this;
            if (this.hasBeenShown) {
                throw new Error("This dialog has already been shown once and cannot be shown again");
            }
            this.hasBeenShown = true;
            this.dialogHostResultSubscription = ExperimentEditor.DialogHost.dialogDismissedEvent.subscribe(function (result) {
                // We want to receive exactly one dismissal notification (this one). This is particularly
                // important since the DialogHost is long-lived. By unsubscribing here, we ensure that at most
                // one Dialog instance is kept alive by the DialogHost at a time.
                _this.dialogHostResultSubscription.dispose();
                _this.onDialogDismissed(result);
            });
            var container = ExperimentEditor.DialogHost.showNewDialog(this);
            container.innerHTML = this.koTemplate;
            if (this.viewModel !== null) {
                ko.applyBindings(this.viewModel, container);
            }
            return this.dialogResult;
        };
        DialogView.prototype.close = function () {
            if (ExperimentEditor.DialogHost.isActiveDialog(this)) {
                ExperimentEditor.DialogHost.closeActiveDialog();
            }
        };
        DialogView.prototype.canBeAccepted = function () {
            if (this.viewModel.canBeAccepted) {
                return this.viewModel.canBeAccepted();
            }
            return true;
        };
        DialogView.prototype.onDialogDismissed = function (result) {
            if (result.dialog !== this) {
                DataLab.Log.error("Dialog received a dismissal notification for a different dialog");
                return;
            }
            if (this.viewModel) {
                this.viewModel.dismissed(result);
            }
            this.dialogResult.resolveWith(this, [result]);
        };
        return DialogView;
    })();
    ExperimentEditor.DialogView = DialogView;
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
/// <reference path="../../View/DialogView.ts" />
/// <reference path="../ExperimentEditor/PortViewModel.ts" />
var ExperimentEditor;
(function (ExperimentEditor) {
    var OutputPromotionDialogViewModel = (function () {
        function OutputPromotionDialogViewModel(port, resource, resourceCache, promoteFunc) {
            /** Fired if the user initiates promotion of an output port (by accepting the dialog).
                The event value is a DataLab.Util.Promise representing the in-progress promotion. */
            this.resourcePromotionStartedEvent = new ko.subscribable();
            this.outputPort = port;
            this.promoteFunc = promoteFunc;
            var portModel = port.portModel;
            var node = portModel.parent;
            if (!(node instanceof DataLab.Model.ModuleNode)) {
                throw new Error("Only module output ports can be saved as datasets.");
            }
            var moduleNodeModel = node;
            var defaultName = portModel.name + " (saved from " + moduleNodeModel.module_.name() + ")";
            this.resource = resource;
            // If user wants to promote output that has already been promoted (same module and output from the older version of experiment)
            // we need to provide a hint
            var experimentId = port.portModel.parent.executedExperimentId;
            var moduleId = port.portModel.parent.id;
            var outputName = port.portModel.name;
            var hintDataset = DataLab.Util.first(resourceCache.items(), function (d) {
                if (d.experimentId) {
                    return (d.moduleId === moduleId && d.outputName === outputName);
                }
                else {
                    return false;
                }
            }, null);
            if (hintDataset) {
                this.resource.deprecate(true);
                this.resource.resourceToDeprecate(hintDataset.name());
                this.resource.hint(true);
            }
            else {
                this.resource.name(defaultName);
            }
        }
        OutputPromotionDialogViewModel.prototype.canBeAccepted = function () {
            // We're validating name directly since we didn't set a data type. promoteOutputToDatasetAsync handles that.
            this.resource.startValidating();
            return this.resource.isValid();
        };
        OutputPromotionDialogViewModel.prototype.dismissed = function (result) {
            if (result.accepted) {
                DataLab.Log.info("Output promotion dialog accepted");
                this.promote();
            }
            else {
                DataLab.Log.info("Output promotion dialog cancelled");
            }
        };
        OutputPromotionDialogViewModel.prototype.promote = function () {
            var promotionPromise = this.promoteFunc(this.outputPort.portModel, this.resource.name(), this.resource.familyId(), this.resource.description());
            this.resourcePromotionStartedEvent.notifySubscribers(promotionPromise);
        };
        return OutputPromotionDialogViewModel;
    })();
    ExperimentEditor.OutputPromotionDialogViewModel = OutputPromotionDialogViewModel;
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
/// <reference path="../../View/DialogView.ts" />
var ExperimentEditor;
(function (ExperimentEditor) {
    var CreateWebServiceFromTrainedModelDialogViewModel = (function () {
        function CreateWebServiceFromTrainedModelDialogViewModel(name, handler) {
            this.name = ko.observable();
            this.description = ko.observable();
            this.name(name);
            this.handler = handler;
        }
        CreateWebServiceFromTrainedModelDialogViewModel.prototype.canBeAccepted = function () {
            return true;
        };
        CreateWebServiceFromTrainedModelDialogViewModel.prototype.dismissed = function (result) {
            if (result.accepted) {
                this.handler(this.name(), this.description());
            }
        };
        return CreateWebServiceFromTrainedModelDialogViewModel;
    })();
    ExperimentEditor.CreateWebServiceFromTrainedModelDialogViewModel = CreateWebServiceFromTrainedModelDialogViewModel;
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../Global.ts" />
/// <reference path="DialogView.ts" />
var ExperimentEditor;
(function (ExperimentEditor) {
    var DialogViews;
    (function (DialogViews) {
        DialogViews.OutputPromotion;
        DialogViews.Confirmation;
        DialogViews.UploadDataset;
        DialogViews.UploadCustomModulePackage;
        DialogViews.SaveSSSIMDataset;
        DialogViews.InteractiveScore;
        DialogViews.TrainedModelPromotion;
        DialogViews.TransformModulePromotion;
        DialogViews.FeedbackControl;
        DialogViews.CreateWebServiceFromTrainedModel;
        DialogViews.PublishToCommunityStepOnComplete;
        DialogViews.ShowApiCode;
        DialogViews.CopyExperiment;
        DialogViews.CopyExperimentFromGallery;
        function createViews() {
            DialogViews.OutputPromotion = ExperimentEditor.DialogView.createFactoryForTemplate(ExperimentEditor._outputPromotionDialogMarkup);
            DialogViews.Confirmation = ExperimentEditor.DialogView.createFactoryForTemplate(ExperimentEditor._confirmationDialogMarkup, { size: ['auto', 'auto'] });
            DialogViews.UploadDataset = ExperimentEditor.DialogView.createFactoryForTemplate(ExperimentEditor._uploadDatasetDialogMarkup);
            DialogViews.UploadCustomModulePackage = ExperimentEditor.DialogView.createFactoryForTemplate(ExperimentEditor._uploadModuleDialogMarkup);
            DialogViews.SaveSSSIMDataset = ExperimentEditor.DialogView.createFactoryForTemplate(ExperimentEditor._saveSSIMDatasetMarkup);
            DialogViews.InteractiveScore = ExperimentEditor.DialogView.createFactoryForTemplate(ExperimentEditor._scoreDialogMarkup);
            DialogViews.TrainedModelPromotion = ExperimentEditor.DialogView.createFactoryForTemplate(ExperimentEditor._trainedModelPromotionDialogMarkup);
            DialogViews.TransformModulePromotion = ExperimentEditor.DialogView.createFactoryForTemplate(ExperimentEditor._transformPromotionDialogMarkup);
            DialogViews.FeedbackControl = ExperimentEditor.DialogView.createFactoryForTemplate(ExperimentEditor._feedbackControlMarkup);
            DialogViews.CreateWebServiceFromTrainedModel = ExperimentEditor.DialogView.createFactoryForTemplate(ExperimentEditor._createWebServiceGraphFromTrainedModelDialogMarkup);
            DialogViews.PublishToCommunityStepOnComplete = ExperimentEditor.DialogView.createFactoryForTemplate(ExperimentEditor._publishToCommunityStepOnCompleteMarkup);
            DialogViews.ShowApiCode = ExperimentEditor.DialogView.createFactoryForTemplate(ExperimentEditor._apiCodeDialogMarkup);
            DialogViews.CopyExperiment = ExperimentEditor.DialogView.createFactoryForTemplate(ExperimentEditor._copyExperimentDialogMarkup, { size: ['360px', '255px'] });
            DialogViews.CopyExperimentFromGallery = ExperimentEditor.DialogView.createFactoryForTemplate(ExperimentEditor._copyExperimentFromGalleryDialogMarkup, { size: ['360px', '125px'] });
        }
        DialogViews.createViews = createViews;
    })(DialogViews = ExperimentEditor.DialogViews || (ExperimentEditor.DialogViews = {}));
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
/// <reference path="ExperimentEditorViewModel.ts" />
/// <reference path="../../View/ExperimentEditorContainer.ts" />
/// <reference path="../PaletteControl/PaletteViewModel.ts" />
/// <reference path="../PropertyEditorControl/PropertyEditorViewModel.ts" />
/// <reference path="../Dialogs/OutputPromotionDialogViewModel.ts" />
/// <reference path="../Dialogs/CreateWebServiceFromTrainedModelDialogViewModel.ts" />
/// <reference path="../../View/DialogViewFactories.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var ExperimentEditor;
(function (ExperimentEditor) {
    var ExperimentEditorContainerViewModel = (function (_super) {
        __extends(ExperimentEditorContainerViewModel, _super);
        function ExperimentEditorContainerViewModel(workspace, graphFetcher, experimentId) {
            var _this = this;
            _super.call(this);
            this.searchText = ko.observable('');
            this.paletteIsCollapsed = ko.observable(true);
            this.workspace = workspace;
            this.graphFetcher = graphFetcher;
            this.endpointDownloader = new ExperimentEditor.EndpointDownloader();
            // We own all these disposables, so we have to register them for disposal
            this.registerForDisposal(this.experimentEditorViewModel = new ExperimentEditor.ExperimentEditorViewModel(workspace.moduleCache, workspace.datasetCache, workspace.trainedModelCache, workspace.transformModulesCache, this.endpointDownloader, {
                promoteOutput: new ExperimentEditor.CallbackCommand(function (target) { return _this.promoteOutputToDataset(target); }),
                promoteTrainerOutput: new ExperimentEditor.CallbackCommand(function (target) { return _this.promoteOutputToModel(target); }),
                promoteTransformOutput: new ExperimentEditor.CallbackCommand(function (target) { return _this.promoteOutputToTransform(target); }),
                refreshExperiment: new ExperimentEditor.CallbackCommand(function () {
                    _this.refreshExperiment();
                }),
                navigateToParent: new ExperimentEditor.CallbackCommand(function () { return _this.navigateToParent(); }),
                promoteCreateWebService: new ExperimentEditor.CallbackCommand(function (target) { return _this.promoteCreateWebService(target); })
            }, workspace, {
                onAlert: function (message) { return _this.alertHandler(message); }
            }), this.propertyEditorViewModel = new ExperimentEditor.PropertyEditorViewModel(this.experimentEditorViewModel, this.endpointDownloader, this.workspace), this.paletteViewModel = new ExperimentEditor.PaletteViewModel(this.workspace.moduleCategoryRegistry, this.workspace.applicationCache.datasetCategoryRegistry, this.workspace.datasetCache, this.workspace.moduleCache, this.workspace.trainedModelCache, this.workspace.transformModulesCache), this.webServiceViewModel = new ExperimentEditor.ExperimentWebServiceViewModel());
            this.alertHandler = null;
            // The experimentId should be null if a new, empty experiment is opened. Hence isDraft is dependent on this condition.
            // However, if experimentId is not null, its draft state cannot be determined immediately, since it could be either a
            // service draft or a submitted experiment. Hence we make the assumption that if an id is provided, it is a submitted
            // experiment to avoid starting in edit mode and reverting back to non-edit mode.
            this.experiment.setDraftState(!experimentId);
            this.experiment.experimentId(experimentId);
            this.paletteIsCollapsed = ko.observable(false);
            this.experimentId = ko.observable(experimentId);
            // The start of dirtying is handled in the deserializer for all other cases. If a new empty experiment is opened,
            // We must start dirtying the experiment here.
            if (!experimentId) {
                this.experiment.dirtyStatus.startDirtying();
                this.experiment.dirtyForPublishStatus.startDirtying();
            }
            this.descriptionFocus = ko.observable(true);
            // If the experiment was created in the current workspace
            this.userWorkspaceExperiment = ko.computed(function () { return _this.experiment.experimentId() ? _this.experiment.experimentId().split(".")[0] === _this.workspace.id : true; });
            this.readOnlyMode = ko.computed(function () { return !_this.experiment.isLeaf() || !_this.userWorkspaceExperiment() || _this.experiment.statusCode() === DataLab.DataContract.State.Running || _this.experiment.statusCode() === DataLab.DataContract.State.NotStarted; });
            // Link up read only at the experiment level to the components
            // ko.computed is handy here since the experimentViewModel will change whenever we load a new experiment.
            ko.computed(function () {
                _this.experimentEditorViewModel.experimentViewModel().readOnlyMode(_this.readOnlyMode());
                _this.propertyEditorViewModel.readOnlyMode(_this.readOnlyMode());
            });
            this.experimentEditorViewModel.registerEntityActivationEvent(this.activateEntity.bind(this));
            this.experimentEditorViewModel.registerCloneHandler(function () {
                _this.clone();
            });
            // We own the propertyEditorViewModel. No need to dispose.
            this.propertyEditorViewModel.navigateToParent.subscribe(function () {
                _this.navigateToParent();
            });
            this.propertyEditorViewModel.navigateToWebService.subscribe(function () {
                _this.navigateToWebService();
            });
            // By default, refresh experiment does no additional work.
            this.refreshExperimentHandler = null;
            // We created this. No need to dispose.
            this.searchText.extend({ rateLimit: { timeout: 400, method: "notifyWhenChangesStop" } }).subscribe(function (searchText) {
                Shell.Diagnostics.Telemetry.featureUsage(17 /* Search */, 16 /* Palette */, workspace.id, experimentId, null, searchText);
                _this.paletteViewModel.applyPaletteSearch(searchText);
            });
            var lastSelectedItem = null;
            // Create subscriptions to selected observable entities that updates the propertyEditorViewModel on change event.
            // We don't own this, so we need to dispose of the subscription
            this.registerForDisposal(new DataLab.Util.DisposableSubscription(this.experimentEditorViewModel.selectionManager.selectedGraphNodes.subscribeToCollectionChanges(function () {
                var selectedItems = _this.experimentEditorViewModel.selectionManager.selectedGraphNodes;
                if (lastSelectedItem && lastSelectedItem instanceof ExperimentEditor.Module) {
                    lastSelectedItem.startValidating();
                    lastSelectedItem.updateValidState();
                }
                if (selectedItems.count() === 1) {
                    // If the selected item is a module or a dataset, update the property editor. Otherwise, clear it.
                    lastSelectedItem = DataLab.Util.first(selectedItems(), function (entity) {
                        return (entity instanceof ExperimentEditor.Module || entity instanceof ExperimentEditor.Dataset || entity instanceof ExperimentEditor.TrainedModel || entity instanceof ExperimentEditor.Transform || entity instanceof ExperimentEditor.WebServicePort);
                    }, null);
                    if (lastSelectedItem) {
                        _this.propertyEditorViewModel.setNode(lastSelectedItem);
                    }
                    else {
                        _this.propertyEditorViewModel.clearModuleParameters();
                    }
                }
                else {
                    _this.propertyEditorViewModel.clearModuleParameters();
                    lastSelectedItem = null;
                }
            })), new DataLab.Util.DisposableSubscription(this.experimentEditorViewModel.newExperimentLoaded.subscribe(function () {
                _this.propertyEditorViewModel.experiment(_this.experimentEditorViewModel.experiment);
                if (_this.experiment.isDraft()) {
                    _this.promptForUpgradeIfNodesAreEligible();
                }
            })));
            // If we try to view something too big, we'll need to handle notifying the user
            // We own the endpoint downloader, so we don't need to unsubscribe
            this.endpointDownloader.endpointTooBig.subscribe(function () {
                var message = DataLab.LocalizedResources.viewModelDataTooLarge;
                if (_this.alertHandler) {
                    _this.alertHandler(message);
                }
                else {
                    alert(message);
                }
            });
            this.nodesEligibleForUpgradeHandler = function (eligibleNodes) {
                DataLab.Log.info("Nodes are eligible for upgrade in the current experiment, but no prompt handler is installed.");
            };
            // Update palette with web service category
            this.paletteViewModel.categories().splice(-1, 0, this.webServiceViewModel.webServiceCategory);
            this.projectViewModel = new ExperimentEditor.ProjectViewModel(workspace, function () { return _this.experiment; });
        }
        Object.defineProperty(ExperimentEditorContainerViewModel.prototype, "experiment", {
            // For now the editor view model manages the current experiment and does deserialization.
            // In principle the current experiment should be pushed down from this top-level viewmodel.
            // We pretend that that is the case here by providing an accessor for the template.
            get: function () {
                return this.experimentEditorViewModel.experimentViewModel().experiment;
            },
            enumerable: true,
            configurable: true
        });
        ExperimentEditorContainerViewModel.prototype.registerNavigateToParentHandler = function (handler) {
            this.navigateToParentHandler = handler;
        };
        ExperimentEditorContainerViewModel.prototype.registerNavigateToWebServiceHandler = function (handler) {
            this.navigateToWebServiceHandler = handler;
        };
        ExperimentEditorContainerViewModel.prototype.registerOutputPromotionProgressHandler = function (handler) {
            this.outputPromotionProgressHandler = handler;
        };
        /** Register a handler to be called when the user should be prompted to upgrade outdated modules / datasets in the experiment. */
        ExperimentEditorContainerViewModel.prototype.registerNodeUpgradeEligibilityHandler = function (handler) {
            this.nodesEligibleForUpgradeHandler = handler;
        };
        ExperimentEditorContainerViewModel.prototype.registerAlertHandler = function (handler) {
            this.alertHandler = handler;
        };
        ExperimentEditorContainerViewModel.prototype.registerCannotSaveDraftHandler = function (handler) {
            this.cannotSaveDraftHandler = handler;
        };
        ExperimentEditorContainerViewModel.prototype.refreshExperiment = function () {
            return this.experimentEditorViewModel.refreshExperiment();
        };
        ExperimentEditorContainerViewModel.prototype.startAutoRefresh = function () {
            this.experimentEditorViewModel.startAutoRefresh();
        };
        ExperimentEditorContainerViewModel.prototype.loadFromService = function () {
            var _this = this;
            var experimentLoadedDeferred = $.Deferred();
            if (this.graphFetcher && this.experimentId()) {
                var getExperiment = this.graphFetcher.loadFromService(this.experimentId());
                getExperiment.done(function (experiment) {
                    _this.descriptionFocus(true);
                    if (_this.onRefreshFromNewExperiment) {
                        experiment.onRefreshFromNewExperiment = _this.onRefreshFromNewExperiment;
                    }
                    _this.experimentEditorViewModel.experiment = experiment;
                    _this.propertyEditorViewModel.experiment(_this.experimentEditorViewModel.experiment);
                    if (experiment.experimentParameterInUse) {
                        _this.alertHandler(DataLab.LocalizedResources.experimentParameterDeletedNotification);
                        // Set it false to avoid multiple alerts
                        experiment.experimentParameterInUse = false;
                        Shell.Diagnostics.Telemetry.featureUsage(51 /* ExperimentParameterInUse */, 43 /* WebServiceParameter */, _this.workspace.id, _this.experiment.experimentId());
                    }
                    experimentLoadedDeferred.resolve();
                }).fail(function (err) {
                    experimentLoadedDeferred.reject(err);
                });
            }
            else {
                experimentLoadedDeferred.resolve();
            }
            // We want an exception to be thrown if a failure during load is not observed.
            return DataLab.Util.when(experimentLoadedDeferred);
        };
        ExperimentEditorContainerViewModel.prototype.navigateToParent = function () {
            // Find the parent experiment ID of the experiment we are viewing
            var parentExperimentId = this.experimentEditorViewModel.experiment.parentExperimentId;
            this.experimentEditorViewModel.rememberExperimentPosition(this.experimentEditorViewModel.experiment.experimentId());
            this.navigateToParentHandler(parentExperimentId);
        };
        ExperimentEditorContainerViewModel.prototype.navigateToWebService = function () {
            var publishedWebServiceGroupId = this.experimentEditorViewModel.experiment.publishedWebServiceGroupId;
            this.navigateToWebServiceHandler(publishedWebServiceGroupId);
        };
        ExperimentEditorContainerViewModel.prototype.clone = function (suppressUpgradePrompt) {
            if (!this.experiment.isDraft()) {
                this.experiment.dirtyStatus.stopDirtying();
                this.experiment.dirtyForPublishStatus.stopDirtying();
                this.experiment.parentExperimentId = this.experiment.experimentId();
                this.experimentEditorViewModel.parentExperimentId(this.experiment.parentExperimentId);
                this.createExperimentCopy(suppressUpgradePrompt);
            }
            DataLab.Log.info("Starting editing the experiment after cloning", "ExperimentEditorContainerViewModel.clone", this.experiment.experimentId());
        };
        /**
         * Copies the current experiment. Unlike clone, the new experiment is the root of a new lineage.
         */
        ExperimentEditorContainerViewModel.prototype.copy = function (copyName) {
            var _this = this;
            if (copyName === void 0) { copyName = ""; }
            this.experiment.dirtyStatus.stopDirtying();
            this.experiment.dirtyForPublishStatus.stopDirtying();
            this.experimentEditorViewModel.stopAutoRefresh();
            this.experimentEditorViewModel.experimentViewModel().experimentProperties.remove(function (propertyViewModel) {
                return (propertyViewModel.property === _this.experiment.priorRunLinkProperty) || (propertyViewModel.property === _this.experiment.publishedWebServiceLinkProperty);
            });
            this.experiment.nodes.forEach(function (node) {
                if (node instanceof DataLab.Model.ModuleNode) {
                    node.statusCode.value(DataLab.DataContract.State.NotStarted);
                }
            });
            this.experiment.parentExperimentId = null;
            this.createExperimentCopy();
            this.experiment.publishedWebServiceGroupId = null; // clear the wsg relationship when create a new one
            this.experimentEditorViewModel.parentExperimentId(null);
            this.experiment.description(copyName);
            this.projectViewModel.init();
            DataLab.Log.info("Starting editing the experiment after copying", "ExperimentEditorContainerViewModel.copy", this.experiment.experimentId());
        };
        /**
         * Creates a copy of the current experiment. Utility function used by both the "copy" and "clone" functions
         */
        ExperimentEditorContainerViewModel.prototype.createExperimentCopy = function (suppressUpgradePrompt) {
            this.experiment.experimentId(null);
            this.experimentId(null);
            this.experiment.setDraftState(true);
            this.experiment.isLeaf(true);
            this.experiment.publishedModelPackageId = null;
            if (!suppressUpgradePrompt) {
                this.promptForUpgradeIfNodesAreEligible();
            }
            this.experiment.dirtyStatus.startDirtying();
            this.experiment.dirtyForPublishStatus.startDirtying();
            this.experiment.dirtyStatus.clean();
            this.experiment.dirtyForPublishStatus.clean();
        };
        ExperimentEditorContainerViewModel.prototype.submit = function () {
            return this.experimentEditorViewModel.draftStateMachine.submitExperiment();
        };
        ExperimentEditorContainerViewModel.prototype.publish = function () {
            return this.workspace.publishExperimentAsync(this.experiment);
        };
        ExperimentEditorContainerViewModel.prototype.save = function () {
            var saveError = this.experiment.saveError();
            if (!saveError) {
                if (!this.readOnlyMode()) {
                    this.clone();
                }
                return this.experimentEditorViewModel.draftStateMachine.saveDraft();
            }
            else {
                this.cannotSaveDraftHandler(saveError);
                return DataLab.Util.fail(new Error(saveError));
            }
        };
        ExperimentEditorContainerViewModel.prototype.discard = function () {
            var _this = this;
            if (this.projectViewModel && this.projectViewModel.findExperiment(function (vm) { return vm.experimentId() === _this.experiment.experimentId() && vm.role === DataLab.DataContract.ExperimentRole.Scoring; })) {
                Shell.Diagnostics.Telemetry.featureUsage(78 /* DeleteScoringExperiment */, 72 /* ScoringExperiment */, this.workspace.id, this.experiment.experimentId());
            }
            return this.experimentEditorViewModel.draftStateMachine.discardDraft();
        };
        ExperimentEditorContainerViewModel.prototype.cancel = function () {
            return this.workspace.cancelExperimentAsync(this.experiment.experimentId());
        };
        ExperimentEditorContainerViewModel.prototype.firstTimePublishWebService = function (webServiceGroupName) {
            var _this = this;
            var deferred = $.Deferred();
            var errorCallback = function (err) { return deferred.reject(err); };
            this.workspace.createWebServiceGroupAsync(webServiceGroupName, DataLab.LocalizedResources.webServiceGroupDefaultDescription, false).done(function (webServiceGroupId) {
                var errorCallbackWithDeleteWSG = function (err) {
                    _this.workspace.deleteWebServiceGroupAsync(webServiceGroupId);
                    var newErrorMessage = null;
                    if (err.xmlHttpRequest !== null && err.xmlHttpRequest !== undefined && err.xmlHttpRequest.status >= 400) {
                        try {
                            // responseText is like: "<Error><ErrorCode>UnsupportedModuleType</ErrorCode><MessageDetail>Project Columns</MessageDetail></Error>"
                            // or like: "<Error><Message>some message</Message><ExceptionMessage>some exception message</ExceptionMessage><ExceptionType>some type</ExceptionType><StackTrace>   at something</StackTrace></Error>"                
                            var errorXml = $.parseXML(err.xmlHttpRequest.responseText);
                            var errNode = errorXml.querySelector("Error");
                            if (errNode !== null) {
                                var errCodeNode = errNode.querySelector("ErrorCode");
                                var errDetailNode = errNode.querySelector("MessageDetail");
                                var errMessageNode = errNode.querySelector("Message");
                                var errExceptionMessageNode = errorXml.querySelector("ExceptionMessage");
                                if (errCodeNode !== null) {
                                    if (errCodeNode.textContent === "UnsupportedModuleType") {
                                        var moduleType = (errDetailNode !== null) ? errDetailNode.textContent : "";
                                        newErrorMessage = DataLab.Util.format(DataLab.LocalizedResources.publishWebServiceUnsupportedModule, moduleType);
                                    }
                                    else if (errCodeNode.textContent === "MixedVersions") {
                                        newErrorMessage = DataLab.LocalizedResources.publishWebServiceModuleVersionIsOld;
                                    }
                                    else {
                                        newErrorMessage = errCodeNode.textContent;
                                    }
                                }
                                else {
                                    newErrorMessage = (errMessageNode !== null ? (errMessageNode.textContent + " ") : "") + (errExceptionMessageNode !== null ? errExceptionMessageNode.textContent : "");
                                }
                            }
                        }
                        catch (parseErr) {
                        }
                    }
                    if (newErrorMessage !== null) {
                        deferred.reject(new DataLab.Util.AjaxError(newErrorMessage, err.xmlHttpRequest));
                    }
                    else {
                        deferred.reject(err);
                    }
                };
                var errorCallbackForCreateModelPackage = function (err) {
                    if (err.xmlHttpRequest && err.xmlHttpRequest.status == 400) {
                        _this.workspace.deleteWebServiceGroupAsync(webServiceGroupId);
                        // The most likely reason we are here is that the model package payload exceeded the maximum content size limit.
                        // Suggest to the user to re-try after reducing the number of input/output columns.
                        deferred.reject(new DataLab.Util.AjaxError(DataLab.LocalizedResources.publishWebServiceErrorWithTooManyColumns, err.xmlHttpRequest));
                    }
                    else {
                        errorCallbackWithDeleteWSG(err);
                    }
                };
                _this.workspace.createModelPackageAsync(webServiceGroupId, _this.experiment, _this.workspace).done(function (modelPackageId) {
                    _this.workspace.registerWebServiceAsync(webServiceGroupId, modelPackageId).done(function (webServiceId) {
                        _this.experiment.publishedWebServiceGroupId = webServiceGroupId;
                        _this.experiment.publishedModelPackageId = modelPackageId;
                        _this.workspace.updateDraftAsync(_this.experiment).done(function () {
                            deferred.resolve(webServiceGroupId, modelPackageId, webServiceId);
                        }).fail(errorCallbackWithDeleteWSG);
                    }).fail(errorCallbackWithDeleteWSG);
                }).fail(errorCallbackForCreateModelPackage);
            }).fail(errorCallback);
            return DataLab.Util.when(deferred);
        };
        ExperimentEditorContainerViewModel.prototype.republishWebService = function (webServiceGroupId, webServiceId) {
            var _this = this;
            var deferred = $.Deferred();
            var errorCallback = function (err) { return deferred.reject(err); };
            DataLab.Util.then(this.workspace.createModelPackageAsync(webServiceGroupId, this.experiment, this.workspace), function (modelPackageId) {
                return DataLab.Util.then(_this.workspace.updateWebServiceAsync(webServiceGroupId, webServiceId, modelPackageId, null), function () {
                    _this.experiment.publishedModelPackageId = modelPackageId;
                    return DataLab.Util.then(_this.workspace.updateDraftAsync(_this.experiment), function (result) {
                        deferred.resolve(modelPackageId);
                    }, errorCallback);
                }, errorCallback);
            }, errorCallback);
            return DataLab.Util.when(deferred);
        };
        ExperimentEditorContainerViewModel.prototype.firstTimePublishExperimentToCommunity = function (publishableExperiment) {
            var _this = this;
            var pollingExperimentPackage = DataLab.Util.then(DataLab.Workspace.createExperimentStoragePackageAsync(this.experimentId(), true, this.experiment.description()), function (response) {
                return _this.pollOnPackage(response);
            });
            var createCommunityExperimentPromise = DataLab.Util.then(pollingExperimentPackage, function (experimentPackage) {
                return _this.workspace.createCommunityExperimentAsync(publishableExperiment, experimentPackage.Location);
            });
            return DataLab.Util.then(createCommunityExperimentPromise, function (catalogExperimentUrl) {
                return catalogExperimentUrl;
            });
        };
        ExperimentEditorContainerViewModel.prototype.validate = function () {
            var _this = this;
            var errors = this.experimentEditorViewModel.experiment.validate();
            var displayHandled = false;
            this.experimentEditorViewModel.experimentViewModel().experimentNodes.forEach(function (node) {
                node.updateValidState();
            });
            if (errors.length > 0) {
                if (errors[0].erroneousObject instanceof DataLab.Model.GraphNode) {
                    var erroneousNode = errors[0].erroneousObject;
                    var nodeViewModel = this.experimentEditorViewModel.experimentViewModel().getViewModelForNode(erroneousNode);
                    // Wait for animation to complete, then show the balloon
                    // One shot. Dispose when fired
                    var subscription = this.experimentEditorViewModel.animationComplete.subscribe(function () {
                        nodeViewModel.forceBalloon.notifySubscribers(null);
                        subscription.dispose();
                    });
                    // We select the module BEFORE animating, because selecting modules will clear the
                    // balloon in the case that the module is already in view and needsAnimationToNode
                    // notifies subscribers immediately. We want to trigger the balloon when the editor
                    // is in a steady state.
                    this.experimentEditorViewModel.selectionManager.modifySelection(function () {
                        _this.experimentEditorViewModel.selectionManager.resetSelection();
                        _this.experimentEditorViewModel.selectionManager.selectEntity(nodeViewModel);
                    });
                    this.experimentEditorViewModel.needsAnimationToNode.notifySubscribers(erroneousNode);
                    displayHandled = true;
                }
                else if (errors[0].erroneousObject instanceof DataLab.Model.ModuleNodeParameter) {
                    var parameter = errors[0].erroneousObject;
                    this.propertyEditorViewModel.navigateToParameter(parameter);
                    displayHandled = true;
                }
                else if (errors[0].erroneousObject instanceof DataLab.Model.WebServiceParameter) {
                    var parameter = errors[0].erroneousObject;
                    this.propertyEditorViewModel.navigateToParameter(parameter);
                    displayHandled = true;
                }
                else if (errors[0].erroneousObject === this.experiment.description) {
                    this.descriptionFocus(true);
                    displayHandled = true;
                }
            }
            return {
                allErrors: errors,
                unhandledErrors: displayHandled ? errors.slice(1) : errors,
                valid: errors.length === 0
            };
        };
        ExperimentEditorContainerViewModel.prototype.pollOnPackage = function (experimentPackage) {
            var pollingDeferred = $.Deferred();
            this.pollOnPackageHandler(experimentPackage, 0, pollingDeferred);
            return DataLab.Util.when(pollingDeferred.promise());
        };
        ExperimentEditorContainerViewModel.prototype.pollOnPackageHandler = function (experimentPackage, retryCount, resultPromise) {
            var _this = this;
            DataLab.Workspace.getExperimentStoragePackageAsync(experimentPackage.Location).done(function (updatedPackage) {
                if (updatedPackage.Status === "Pending") {
                    // Poll for ~1 hour and then fail
                    if (retryCount > 15) {
                        resultPromise.reject(new Error("Exceeded retry count"));
                    }
                    var interval = Math.pow(2, retryCount) * 100;
                    setTimeout(function () {
                        _this.pollOnPackageHandler(updatedPackage, retryCount + 1, resultPromise);
                    }, interval);
                }
                else if (updatedPackage.Status === "Complete") {
                    resultPromise.resolve(updatedPackage);
                }
                else {
                    resultPromise.reject(new Error("Unknown status returned for package"));
                }
            }).fail(function (error) { return resultPromise.reject(error); });
        };
        ExperimentEditorContainerViewModel.prototype.promoteOutputToDataset = function (target) {
            var _this = this;
            var resource = new DataLab.Model.UnsavedResource(this.workspace, this.workspace.datasetCache, this.workspace.datasetUploadsInProgress, DataLab.Constants.DatasetName);
            var dialogViewModel = new ExperimentEditor.OutputPromotionDialogViewModel(target, resource, this.workspace.datasetCache, this.workspace.promoteOutputToDatasetAsync.bind(this.workspace));
            // One shot. Dispose on firing.
            var subscription = dialogViewModel.resourcePromotionStartedEvent.subscribe(function (promotionPromise) {
                if (_this.outputPromotionProgressHandler) {
                    _this.outputPromotionProgressHandler(promotionPromise);
                }
                subscription.dispose();
            });
            ExperimentEditor.DialogViews.OutputPromotion.show(dialogViewModel);
        };
        ExperimentEditorContainerViewModel.prototype.promoteOutputToModel = function (target) {
            var _this = this;
            var resource = new DataLab.Model.UnsavedResource(this.workspace, this.workspace.trainedModelCache, this.workspace.trainedModelUploadsInProgress, DataLab.Constants.TrainedModelName);
            var dialogViewModel = new ExperimentEditor.OutputPromotionDialogViewModel(target, resource, this.workspace.trainedModelCache, this.workspace.promoteOutputToTrainedModelAsync.bind(this.workspace));
            var subscription = dialogViewModel.resourcePromotionStartedEvent.subscribe(function (promotionPromise) {
                if (_this.outputPromotionProgressHandler) {
                    _this.outputPromotionProgressHandler(promotionPromise);
                }
                subscription.dispose();
            });
            ExperimentEditor.DialogViews.TrainedModelPromotion.show(dialogViewModel);
        };
        ExperimentEditorContainerViewModel.prototype.promoteOutputToTransform = function (target) {
            var _this = this;
            var resource = new DataLab.Model.UnsavedResource(this.workspace, this.workspace.transformModulesCache, this.workspace.transformModuleUploadsInProgress, DataLab.Constants.TransformModuleName);
            var dialogViewModel = new ExperimentEditor.OutputPromotionDialogViewModel(target, resource, this.workspace.transformModulesCache, this.workspace.promoteOutputToTransformModuleAsync.bind(this.workspace));
            var subscription = dialogViewModel.resourcePromotionStartedEvent.subscribe(function (promotionPromise) {
                if (_this.outputPromotionProgressHandler) {
                    _this.outputPromotionProgressHandler(promotionPromise);
                }
                subscription.dispose();
            });
            ExperimentEditor.DialogViews.TransformModulePromotion.show(dialogViewModel);
        };
        ExperimentEditorContainerViewModel.prototype.promoteCreateWebService = function (target) {
            var _this = this;
            var dialogViewModel = new ExperimentEditor.CreateWebServiceFromTrainedModelDialogViewModel(this.experiment.description() + " (Scoring)", function (name, description) {
                _this.createTrainedModelAndWebServiceGraph(name, description, target);
            });
            ExperimentEditor.DialogViews.CreateWebServiceFromTrainedModel.show(dialogViewModel);
        };
        ExperimentEditorContainerViewModel.prototype.createTrainedModelAndWebServiceGraph = function (name, description, target) {
            var _this = this;
            Shell.UI.Spinner.show();
            this.workspace.promoteOutputToTrainedModelAsync(target.portModel, name, "", description).done(function (trainedModel) {
                _this.copy(name);
                _this.experimentEditorViewModel.selectionManager.resetSelection();
                _this.experimentEditorViewModel.selectionManager.selectEntity(target.parent);
                var trainedModelNode = _this.experimentEditorViewModel.addTrainedModelById(trainedModel.id, 50, 200);
                var scoreModule = DataLab.Util.first(_this.experimentEditorViewModel.moduleCache.items(), function (m) {
                    return m.familyId.indexOf(DataLab.Constants.WellKnownResource.ScoreGenericModuleFamilyId) > -1;
                });
                if (scoreModule) {
                    var scoreModuleNode = _this.experimentEditorViewModel.addModuleById(scoreModule.id, 50, 300);
                    var scoreInputPort = DataLab.Util.first(scoreModuleNode.inputPorts);
                    var trainedModelOutputPort = DataLab.Util.first(trainedModelNode.outputPorts);
                    scoreInputPort.portModel.connectTo(trainedModelOutputPort.portModel);
                }
                _this.save();
                var wizard = $("<div/>").fxsWizard();
                var wizardViewModel = wizard.fxsWizard("getViewModel");
                var step1 = new $.fxs.fxsWizard.WizardStep();
                step1.content(ExperimentEditor._createWebServiceTutorialStep1Markup);
                var step2 = new $.fxs.fxsWizard.WizardStep();
                step2.content(ExperimentEditor._createWebServiceTutorialStep2Markup);
                var step3 = new $.fxs.fxsWizard.WizardStep();
                step3.content(ExperimentEditor._createWebServiceTutorialStep3Markup);
                wizardViewModel.steps.push(step1);
                wizardViewModel.steps.push(step2);
                wizardViewModel.steps.push(step3);
                wizardViewModel.currentStep(step1);
                wizard.fxsWizard("open");
                Impl.UI.Dialogs.ModalPresenter.open(wizard);
            }).fail(function (error) {
                if (_this.alertHandler) {
                    _this.alertHandler(error.message);
                }
            }).always(function () {
                Shell.UI.Spinner.hide();
            });
        };
        ExperimentEditorContainerViewModel.prototype.createTransformAndWebServiceGraph = function (name, description, target) {
            var _this = this;
            Shell.UI.Spinner.show();
            this.workspace.promoteOutputToTransformModuleAsync(target.portModel, name, "", description).done(function (transform) {
                _this.copy(name);
                _this.experimentEditorViewModel.selectionManager.resetSelection();
                _this.experimentEditorViewModel.selectionManager.selectEntity(target.parent);
                var transformNode = _this.experimentEditorViewModel.addTransformById(transform.id, 50, 200);
                var transformModule = DataLab.Util.first(_this.experimentEditorViewModel.moduleCache.items(), function (m) {
                    return m.familyId.indexOf(DataLab.Constants.WellKnownResource.TransformFamilyId) > -1;
                });
                if (transformModule) {
                    var transformModuleNode = _this.experimentEditorViewModel.addModuleById(transformModule.id, 50, 300);
                    var scoreInputPort = DataLab.Util.first(transformModuleNode.inputPorts);
                    var transformOutputPort = DataLab.Util.first(transformNode.outputPorts);
                    scoreInputPort.portModel.connectTo(transformOutputPort.portModel);
                }
                _this.save();
                var wizard = $("<div/>").fxsWizard();
                var wizardViewModel = wizard.fxsWizard("getViewModel");
                var step1 = new $.fxs.fxsWizard.WizardStep();
                step1.content(ExperimentEditor._createWebServiceTutorialStep1Markup);
                var step2 = new $.fxs.fxsWizard.WizardStep();
                step2.content(ExperimentEditor._createWebServiceTutorialStep2Markup);
                var step3 = new $.fxs.fxsWizard.WizardStep();
                step3.content(ExperimentEditor._createWebServiceTutorialStep3Markup);
                wizardViewModel.steps.push(step1);
                wizardViewModel.steps.push(step2);
                wizardViewModel.steps.push(step3);
                wizardViewModel.currentStep(step1);
                wizard.fxsWizard("open");
                Impl.UI.Dialogs.ModalPresenter.open(wizard);
            }).fail(function (error) {
                if (_this.alertHandler) {
                    _this.alertHandler(error.message);
                }
            }).always(function () {
                Shell.UI.Spinner.hide();
            });
        };
        ExperimentEditorContainerViewModel.prototype.activateEntity = function (entity, secondaryActivation) {
            var endpoint = null;
            if (entity instanceof ExperimentEditor.OutputPort) {
                var parent = entity.parent;
                if (parent instanceof ExperimentEditor.Module && parent.moduleNode.statusCode.value() !== DataLab.DataContract.State.Finished) {
                    return;
                }
                if (parent.graphNodeType === 1 /* Dataset */ || parent.graphNodeType === 2 /* TrainedModel */ || parent.graphNodeType === 4 /* Transform */) {
                    endpoint = entity.portModel.outputEndpoint;
                    Shell.Diagnostics.Telemetry.featureUsage(18 /* Download */, 0, this.workspace.id, this.experimentId(), null, JSON.stringify({ port: entity.portModel.name, isModule: parent.isModule(), nodeType: parent.graphNodeType, nodeName: parent.graphNode.name }));
                }
                else if (entity.portModel.isVisualizable()) {
                    this.endpointDownloader.visualize(entity.portModel, this.workspace, entity.parent.isModule());
                }
                else {
                    // Disable opening output port data while running.
                    if (!(entity.parent instanceof ExperimentEditor.Module && parent.statusCode.property.value() === DataLab.DataContract.State.Running)) {
                        // Do not allow download if the type of the output port is ILearnerDotNet
                        if (entity.portModel.descriptor.allowedDataTypes.some(function (value, index, array) {
                            return value.dataTypeId === "ILearnerDotNet" || value.dataTypeId === "IClusterDotNet";
                        })) {
                            if (DataLab.Features.authorizeDownloadILearnerEnabled()) {
                                endpoint = entity.portModel.outputEndpoint;
                            }
                            else {
                                var notification = new Shell.UI.Notifications.Notification(DataLab.LocalizedResources.cannotDownloadThisTypeOfData, 'error');
                                notification.setActions([Shell.UI.Notifications.Buttons.close(function () {
                                })]);
                                Shell.UI.Notifications.add(notification);
                                Shell.Diagnostics.Telemetry.customEvent("TentativeToDownloadUnauthorizedDataType", "DownloadData");
                            }
                        }
                        else if (entity.portModel.descriptor.allowedDataTypes.some(function (value, index, array) {
                            return value.dataTypeId === "ITransformDotNet";
                        })) {
                            if (DataLab.Features.authorizeDownloadILearnerEnabled()) {
                                endpoint = entity.portModel.outputEndpoint;
                            }
                            else {
                                var notification = new Shell.UI.Notifications.Notification(DataLab.LocalizedResources.cannotDownloadThisTypeOfData, 'error');
                                notification.setActions([Shell.UI.Notifications.Buttons.close(function () {
                                })]);
                                Shell.UI.Notifications.add(notification);
                                Shell.Diagnostics.Telemetry.customEvent("TentativeToDownloadUnauthorizedDataType", "DownloadData");
                            }
                        }
                        else {
                            endpoint = entity.portModel.outputEndpoint;
                            Shell.Diagnostics.Telemetry.featureUsage(18 /* Download */, 0, this.workspace.id, this.experimentId(), parent.graphNode.module_.id, JSON.stringify({ port: entity.portModel.name, isModule: parent.isModule(), nodeType: parent.graphNodeType, nodeName: parent.graphNode.name }));
                        }
                    }
                }
            }
            if (endpoint) {
                this.endpointDownloader.download(endpoint);
            }
        };
        /** If nodes in the graph are eligible for upgrade, prompts the user to upgrade them (via nodesEligibleForUpgradeHandler). */
        ExperimentEditorContainerViewModel.prototype.promptForUpgradeIfNodesAreEligible = function () {
            if (!this.experiment.disableNodesUpdate()) {
                var eligibleNodes = this.experiment.findNodesEligibleForUpgrade();
                if (eligibleNodes.length > 0) {
                    // Only prompt for update if any modules have gone up a major version.
                    var promptForUpdate = eligibleNodes.some(function (node) { return node instanceof DataLab.Model.ModuleNode && !node.module_.isLatestClientVersion; });
                    if (promptForUpdate) {
                        DataLab.Log.info("The current graph contains nodes eligible for upgrade. The user will be prompted to upgrade them.", "ExperimentEditorContainerViewModel.promptForUpgradeIfNodesAreEligible", {
                            eligibleNodeCount: eligibleNodes.length
                        });
                        this.nodesEligibleForUpgradeHandler(eligibleNodes);
                    }
                    else {
                        DataLab.Log.info("The current graph contains nodes eligible for upgrade. The graph will be updated.", "ExperimentEditorContainerViewModel.promptForUpgradeIfNodesAreEligible", {
                            eligibleNodeCount: eligibleNodes.length
                        });
                        var ws = this.workspace;
                        this.experiment.upgradeNodes(ws.moduleCache, ws.datasetCache, ws.trainedModelCache, ws.transformModulesCache, ws);
                    }
                }
            }
        };
        return ExperimentEditorContainerViewModel;
    })(DataLab.Util.Disposable);
    ExperimentEditor.ExperimentEditorContainerViewModel = ExperimentEditorContainerViewModel;
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../ViewModel/PropertyEditorControl/PropertyEditorViewModel.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var ExperimentEditor;
(function (ExperimentEditor) {
    var PropertyEditorControl = (function (_super) {
        __extends(PropertyEditorControl, _super);
        /**
          * Constructor of the PropertyEditorControl
          * @constructor
          * @param rootContainerId {string} the div the control applies its knockout bindings to
          * @param viewModel {PropertyEditorViewModel} the view model backing the property editor
         **/
        function PropertyEditorControl(rootContainerDiv, viewModel) {
            _super.call(this);
            if (!rootContainerDiv) {
                throw new Error("Property editor root div does not exist");
            }
            this.rootContainerDiv = rootContainerDiv;
            if (!viewModel) {
                throw new Error("argument: viewModel cannot be undefined or null");
            }
            this.viewModel = viewModel;
            // Insert the markup into the root container, this should be the first thing
            // initialized from within the control constructor.
            this.registerForDisposal(new DataLab.Util.DisposableSetHTML(this.rootContainerDiv, ExperimentEditor._propertyEditorMarkup), new DataLab.Util.DisposableKOApplyBindings(viewModel, this.rootContainerDiv));
        }
        return PropertyEditorControl;
    })(DataLab.Util.Disposable);
    ExperimentEditor.PropertyEditorControl = PropertyEditorControl;
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../Global.ts" />
/// <reference path="ExperimentEditorControl.ts" />
/// <reference path="PaletteControl.ts" />
/// <reference path="../ViewModel/ExperimentEditor/ExperimentEditorContainerViewModel.ts" />
/// <reference path="PropertyEditorControl.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var ExperimentEditor;
(function (ExperimentEditor) {
    // We use this constant because the view model needs to reference this in the current inplementation
    // TODO [114223] the property editor view model shouldn't reference its view
    var Constants;
    (function (Constants) {
        var PropertyEditor;
        (function (PropertyEditor) {
            // TODO [1149975]: Don't assume we are the only experiment editor on the page.
            PropertyEditor.Id = "#propertyEditorRoot";
        })(PropertyEditor = Constants.PropertyEditor || (Constants.PropertyEditor = {}));
    })(Constants = ExperimentEditor.Constants || (ExperimentEditor.Constants = {}));
    var ExperimentEditorContainer = (function (_super) {
        __extends(ExperimentEditorContainer, _super);
        function ExperimentEditorContainer(parentDiv, xeContainerViewModel) {
            _super.call(this);
            this.parentDiv = parentDiv;
            this.experimentEditorContainerViewModel = xeContainerViewModel;
            // For testing, we need to be able to introspect the control instance attached to a particular DOM node.
            // We need to dispose of this because we don't own parentDiv.
            parentDiv.experimentEditorContainer = this;
            this.registerForDisposal(new DataLab.Util.DisposableSetHTML(parentDiv, ExperimentEditor._experimentEditorMarkup), new DataLab.Util.DisposableKOApplyBindings(xeContainerViewModel, parentDiv.querySelector(".headerExperimentEditorContainer")), new DataLab.Util.DisposableKOApplyBindings(xeContainerViewModel, parentDiv.querySelector(".xe-utilityPanelRoot")));
            // These are disposables, so they need to get disposed when we get disposed.
            this.registerForDisposal(this.xeControl = new ExperimentEditor.ExperimentEditorControl(parentDiv.querySelector(".experimentEditorRoot"), xeContainerViewModel.experimentEditorViewModel), this.paletteView = new ExperimentEditor.PaletteControl(parentDiv.querySelector(".xe-utilityPanel"), xeContainerViewModel.paletteViewModel), this.propertyEditorControl = new ExperimentEditor.PropertyEditorControl(parentDiv.querySelector(".propertyEditorRoot"), xeContainerViewModel.propertyEditorViewModel));
            // Wire up the palettes for drag and drop
            xeContainerViewModel.paletteViewModel.registerActivationEvent(this.xeControl.addEntityToCenter.bind(this.xeControl));
            xeContainerViewModel.paletteViewModel.dragResponder = this.xeControl;
        }
        ExperimentEditorContainer.prototype.zoomToFitIfSample = function () {
            if (!this.experimentEditorContainerViewModel.userWorkspaceExperiment()) {
                this.xeControl.zoomToFitWithAnimation();
            }
        };
        ExperimentEditorContainer.prototype.zoomToFitWithAnimation = function () {
            var dfd = $.Deferred();
            this.xeControl.zoomToFitWithAnimation();
            var subscription = this.xeControl.viewModel.animationComplete.subscribe(function () {
                dfd.resolve();
            });
            return dfd.promise().done(function () {
                subscription.dispose();
            });
        };
        ExperimentEditorContainer.prototype.dispose = function () {
            ExperimentEditor.Balloon.hide();
            // We don't own parentDiv, so we need to remove the reference to us to avoid
            // a leak.
            delete this.parentDiv.experimentEditorContainer;
            _super.prototype.dispose.call(this);
        };
        return ExperimentEditorContainer;
    })(DataLab.Util.Disposable);
    ExperimentEditor.ExperimentEditorContainer = ExperimentEditorContainer;
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../Global.ts" />
var ExperimentEditor;
(function (ExperimentEditor) {
    var PublishWebServiceDialogViewModel = (function () {
        function PublishWebServiceDialogViewModel(description, error) {
            this.webServiceGroupName = ko.observable(description);
            this.error = error;
        }
        return PublishWebServiceDialogViewModel;
    })();
    ExperimentEditor.PublishWebServiceDialogViewModel = PublishWebServiceDialogViewModel;
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
/// <reference path="../../View/DialogView.ts" />
var ExperimentEditor;
(function (ExperimentEditor) {
    var InputColumnViewModel = (function () {
        function InputColumnViewModel(name, valueType, value, friendlyName, allowedValues) {
            this.valueType = valueType;
            this.value = ko.observable(value);
            this.name = name;
            this.friendlyName = friendlyName;
            this.allowedValues = allowedValues;
        }
        return InputColumnViewModel;
    })();
    ExperimentEditor.InputColumnViewModel = InputColumnViewModel;
    var WebServiceParameterViewModel = (function () {
        function WebServiceParameterViewModel(metadata, value) {
            this.metadata = metadata;
            this.value = ko.observable(value);
        }
        return WebServiceParameterViewModel;
    })();
    ExperimentEditor.WebServiceParameterViewModel = WebServiceParameterViewModel;
    var ScoreDialogErrorInfo = (function () {
        function ScoreDialogErrorInfo(title, message) {
            this.title = title;
            this.message = message;
        }
        return ScoreDialogErrorInfo;
    })();
    ExperimentEditor.ScoreDialogErrorInfo = ScoreDialogErrorInfo;
    var ScoreDialogViewModel = (function () {
        function ScoreDialogViewModel(modelPackageInfo, webServiceGroup, webserviceId, workspace) {
            var _this = this;
            this.wsgName = webServiceGroup.Name;
            this.wsgId = webServiceGroup.Id;
            // TODO: currently only support 1st input as web service input.
            if (modelPackageInfo.Inputs && modelPackageInfo.Inputs.length > 0 && modelPackageInfo.Inputs[0].Schema) {
                var inputSchema = JSON.parse(modelPackageInfo.Inputs[0].Schema);
                var inputId = modelPackageInfo.Inputs[0].Id;
                var inputMetadata = modelPackageInfo.InputsMetadata ? modelPackageInfo.InputsMetadata[inputId] : null;
                this.inputColumns = $.map(inputSchema.columnAttributes, function (column, index) {
                    var description = (inputMetadata && inputMetadata[column.name]) ? inputMetadata[column.name] : column.name;
                    var allowedValues = [];
                    if (column.domain && column.domain.categories) {
                        allowedValues = column.domain.categories;
                    }
                    return new InputColumnViewModel(column.name, column.type, _this.getDefaultValue(column.type, allowedValues), description, allowedValues);
                });
            }
            else {
                this.inputColumns = [];
            }
            if (modelPackageInfo.GlobalParametersMetadata) {
                this.webServiceParameters = $.map(modelPackageInfo.GlobalParametersMetadata, function (paramData, index) {
                    var suggestedValue;
                    if (paramData.DefaultValue) {
                        suggestedValue = paramData.DefaultValue;
                    }
                    else if (paramData.Type == DataLab.DataContract.ModuleParameterType.Enumerated) {
                        try {
                            suggestedValue = paramData.ParameterRules[0].Values[0];
                        }
                        catch (e) {
                            DataLab.Log.exception(e, "Failed to get enumeration values for Web Service Parameter");
                        }
                    }
                    else {
                        switch (paramData.Type) {
                            case DataLab.DataContract.ModuleParameterType.Boolean:
                                suggestedValue = true;
                                break;
                            case DataLab.DataContract.ModuleParameterType.Double:
                            case DataLab.DataContract.ModuleParameterType.Float:
                                suggestedValue = 0.0;
                                break;
                            case DataLab.DataContract.ModuleParameterType.Int:
                                suggestedValue = 0;
                                break;
                        }
                    }
                    return new WebServiceParameterViewModel(paramData, suggestedValue);
                });
            }
            else {
                this.webServiceParameters = [];
            }
            this.webserviceId = webserviceId;
            this.workspace = workspace;
        }
        ScoreDialogViewModel.prototype.dismissed = function (result) {
            var _this = this;
            if (result.accepted) {
                var progress = new Shell.UI.Notifications.Progress(DataLab.Util.format(DataLab.LocalizedResources.webServiceTestProgressTitle, this.wsgName), "active", true);
                progress.setDismissable(true);
                progress.setActions([Shell.UI.Notifications.Buttons.close(function () {
                    Shell.UI.Notifications.remove(progress);
                })]);
                Shell.UI.Notifications.add(progress);
                var inputs = {};
                $.each(this.inputColumns, function (index, inputColumn) {
                    inputs[inputColumn.name] = inputColumn.value();
                });
                var globalParameters = {};
                $.each(this.webServiceParameters, function (index, parameter) {
                    globalParameters[parameter.metadata.Name] = parameter.value();
                });
                this.workspace.invokeScoreWebServiceAsync(this.wsgId, this.webserviceId, inputs, globalParameters).done(function (result) {
                    var resultSummary = _this.getScoringResultSummary(result);
                    if (resultSummary) {
                        progress.setTitle(DataLab.Util.format(DataLab.LocalizedResources.webServiceTestSuccessAndResultSummary, _this.wsgName, resultSummary));
                    }
                    else {
                        progress.setTitle(DataLab.Util.format(DataLab.LocalizedResources.webServiceTestSuccessTitle, _this.wsgName));
                    }
                    progress.setStatus("success");
                    progress.addStep(DataLab.Util.format(DataLab.LocalizedResources.webServiceTestResultStepTitle, JSON.stringify(result)), "success");
                }).fail(function (error) {
                    progress.setStatus("error");
                    var errorInfo = _this.getScoringErrorInfo(error);
                    progress.setTitle(errorInfo.title);
                    progress.setDetailsText(errorInfo.message);
                });
            }
        };
        ScoreDialogViewModel.prototype.canBeAccepted = function () {
            // TODO: 2107090 add parameter validations
            return true;
        };
        ScoreDialogViewModel.prototype.getScoringResultSummary = function (result) {
            // Returns the first row of an output table from the result
            if (result && typeof (result) === "object") {
                var results = result["Results"];
                if (results) {
                    for (var outputName in results) {
                        var output = results[outputName];
                        if (output && output["type"] === "table") {
                            var outputValue = output["value"];
                            if (outputValue) {
                                var values = outputValue["Values"];
                                if (values && typeof (values.length) === "number" && values.length > 0) {
                                    return JSON.stringify(values[0]);
                                }
                            }
                        }
                    }
                }
            }
            return null;
        };
        ScoreDialogViewModel.prototype.getScoringErrorInfo = function (error) {
            var errors = [];
            var errorTitle = "";
            var errorResponse = null;
            if (!error || !error.xmlHttpRequest) {
                errors.push(DataLab.LocalizedResources.unexpectedError);
            }
            else if (error.xmlHttpRequest.responseText) {
                errorResponse = this.tryParseJson(error.xmlHttpRequest.responseText);
                if (errorResponse) {
                    if (errorResponse.error) {
                        errorResponse = errorResponse.error;
                    }
                    if (errorResponse.message) {
                        errorTitle = errorResponse.message;
                    }
                    else if (errorResponse.Message) {
                        errorTitle = errorResponse.Message;
                    }
                }
                if (error.xmlHttpRequest.status === 401 || error.xmlHttpRequest.status === 403 || error.xmlHttpRequest.status === 404) {
                    errors.push(DataLab.LocalizedResources.webServiceNotReady);
                }
                else if (error.xmlHttpRequest.status < 500) {
                    if (errorResponse && errorResponse.details && errorResponse.details.length > 0) {
                        $.map(errorResponse.details, function (detail, i) {
                            if (detail && detail.code && detail.message) {
                                errors.push(DataLab.Util.format("{0}: {1}", detail.code, detail.message));
                            }
                        });
                    }
                }
                if (errorResponse) {
                    var mainErrorCode = errorResponse.code ? errorResponse.code : errorResponse.ErrorCode;
                    if (mainErrorCode) {
                        errors.push(DataLab.Util.format(DataLab.LocalizedResources.scoreErrorCode, mainErrorCode));
                    }
                }
                errors.push(DataLab.Util.format(DataLab.LocalizedResources.scoreErrorHttpStatusCode, error.xmlHttpRequest.status.toString()));
                var requestId = error.xmlHttpRequest.getResponseHeader("x-ms-request-id");
                if (requestId) {
                    errors.push(DataLab.Util.format(DataLab.LocalizedResources.scoreErrorRequestId, requestId));
                }
                var timestamp = error.xmlHttpRequest.getResponseHeader("Date");
                if (timestamp) {
                    errors.push(DataLab.Util.format(DataLab.LocalizedResources.scoreErrorTimestamp, timestamp));
                }
            }
            return new ScoreDialogErrorInfo(DataLab.Util.format(DataLab.LocalizedResources.webServiceTestFailureTitle, this.wsgName, errorTitle), errors.join(", "));
        };
        ScoreDialogViewModel.prototype.tryParseJson = function (text) {
            var obj;
            try {
                obj = JSON.parse(text);
            }
            catch (e) {
                obj = null;
            }
            return obj;
        };
        ScoreDialogViewModel.prototype.getDefaultValue = function (type, allowedValues) {
            switch (type) {
                case "Numeric":
                    return 0;
                case "Binary":
                    return false;
                case "Categorical":
                    return (allowedValues.length > 0 ? allowedValues[0] : "");
                default:
                    return "";
            }
        };
        return ScoreDialogViewModel;
    })();
    ExperimentEditor.ScoreDialogViewModel = ScoreDialogViewModel;
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../Typescript/Global.ts" />
/// <reference path="../Typescript/View/DialogViewFactories.ts" />
/// <reference path="../Typescript/ViewModel/Dialogs/ScoreDialogViewModel.ts" />
/// <reference path="../Typescript/View/ExperimentEditorContainer.ts" />
var DataLabViews;
(function (DataLabViews) {
    DataLabViews.WebServiceGroupType = {
        name: "WebServiceGroup",
        displayName: DataLab.LocalizedResources.webServiceGroupDisplayName,
        dataFunction: function (dataRequest, path, dataSet) {
            return {
                data: [{ name: dataRequest.WebServiceGroup, displayName: dataRequest.WebServiceGroup }]
            };
        }
    };
    var WebService = (function () {
        function WebService(id, url, type, creationTime) {
            this.Id = id;
            this.Url = url;
            this.Type = type;
            this.CreationTime = creationTime;
        }
        return WebService;
    })();
    DataLabViews.WebService = WebService;
    ;
})(DataLabViews || (DataLabViews = {}));

/// <reference path="../Typescript/Global.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var DataLabViews;
(function (DataLabViews) {
    var ViewBase = (function (_super) {
        __extends(ViewBase, _super);
        function ViewBase(extensionName) {
            _super.call(this);
            this.extensionName = extensionName;
        }
        ViewBase.prototype.isViewExtensionStillActive = function () {
            return cdm.currentExtension === Shell.extensionIndex[this.extensionName];
        };
        return ViewBase;
    })(DataLab.Util.Disposable);
    DataLabViews.ViewBase = ViewBase;
})(DataLabViews || (DataLabViews = {}));

/// <reference path="../../Global.ts" />
/// <reference path="CustomUX.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var ExperimentEditor;
(function (ExperimentEditor) {
    var ExperimentSaveAs;
    (function (ExperimentSaveAs) {
        var ExperimentSaveAsViewModel = (function (_super) {
            __extends(ExperimentSaveAsViewModel, _super);
            function ExperimentSaveAsViewModel(newExperimentName, oldExperimentName) {
                var _this = this;
                _super.call(this);
                this.hasErrors = ko.observable(true);
                this.name = DataLab.Validation.validatableObservable(oldExperimentName + DataLab.LocalizedResources.copyForNewExperimentName, function (name) {
                    // String must contain a non-whitespace character
                    if (/\S/.test(name)) {
                        _this.hasErrors(false);
                        return null;
                    }
                    else {
                        _this.hasErrors(true);
                        return DataLab.LocalizedResources.experimentNameError;
                    }
                });
                this.name.subscribe(function () {
                    _this.name.startValidating();
                    _this.name.validate();
                });
                this.launchSaveAsHelp = function () {
                    // launches save as help: something like https://www.contoso.com/Help/?topic=html/e548ed9d-064b-42fd-a1b7-4c34eccb88f8.htm
                    ExperimentEditor.Help.openHelpWindow(ExperimentEditor.Constants.saveAsHelpLinkGuid);
                };
                this.save = function () {
                    newExperimentName(_this.name());
                };
                this.saveNameAndClose = function () {
                    _this.name.startValidating();
                    _this.name.validate();
                    if (!_this.hasErrors()) {
                        _this.save();
                        ExperimentEditor.CustomUX.close(_this);
                        Shell.Diagnostics.Telemetry.customEvent("Close", "SaveAs", newExperimentName());
                    }
                };
            }
            return ExperimentSaveAsViewModel;
        })(DataLab.Util.Disposable);
        ExperimentSaveAs.ExperimentSaveAsViewModel = ExperimentSaveAsViewModel;
    })(ExperimentSaveAs = ExperimentEditor.ExperimentSaveAs || (ExperimentEditor.ExperimentSaveAs = {}));
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
var ExperimentEditor;
(function (ExperimentEditor) {
    var TagTextBoxViewModel = (function () {
        function TagTextBoxViewModel(tags) {
            var _this = this;
            this.tags = tags;
            this.nameInputFocused = ko.observable(false);
            this.setNameInputFocused = (function () {
                _this.nameInputFocused(true);
            });
            this.removeTag = function (tag) {
                _this.tags.remove(tag);
            };
            this.currentTag = DataLab.Validation.validatableObservable("", $.noop);
            this.currentTag.subscribe(function () {
                if (_this.currentTag() !== "") {
                    var names = DataLab.Util.Str.getArrayFromCommaSeparatedString(_this.currentTag());
                    names.forEach(function (trimmedName) {
                        if (trimmedName !== "") {
                            if (_this.tags().indexOf(trimmedName) === -1) {
                                _this.tags.push(trimmedName);
                            }
                        }
                    });
                }
                _this.currentTag.startValidating();
                _this.currentTag.validate();
                // Clear the input
                _this.currentTag("");
            });
            this.hasTags = ko.computed(function () {
                return _this.tags().length > 0;
            });
        }
        return TagTextBoxViewModel;
    })();
    ExperimentEditor.TagTextBoxViewModel = TagTextBoxViewModel;
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
var ExperimentEditor;
(function (ExperimentEditor) {
    ;
    function findValuePairInValuePairArray(valuePairs, valueToFind) {
        var valuePairsWithItem = valuePairs.filter(function (valuePair) {
            return valuePair.value === valueToFind;
        });
        if (valuePairsWithItem.length === 1) {
            return valuePairsWithItem[0];
        }
        else {
            return;
        }
    }
    ;
    ko.bindingHandlers["fxRadio"] = {
        init: function (element, valueAccessor, allBindingsAccessor, targetViewModel) {
            var bindingOptions = valueAccessor();
            if ('change' in bindingOptions) {
                throw new Error("This custom binding handles change tracking automatically. Just specify an observable with the 'value' option and it will get set to the selected value.");
            }
            if (!ko.isObservable(bindingOptions.value)) {
                throw new Error("'value' custom binding option must be a Knockout observable. Oobservable can contain initial value.");
            }
            var valueObservable = bindingOptions.value;
            // Specifying an initial value is optional, default is the first possible value in the values array
            if (typeof valueObservable() === "undefined") {
                valueObservable(bindingOptions.values[0].value);
            }
            var fxRadioOptions = {
                value: findValuePairInValuePairArray(bindingOptions.values, valueObservable()),
                values: bindingOptions.values,
                trackedit: bindingOptions.trackedit,
                change: function (event, args) {
                    var visibility = args.value.value;
                    valueObservable(visibility);
                }
            };
            if (typeof fxRadioOptions.value === "undefined") {
                throw new Error("The observable has a value not found in the values array.");
            }
            $(element).fxRadio(fxRadioOptions);
        }
    };
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../Global.ts" />
var ExperimentEditor;
(function (ExperimentEditor) {
    var WizardView = (function () {
        function WizardView(wizardContentViewModel, stepsAny, fxsWizardOptions) {
            var _this = this;
            this.wizardContentViewModel = wizardContentViewModel;
            this.onWizardClosingEvent = new ko.subscribable();
            this.enableOrDisable = function (isDisabled) {
                _this.wizardInternalViewModel.completeButtonEnabled(!isDisabled);
                _this.wizardInternalViewModel.lockOrUnlockNextSteps(isDisabled);
            };
            var steps = stepsAny; // Workaround for the fact that we can't reference $ in Leakmaster .d.ts files. I can't figure out why.
            fxsWizardOptions.closing = function (info) {
                var isClosing = wizardContentViewModel.onWizardClosing(info);
                if (isClosing) {
                    _this.onWizardClosingEvent.notifySubscribers(info);
                }
                return isClosing;
            };
            this.wizard = $("<div/>").fxsWizard(fxsWizardOptions);
            this.wizardInternalViewModel = this.wizard.fxsWizard("getViewModel");
            wizardContentViewModel.registerForDisposal(new DataLab.Util.DisposableSubscription(wizardContentViewModel.isNextStepDisabled.subscribe(this.enableOrDisable)));
            steps.forEach(function (value) {
                _this.wizardInternalViewModel.steps.push(value);
            });
            this.wizardInternalViewModel.currentStep(steps[0]);
            this.enableOrDisable(wizardContentViewModel.isNextStepDisabled()); // call once to immediately disable if necessary, must be called after current step is set.
        }
        WizardView.prototype.show = function () {
            this.wizard.fxsWizard("open");
            Impl.UI.Dialogs.ModalPresenter.open(this.wizard);
        };
        return WizardView;
    })();
    ExperimentEditor.WizardView = WizardView;
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
/// <reference path="TagTextBoxViewModel.ts" />
/// <reference path="../../../../../../External/Typescript/jquery.d.ts" />
/// <reference path="../../View/CustomBindingHandlers/fxRadio.ts" />
/// <reference path="../../View/WizardView.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var ExperimentEditor;
(function (ExperimentEditor) {
    (function (ImageSelectionMode) {
        ImageSelectionMode[ImageSelectionMode["SelectYourOwn"] = 0] = "SelectYourOwn";
        ImageSelectionMode[ImageSelectionMode["StockImageFromGallery"] = 1] = "StockImageFromGallery";
    })(ExperimentEditor.ImageSelectionMode || (ExperimentEditor.ImageSelectionMode = {}));
    var ImageSelectionMode = ExperimentEditor.ImageSelectionMode;
    var PublishToCommunityWizardViewModel = (function (_super) {
        __extends(PublishToCommunityWizardViewModel, _super);
        function PublishToCommunityWizardViewModel(experimentViewModel) {
            var _this = this;
            _super.call(this);
            this.experimentViewModel = experimentViewModel;
            this.summary = ko.observable("");
            this.description = ko.observable("");
            this.visibility = ko.observable(1 /* Public */);
            this.tags = ko.observableArray();
            this.onWizardClosingEvent = new ko.subscribable();
            this.onWizardCompleted = ko.observable(false);
            this.imageViewModel = new ExperimentEditor.ImageSelectorViewModel();
            this.uploadImageOption = ko.observable(0 /* SelectYourOwn */);
            this.hasConsented = ko.observable(false);
            this.hasConsentedCredentials = ko.observable(false);
            var originalExperimentName = experimentViewModel.experiment.description();
            this.experimentName = DataLab.Validation.validatableObservable(originalExperimentName, DataLab.Model.Experiment.validateDescription);
            // Assume the experiment name is valid right away since it comes from the experiment.
            this.experimentName.startValidating();
            this.isValid = ko.computed(function () {
                return _this.experimentName.isValid();
            });
            this.hasCredentials = experimentViewModel.experiment.firstModuleWithCredentials() ? true : false;
            this.useMarkdownEditor = !!DataLab.Features.markdownInPublishDialogEnabled();
            this.isNextStepDisabled = ko.computed(function () {
                return !_this.isValid() || _this.imageViewModel.imageUploadViewModel.isProcessingSelectedImage() || !_this.hasConsented() || _this.hasCredentials && !_this.hasConsentedCredentials();
            });
            if (DataLab.Features.experimentDescriptionEnabled()) {
                this.summary(experimentViewModel.summary.property.value());
                this.description(experimentViewModel.details.property.value());
            }
        }
        PublishToCommunityWizardViewModel.prototype.onWizardClosing = function (info) {
            this.onWizardCompleted(true);
            if (info.completed) {
                Shell.Diagnostics.Telemetry.customEvent("WizardCompleted", "PublishToCommunity");
            }
            else {
                Shell.Diagnostics.Telemetry.customEvent("WizardCanceled", "PublishToCommunity");
            }
            return true;
        };
        PublishToCommunityWizardViewModel.prototype.getPublishableExperiment = function () {
            if (!this.onWizardCompleted()) {
                throw new Error("Cannot generate a PublishableExperiment if the Publish To Community Wizard was not completed.");
            }
            else if (!this.isValid()) {
                throw new Error("Cannot generate a PublishableExperiment with validation errors still present.");
            }
            return new DataLab.Model.PublishableExperiment(this.experimentViewModel.experiment, this.experimentName(), this.summary(), this.description(), this.visibility(), this.tags(), this.imageViewModel.imageUploadViewModel.finalImageContent(), this.imageViewModel.imageUploadViewModel.finalImageContent() ? "" : this.imageViewModel.selectedStockImgUrl());
        };
        PublishToCommunityWizardViewModel.uploadImageOptions = [
            { text: DataLab.LocalizedResources.publishExperimentToCommunityWizardImageSelectionCustomImageTab, value: 0 /* SelectYourOwn */ },
            { text: DataLab.LocalizedResources.publishExperimentToCommunityWizardImageSelectionStockImagesTab, value: 1 /* StockImageFromGallery */ }
        ];
        return PublishToCommunityWizardViewModel;
    })(DataLab.Util.Disposable);
    ExperimentEditor.PublishToCommunityWizardViewModel = PublishToCommunityWizardViewModel;
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
var ExperimentEditor;
(function (ExperimentEditor) {
    var defaultOptions = {
        count: 'none',
        hashtags: 'AzureML',
    };
    function getOpenTwitterPopupCallback(url) {
        return function openTwitterPopup() {
            // pop-up window options
            var windowChromeOptions = "scrollbars=yes,resizable=yes,toolbar=no,location=yes", width = 550, height = 420, screenHeight = screen.height, screenWidth = screen.width, left = Math.round(screenWidth / 2 - width / 2), top = 0;
            if (screenHeight > height) {
                top = Math.round(screenHeight / 2 - height / 2);
            }
            var windowOptions = windowChromeOptions + ",width=" + width + ",height=" + height + ",left=" + left + ",top=" + top;
            window.open(url, 'twitter', windowOptions);
            return false;
        };
    }
    // Given the way the twitter code works, by finding the element and replacing it with an iframe, 
    // there is no easy way to support observables. This only takes into account the valueAccessor at
    // the time of initialization, whether they are observable or not.
    ko.bindingHandlers["twitterButton"] = {
        init: function (element, valueAccessor, allBindingsAccessor, targetViewModel) {
            var optionsProvided = valueAccessor();
            var options = $.extend({}, defaultOptions, optionsProvided);
            var twitterUrl = 'https://twitter.com/intent/tweet?' + DataLab.Util.param(options);
            $(element).addClass('twitter-share-button');
            $(element).attr('href', twitterUrl);
            $(element).click(getOpenTwitterPopupCallback(twitterUrl));
            var image = $("<img />").attr({
                src: "/Content/Images/sharing-twitter.svg",
                title: DataLab.LocalizedResources.twitterButtonTitle
            });
            $(element).append(image);
        }
    };
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
/// <reference path="../../View/CustomBindingHandlers/fxRadio.ts" />
/// <reference path="../../View/DialogView.ts" />
/// <reference path="../../View/CustomBindingHandlers/TwitterButton.ts" />
var ExperimentEditor;
(function (ExperimentEditor) {
    var PublishToCommunityOnCompleteViewModel = (function () {
        function PublishToCommunityOnCompleteViewModel(catalogExperimentUrl) {
            var _this = this;
            this.shouldGoToPublishedExperiment = ko.observable(false);
            this.catalogExperimentUrl = ko.observable(catalogExperimentUrl);
            this.defaultPromotionTitle = ko.observable(DataLab.LocalizedResources.publishExperimentToCommunitySharePromotionTitle);
            this.defaultPromotionText = ko.observable(DataLab.Util.format(DataLab.LocalizedResources.publishExperimentToCommunitySharePromotionText, DataLab.LocalizedResources.productNameMedium));
            this.twitterButtonOptions = ko.computed(function () {
                return {
                    url: _this.catalogExperimentUrl(),
                    text: _this.defaultPromotionText(),
                    hashtags: 'AzureML',
                    title: DataLab.LocalizedResources.publishExperimentToCommunityTwitterButtonTitle
                };
            });
            this.emailBody = ko.computed(function () {
                DataLab.Util.format;
                return _this.defaultPromotionText() + '\n\n' + _this.catalogExperimentUrl();
            });
            this.emailSubject = ko.computed(function () {
                return _this.defaultPromotionTitle();
            });
            this.emailLink = ko.computed(function () {
                return 'mailto:?' + DataLab.Util.param({
                    Subject: _this.emailSubject(),
                    Body: _this.emailBody()
                });
            });
        }
        PublishToCommunityOnCompleteViewModel.prototype.dismissed = function (result) {
            if (this.shouldGoToPublishedExperiment()) {
                Shell.UI.Spinner.show(); // Just in case navigation doesn't begin instantly.
                window.location.href = this.catalogExperimentUrl();
            }
        };
        return PublishToCommunityOnCompleteViewModel;
    })();
    ExperimentEditor.PublishToCommunityOnCompleteViewModel = PublishToCommunityOnCompleteViewModel;
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../../TypescriptLib/lodash.d.ts" />
var buttonBarId = 'wmd-button-bar', inputAreaId = 'wmd-input', previewAreaId = 'wmd-preview';
var ScorllingSource;
(function (ScorllingSource) {
    ScorllingSource[ScorllingSource["EDIT"] = 0] = "EDIT";
    ScorllingSource[ScorllingSource["PREVIEW"] = 1] = "PREVIEW";
})(ScorllingSource || (ScorllingSource = {}));
;
var ExperimentEditor;
(function (ExperimentEditor) {
    var MarkdownEditor = (function () {
        function MarkdownEditor(value, placeholder, element, idPostfix) {
            this.inPreview = ko.observable(false);
            this.value = value;
            this.placeholder = ko.observable(placeholder);
            idPostfix = idPostfix || "";
            this.buttonBarId = ko.observable(buttonBarId + idPostfix);
            this.inputAreaId = ko.observable(inputAreaId + idPostfix);
            this.previewAreaId = ko.observable(previewAreaId + idPostfix);
            this.textareaElement = $(element).find("textarea")[0];
            this.previewElement = $(element).find('.wmd-preview')[0];
            if (this.textareaElement && this.previewElement) {
                this.textareaElement.addEventListener('scroll', _.throttle(this.syncScrolling.bind(this, 0 /* EDIT */), 200));
                this.previewElement.addEventListener('scroll', _.throttle(this.syncScrolling.bind(this, 1 /* PREVIEW */), 200));
            }
            this.setupMarkdown();
        }
        MarkdownEditor.prototype.toPreview = function (previewMode) {
            this.inPreview(previewMode);
        };
        MarkdownEditor.prototype.syncScrolling = function (scorllingSource) {
            var _this = this;
            requestAnimationFrame(function () {
                var source = scorllingSource === 0 /* EDIT */ ? _this.textareaElement : _this.previewElement, previousScrollTop = scorllingSource === 0 /* EDIT */ ? _this.previousEditorScrollPosition : _this.previousPreviewScrollPosition, target = scorllingSource === 0 /* EDIT */ ? _this.previewElement : _this.textareaElement;
                var sourceScrollHeight = source.scrollHeight, sourceScrollTop = source.scrollTop, targetScrollTop, targetScrollHeight = target.scrollHeight, clientHeight = source.clientHeight;
                // at current design, source and target have the same clientHeight.
                if (sourceScrollTop !== previousScrollTop && sourceScrollHeight > clientHeight && targetScrollHeight > clientHeight) {
                    // this is a little trick. JS only use fixed number to do bit operation, so '0 | number' converts a float point number to a fixed number.
                    targetScrollTop = 0 | (sourceScrollTop / (sourceScrollHeight - clientHeight) * (targetScrollHeight - clientHeight));
                    target.scrollTop = targetScrollTop;
                    if (scorllingSource === 0 /* EDIT */) {
                        _this.previousEditorScrollPosition = sourceScrollTop;
                        _this.previousPreviewScrollPosition = targetScrollTop;
                    }
                    else {
                        _this.previousPreviewScrollPosition = sourceScrollTop;
                        _this.previousEditorScrollPosition = targetScrollTop;
                    }
                }
            });
        };
        MarkdownEditor.prototype.setupMarkdown = function () {
            var _this = this;
            this.converter = window.Markdown.getSanitizingConverter();
            //markdownExtra.setContext(markdownExtra.previewContext);
            //markdownExtra.anchorLink(this.converter);
            this.editor = new window.Markdown.Editor(this.converter, "", {
                strings: {
                    linkdialog: "<p><b>Insert Hyperlink</b></p><p>http://example.com/</p>",
                    imagedialog: "<p><b>Insert Image</b></p><p>http://example.com/images/diagram.jpg</p>",
                }
            });
            setTimeout(function () {
                _this.editor.run();
            }, 0);
        };
        return MarkdownEditor;
    })();
    ExperimentEditor.MarkdownEditor = MarkdownEditor;
    function createMarkdownEditorViewModel(params, componentInfo) {
        return new MarkdownEditor(params.value, params.placeholder, componentInfo.element, params.idPostfix || null);
    }
    ExperimentEditor.createMarkdownEditorViewModel = createMarkdownEditorViewModel;
    ExperimentEditor.markdownEditorRegisterInfo = {
        componentName: "markdown-editor",
        viewModel: { createViewModel: createMarkdownEditorViewModel },
        template: ExperimentEditor._markdownEditorMarkup
    };
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../Global.ts" />
var ExperimentEditor;
(function (ExperimentEditor) {
    var _defaultOptions = {
        canCloseWithEscape: true
    };
    // creates dialogs similar to fxDialog but without the OK and close buttons
    var StrippedDialog = (function () {
        function StrippedDialog(options) {
            if (options === void 0) { options = null; }
            this.dialog = null;
            this.options = $.extend(true, _defaultOptions, options);
        }
        StrippedDialog.prototype.show = function (data, template, size) {
            if (size === void 0) { size = null; }
            var self = this;
            var createDialog = function () {
                Shell.UI.DialogPresenter.show({
                    template: $.templates(template),
                    init: function () {
                        this.element.find('.fx-dialog-ok').css('display', 'none');
                        this.element.find('.fx-dialog-close').css('display', 'none');
                        this.element.css('padding-bottom', this.element.css('padding-top'));
                        this.element.css('min-height', '0');
                        ko.applyBindings(data, this.element.get(0));
                        self.dialog = this;
                        self.autofocus(this.element.get(0));
                        if (!self.options.canCloseWithEscape) {
                            var originalClose = this.close;
                            this.close = function (event) {
                                if (event.which !== $.ui.keyCode.ESCAPE) {
                                    originalClose.call(this, event);
                                }
                            };
                        }
                    },
                    size: size
                });
            };
            this.closeAnyActiveDialog();
            var shield = $('.fx-dialogpresenter-shield');
            // wait for animation for closing existing dialog to end before showing new one
            shield.promise().done(createDialog);
        };
        StrippedDialog.prototype.close = function (event) {
            if (event === void 0) { event = null; }
            if (this.dialog) {
                this.dialog.close(event || { preventDefault: $.noop });
            }
            this.dialog = null;
        };
        StrippedDialog.prototype.closeAnyActiveDialog = function () {
            var element = $('.fx-dialog');
            if (element.length > 0 && element.is(":data(fx-fxDialog)")) {
                var event = document.createEvent("CustomEvent");
                event.initEvent("close", true, true);
                element.fxDialog("close", event);
            }
        };
        StrippedDialog.prototype.autofocus = function (container) {
            // work-around to give starting focus priority to 'autofocus' class and buttons
            // fxDialog focuses on first tabbable element
            var wantsFocus = container.getElementsByClassName('autofocus')[0];
            var firstButton = container.getElementsByTagName('button')[0];
            var toFocus = wantsFocus || firstButton;
            if (toFocus) {
                setTimeout(function () { return toFocus.focus(); });
            }
        };
        return StrippedDialog;
    })();
    ExperimentEditor.StrippedDialog = StrippedDialog;
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
/// <reference path="../../View/StrippedDialog.ts" />
var ExperimentEditor;
(function (ExperimentEditor) {
    var Util = DataLab.Util;
    var LocalizedResources = DataLab.LocalizedResources;
    var FeatureId = DataLab.Constants.FeatureId;
    var azureSubscriptionLinkUrl = "http://go.microsoft.com/fwlink/?LinkId=524172";
    var azureMachineLearningWorkspaceLinkUrl = "http://go.microsoft.com/fwlink/?LinkId=524173";
    var signupLinkUrl = "http://go.microsoft.com/fwlink/?LinkId=524171";
    var genericDialogDataTemplate = {
        title: LocalizedResources.trialDialogDisabledFeatureTitle,
        description: [{
            text: "",
            links: [{
                text: LocalizedResources.microsoftAccount,
                url: LocalizedResources.microsoftAccountUrl
            }]
        }],
        link: {
            text: LocalizedResources.trialDialogLearnMore,
            url: LocalizedResources.trialDialogLearnMoreUrl
        }
    };
    function ILinkToHtml(link) {
        return $('<a target="_blank"></a>').attr("href", link.url).text(link.text).get(0).outerHTML;
    }
    function IParagraphToHtml(paragraph) {
        var links = paragraph.links || [];
        var linksAsHtml = links.map(ILinkToHtml);
        var formatArguments = [$('<div />').text(paragraph.text).html()].concat(linksAsHtml);
        return DataLab.Util.format.apply(null, formatArguments);
    }
    var DisabledFeatureDialog = (function () {
        function DisabledFeatureDialog(data, groupId, dialogOptions, templateMarkup) {
            var _this = this;
            if (groupId === void 0) { groupId = 0 /* None */; }
            if (dialogOptions === void 0) { dialogOptions = null; }
            if (templateMarkup === void 0) { templateMarkup = ExperimentEditor._disabledFeatureDialogMarkup; }
            this._signInFeatureId = 61 /* TrialDialogSignIn */;
            this._closeFeatureId = 62 /* TrialDialogClose */;
            this._signUpFeatureId = 67 /* TrialDialogSignUp */;
            this.signIn = function (data, event) {
                Shell.Diagnostics.Telemetry.featureUsage(_this._signInFeatureId, _this._groupId);
                window.open('/Home/Free', '_self');
            };
            this.dismiss = function (data, event) {
                Shell.Diagnostics.Telemetry.featureUsage(_this._closeFeatureId, _this._groupId);
                if (_this._dialog) {
                    _this._dialog.close(event);
                }
                ;
            };
            this.signUp = function (data, event) {
                Shell.Diagnostics.Telemetry.featureUsage(_this._signUpFeatureId, _this._groupId);
                window.open(signupLinkUrl, '_blank');
                if (_this._dialog) {
                    _this._dialog.close(event);
                }
                ;
            };
            this.title = data.title;
            this.description = data.description.map(IParagraphToHtml);
            this.link = data.link;
            this._groupId = groupId;
            this._dialog = new ExperimentEditor.StrippedDialog(dialogOptions);
            this._templateMarkup = templateMarkup;
        }
        DisabledFeatureDialog.prototype.show = function () {
            this._dialog.show(this, this._templateMarkup, ['430px', null]);
        };
        return DisabledFeatureDialog;
    })();
    function showExpiredTrialDialog() {
        var dialog = new ExperimentEditor.StrippedDialog({ canCloseWithEscape: false });
        var trialLength = DataLab.Trial.getTimeLimit();
        var data = {
            descriptionHtml: DataLab.Util.format(LocalizedResources.trialDialogExpiredTrialDescription, trialLength.toString(), DataLab.Util.format('<a href="{0}" target="_blank">{1}</a>', LocalizedResources.microsoftAccountUrl, LocalizedResources.microsoftAccount)),
            signIn: function (data, event) {
                Shell.Diagnostics.Telemetry.featureUsage(61 /* TrialDialogSignIn */, 0);
                window.open('/Home/Free', '_self');
            },
            endTrial: function (data, event) {
                Shell.Diagnostics.Telemetry.featureUsage(62 /* TrialDialogClose */, 0);
                if (dialog) {
                    dialog.close(event);
                }
                window.open('/', '_self');
            }
        };
        dialog.show(data, ExperimentEditor._expiredTrialDialogMarkup, ['450px', null]);
    }
    ExperimentEditor.showExpiredTrialDialog = showExpiredTrialDialog;
    function showDisabledFeatureDialog() {
        var data = {
            title: LocalizedResources.trialDialogDisabledFeatureTitle,
            description: [{
                text: LocalizedResources.trialDialogDisabledFeatureDescription,
                links: [{
                    text: LocalizedResources.microsoftAccount,
                    url: LocalizedResources.microsoftAccountUrl
                }]
            }],
            link: {
                text: LocalizedResources.trialDialogSeeFeatures,
                url: LocalizedResources.trialDialogSeeFeaturesUrl
            }
        };
        new DisabledFeatureDialog(data).show();
    }
    ExperimentEditor.showDisabledFeatureDialog = showDisabledFeatureDialog;
    function showDisabledDatasetUploadDialog() {
        var data = $.extend(true, genericDialogDataTemplate);
        data.description[0].text = LocalizedResources.trialDialogDisabledDatasetUploadDescription;
        new DisabledFeatureDialog(data, 59 /* DisabledDatasetUpload */).show();
    }
    ExperimentEditor.showDisabledDatasetUploadDialog = showDisabledDatasetUploadDialog;
    function showDisabledModuleUploadDialog() {
        var data = $.extend(true, genericDialogDataTemplate);
        data.description[0].text = LocalizedResources.trialDialogDisabledModuleUploadDescription;
        new DisabledFeatureDialog(data, 59 /* DisabledDatasetUpload */).show();
    }
    ExperimentEditor.showDisabledModuleUploadDialog = showDisabledModuleUploadDialog;
    function showDisabledModuleDialog(familyId, moduleName) {
        if (familyId === void 0) { familyId = null; }
        if (moduleName === void 0) { moduleName = null; }
        var data = $.extend(true, genericDialogDataTemplate);
        if (familyId) {
            // look-up the name of the module if not provided
            if (!moduleName) {
                familyId = familyId.toLowerCase();
                var matchingModule = DataLab.Workspace.applicationCache.moduleCache.getLatestResourceInFamily(familyId);
                moduleName = matchingModule && matchingModule.name();
            }
        }
        if (familyId && moduleName) {
            // show which module triggered the restriction
            var guid = familyId.slice(familyId.indexOf(".") + 1);
            data.description = [{
                text: LocalizedResources.trialDialogDisabledModuleDescriptionNamed,
                links: [{
                    text: moduleName,
                    url: ExperimentEditor.Help.getTopicUrl(Util.resurrectDashesInGUID(guid)),
                }, {
                    text: LocalizedResources.microsoftAccount,
                    url: LocalizedResources.microsoftAccountUrl
                }]
            }];
        }
        else {
            // ... or use a generic dialog if no details are available
            data.description[0].text = LocalizedResources.trialDialogDisabledModuleDescription;
        }
        new DisabledFeatureDialog(data, 58 /* DisabledModule */).show();
    }
    ExperimentEditor.showDisabledModuleDialog = showDisabledModuleDialog;
    function showDisabledWebServicePublishDialog() {
        var data = $.extend(true, genericDialogDataTemplate);
        data.description[0].text = LocalizedResources.trialDialogDisabledWebServicePublishDescription;
        new DisabledFeatureDialog(data).show();
    }
    ExperimentEditor.showDisabledWebServicePublishDialog = showDisabledWebServicePublishDialog;
    function showDisabledPublishToCommunityDialog() {
        var data = $.extend(true, genericDialogDataTemplate);
        data.description[0].text = LocalizedResources.trialDialogDisabledPublishToCommunityDescription;
        new DisabledFeatureDialog(data).show();
    }
    ExperimentEditor.showDisabledPublishToCommunityDialog = showDisabledPublishToCommunityDialog;
    function showExceededNumberOfModulesLimitDialog(value) {
        if (value === void 0) { value = null; }
        value = value || DataLab.Trial.getMaxNumberOfModules();
        var data = null;
        if (DataLab.Trial.getWorkspaceType() === 1 /* Free */) {
            data = {
                title: LocalizedResources.trialDialogOops,
                description: [
                    {
                        text: Util.format(LocalizedResources.trialDialogExceededModuleCountLimitDescriptionForFree, value.toString(), "{0}", "{1}"),
                        links: [
                            {
                                text: LocalizedResources.azureSubscription,
                                url: azureSubscriptionLinkUrl
                            },
                            {
                                text: LocalizedResources.standardWorkspace,
                                url: azureMachineLearningWorkspaceLinkUrl
                            }
                        ]
                    }
                ],
                link: {
                    text: LocalizedResources.trialDialogLearnMore,
                    url: LocalizedResources.trialDialogLearnMoreUrl
                }
            };
            new DisabledFeatureDialog(data, 60 /* ExceededModuleCountLimit */, null, ExperimentEditor._limitedFeatureDialogMarkup).show();
        }
        else {
            data = {
                title: LocalizedResources.trialDialogOops,
                description: [
                    {
                        text: Util.format(LocalizedResources.trialDialogExceededModuleCountLimitDescription, value.toString(), "{0}", "{1}"),
                        links: [
                            {
                                text: LocalizedResources.azureSubscription,
                                url: azureSubscriptionLinkUrl
                            },
                            {
                                text: LocalizedResources.standardWorkspace,
                                url: azureMachineLearningWorkspaceLinkUrl
                            }
                        ]
                    }
                ],
                link: {
                    text: LocalizedResources.trialDialogLearnMore,
                    url: LocalizedResources.trialDialogLearnMoreUrl
                }
            };
            new DisabledFeatureDialog(data, 60 /* ExceededModuleCountLimit */, null, ExperimentEditor._limitedFeatureDialogMarkup).show();
        }
    }
    ExperimentEditor.showExceededNumberOfModulesLimitDialog = showExceededNumberOfModulesLimitDialog;
    function showExceededStorageLimitDialog(value) {
        if (value === void 0) { value = null; }
        value = value || (DataLab.Trial.getStorageLimit() / Math.pow(2, 30));
        var data = {
            title: LocalizedResources.trialDialogOops,
            description: [
                {
                    text: Util.format(DataLab.Trial.isWorkspaceTypeAnonymous() ? LocalizedResources.trialDialogExceededStorageLimitDescriptionAnonymous : LocalizedResources.trialDialogExceededStorageLimitDescription, value.toFixed(0), "{0}"),
                    links: [
                        {
                            text: LocalizedResources.azureSubscription,
                            url: azureSubscriptionLinkUrl
                        }
                    ]
                }
            ],
            link: {
                text: LocalizedResources.trialDialogLearnMore,
                url: LocalizedResources.trialDialogLearnMoreUrl
            }
        };
        new DisabledFeatureDialog(data, 60 /* ExceededModuleCountLimit */, null, ExperimentEditor._limitedFeatureDialogMarkup).show();
    }
    ExperimentEditor.showExceededStorageLimitDialog = showExceededStorageLimitDialog;
    function showParallelRunDisabledDialog() {
        var data = null;
        if (DataLab.Trial.getWorkspaceType() === 1 /* Free */) {
            data = {
                title: LocalizedResources.trialDialogOops,
                description: [
                    {
                        text: LocalizedResources.trialDialogParallelRunDisabledDescriptionForFree,
                        links: [
                            {
                                text: LocalizedResources.azureSubscription,
                                url: azureSubscriptionLinkUrl
                            },
                            {
                                text: LocalizedResources.standardWorkspace,
                                url: azureMachineLearningWorkspaceLinkUrl
                            }
                        ]
                    }
                ],
                link: {
                    text: LocalizedResources.trialDialogLearnMore,
                    url: LocalizedResources.trialDialogLearnMoreUrl
                }
            };
            new DisabledFeatureDialog(data, 60 /* ExceededModuleCountLimit */, null, ExperimentEditor._limitedFeatureDialogMarkup).show();
        }
        else {
            data = {
                title: LocalizedResources.trialDialogOops,
                description: [
                    {
                        text: LocalizedResources.trialDialogParallelRunDisabledDescription,
                        links: [
                            {
                                text: LocalizedResources.microsoftAccount,
                                url: LocalizedResources.microsoftAccountUrl
                            }
                        ]
                    }
                ],
                link: {
                    text: LocalizedResources.trialDialogLearnMore,
                    url: LocalizedResources.trialDialogLearnMoreUrl
                }
            };
            new DisabledFeatureDialog(data, 65 /* ParallelRunDisabled */).show();
        }
    }
    ExperimentEditor.showParallelRunDisabledDialog = showParallelRunDisabledDialog;
    function showExceededRuntimeLimitDialog(value) {
        if (value === void 0) { value = null; }
        value = value || DataLab.Trial.getModuleRunTimeLimit();
        var data = null;
        if (DataLab.Trial.getWorkspaceType() === 1 /* Free */) {
            data = {
                title: LocalizedResources.trialDialogOops,
                description: [
                    {
                        text: Util.format(LocalizedResources.trialDialogExceededModuleRuntimeLimitDescriptionForFree, value.toString(), "{0}", "{1}"),
                        links: [
                            {
                                text: LocalizedResources.azureSubscription,
                                url: azureSubscriptionLinkUrl
                            },
                            {
                                text: LocalizedResources.standardWorkspace,
                                url: azureMachineLearningWorkspaceLinkUrl
                            }
                        ]
                    }
                ],
                link: {
                    text: LocalizedResources.trialDialogLearnMore,
                    url: LocalizedResources.trialDialogLearnMoreUrl
                }
            };
            new DisabledFeatureDialog(data, 60 /* ExceededModuleCountLimit */, null, ExperimentEditor._limitedFeatureDialogMarkup).show();
        }
        else {
            data = {
                title: LocalizedResources.trialDialogOops,
                description: [
                    {
                        text: Util.format(LocalizedResources.trialDialogExceededModuleRuntimeLimitDescription, value.toString(), "{0}"),
                        links: [
                            {
                                text: LocalizedResources.microsoftAccount,
                                url: LocalizedResources.microsoftAccountUrl
                            }
                        ]
                    }
                ],
                link: {
                    text: LocalizedResources.trialDialogLearnMore,
                    url: LocalizedResources.trialDialogLearnMoreUrl
                }
            };
            new DisabledFeatureDialog(data, 63 /* ExceededModuleRuntimeLimit */).show();
        }
    }
    ExperimentEditor.showExceededRuntimeLimitDialog = showExceededRuntimeLimitDialog;
    function tryShowDialogForTrialRestriction(error) {
        if (!(error instanceof DataLab.Util.AjaxError)) {
            return false;
        }
        var xhr = error.xmlHttpRequest;
        var restriction = new DataLab.Trial.RestrictedFeatureError(xhr);
        switch (restriction.feature) {
            case DataLab.DataContract.CancellationReason.ExceededStorageLimit:
                Shell.Diagnostics.Telemetry.featureUsage(64 /* ExceededStorageLimit */, 56 /* TrialFeature */);
                showExceededStorageLimitDialog(restriction.value);
                return true;
            case DataLab.DataContract.CancellationReason.ModulesRestriction:
                switch (restriction.type) {
                    case "MaxLimit":
                        Shell.Diagnostics.Telemetry.featureUsage(60 /* ExceededModuleCountLimit */, 56 /* TrialFeature */);
                        showExceededNumberOfModulesLimitDialog(restriction.value);
                        return true;
                    case "Value":
                        Shell.Diagnostics.Telemetry.featureUsage(58 /* DisabledModule */, 56 /* TrialFeature */);
                        var familyId = restriction.value ? (environment.globalWorkspaceId + "." + restriction.value).toLowerCase() : null;
                        showDisabledModuleDialog(familyId);
                        return true;
                    default:
                        break;
                }
                break;
            case DataLab.DataContract.CancellationReason.DatasetRestriction:
            case DataLab.DataContract.CancellationReason.CustomModulesRestriction:
            case DataLab.DataContract.CancellationReason.WebServicesRestriction:
            case DataLab.DataContract.CancellationReason.WorkspaceTypeRestriction:
                Shell.Diagnostics.Telemetry.featureUsage(66 /* DisabledFeature */, 56 /* TrialFeature */);
                showDisabledFeatureDialog();
                return true;
            default:
                break;
        }
        return false;
    }
    ExperimentEditor.tryShowDialogForTrialRestriction = tryShowDialogForTrialRestriction;
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../Typescript/Global.ts" />
/// <reference path="../Typescript/View/ExperimentEditorContainer.ts" />
/// <reference path="../Typescript/View/PublishWebServiceDialog.ts" />
/// <reference path="./WebServiceGroupView.ts" />
/// <reference path="./DataLabView.ts" />
/// <reference path="../Typescript/ViewModel/ExperimentEditor/ExperimentSaveAsViewModel.ts" />
/// <reference path="../Typescript/View/DialogViewFactories.ts" />
/// <reference path="../Typescript/ViewModel/ExperimentEditor/PublishToCommunityWizardViewModel.ts" />
/// <reference path="../Typescript/ViewModel/ExperimentEditor/PublishToCommunityOnCompleteViewModel.ts" />
/// <reference path="../Typescript/view/MarkdownEditor/MarkdownEditor.ts" />
/// <reference path="../Typescript/View/ExperimentEditorControl.ts" />
/// <reference path="../Typescript/View/WizardView.ts" />
/// <reference path="../Typescript/ViewModel/Dialogs/TrialDialogs.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var DataLabViews;
(function (DataLabViews) {
    var format = DataLab.Util.format;
    var formatDataSize = DataLab.Util.formatDataSize;
    var LocalizedResources = DataLab.LocalizedResources;
    DataLabViews.experimentExtensionName = "Experiments";
    DataLabViews.dataflowExtensionName = "Dataflows";
    DataLabViews.webServiceGroupExtensionName = "WebServiceGroups";
    // Azure FX decomposes hash locations as #Workspaces/{extension}/({type}/{id})+/{view}
    // Here we define an Experiment type so that we can link to them by ID. It is registered with the call to
    // Exp.TypeRegistry.add below.
    DataLabViews.ExperimentType = {
        name: "Experiment",
        displayName: "Experiment",
        dataFunction: function (dataRequest, path, dataSet) {
            // dataRequest is of the form {type: id}. In this case we do not expect any nesting.
            // Note that although the request suggests we want e.g. {Experiment: '123abc'}, we are
            // expected to return all sibling data as well.
            // For now, pretend that the requested experiment is the only one (since we don't have the real data here).
            return {
                data: [{ name: dataRequest.Experiment, displayName: dataRequest.Experiment }]
            };
        },
        draftExperimentId: "Draft",
    };
    DataLabViews.ExperimentLineageType = {
        name: "ExperimentLineage",
        displayName: "Run History",
        dataFunction: function (dataRequest, path, dataSet) {
            // dataRequest is of the form {type: id}. In this case we do not expect any nesting.
            // Note that although the request suggests we want e.g. {Experiment: '123abc'}, we are
            // expected to return all sibling data as well.
            // For now, pretend that the requested experiment is the only one (since we don't have the real data here).
            return {
                data: [{ name: dataRequest.ExperimentLineage, displayName: dataRequest.ExperimentLineage }]
            };
        }
    };
    DataLabViews.DataflowType = {
        name: "Dataflow",
        displayName: "Dataflow",
        dataFunction: function (dataRequest, path, dataSet) {
            // dataRequest is of the form {type: id}. In this case we do not expect any nesting.
            // Note that although the request suggests we want e.g. {Experiment: '123abc'}, we are
            // expected to return all sibling data as well.
            // For now, pretend that the requested experiment is the only one (since we don't have the real data here).
            return {
                data: [{ name: dataRequest.Dataflow, displayName: dataRequest.Dataflow }]
            };
        }
    };
    function navigateToExperiment(experimentId) {
        Shell.UI.Navigation.navigate({
            extension: DataLabViews.experimentExtensionName,
            type: DataLabViews.ExperimentType.name,
            name: experimentId,
        });
    }
    DataLabViews.navigateToExperiment = navigateToExperiment;
    function navigateToExperimentLineage(experimentId) {
        Shell.UI.Navigation.navigate({
            extension: DataLabViews.experimentExtensionName,
            type: DataLabViews.ExperimentLineageType.name,
            name: experimentId
        });
    }
    DataLabViews.navigateToExperimentLineage = navigateToExperimentLineage;
    function navigateToDataflow(dataflowId) {
        Shell.UI.Navigation.navigate({
            extension: DataLabViews.dataflowExtensionName,
            type: DataLabViews.DataflowType.name,
            name: dataflowId
        });
    }
    DataLabViews.navigateToDataflow = navigateToDataflow;
    function navigateToWebService(webServiceGroupId) {
        Shell.UI.Navigation.navigate({
            extension: DataLabViews.webServiceGroupExtensionName,
            type: DataLabViews.WebServiceGroupType.name,
            name: webServiceGroupId
        });
    }
    DataLabViews.navigateToWebService = navigateToWebService;
    var ExperimentView = (function (_super) {
        __extends(ExperimentView, _super);
        function ExperimentView(renderArea, experimentId, workspace) {
            var _this = this;
            _super.call(this, DataLabViews.experimentExtensionName);
            this.notifications = [];
            DataLab.Log.info("Opening the experiment viewer", "ExperimentView", experimentId);
            this._renderArea = renderArea;
            // When submitting or refreshing an experiment, disable commands until action is done.
            this.commandsDisabled = ko.observable(false);
            var rootExperimentContainer = document.querySelector("#ExperimentEditor");
            this.registerForDisposal(this.xeViewModel = new ExperimentEditor.ExperimentEditorContainerViewModel(workspace, {
                loadFromService: function (id) {
                    return workspace.getExperimentAsync(id);
                }
            }, experimentId === DataLabViews.ExperimentType.draftExperimentId ? null : experimentId), this.xeControlContainer = new ExperimentEditor.ExperimentEditorContainer(rootExperimentContainer, this.xeViewModel));
            // Set up the ability for the container view model to send us alerts.
            this.xeViewModel.registerAlertHandler(function (message) {
                var errorNotification = new Shell.UI.Notifications.Notification(message, "error");
                _this.addNotification(errorNotification);
                errorNotification.setActions([Shell.UI.Notifications.Buttons.close(function () {
                    DataLab.Util.removeElementFromArray(_this.notifications, errorNotification);
                })]);
            });
            this.xeViewModel.registerOutputPromotionProgressHandler(function (promise) {
                // 'true' here marks the operation as indeterminate (i.e. we don't set percentage)
                var progress = new Shell.UI.Notifications.Progress(DataLab.LocalizedResources.promotionSavingIntermediateOutput, "active", true);
                _this.addNotification(progress);
                promise.done(function (resource) {
                    progress.setTitle("Output saved as '" + resource.name() + "'.");
                    progress.setStatus("success");
                    progress.setActions([Shell.UI.Notifications.Buttons.close(function () {
                        DataLab.Util.removeElementFromArray(_this.notifications, progress);
                    })]);
                }).fail(function (failureInfo) {
                    if (DataLab.Features.trialLimitationsEnabled() && ExperimentEditor.tryShowDialogForTrialRestriction(failureInfo)) {
                        DataLab.Util.removeElementFromArray(_this.notifications, progress);
                        Shell.UI.Notifications.remove(progress);
                        return;
                    }
                    progress.setTitle("Saving intermediate output failed. " + failureInfo.xmlHttpRequest.responseText);
                    progress.setStatus("error");
                    progress.setActions([Shell.UI.Notifications.Buttons.close(function () {
                        DataLab.Util.removeElementFromArray(_this.notifications, progress);
                    })]);
                });
            });
            this.xeViewModel.registerNavigateToParentHandler(function (parentExperimentId) {
                if (parentExperimentId) {
                    navigateToExperiment(parentExperimentId);
                }
            });
            this.xeViewModel.registerNavigateToWebServiceHandler(function (webServiceGroupId) {
                if (webServiceGroupId) {
                    navigateToWebService(webServiceGroupId);
                }
            });
            var preventBackspaceNavigation = function (event) {
                if (_this.upgradeNotificationOpen && event.which === 8) {
                    event.preventDefault();
                }
            };
            this.xeViewModel.registerNodeUpgradeEligibilityHandler(function () {
                var confirmation = new Shell.UI.Notifications.Confirmation(DataLab.LocalizedResources.autoUpgradeModulesAndDatasets, 'active');
                var currentExperiment = _this.xeViewModel.experiment;
                _this.upgradeNotificationOpen = true;
                var unloadFunction = function () {
                    Shell.UI.Notifications.remove(confirmation);
                };
                confirmation.setActions([
                    new Shell.UI.Notifications.Buttons.ok(function () {
                        if (currentExperiment === _this.xeViewModel.experiment) {
                            currentExperiment.upgradeNodes(workspace.moduleCache, workspace.datasetCache, workspace.trainedModelCache, workspace.transformModules, workspace);
                        }
                        _this.upgradeNotificationOpen = false;
                        DataLab.Util.removeElementFromArray(_this.notifications, confirmation);
                        Shell.Diagnostics.Telemetry.featureUsage(1 /* Upgrade_Yes */, 0, workspace.id, _this.xeViewModel.experiment.experimentId(), null, null);
                    })
                ]);
                _this.addNotification(confirmation);
                Shell.Diagnostics.Telemetry.customEvent("Upgrade_Popup", "Experiment", JSON.stringify(_this.xeViewModel.experiment.experimentId()));
                $(document).on("keydown", preventBackspaceNavigation);
            });
            this.xeViewModel.registerCannotSaveDraftHandler(function (message) {
                var confirmation = new Shell.UI.Notifications.Confirmation(message, 'active');
                confirmation.setActions([new Shell.UI.Notifications.Buttons.ok(function () {
                    DataLab.Util.removeElementFromArray(_this.notifications, confirmation);
                })]);
                _this.addNotification(confirmation);
            });
            // Keep the experiment's description in sync with the sidebar
            this._updateSidebarTitle(this.xeViewModel.experiment.description());
            this.registerForDisposal(this.descriptionSubscription = new DataLab.Util.DisposableSubscription(this.xeViewModel.experiment.description.subscribe(function () {
                _this._updateSidebarTitle(_this.xeViewModel.experiment.description());
            })), new DataLab.Util.DisposableSubscription(this.xeViewModel.experimentEditorViewModel.newExperimentLoaded.subscribe(function () {
                _this._updateSidebarTitle(_this.xeViewModel.experiment.description());
                _this.descriptionSubscription.dispose();
                _this.registerForDisposal(_this.descriptionSubscription = new DataLab.Util.DisposableSubscription(_this.xeViewModel.experiment.description.subscribe(function () {
                    _this._updateSidebarTitle(_this.xeViewModel.experiment.description());
                })));
            })));
            this.createScoreGraphOperation = new ExperimentEditor.CreateScoringGraphOperation(this.xeViewModel, this.xeControlContainer);
            this.updateScoreGraphOperation = new ExperimentEditor.UpdateScoringGraphOperation(this.xeViewModel);
            this.xeViewModel.onRefreshFromNewExperiment = function (oldExperiment, newExperiment) {
                if ((oldExperiment.statusCode() === DataLab.DataContract.State.Running || oldExperiment.statusCode() === DataLab.DataContract.State.NotStarted) && newExperiment.statusCode() === DataLab.DataContract.State.Finished) {
                    if (_this.updateScoreGraphOperation.isEnabled()) {
                        ExperimentEditor.GuideTours.showUpdatingScoringGraphCommandTour();
                    }
                    else if (_this.createScoreGraphOperation.isEnabled()) {
                        ExperimentEditor.GuideTours.showCreatingScoringGraphCommandTour();
                    }
                    else if (_this.xeViewModel.experiment.isWebServiceExperiment()) {
                        ExperimentEditor.GuideTours.showPublishWebServiceCommandTour();
                    }
                }
            };
            this.prepareWebServiceOperation = new ExperimentEditor.PrepareWebServiceOperation(this.xeViewModel, this.xeControlContainer);
            this.upgradeNotificationOpen = false;
            $(window).on("hashchange", function () {
                _this.removeNotifications();
                $(document).unbind("keydown", preventBackspaceNavigation);
                _this.upgradeNotificationOpen = false;
            });
            // Set this view as the target of contextual commands (e.g. submit)
            cdm.setActiveItem(this);
            // Hide the page title (populated by AzureFX)
            var itemTitle = document.querySelector("#tabcontainer .itemtitle")
            if(itemTitle) {
                itemTitle.textContent = "";
            }
        }
        ExperimentView.prototype.addNotification = function (notification) {
            this.notifications.push(notification);
            Shell.UI.Notifications.add(notification);
        };
        ExperimentView.prototype.removeNotifications = function () {
            this.notifications.forEach(function (notification) {
                Shell.UI.Notifications.remove(notification);
            });
        };
        // Validate experiment, return true if experiment has no validation errors.
        ExperimentView.prototype.validateExperiment = function () {
            var _this = this;
            // Run validation on experiment
            var validationResults = this.xeViewModel.validate();
            // If the experiment is already displaying its error, we're done.
            if (!validationResults.valid && validationResults.unhandledErrors.length !== validationResults.allErrors.length) {
                return false;
            }
            else if (validationResults.unhandledErrors.length > 0) {
                if (validationResults.unhandledErrors[0].errorMessages.length > 0) {
                    var errorNotification = new Shell.UI.Notifications.Confirmation(validationResults.unhandledErrors[0].errorMessages[0], 'active');
                    Shell.Diagnostics.Telemetry.customEvent("validateExperiment", "ErrorNotification", validationResults.unhandledErrors[0].errorMessages[0]);
                    errorNotification.setActions([Shell.UI.Notifications.Buttons.close(function () {
                        DataLab.Util.removeElementFromArray(_this.notifications, errorNotification);
                    })]);
                    this.addNotification(errorNotification);
                }
                else {
                    DataLab.Log.error("Encountered an IObjectError with no error message");
                }
                return false;
            }
            return true;
        };
        ExperimentView.prototype.publish = function () {
            var _this = this;
            // TODO: TFS#1206453 add navigateToPublishedExperiment
            DataLab.Log.info("Publishing experiment", "ExperimentView:publish", this.xeViewModel.experiment.experimentId());
            Shell.Diagnostics.Telemetry.featureUsage(6 /* PublishDataflow */, 15 /* Settings */, this.xeViewModel.workspace.id, this.xeViewModel.experimentId(), null, null);
            var location = window.location.hash;
            if (this.validateExperiment()) {
                this.commandsDisabled(true);
                // Only try to save before publishing if the experiment is a draft.
                var savePromise = this.xeViewModel.experiment.isDraft() ? this.xeViewModel.save() : DataLab.Util.when();
                savePromise.done(function () {
                    _this.xeViewModel.publish().done(function (dataflowId) {
                        _this.xeViewModel.experimentEditorViewModel.rememberExperimentPosition(dataflowId);
                        Shell.Diagnostics.Telemetry.customEvent("PublishAsDataflow", "ShellUICommands");
                        // Since submission is async and may have taken a while, we should only show the submitted experiment
                        // if the user has not already navigated elsewhere.
                        if (window.location.hash === location) {
                            navigateToDataflow(dataflowId);
                        }
                        _this.commandsDisabled(false);
                    }).fail(function (value) {
                        if (value === "CredentialValidationSUO6") {
                        }
                        else {
                            var errorNotification = new Shell.UI.Notifications.Notification(DataLab.Util.format(DataLab.LocalizedResources.publishFailed, value.xmlHttpRequest.responseText), "error");
                            errorNotification.setActions([Shell.UI.Notifications.Buttons.close(function () {
                                DataLab.Util.removeElementFromArray(_this.notifications, errorNotification);
                            })]);
                            _this.addNotification(errorNotification);
                            Shell.Diagnostics.Telemetry.customEvent("PublishAsDataflow_Failed", "ShellUICommands");
                        }
                        _this.commandsDisabled(false);
                    });
                });
            }
        };
        ExperimentView.prototype.submit = function () {
            var _this = this;
            DataLab.Log.info("Submitting experiment", "ExperimentView:submit", this.xeViewModel.experiment.experimentId());
            var location = window.location.hash;
            if (this.validateExperiment()) {
                if (this.xeViewModel.experiment.statusCode() !== DataLab.DataContract.State.InDraft) {
                    this.xeViewModel.clone(true);
                }
                this.commandsDisabled(true);
                Shell.Diagnostics.Telemetry.featureUsage(4 /* Run */, 3 /* ShellUICommands */, this.xeViewModel.workspace.id, this.xeViewModel.experimentId(), null, null);
                Shell.UI.Spinner.show();
                this.xeViewModel.submit().done(function (result) {
                    _this.xeViewModel.experiment.setDraftState(false);
                    _this.xeViewModel.experimentEditorViewModel.rememberExperimentPosition(result.ExperimentId);
                    // Since submission is async and may have taken a while, we should only show the submitted experiment
                    // if the user has not already navigated elsewhere.
                    if (window.location.hash === location) {
                        DataLabViews.navigateToExperiment(result.ExperimentId);
                    }
                    _this.commandsDisabled(false);
                }).fail(function (err) {
                    var isTrialRestrictionError = false;
                    if (DataLab.Features.trialLimitationsEnabled()) {
                        isTrialRestrictionError = ExperimentEditor.tryShowDialogForTrialRestriction(err);
                    }
                    // If submission failed due to an etag conflict, DraftStateMachine will show a notification.
                    if (err.xmlHttpRequest.status !== 412 && !isTrialRestrictionError) {
                        // Messages come as <error message>Request ID:<id info>. We want to strip the Request ID information to put before the message so that it
                        // fits on the notification bar.
                        var submissionErrorRegExp = DataLab.Constants.ExperimentSubmissionFailedRegExp;
                        var requestIdText = "";
                        var errorText = err.xmlHttpRequest.responseText;
                        var fullErrorMessage = "";
                        if (submissionErrorRegExp.test(err.xmlHttpRequest.responseText)) {
                            var matchArray = err.xmlHttpRequest.responseText.match(submissionErrorRegExp);
                            errorText = matchArray[1];
                            requestIdText = matchArray[2];
                        }
                        if (requestIdText === "") {
                            fullErrorMessage = DataLab.Util.format(DataLab.LocalizedResources.experimentSubmissionFailedNoRequestId, errorText);
                        }
                        else {
                            fullErrorMessage = DataLab.Util.format(DataLab.LocalizedResources.experimentSubmissionFailedWithRequestId, requestIdText, errorText);
                        }
                        var errorNotification = new Shell.UI.Notifications.Notification(fullErrorMessage, "error");
                        errorNotification.setActions([Shell.UI.Notifications.Buttons.close(function () {
                            DataLab.Util.removeElementFromArray(_this.notifications, errorNotification);
                        })]);
                        _this.addNotification(errorNotification);
                        Shell.Diagnostics.Telemetry.customEvent("ExperimentSubmission_Failed", "ShellUICommands");
                    }
                    _this.xeViewModel.experiment.setDraftState(true);
                    _this.commandsDisabled(false);
                }).always(function () {
                    Shell.UI.Spinner.hide();
                });
            }
        };
        ExperimentView.prototype.createScoringGraphCommand = function () {
            this.updateScoreGraphOperation.initialize(this.xeViewModel);
            if (this.updateScoreGraphOperation.isUpdatable()) {
                this.updateScoreGraphOperation.runAsync();
            }
            else {
                this.createScoreGraphOperation.initialize(this.xeViewModel, this.xeControlContainer);
                this.createScoreGraphOperation.runAsync();
            }
        };
        ExperimentView.prototype.prepareWebServiceCommand = function () {
            this.prepareWebServiceOperation.initialize(this.xeViewModel, this.xeControlContainer);
            this.prepareWebServiceOperation.runAsync();
        };
        ExperimentView.prototype.handlePublishWebServiceCommand = function () {
            var _this = this;
            if (!DataLab.Trial.isWebServicePublishEnabled()) {
                Shell.Diagnostics.Telemetry.featureUsage(57 /* DisabledWebServicePublish */, 56 /* TrialFeature */, this.xeViewModel.workspace.id, this.xeViewModel.experimentId(), null, null);
                ExperimentEditor.showDisabledWebServicePublishDialog();
                return;
            }
            var needConfirmation = true;
            var experiment = this.xeViewModel.experiment;
            // TODO: Uncomment this when we do #2786002	[SCORE] Complete Scoring Improvements
            //if (experiment.containsTrainingModule()) {
            //    var errorMessage = DataLab.LocalizedResources.publishWebServiceWithTrainedModelWarning;
            //    var errorNotification = new Shell.UI.Notifications.Notification(errorMessage, "error");
            //    errorNotification.setActions([Shell.UI.Notifications.Buttons.close()]);
            //    Shell.UI.Notifications.add(errorNotification);
            //    Shell.Diagnostics.Telemetry.customEvent("PublishWebService_Error", "ShellUICommands", errorMessage);
            //    return;
            //}
            if (!experiment.allowPublish()) {
                var errorMessage = DataLab.LocalizedResources.cannotPublishDirtyExperiment;
                var errorNotification = new Shell.UI.Notifications.Notification(errorMessage, "error");
                errorNotification.setActions([Shell.UI.Notifications.Buttons.close()]);
                Shell.UI.Notifications.add(errorNotification);
                Shell.Diagnostics.Telemetry.customEvent("PublishWebService_Error", "ShellUICommands", errorMessage);
                return;
            }
            else if (experiment.getPublishInputPorts().length === 1 && experiment.getPublishInputPorts().length === 1) {
                needConfirmation = false;
            }
            if (needConfirmation) {
                var confirmMessage = DataLab.LocalizedResources.confirmPublishWithoutPorts;
                var confirmation = new Shell.UI.Notifications.Confirmation(confirmMessage, 'active');
                confirmation.setActions([
                    new Shell.UI.Notifications.Buttons.yes(function () {
                        Shell.UI.Notifications.remove(confirmation);
                        _this.launchPublishWebServiceDialog();
                        Shell.Diagnostics.Telemetry.customEvent("PublishWebService_Yes", "ShellUICommands");
                    }),
                    new Shell.UI.Notifications.Buttons.no(function () {
                        Shell.UI.Notifications.remove(confirmation);
                        Shell.Diagnostics.Telemetry.customEvent("PublishWebService_No", "ShellUICommands");
                    })
                ]);
                Shell.UI.Notifications.add(confirmation);
            }
            else {
                if (!experiment.validatePortsForPublishAndSetSubgraph()) {
                    var errorMessage = DataLab.LocalizedResources.cannotPublishInvalidPublishPorts;
                    var errorNotification = new Shell.UI.Notifications.Notification(errorMessage, "error");
                    errorNotification.setActions([Shell.UI.Notifications.Buttons.close()]);
                    Shell.UI.Notifications.add(errorNotification);
                    Shell.Diagnostics.Telemetry.customEvent("PublishWebService_Error", "ShellUICommands", errorMessage);
                    return;
                }
                else {
                    this.launchPublishWebServiceDialog();
                    Shell.Diagnostics.Telemetry.customEvent("PublishWebService", "ShellUICommands");
                }
            }
        };
        ExperimentView.prototype.launchPublishWebServiceDialog = function () {
            var _this = this;
            var webServiceGroupId = this.xeViewModel.experiment.publishedWebServiceGroupId;
            if (webServiceGroupId) {
                // the experiment family has been published before, prompt to overwrite
                return DataLab.Util.then(this.xeViewModel.workspace.getWebServiceGroupAsync(webServiceGroupId), function (webServiceGroup) {
                    var confirmation = new Shell.UI.Notifications.Confirmation(DataLab.Util.format(DataLab.LocalizedResources.publishWebServiceOverwritingConfirmationTitle, webServiceGroup.Name), 'active');
                    confirmation.setDetailsText(DataLab.LocalizedResources.publishWebServiceOverwritingConfirmationDetails);
                    confirmation.setActions([
                        new Shell.UI.Notifications.Buttons.yes(function () {
                            _this.republishWebService(webServiceGroupId, webServiceGroup.StagingWebService.Id);
                            DataLab.Util.removeElementFromArray(_this.notifications, confirmation);
                            Shell.Diagnostics.Telemetry.customEvent("PublishWebServiceLaunchDialogOverwritingService_Yes", "ShellUICommands");
                            Shell.Diagnostics.Telemetry.featureUsage(7 /* RepublishWebService */, 3 /* ShellUICommands */, _this.xeViewModel.workspace.id, _this.xeViewModel.experimentId(), null, null);
                        }),
                        new Shell.UI.Notifications.Buttons.no(function () {
                            Shell.UI.Notifications.remove(confirmation);
                            DataLab.Util.removeElementFromArray(_this.notifications, confirmation);
                            Shell.Diagnostics.Telemetry.customEvent("PublishWebServiceLaunchDialogOverwritingService_No", "ShellUICommands");
                        })
                    ]);
                    _this.addNotification(confirmation);
                });
            }
            else {
                // the experiment family has never been published before
                this.firstTimePublishWebService(this.xeViewModel.experiment.description());
                Shell.Diagnostics.Telemetry.featureUsage(5 /* PublishWebService */, 3 /* ShellUICommands */, this.xeViewModel.workspace.id, this.xeViewModel.experimentId(), null, null);
            }
        };
        ExperimentView.prototype.firstTimePublishWebService = function (webServiceGroupName) {
            var _this = this;
            Shell.UI.Spinner.show();
            return this.xeViewModel.firstTimePublishWebService(webServiceGroupName).done(function (webServiceGroupId, modelPackageId, webServiceId) {
                navigateToWebService(webServiceGroupId);
            }).fail(function (error) {
                _this.showErrorNotification(DataLab.LocalizedResources.publishWebServiceErrorConfirmationTitle, error.message);
            }).always(function () {
                Shell.UI.Spinner.hide();
            });
        };
        ExperimentView.prototype.republishWebService = function (webServiceGroupId, webServiceId) {
            var _this = this;
            Shell.UI.Spinner.show();
            return this.xeViewModel.republishWebService(webServiceGroupId, webServiceId).done(function (mpId) {
                navigateToWebService(webServiceGroupId);
            }).fail(function (error) {
                _this.showErrorNotification(DataLab.LocalizedResources.publishWebServiceErrorConfirmationTitle, error.message);
            }).always(function () {
                Shell.UI.Spinner.hide();
            });
        };
        ExperimentView.prototype.handlePublishToCommunityCommand = function () {
            if (!DataLab.Trial.isPublishToCommunityEnabled()) {
                Shell.Diagnostics.Telemetry.featureUsage(104 /* DisabledPublishToCommunity */, 56 /* TrialFeature */, this.xeViewModel.workspace.id, this.xeViewModel.experimentId(), null, null);
                ExperimentEditor.showDisabledPublishToCommunityDialog();
                return;
            }
            var experiment = this.xeViewModel.experiment;
            var errorMessage = null, errorTitle;
            var moduleBlockingPublishing;
            var spaceUsed = experiment.storageUsedByDatasets;
            if (moduleBlockingPublishing = experiment.firstCustomModule()) {
                var errorTitleFormatString = DataLab.LocalizedResources.publishExperimentToCommunityValidationError_CustomModule_Title;
                errorTitle = DataLab.Util.format(errorTitleFormatString, moduleBlockingPublishing.name);
                errorMessage = DataLab.LocalizedResources.publishExperimentToCommunityValidationError_CustomModule_Message;
                Shell.Diagnostics.Telemetry.customEvent("PublishExperimentToCommunity_ValidationError", "ShellUICommands", errorTitle + " " + errorMessage);
            }
            else if (environment.communityDatasetStorageLimit > 0 && spaceUsed > environment.communityDatasetStorageLimit) {
                errorTitle = format(LocalizedResources.publishExperimentToCommunityValidationError_LargeDataset_Title, formatDataSize(environment.communityDatasetStorageLimit));
                Shell.Diagnostics.Telemetry.customEvent("PublishExperimentToCommunity_DatasetsValidationError", "ShellUICommands", errorTitle);
            }
            else if (!experiment.allowPublish()) {
                errorTitle = errorMessage = DataLab.LocalizedResources.cannotPublishDirtyExperiment;
                Shell.Diagnostics.Telemetry.customEvent("PublishExperimentToCommunity_DirtyError", "ShellUICommands", errorMessage);
            }
            else {
                this.launchPublishToCommunityDialog();
                Shell.Diagnostics.Telemetry.featureUsage(54 /* PublishToCommunity */, 3 /* ShellUICommands */, this.xeViewModel.workspace.id, this.xeViewModel.experimentId(), null, null);
                Shell.Diagnostics.Telemetry.customEvent("PublishExperimentToCommunity", "ShellUICommands");
            }
            if (errorTitle) {
                this.showErrorNotification(errorTitle, errorMessage);
            }
        };
        ExperimentView.prototype.launchPublishToCommunityDialog = function () {
            var _this = this;
            this.commandsDisabled(true);
            // We're dependent on the TagTextBox template
            DataLab.Util.initializeTemplateIfNecessary('TagTextBox', ExperimentEditor._tagTextBoxMarkup);
            var publishToCommunityWizardViewModel = new ExperimentEditor.PublishToCommunityWizardViewModel(this.xeViewModel.experimentEditorViewModel.experimentViewModel());
            var step1 = new $.fxs.fxsWizard.WizardStep();
            step1.contentTemplateOptions({
                name: DataLab.Util.initializeTemplateIfNecessary('PublishToCommunityStep1Template', ExperimentEditor._publishToCommunityStep1Markup, DataLab.Features.markdownInPublishDialogEnabled() && [ExperimentEditor.markdownEditorRegisterInfo]),
                data: publishToCommunityWizardViewModel
            });
            step1.title(DataLab.LocalizedResources.publishExperimentToCommunityWizardTitle);
            var step2 = new $.fxs.fxsWizard.WizardStep();
            step2.contentTemplateOptions({
                name: DataLab.Util.initializeTemplateIfNecessary('PublishToCommunityStep2Template', ExperimentEditor._publishToCommunityStep2Markup),
                data: publishToCommunityWizardViewModel
            });
            step2.title(DataLab.LocalizedResources.publishExperimentToCommunityWizardImageSelectionTitle);
            var steps = [step1, step2];
            var options = { size: [680, 725] };
            var wizardView = new ExperimentEditor.WizardView(publishToCommunityWizardViewModel, steps, options);
            wizardView.onWizardClosingEvent.subscribe(function (closeInfo) {
                if (closeInfo.completed) {
                    var publishableExperiment = publishToCommunityWizardViewModel.getPublishableExperiment();
                    _this.firstTimePublishToCommunity(publishableExperiment).always(function () { return _this.commandsDisabled(false); });
                }
                else {
                    _this.commandsDisabled(false);
                }
            });
            wizardView.show();
        };
        ExperimentView.prototype.onPublishToCommunityComplete = function (catalogExperimentUrl) {
            var dialogViewModel = new ExperimentEditor.PublishToCommunityOnCompleteViewModel(catalogExperimentUrl);
            ExperimentEditor.DialogViews.PublishToCommunityStepOnComplete.show(dialogViewModel);
        };
        ExperimentView.prototype.firstTimePublishToCommunity = function (publishableExperiment) {
            var _this = this;
            Shell.UI.Spinner.show();
            return DataLab.Util.then(this.xeViewModel.firstTimePublishExperimentToCommunity(publishableExperiment).always(function () {
                Shell.UI.Spinner.hide();
            }), function (catalogExperimentUrl) {
                catalogExperimentUrl = JSON.parse(catalogExperimentUrl);
                return _this.onPublishToCommunityComplete(catalogExperimentUrl);
            }).fail(function (error) {
                // this can't go in the DataLab.Util.then above as the fail callback, b/c that won't opt out of failure.
                _this.showErrorNotification(DataLab.LocalizedResources.publishExperimentToCommunityErrorTitle, error.message);
            });
        };
        ExperimentView.prototype.save = function () {
            var _this = this;
            this.commandsDisabled(true);
            Shell.Diagnostics.Telemetry.featureUsage(8 /* Save */, 3 /* ShellUICommands */, this.xeViewModel.workspace.id, this.xeViewModel.experimentId(), null, null);
            this.xeViewModel.save().fail(function (err) {
                if (DataLab.Features.trialLimitationsEnabled()) {
                    ExperimentEditor.tryShowDialogForTrialRestriction(err);
                }
            }).always(function () {
                _this.commandsDisabled(false);
            });
        };
        ExperimentView.prototype.confirmDiscard = function () {
            var _this = this;
            var confirmation = new Shell.UI.Notifications.Confirmation(DataLab.LocalizedResources.discardDraftAreYouSureQuestion, 'active');
            confirmation.setActions([
                new Shell.UI.Notifications.Buttons.yes(function () {
                    _this.discard();
                    DataLab.Util.removeElementFromArray(_this.notifications, confirmation);
                    Shell.Diagnostics.Telemetry.featureUsage(10 /* Discard_PressedYes */, 3 /* ShellUICommands */, _this.xeViewModel.workspace.id, _this.xeViewModel.experimentId(), null, null);
                }),
                new Shell.UI.Notifications.Buttons.no(function () {
                    Shell.UI.Notifications.remove(confirmation);
                    DataLab.Util.removeElementFromArray(_this.notifications, confirmation);
                    Shell.Diagnostics.Telemetry.featureUsage(11 /* Discard_PressedNo */, 3 /* ShellUICommands */, _this.xeViewModel.workspace.id, _this.xeViewModel.experimentId(), null, null);
                })
            ]);
            this.addNotification(confirmation);
        };
        ExperimentView.prototype.discard = function () {
            var _this = this;
            DataLab.Log.info("Discarding the experiment draft", "ExperimentView:discard", this.xeViewModel.experiment.experimentId());
            this.commandsDisabled(true);
            Shell.Diagnostics.Telemetry.customEvent("Discard", "ShellUICommands");
            this.xeViewModel.discard().done(function () {
                if (_this.xeViewModel.experiment.parentExperimentId) {
                    Shell.UI.Spinner.show();
                    DataLab.Util.then(_this.xeViewModel.workspace.getExperimentAsync(_this.xeViewModel.experiment.parentExperimentId), function (parentExperiment) {
                        _this.xeViewModel.navigateToParent();
                        Shell.UI.Spinner.hide();
                    });
                }
                else {
                    Shell.UI.Navigation.navigate({
                        extension: DataLabViews.experimentExtensionName
                    });
                }
            }).always(function () {
                _this.commandsDisabled(false);
            });
        };
        ExperimentView.prototype.saveAs = function () {
            var _this = this;
            this.commandsDisabled(true);
            var saveAsName = ko.observable(null);
            var viewModel = new ExperimentEditor.ExperimentSaveAs.ExperimentSaveAsViewModel(saveAsName, this.xeViewModel.experimentEditorViewModel.experimentViewModel().experiment.description());
            ExperimentEditor.CustomUX.open(ExperimentEditor._experimentSaveAsMarkup, viewModel, "206px", "600px", function () {
                _this.commandsDisabled(false);
            });
            saveAsName.subscribe(function () {
                if (saveAsName()) {
                    _this.xeViewModel.copy(saveAsName());
                    _this.commandsDisabled(true);
                    _this.xeViewModel.save().fail(function (err) {
                        if (DataLab.Features.trialLimitationsEnabled()) {
                            ExperimentEditor.tryShowDialogForTrialRestriction(err);
                        }
                    }).always(function () {
                        _this.commandsDisabled(false);
                    });
                    Shell.Diagnostics.Telemetry.featureUsage(9 /* SaveAs */, 3 /* ShellUICommands */, _this.xeViewModel.workspace.id, _this.xeViewModel.experimentId(), null, null);
                }
            });
        };
        ExperimentView.prototype.cancel = function () {
            var _this = this;
            this.commandsDisabled(true);
            Shell.Diagnostics.Telemetry.featureUsage(12 /* Cancel */, 3 /* ShellUICommands */, this.xeViewModel.workspace.id, this.xeViewModel.experimentId(), null, null);
            this.xeViewModel.cancel().done(function () {
                _this.xeViewModel.refreshExperiment().done(function () {
                    _this.commandsDisabled(false);
                });
            });
        };
        ExperimentView.prototype.refresh = function () {
            var _this = this;
            var promise = this.xeViewModel.refreshExperiment();
            this.commandsDisabled(true);
            Shell.Diagnostics.Telemetry.featureUsage(13 /* Refresh */, 3 /* ShellUICommands */, this.xeViewModel.workspace.id, this.xeViewModel.experimentId(), null, null);
            // Failure of refresh should not leave commands disabled.
            promise.always(function () {
                // Set this view as the target of contextual commands (e.g. submit)
                if (_this.isViewExtensionStillActive() && cdm.getActiveItem() !== _this) {
                    cdm.setActiveItem(_this);
                }
                _this.commandsDisabled(false);
            });
        };
        ExperimentView.prototype.open = function () {
            var _this = this;
            this.xeViewModel.startAutoRefresh();
            var promise = this.xeViewModel.loadFromService();
            Shell.UI.Spinner.show();
            this.commandsDisabled(true);
            promise.done(function () {
                if (_this.isViewExtensionStillActive()) {
                    _this.xeControlContainer.zoomToFitIfSample();
                    Shell.UI.Spinner.hide();
                    _this.xeViewModel.experimentEditorViewModel.experimentViewModel().experimentLoaded(true);
                    // Set this view as the target of contextual commands (e.g. submit)
                    cdm.setActiveItem(_this);
                    if (window.newExperimentGeneration) {
                        if (window.newExperimentGeneration.numTimesNavigateCalled > 1) {
                            window.newExperimentGeneration.numTimesNavigateCalled--;
                        }
                        else {
                            if (_this.xeViewModel.experimentId() === window.newExperimentGeneration.id) {
                                window.newExperimentGeneration.createCopy();
                            }
                            window.newExperimentGeneration = null;
                        }
                    }
                    _this.commandsDisabled(false);
                    $(document).trigger("experimentLoaded");
                    if (_this.xeViewModel.experiment && _this.xeViewModel.experiment.hasMissingResources) {
                        // re-validate experiment since some reesources were not loaded successfully (e.g. deleted)
                        _this.validateExperiment();
                        if (_this.xeViewModel.experiment.statusCode() !== DataLab.DataContract.State.InDraft && _this.xeViewModel.experiment.isLeaf()) {
                            _this.xeViewModel.clone(true);
                        }
                        var missingResourcesNotification = new Shell.UI.Notifications.Notification(DataLab.LocalizedResources.experimentContainsMissingResources, "error");
                        _this.addNotification(missingResourcesNotification);
                        missingResourcesNotification.setActions([Shell.UI.Notifications.Buttons.close(function () {
                            DataLab.Util.removeElementFromArray(_this.notifications, missingResourcesNotification);
                        })]);
                        Shell.UI.Notifications.add(missingResourcesNotification);
                    }
                }
                DataLab.Performance.intervalEnd();
            });
        };
        ExperimentView.prototype.showLineage = function () {
            if (this.xeViewModel.experiment.experimentId()) {
                DataLabViews.navigateToExperimentLineage(this.xeViewModel.experiment.experimentId());
            }
            else if (this.xeViewModel.experimentEditorViewModel.parentExperimentId()) {
                DataLabViews.navigateToExperimentLineage(this.xeViewModel.experimentEditorViewModel.parentExperimentId());
            }
            else {
                throw "Experiment ID and parent experiment ID cannot both be empty when viewing lineage";
            }
        };
        ExperimentView.prototype._updateSidebarTitle = function (title) {
            // The sidebar text is initially set by ExperimentType.dataFunction, but at that point we only have
            // the experiment ID. Here we reach in after the fact to keep the displayed text in sync with the
            // actual experiment title. We additionally set the title attribute to prevent the original guid from
            // showing up on hover.
            $(".fxshell-nav2-item.selected a span").text(title).attr('title', title);
        };
        ExperimentView.prototype.isPublishToCommunityOrWebServiceDisabled = function () {
            return this.commandsDisabled() || this.xeViewModel.readOnlyMode() || this.xeViewModel.experiment.statusCode() !== DataLab.DataContract.State.Finished;
        };
        ExperimentView.prototype.setCommands = function () {
            var _this = this;
            var workspaceID = this.xeViewModel.workspace.id;
            var experimentID = this.xeViewModel.experiment.experimentId();
            // experimentViewCommand takes a method of ExperimentView (e.g. ExperimentView.prototype.submit) and
            // returns a parameterless function (suitable for a command action). The method is called with the 'this'
            // context set to the active item (according to the cdm). The active item is verified to be an ExperimentView.
            function experimentViewCommand(fn, featureID) {
                return function () {
                    var item = cdm.currentActiveItem;
                    if (!(item instanceof DataLabViews.ExperimentView)) {
                        throw "Expected an ExperimentView to handle command";
                    }
                    Shell.Diagnostics.Telemetry.featureUsage(featureID, 0, workspaceID, experimentID, null, null);
                    fn.call(item);
                };
            }
            var state = DataLab.DataContract.State;
            var lineageCommand = new Shell.UI.Commands.Command(DataLab.LocalizedResources.commandsViewRunHistory, Shell.UI.Icons.clock, experimentViewCommand(DataLabViews.ExperimentView.prototype.showLineage, 107 /* CommandBarShowLineage */), null, this.commandsDisabled() || !this.xeViewModel.experimentEditorViewModel.parentExperimentId() && this.xeViewModel.experiment.statusCode() === state.InDraft);
            var draftCommand = new Shell.UI.Commands.Command(DataLab.LocalizedResources.commandsSave, Shell.UI.Icons.save, experimentViewCommand(DataLabViews.ExperimentView.prototype.save, 108 /* CommandBarSave */), null, this.commandsDisabled() || this.xeViewModel.readOnlyMode());
            var saveAsCommand = new Shell.UI.Commands.Command(DataLab.LocalizedResources.commandsSaveAs, Shell.UI.Icons.save, experimentViewCommand(DataLabViews.ExperimentView.prototype.saveAs, 109 /* CommandBarSaveAs */), null, this.commandsDisabled());
            var discardCommand = new Shell.UI.Commands.Command(DataLab.LocalizedResources.commandsDiscardChanges, Shell.UI.Icons["delete"], experimentViewCommand(DataLabViews.ExperimentView.prototype.confirmDiscard, 110 /* CommandBarDiscard */), null, this.commandsDisabled() || !this.xeViewModel.experimentEditorViewModel.parentExperimentId() || this.xeViewModel.readOnlyMode() || !this.xeViewModel.experimentEditorViewModel.experiment.isDraft());
            var publishCommand = new Shell.UI.Commands.Command(DataLab.LocalizedResources.commandsPublishAsDataflow, Shell.UI.Icons.publish, experimentViewCommand(DataLabViews.ExperimentView.prototype.publish, 111 /* CommandBarPublish */), null, this.commandsDisabled());
            var runCommand = new Shell.UI.Commands.Command(DataLab.LocalizedResources.commandsRun, Shell.UI.Icons.play, experimentViewCommand(DataLabViews.ExperimentView.prototype.submit, 112 /* CommandBarSubmit */), null, this.commandsDisabled() || this.xeViewModel.readOnlyMode() || this.xeViewModel.experiment.statusCode() === state.Running);
            var cancelCommand = new Shell.UI.Commands.Command(DataLab.LocalizedResources.commandsCancel, Shell.UI.Icons.stop, experimentViewCommand(DataLabViews.ExperimentView.prototype.cancel, 113 /* CommandBarCancel */), null, this.commandsDisabled() || !this.xeViewModel.userWorkspaceExperiment() || this.xeViewModel.experiment.statusCode() !== state.Running);
            var publishWebServiceCommand = new Shell.UI.Commands.Command(DataLab.LocalizedResources.publishWebServiceCommandTitle, Shell.UI.Icons.publish, experimentViewCommand(DataLabViews.ExperimentView.prototype.handlePublishWebServiceCommand, 114 /* CommandBarPublishWebService */), null, this.isPublishToCommunityOrWebServiceDisabled());
            var publishToCommunityCommand = new Shell.UI.Commands.Command(DataLab.LocalizedResources.commandsPublishExperimentToCommunity, Shell.UI.Icons.publishToCommunity, experimentViewCommand(DataLabViews.ExperimentView.prototype.handlePublishToCommunityCommand, 115 /* CommandBarPublishToCommunity */), null, this.isPublishToCommunityOrWebServiceDisabled());
            var createScoringGraphCommand = new Shell.UI.Commands.Command(DataLab.LocalizedResources.createScoreGraphCommandTitle, "/Libraries/Images/create-scoring-experiment.png", experimentViewCommand(DataLabViews.ExperimentView.prototype.createScoringGraphCommand, 116 /* CommandBarCreateScoringGraph */), null, false);
            var refreshCommand = new Shell.UI.Commands.Command(DataLab.LocalizedResources.commandsRefresh, Shell.UI.Icons.sync, experimentViewCommand(DataLabViews.ExperimentView.prototype.refresh, 117 /* CommandBarRefresh */), null, this.commandsDisabled() || code === state.Finished || code === state.Failed || (code === state.InDraft && !this.xeViewModel.experiment.parentExperimentId));
            if (DataLab.Features.dataflowsEnabled()) {
                Shell.UI.Commands.add([publishCommand]);
            }
            var code = this.xeViewModel.experiment.statusCode();
            Shell.UI.Commands.add([
                lineageCommand,
                draftCommand,
                saveAsCommand,
                discardCommand,
                refreshCommand,
                cancelCommand,
                runCommand
            ]);
            Shell.UI.Commands.add([publishWebServiceCommand]);
            if (DataLab.Features.packingServiceEnabled() && DataLab.Features.communityUXInStudioEnabled()) {
                Shell.UI.Commands.add([publishToCommunityCommand]);
            }
            Shell.UI.Commands.add([createScoringGraphCommand]);
            ko.computed(function () {
                if (_this.updateScoreGraphOperation.isUpdatable()) {
                    createScoringGraphCommand.setText(DataLab.LocalizedResources.updateScoreGraphCommandTitle);
                    createScoringGraphCommand.setDisabled(_this.commandsDisabled() || _this.xeViewModel.readOnlyMode() || _this.xeViewModel.experiment.statusCode() !== state.Finished || !_this.updateScoreGraphOperation.isEnabled());
                }
                else {
                    createScoringGraphCommand.setText(DataLab.LocalizedResources.createScoreGraphCommandTitle);
                    createScoringGraphCommand.setDisabled(_this.commandsDisabled() || _this.xeViewModel.readOnlyMode() || _this.xeViewModel.experiment.statusCode() !== state.Finished || !_this.createScoreGraphOperation.isEnabled());
                }
            });
            ko.computed(function () {
                if (!_this.xeViewModel.experiment.isWebServiceExperiment()) {
                    publishWebServiceCommand.setIcon("/Libraries/Images/prepare-web-service.png");
                    publishWebServiceCommand.setText(DataLab.LocalizedResources.prepareWebServiceCommandTitle);
                    publishWebServiceCommand.setDisabled(_this.commandsDisabled() || _this.xeViewModel.readOnlyMode() || _this.prepareWebServiceOperation.isRunning());
                    publishWebServiceCommand.setClick(experimentViewCommand(DataLabViews.ExperimentView.prototype.prepareWebServiceCommand, 118 /* CommandBarPrepareWebService */));
                }
                else {
                    publishWebServiceCommand.setIcon(Shell.UI.Icons.publish);
                    publishWebServiceCommand.setText(DataLab.LocalizedResources.publishWebServiceCommandTitle);
                    publishWebServiceCommand.setDisabled(_this.isPublishToCommunityOrWebServiceDisabled());
                    publishWebServiceCommand.setClick(experimentViewCommand(DataLabViews.ExperimentView.prototype.handlePublishWebServiceCommand, 114 /* CommandBarPublishWebService */));
                }
            });
            // Computed is used below so the commands may be enabled or disabled correctly each time any dependent value changes.
            // This means we don't have to rely on multiple subscriptions to achieve the same result.
            ko.computed(function () {
                discardCommand.setDisabled(_this.commandsDisabled() || !_this.xeViewModel.experimentEditorViewModel.parentExperimentId() || _this.xeViewModel.readOnlyMode() || !_this.xeViewModel.experimentEditorViewModel.experiment.isDraft());
                runCommand.setDisabled(_this.commandsDisabled() || _this.xeViewModel.readOnlyMode() || _this.xeViewModel.experiment.statusCode() === state.Running);
                draftCommand.setDisabled(_this.commandsDisabled() || !_this.xeViewModel.experimentEditorViewModel.experiment.isDraft());
                cancelCommand.setDisabled(_this.commandsDisabled() || !_this.xeViewModel.userWorkspaceExperiment() || _this.xeViewModel.experiment.statusCode() !== state.Running);
                lineageCommand.setDisabled(_this.commandsDisabled() || !_this.xeViewModel.experimentEditorViewModel.parentExperimentId() && _this.xeViewModel.experiment.statusCode() === state.InDraft);
                publishToCommunityCommand.setDisabled(_this.isPublishToCommunityOrWebServiceDisabled());
                publishCommand.setDisabled(_this.commandsDisabled());
                saveAsCommand.setDisabled(_this.commandsDisabled());
            });
            ko.computed(function () {
                code = _this.xeViewModel.experiment.statusCode();
                refreshCommand.setDisabled(_this.commandsDisabled() || code === state.Finished || code === state.Failed || (code === state.InDraft && !_this.xeViewModel.experiment.parentExperimentId));
            });
        };
        ExperimentView.prototype.showErrorNotification = function (title, details) {
            if (details === void 0) { details = null; }
            var notification = new Shell.UI.Notifications.Notification(title, "error");
            if (details) {
                notification.setDetailsText(details);
            }
            notification.setActions([Shell.UI.Notifications.Buttons.close(function () {
                Shell.UI.Notifications.remove(notification);
            })]);
            Shell.UI.Notifications.add(notification);
            return notification;
        };
        return ExperimentView;
    })(DataLabViews.ViewBase);
    DataLabViews.ExperimentView = ExperimentView;
})(DataLabViews || (DataLabViews = {}));

/// <reference path="../../Global.ts" />
/// <reference path="HelpSearchViewModel.ts" />
/// <reference path="../../../DataLabViews/ExperimentView.ts" />
var ExperimentEditor;
(function (ExperimentEditor) {
    var Help;
    (function (Help) {
        Help.currentHelpTopic = ko.observable("");
        Help.moduleTopicID = ko.observable(null);
        Help.resourceName = ko.observable("");
        function setHelpContent(content, topicID, resourceNameArg) {
            if (topicID === void 0) { topicID = null; }
            if (resourceNameArg === void 0) { resourceNameArg = ""; }
            Help.currentHelpTopic(content);
            Help.moduleTopicID(topicID);
            Help.resourceName(resourceNameArg);
        }
        Help.setHelpContent = setHelpContent;
        var WindowTitle = DataLab.Util.format(DataLab.LocalizedResources.helpStudioHelpName, DataLab.LocalizedResources.productName);
        var CreatingAndEditingAnExperimentTopic = "c5ff103f-d6ef-44f5-a5aa-21fdaed12c77";
        var RecentWorkViewTopic = "6cfeb32e-6aa1-4bce-91e6-ed38a7b0c4df";
        var PaletteTopic = "e1a8c2a1-3a47-43a9-b228-20869cdf898b";
        var FindingExperimentsModulesAndDatasetsTopic = "057b7239-f796-40d1-b60c-dd721e35c3fc";
        var ExperimentsListViewTopic = "6cfeb32e-6aa1-4bce-91e6-ed38a7b0c4df";
        var WhatIsMLStudioTopic = "e76c990c-bb44-4dea-b834-39d4c4e864ec";
        var ConfiguringSessionSettingsTopic = "384efded-6c42-4c7f-968d-7993263a3269";
        var WebServicesTopic = "631fbe7a-8e23-460f-892b-0d66bbd04b47";
        var CredentialsTopic = "13a22b84-5132-47d7-9b93-9b2fd476b0ff";
        var UsersTopic = "20ff2e97-6a44-4312-88b6-64457f0583d8";
        var ExperimentLineageViewTopic = "fd68e26d-66b0-4267-bbef-0378a8b367f4";
        var DatasetsTopic = "4fe54478-1837-45ef-ae58-393d2cb4eeec";
        var ReferenceHelpWebsiteURI = typeof environment == "undefined" ? "https://sandboxmsdnstage.redmond.corp.microsoft.com/library/" : environment.referenceHelpBaseURL;
        var AzureHelpWebsiteURI = "http://azure.microsoft.com/en-us/documentation/articles/";
        var HelpHomeURI = "http://go.microsoft.com/fwlink/?LinkId=524824";
        function getTopicUrl(topic) {
            var url = HelpHomeURI;
            if (topic) {
                if (topic.match(/^machine/)) {
                    url = AzureHelpWebsiteURI + topic;
                }
                else {
                    url = ReferenceHelpWebsiteURI + topic;
                }
            }
            return url;
        }
        Help.getTopicUrl = getTopicUrl;
        function openHelpWindow(helpTopicURL, anchor) {
            if (anchor === void 0) { anchor = ""; }
            Shell.Diagnostics.Telemetry.featureUsage(22 /* OpenHelp */, 0, null, null, null, JSON.stringify({ topicId: helpTopicURL, anchor: anchor }));
            var helpWindow;
            if (helpTopicURL == null) {
                helpTopicURL == "";
            }
            helpWindow = window.open(getTopicUrl(helpTopicURL), WindowTitle, "");
            // On IE, Help window is undefined if the ALLOW POP-UP confirmation has not been accepted.
            if (helpWindow) {
                helpWindow.focus();
            }
        }
        Help.openHelpWindow = openHelpWindow;
        function Initialize() {
            ExperimentEditor.HelpSearch.Initialize();
            var helpHandler = function () {
                var helpTopicID = "";
                var anchor = "";
                // If we're viewing the experiments list, take them to the searching
                // experiments topic
                if (cdm.currentExtension && cdm.currentExtension.name === "ListExperiments") {
                    helpTopicID = FindingExperimentsModulesAndDatasetsTopic;
                }
                else if (cdm.currentActiveItem instanceof DataLabViews.RecentWorkView) {
                    helpTopicID = RecentWorkViewTopic;
                }
                else if (cdm.currentActiveItem instanceof DataLabViews.ExperimentListView) {
                    helpTopicID = ExperimentsListViewTopic;
                }
                else if (cdm.currentActiveItem instanceof DataLabViews.ExperimentLineageView) {
                    helpTopicID = ExperimentLineageViewTopic;
                }
                else if (cdm.currentActiveItem instanceof DataLabViews.ExperimentView) {
                    helpTopicID = PaletteTopic;
                }
                else if (cdm.currentExtension && cdm.currentExtension.name === "Datasets") {
                    helpTopicID = DatasetsTopic;
                }
                else if (cdm.currentActiveItem instanceof DataLabViews.WelcomeView) {
                    helpTopicID = WhatIsMLStudioTopic;
                }
                else if (cdm.currentExtension && cdm.currentExtension.name === "Settings") {
                    helpTopicID = ConfiguringSessionSettingsTopic;
                }
                else if (cdm.currentActiveItem instanceof ExperimentEditor.CredentialsPivot) {
                    helpTopicID = CredentialsTopic;
                }
                else if (cdm.currentActiveItem instanceof ExperimentEditor.UsersPivot) {
                    helpTopicID = UsersTopic;
                }
                else if (cdm.currentExtension && cdm.currentExtension.name === "WebServiceGroups") {
                    helpTopicID = WebServicesTopic;
                }
                openHelpWindow(helpTopicID, anchor);
                Shell.Diagnostics.Telemetry.customEvent(anchor, "Help");
                return false;
            };
            $(".helpSearch").children(".helpIcon").click(helpHandler);
            $("html").keydown(function (e) {
                if (e.keyCode === 112 /* F1 */) {
                    e.preventDefault();
                    e.stopPropagation();
                    helpHandler();
                    return false;
                }
            });
            if (ExperimentEditor.Constants.CurrentBrowser === 2 /* IE9 */ || ExperimentEditor.Constants.CurrentBrowser === 3 /* IE10 */ || ExperimentEditor.Constants.CurrentBrowser === 4 /* IE11 */) {
                window.onhelp = helpHandler;
                document.onhelp = helpHandler;
            }
        }
        Help.Initialize = Initialize;
        function QuickHelpMoreInfo() {
            openHelpWindow(Help.moduleTopicID());
        }
        Help.QuickHelpMoreInfo = QuickHelpMoreInfo;
    })(Help = ExperimentEditor.Help || (ExperimentEditor.Help = {}));
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
/// <reference path="IconUtilities.ts" />
/// <reference path="IPaletteItem.ts" />
/// <reference path="IPaletteDragResponder.ts" />
/// <reference path="../ExperimentEditor/Help.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var ExperimentEditor;
(function (ExperimentEditor) {
    var PaletteItem = (function () {
        function PaletteItem(id, name, description, type) {
            var _this = this;
            // A palette item is visible when it satisfies the search text.
            this.isVisible = ko.observable(true);
            this.classId = ko.observable("xe-paletteItem xe-" + type + "PaletteItem");
            this.id = ko.observable(id);
            this.name = ko.observable(name);
            this.description = ko.observable(description);
            this.type = ko.observable(type);
            this.tooltip = ko.computed(function () {
                var text = _this.name();
                if (_this.description()) {
                    text = text + "\n" + _this.description();
                }
                return text;
            });
        }
        return PaletteItem;
    })();
    ExperimentEditor.PaletteItem = PaletteItem;
    var PaletteCategory = (function (_super) {
        __extends(PaletteCategory, _super);
        function PaletteCategory(categoryPath, resourceCache, children) {
            var _this = this;
            if (children === void 0) { children = null; }
            _super.call(this);
            this.name = ko.observable(null);
            this.items = ko.observableArray();
            this.childCategories = ko.observableArray();
            this.resourceCache = resourceCache;
            this.hasVisibleItems = ko.computed(function () { return _this.items().some(function (item) { return item.isVisible(); }); });
            this.hasVisibleChildCategories = ko.computed(function () { return _this.childCategories().some(function (category) { return !category.isEmpty(); }); });
            this.isEmpty = ko.computed(function () { return !_this.hasVisibleItems() && !_this.hasVisibleChildCategories(); });
            this.path = categoryPath;
            if (!this.path) {
                this.name(DataLab.Constants.ResourceCategory.Uncategorized);
            }
            else {
                var categoryPathSegments = categoryPath.split('\\');
                // The last segment of the category path is the heading to display for this category.
                this.name(categoryPathSegments[categoryPathSegments.length - 1]);
            }
            this.currentSearchFilter = "";
            this.isCollapsed = ko.observable(true);
            this.isCollapsedWhenSearchEmpty = true;
            this.isCollapsed.subscribe(function (collapsed) {
                if (!_this.currentSearchFilter) {
                    _this.isCollapsedWhenSearchEmpty = collapsed;
                }
            });
            if (children) {
                var sortedCategoryNames = children.keys().sort();
                sortedCategoryNames.forEach(function (categoryName) {
                    _this.childCategories.push(new PaletteCategory(categoryName, _this.resourceCache, children.lookup(categoryName)));
                });
            }
            if (resourceCache) {
                // If the set of resources changes, this palette should reflect that.
                this.registerForDisposal(new DataLab.Util.DisposableSubscription(this.resourceCache.resourceFamilyUpdated.subscribe(function () {
                    _this.updatePaletteItemsFromResourceCache();
                })), new DataLab.Util.DisposableSubscription(this.resourceCache.items.subscribe(function () {
                    _this.updatePaletteItemsFromResourceCache();
                })));
                this.updatePaletteItemsFromResourceCache();
            }
            // Show icons for top level categories
            if (!this.path) {
                this.icon = ExperimentEditor.GetIconForCategory(this.name());
            }
            else if (this.path.split("\\").length === 1) {
                this.icon = ExperimentEditor.GetIconForCategory(this.path);
            }
            else {
                this.icon = null;
            }
        }
        /**
         * Perform a case-insensitive search over all palette items (name, description and category heading)
         * using the supplied search text.
         * @return {boolean} whether any item in this category matches the search text
         */
        PaletteCategory.prototype.applyPaletteSearch = function (searchText) {
            this.currentSearchFilter = searchText;
            // Apply search text to all children categories.
            var nonEmptyChildExists = false;
            this.childCategories().forEach(function (child) {
                if (child.applyPaletteSearch(searchText)) {
                    nonEmptyChildExists = true;
                }
            });
            this.applyCurrentSearchFilterToItems(this.items());
            if (!this.currentSearchFilter) {
                this.isCollapsed(this.isCollapsedWhenSearchEmpty);
            }
            else {
                this.isCollapsed(this.isEmpty());
            }
            return !this.isEmpty();
        };
        /**
          * Applies the current search (set by {@see applyPaletteSearch}).
          * This is the only code which updates the visibility of palette items.
          * Also checks whether the palette category contains any visible items and sets this.isEmpty() accordingly.
          * The list of PaletteItems is provided as a parameter to facilitate pre-filtering the item list
          * before exposing it to the view.
        */
        PaletteCategory.prototype.applyCurrentSearchFilterToItems = function (items) {
            var _this = this;
            // Regular expression used to treat all punctuation marks the same way as spaces.
            var regex = /[^A-Za-z0-9 ]/g;
            var searchTextLowerCase = this.currentSearchFilter.toLowerCase().replace(regex, " ");
            items.forEach(function (paletteItem) {
                // We do not allow a palette item to have a name that is null.
                if (paletteItem.name() === null) {
                    throw new Error(_this.name() + " palette item: name is null.");
                }
                var paletteItemName = paletteItem.name().toLowerCase().replace(regex, " ");
                // We treat a null description or null category as though it is an empty string.
                var description = paletteItem.description() === null ? "" : paletteItem.description();
                description = description.toLowerCase().replace(regex, " ");
                var categoryPath = _this.path === null ? "" : _this.path;
                categoryPath = categoryPath.toLowerCase().replace(regex, " ");
                var categoryName = _this.name().toLowerCase().replace(regex, " ");
                if (paletteItemName.indexOf(searchTextLowerCase) !== -1 || description.indexOf(searchTextLowerCase) !== -1 || categoryPath.indexOf(searchTextLowerCase) !== -1 || categoryName.indexOf(searchTextLowerCase) !== -1) {
                    paletteItem.isVisible(true);
                }
                else {
                    paletteItem.isVisible(false);
                }
            });
        };
        /**
         * Populates palette items for the current contents of the underlying resource cache that belong in this category.
         * Only the latest version in each resource family is included, and the updated list is sorted by name.
         * The current search filter is re-applied to the new palette category list.
         */
        PaletteCategory.prototype.updatePaletteItemsFromResourceCache = function () {
            var _this = this;
            var newItems = DataLab.Util.filter(this.resourceCache.items(), function (resource) {
                return resource.category === _this.path && resource.isLatest();
            }).map(function (resource) { return _this.createPaletteItemForResource(resource); });
            newItems.sort(function (a, b) {
                return a.name().localeCompare(b.name());
            });
            // New items should be filtered according to the current search text.
            // If items have been removed, this call may also update isEmpty.
            this.applyCurrentSearchFilterToItems(newItems);
            this.items(newItems);
        };
        PaletteCategory.prototype.createPaletteItemForResource = function (resource) {
            return new PaletteItem(resource.id, resource.name(), resource.description(), this.getEntityTypeOfResource(resource));
        };
        PaletteCategory.prototype.getEntityTypeOfResource = function (resource) {
            if (resource instanceof DataLab.Model.Module) {
                return ExperimentEditor.Constants.EntityType.Module;
            }
            else if (resource instanceof DataLab.Model.Dataset) {
                return ExperimentEditor.Constants.EntityType.Dataset;
            }
            else if (resource instanceof DataLab.Model.TrainedModel) {
                return ExperimentEditor.Constants.EntityType.TrainedModel;
            }
            else if (resource instanceof DataLab.Model.Transform) {
                return ExperimentEditor.Constants.EntityType.Transform;
            }
            else {
                throw new Error("EntityType is unknown for resource");
            }
        };
        return PaletteCategory;
    })(DataLab.Util.Disposable);
    ExperimentEditor.PaletteCategory = PaletteCategory;
    var PaletteViewModel = (function (_super) {
        __extends(PaletteViewModel, _super);
        function PaletteViewModel(moduleCategoryRegistry, datasetCategoryRegistry, datasetCache, moduleCache, trainedModelCache, transformModulesCache) {
            var _this = this;
            _super.call(this);
            this.canceled = false;
            this.firstModuleCategoryIndex = 0;
            this.categories = ko.observableArray();
            if (!datasetCache || !moduleCache || !trainedModelCache || !transformModulesCache) {
                throw new Error("Dataset, Trained model, Transforms, and Module caches must be provided.");
            }
            this.datasetCache = datasetCache;
            this.moduleCache = moduleCache;
            this.trainedModelCache = trainedModelCache;
            this.transformModulesCache = transformModulesCache;
            // First add all non module categories
            var datasetChildCategories = datasetCategoryRegistry.lookup(DataLab.Constants.ResourceCategory.Dataset);
            this.categories.push(new PaletteCategory(DataLab.Constants.ResourceCategory.Dataset, datasetCache, datasetChildCategories));
            this.categories.push(new PaletteCategory(DataLab.Constants.ResourceCategory.TrainedModel, trainedModelCache));
            this.categories.push(new PaletteCategory(DataLab.Constants.ResourceCategory.Transform, transformModulesCache));
            // Add all module categories, keeping the null and deprecated categories last.
            this.firstModuleCategoryIndex = this.categories().length;
            // removed the deprecated category, when sorting existing module categories and add it last
            var sortedCategoryNames = moduleCategoryRegistry.keys().sort();
            var deprecatedCategoryName = DataLab.Constants.ResourceCategory.Deprecated;
            sortedCategoryNames = sortedCategoryNames.filter(function (name) {
                return name != deprecatedCategoryName;
            });
            sortedCategoryNames.forEach(function (categoryName) {
                _this.categories.push(new PaletteCategory(categoryName, moduleCache, moduleCategoryRegistry.lookup(categoryName)));
            });
            // these are uncategorized modules 
            this.categories.push(new PaletteCategory(null, moduleCache));
            // deprecated category
            this.categories.push(new PaletteCategory(deprecatedCategoryName, moduleCache, moduleCategoryRegistry.lookup(deprecatedCategoryName)));
            moduleCategoryRegistry.subscribeToCollectionChanges(function (change) {
                if (change.type === 0 /* add */) {
                    var categoryName = change.key;
                    for (var i = _this.firstModuleCategoryIndex; i < _this.categories().length; i++) {
                        if (categoryName.localeCompare(_this.categories()[i].name()) < 0 || i === _this.categories().length) {
                            _this.categories().splice(i, 0, new PaletteCategory(categoryName, moduleCache, moduleCategoryRegistry.lookup(categoryName)));
                            _this.categories.notifySubscribers(null);
                            break;
                        }
                    }
                }
            });
            this.isDragging = ko.observable(false);
            this.mouseDown = function (paletteItem, e) {
                if (e.button === 0 /* Left */) {
                    ExperimentEditor.Help.setHelpContent(paletteItem.description(), paletteItem.type() === ExperimentEditor.Constants.EntityType.Module ? DataLab.Util.resurrectDashesInGUID(paletteItem.id().split(".")[1]) : null, paletteItem.name());
                    _this.isDragging(true);
                    _this.dragResponder.paletteDragStart(e, paletteItem);
                    _this.canceled = false;
                }
            };
            this.mouseUp = function (paletteItem, e) {
                if (e.button === 0 /* Left */) {
                    _this.dragResponder.paletteDragEnd(e);
                    _this.isDragging(false);
                }
            };
            this.mouseMove = function (paletteItem, e) {
                // We only send this when dragging, otherwise a drag with a non-left mouse button will start a capture
                // and we could end up sending mouse moves over the canvas.
                if (_this.isDragging()) {
                    e.preventDefault();
                    e.stopPropagation();
                    if (!_this.canceled) {
                        _this.dragResponder.paletteDragMoved(e);
                    }
                }
            };
            this.activate = function (paletteItem, e) {
                if (_this.activationAction) {
                    _this.activationAction(paletteItem, e);
                }
            };
            this.applyPaletteSearch("");
        }
        PaletteViewModel.prototype.registerActivationEvent = function (callback) {
            this.activationAction = callback;
        };
        /**
         * Perform a case-insensitive search over all palette items (name and description) and category headings
         * in the entire palette using the supplied search text.
         */
        PaletteViewModel.prototype.applyPaletteSearch = function (searchText) {
            this.categories().forEach(function (category) {
                category.applyPaletteSearch(searchText);
            });
        };
        PaletteViewModel.prototype.cancelDrag = function () {
            this.canceled = true;
            this.dragResponder.paletteDragCancel();
        };
        return PaletteViewModel;
    })(DataLab.Util.Disposable);
    ExperimentEditor.PaletteViewModel = PaletteViewModel;
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
/// <reference path="Entity.ts" />
/// <reference path="GraphNodeViewModel.ts" />
/// <reference path="PortViewModel.ts" />
/// <reference path="../PropertyEditorControl/PropertyViewModel.ts" />
/// <reference path="../PaletteControl/PaletteViewModel.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var ExperimentEditor;
(function (ExperimentEditor) {
    // A class represents a Module entity
    var Module = (function (_super) {
        __extends(Module, _super);
        function Module(moduleNode, workspace) {
            var _this = this;
            _super.call(this, moduleNode, ExperimentEditor.EntityTypes[ExperimentEditor.Constants.EntityType.Module]);
            this.moduleNode = moduleNode;
            this.graphNodeType = 0 /* Module */;
            this.statusIconURL = ko.computed(function () {
                if (!_this.valid()) {
                    return "/Content/Images/icon-validation-invalid.svg";
                }
                else {
                    // Modules which have not started should have the following icon unless the experiment is a draft. Draft modules should have no status icon.
                    if (_this.moduleNode.statusCode.value() === DataLab.DataContract.State.NotStarted && _this.moduleNode.parent && _this.moduleNode.parent.statusCode() !== DataLab.DataContract.State.InDraft) {
                        return "/Content/Images/icon-notstarted.svg";
                    }
                    else if (_this.moduleNode.statusCode.value() === DataLab.DataContract.State.Running) {
                        return "/Content/Images/Processing.gif";
                    }
                    else if (_this.moduleNode.statusCode.value() === DataLab.DataContract.State.Finished) {
                        return "/Content/Images/icon-complete.svg";
                    }
                    else if (_this.moduleNode.statusCode.value() === DataLab.DataContract.State.Failed) {
                        return "/Content/Images/icon-error.svg";
                    }
                    else {
                        return "/Content/Images/icon-none.svg";
                    }
                }
            });
            this.classId = ko.computed(function () {
                var executionState = _this.moduleNode.statusCode.value();
                var value = (_this.hovered() ? " hoveredEntity" : "") + (_this.selected() ? " selectedEntity" : "") + " " + _this.getCompatibilityClass();
                return "rectEntity module " + executionState + value;
            });
            // Listen to all our parameters, so we can live update validation
            this.subscribeToParameters(this.moduleNode.parameters);
            this.startTime = new ExperimentEditor.StaticTextPropertyViewModel(this.moduleNode.startTime);
            this.endTime = new ExperimentEditor.StaticTextPropertyViewModel(this.moduleNode.endTime);
            this.elapsedTime = new ExperimentEditor.StaticTextPropertyViewModel(this.moduleNode.elapsedTime);
            this.statusCode = new ExperimentEditor.StaticTextPropertyViewModel(this.moduleNode.statusCode);
            this.statusDetails = new ExperimentEditor.StaticTextPropertyViewModel(this.moduleNode.statusDetails);
            this.outputLog = new ExperimentEditor.EndpointPropertyViewModel(this.moduleNode.outputLog);
            this.errorLog = new ExperimentEditor.EndpointDialogPropertyViewModel(this.moduleNode.errorLog, this.moduleNode.name, this.moduleNode.id, workspace, this.moduleNode.executedExperimentId);
            this.outputEndpoints = [];
            DataLab.Util.forEach(this.moduleNode.outputEndpoints, function (endpointProperty, name) {
                _this.outputEndpoints.push(new ExperimentEditor.EndpointPropertyViewModel(endpointProperty));
            });
            this.nodeIconClicked = function (source, e) {
                // In case we had an error -- module failed and is valid (so no ! icon)
                if (_this.moduleNode.statusCode.value() === DataLab.DataContract.State.Failed && _this.valid()) {
                    _this.errorLog.onClick(_this.errorLog, e);
                }
            };
            this.icon = ExperimentEditor.GetIconForCategory(this.moduleNode.module_.category);
            this.iconSymbol = ExperimentEditor.GetIconSymbol(this.icon);
        }
        Object.defineProperty(Module.prototype, "label", {
            get: function () {
                return this.moduleNode.module_.name();
            },
            enumerable: true,
            configurable: true
        });
        Module.prototype.startValidating = function () {
            this.moduleNode.startValidating();
        };
        Module.prototype.updateValidState = function () {
            var errors = this.moduleNode.validate();
            if (errors.length > 0) {
                if (errors[0].errorMessages.length > 0) {
                    this.moduleNode.balloonMessage(errors[0].errorMessages[0]);
                    this.valid(false);
                }
                else {
                    DataLab.Log.error("An error object had no error messages.");
                }
            }
            else {
                // if the module had failed, its message should not changed until the module state changes. 
                if (this.moduleNode.statusCode.value() !== DataLab.DataContract.State.Failed) {
                    this.moduleNode.balloonMessage("");
                }
                this.valid(true);
            }
        };
        Module.prototype.subscribeToParameters = function (parameters) {
            var _this = this;
            DataLab.Util.forEach(parameters, function (parameter) {
                parameter.value.errorMessage.subscribe(function () {
                    _this.updateValidState();
                });
                if (parameter.descriptor instanceof DataLab.Model.ModeModuleParameterDescriptor) {
                    // Need to re-validate when a mode parameter value changes, because the set of
                    // relevant parameters might have changed.
                    parameter.value.subscribe(function () {
                        _this.updateValidState();
                    });
                    DataLab.Util.forEach(parameter.childParameters, function (childParameters) {
                        _this.subscribeToParameters(childParameters);
                    });
                }
            });
        };
        return Module;
    })(ExperimentEditor.GraphNodeViewModel);
    ExperimentEditor.Module = Module;
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
/// <reference path="GraphControlViewModel.ts" />
var ExperimentEditor;
(function (ExperimentEditor) {
    var Visualization;
    (function (Visualization) {
        var D3GraphViewModel = (function () {
            function D3GraphViewModel(graphType, xlog, ylog, binCount, categoryCount, cumulativeDistribution, probabilityDensity, datatable, feature, crossCompareFeature, layout, index) {
                var _this = this;
                if (index === void 0) { index = null; }
                this._graphType = ko.observable(0 /* Histogram */);
                // dissallow boxplot on non-numeric features
                this.graphType = ko.computed({
                    write: function (gt) {
                        if (gt === 1 /* BoxPlot */) {
                            _this._graphType(DataLab.DataContract.isNumericFeature(feature.featureType) ? 1 /* BoxPlot */ : 0 /* Histogram */);
                        }
                        else {
                            _this._graphType(gt);
                        }
                    },
                    read: function () {
                        return _this._graphType();
                    }
                });
                this.graphType(graphType);
                this.xlog = xlog;
                this.ylog = ylog;
                this.binCount = binCount;
                this.categoryCount = categoryCount;
                this.cumulativeDistibution = cumulativeDistribution;
                this.probabilityDensity = probabilityDensity;
                this.datatable = datatable;
                this.feature = feature;
                this.crossCompareFeature = crossCompareFeature;
                this.layout = layout;
                this.index = index;
                this.subscribed = false; // will be used in d3graph binding to manage partial update subscriptions            
            }
            return D3GraphViewModel;
        })();
        Visualization.D3GraphViewModel = D3GraphViewModel;
    })(Visualization = ExperimentEditor.Visualization || (ExperimentEditor.Visualization = {}));
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
/// <reference path="D3GraphViewModel.ts" />
/// <reference path="VisualizationViewModel.ts" />
var ExperimentEditor;
(function (ExperimentEditor) {
    var Visualization;
    (function (Visualization) {
        var V = ExperimentEditor.Visualization;
        (function (GraphType) {
            GraphType[GraphType["Histogram"] = 0] = "Histogram";
            GraphType[GraphType["BoxPlot"] = 1] = "BoxPlot";
            GraphType[GraphType["ScatterPlot"] = 2] = "ScatterPlot";
            GraphType[GraphType["MultiboxPlot"] = 3] = "MultiboxPlot";
            GraphType[GraphType["Crosstab"] = 4] = "Crosstab";
        })(Visualization.GraphType || (Visualization.GraphType = {}));
        var GraphType = Visualization.GraphType;
        var ScaleBoxViewModel = (function () {
            function ScaleBoxViewModel(visible, value, label) {
                this.visible = ko.observable(false);
                this.value = ko.observable(false);
                this.label = ko.observable("");
            }
            ScaleBoxViewModel.prototype.refresh = function (visible, label) {
                this.visible(visible);
                this.label(label);
            };
            return ScaleBoxViewModel;
        })();
        Visualization.ScaleBoxViewModel = ScaleBoxViewModel;
        var GraphControlViewModel = (function () {
            function GraphControlViewModel(compareToFeatures, datatable, featureContract, layout) {
                var _this = this;
                this.isNull = (datatable === null);
                this.compareToFeatures = compareToFeatures;
                this.crossCompareFeature = ko.observable("None");
                if (!this.isNull) {
                    this.crossCompareFeatureContract = ko.computed(function () {
                        return DataLab.Util.first(datatable.features, function (f) {
                            return f.name === _this.crossCompareFeature();
                        }, null);
                    });
                    this.crossCompareFeatureContract.subscribe(function (d) {
                        if (!d) {
                            _this.graphType(_this.mainGraphType);
                        }
                        else if (DataLab.DataContract.isNumericFeature(featureContract.featureType) && DataLab.DataContract.isNumericFeature(d.featureType)) {
                            _this.graphType(2 /* ScatterPlot */);
                        }
                        else if (!DataLab.DataContract.isNumericFeature(featureContract.featureType) && !DataLab.DataContract.isNumericFeature(d.featureType)) {
                            _this.graphType(4 /* Crosstab */);
                        }
                        else {
                            _this.graphType(3 /* MultiboxPlot */);
                        }
                    });
                    this.feature = featureContract.name;
                }
                ;
                this.featureContract = featureContract;
                this.mainGraphType = 0 /* Histogram */;
                this.graphType = ko.observable(this.mainGraphType);
                this.binCount = ko.observable(10);
                this.categoriesCount = ko.observable(5);
                this.categoriesVisible = ko.observable(true);
                this.binCountVisible = ko.observable(true);
                this.xScaleCheckbox = new ScaleBoxViewModel(true, true, "");
                this.yScaleCheckbox = new ScaleBoxViewModel(true, true, "");
                this.probabilityDensity = ko.observable(false);
                this.cumulativeDistribution = ko.observable(false);
                this.probabilityFunctionsVisible = ko.observable(true);
                this.scaleCheckboxesVisible = ko.computed(function () {
                    return _this.xScaleCheckbox.visible() || _this.yScaleCheckbox.visible();
                });
                this.parametersVisible = ko.computed(function () {
                    return _this.scaleCheckboxesVisible() || _this.binCountVisible() || _this.categoriesVisible() || _this.probabilityFunctionsVisible();
                });
                // set up instrumentation for the graph control inputs
                this.binCount.subscribe(this.logGraphControlEvent("BinCountChanged"));
                this.categoriesCount.subscribe(this.logGraphControlEvent("CategoriesCountChanged"));
                this.probabilityDensity.subscribe(this.logGraphControlEvent("ProbabilityDensityChanged"));
                this.cumulativeDistribution.subscribe(this.logGraphControlEvent("CumulativeDistributionChanged"));
                this.xScaleCheckbox.value.subscribe(this.logGraphControlEvent("XScaleCheckboxChanged"));
                this.yScaleCheckbox.value.subscribe(this.logGraphControlEvent("YScaleCheckboxChanged"));
                if (!this.isNull) {
                    this.graph = new Visualization.D3GraphViewModel(this.graphType(), this.xScaleCheckbox.value, this.yScaleCheckbox.value, this.binCount, this.categoriesCount, this.cumulativeDistribution, this.probabilityDensity, datatable, featureContract, this.crossCompareFeatureContract, layout);
                    this.graphType.subscribe(function (val) {
                        _this.graph.graphType(val);
                    });
                    this.createInputsUI();
                    this.graphTypeString = ko.computed(function () {
                        return GraphType[_this.graph.graphType()];
                    });
                }
                else {
                    this.graph = null;
                }
            }
            GraphControlViewModel.prototype.setCrossCompareFeature = function (featureName) {
                if (DataLab.Util.first(this.compareToFeatures, function (f) {
                    return f === featureName;
                }, false)) {
                    this.crossCompareFeature(featureName);
                }
            };
            GraphControlViewModel.prototype.setGraphType = function (graphType) {
                if (this.graphType() === 0 /* Histogram */ || this.graphType() === 1 /* BoxPlot */) {
                    this.graphType(graphType);
                }
                this.mainGraphType = graphType;
            };
            GraphControlViewModel.prototype.logGraphControlEvent = function (eventName) {
                return function (newValue) {
                    Shell.Diagnostics.Telemetry.featureUsage(23 /* VisualizationParameter */, 24 /* Visualization */, null, null, null, JSON.stringify({ name: eventName, value: newValue }));
                };
            };
            GraphControlViewModel.prototype.createInputsUI = function () {
                var _this = this;
                ko.computed(function () {
                    var numeric = DataLab.DataContract.isNumericFeature(_this.featureContract.featureType);
                    switch (_this.graph.graphType()) {
                        case 0 /* Histogram */:
                            _this.xScaleCheckbox.refresh(numeric ? true : false, DataLab.Util.format(DataLab.LocalizedResources.featureLogScale, _this.feature));
                            _this.yScaleCheckbox.refresh(true, "frequency log scale");
                            _this.binCountVisible(true);
                            _this.categoriesVisible(false);
                            _this.probabilityFunctionsVisible(numeric);
                            break;
                        case 1 /* BoxPlot */:
                            _this.xScaleCheckbox.refresh(true, DataLab.Util.format(DataLab.LocalizedResources.featureLogScale, _this.feature));
                            _this.yScaleCheckbox.refresh(false, "");
                            _this.binCountVisible(false);
                            _this.categoriesVisible(false);
                            _this.probabilityFunctionsVisible(false);
                            break;
                        case 2 /* ScatterPlot */:
                            _this.xScaleCheckbox.refresh(true, DataLab.Util.format(DataLab.LocalizedResources.featureLogScale, _this.feature));
                            _this.yScaleCheckbox.refresh(true, DataLab.Util.format(DataLab.LocalizedResources.featureLogScale, _this.crossCompareFeature()));
                            _this.binCountVisible(false);
                            _this.categoriesVisible(false);
                            _this.probabilityFunctionsVisible(false);
                            break;
                        case 4 /* Crosstab */:
                            _this.xScaleCheckbox.refresh(false, "");
                            _this.yScaleCheckbox.refresh(false, "");
                            _this.binCountVisible(false);
                            _this.categoriesVisible(false);
                            _this.probabilityFunctionsVisible(false);
                            break;
                        case 3 /* MultiboxPlot */:
                            _this.xScaleCheckbox.refresh(!numeric, DataLab.Util.format(DataLab.LocalizedResources.featureLogScale, _this.crossCompareFeature()));
                            _this.yScaleCheckbox.refresh(numeric, DataLab.Util.format(DataLab.LocalizedResources.featureLogScale, _this.feature));
                            _this.binCountVisible(false);
                            _this.categoriesVisible(true);
                            _this.probabilityFunctionsVisible(false);
                            break;
                        default:
                            throw new Error("Unknown Graph type requested: " + _this.graphTypeString());
                            break;
                    }
                });
            };
            return GraphControlViewModel;
        })();
        Visualization.GraphControlViewModel = GraphControlViewModel;
        Visualization.NullGraph = new GraphControlViewModel([], null, null, null);
    })(Visualization = ExperimentEditor.Visualization || (ExperimentEditor.Visualization = {}));
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
/// <reference path="GraphControlViewModel.ts" />
/// <reference path="../../View/DialogView.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var ExperimentEditor;
(function (ExperimentEditor) {
    var Visualization;
    (function (Visualization) {
        var Constants;
        (function (Constants) {
            Constants.placeholderWidth = "200px";
            Constants.placeholderHeight = "155px";
            Constants.graphControlWidth = "500px";
            Constants.graphControlheight = "448px";
            Constants.transitionDuration = 500;
            Constants.maxPrecision = 6;
            Constants.maxPrecisionOfStats = 4;
            Constants.maxNumberOfRowsToDisplay = 100;
            Constants.typesToNotReducePrecision = ["System.Int32", "System.Int64"];
        })(Constants = Visualization.Constants || (Visualization.Constants = {}));
    })(Visualization = ExperimentEditor.Visualization || (ExperimentEditor.Visualization = {}));
})(ExperimentEditor || (ExperimentEditor = {}));
var ExperimentEditor;
(function (ExperimentEditor) {
    var Visualization;
    (function (Visualization) {
        var ColumnViewModel = (function () {
            function ColumnViewModel(name, graphControl, minimizedGraph, columnStatistics) {
                this.selected = ko.observable(false);
                this.name = name;
                this.graphControl = graphControl;
                this.minimizedGraph = minimizedGraph;
                this.columnStatistics = ko.observableArray(columnStatistics);
            }
            return ColumnViewModel;
        })();
        Visualization.ColumnViewModel = ColumnViewModel;
        var SnapshotViewModel = (function () {
            function SnapshotViewModel(feature) {
                this.feature = feature;
                this.visible = ko.observable(true);
                this.animationDuration = Visualization.Constants.transitionDuration;
            }
            return SnapshotViewModel;
        })();
        Visualization.SnapshotViewModel = SnapshotViewModel;
        function reduceToFixedPrecision(value, precision) {
            return parseFloat(value.toFixed(precision));
        }
        Visualization.reduceToFixedPrecision = reduceToFixedPrecision;
        var DataTableViewModel = (function () {
            function DataTableViewModel(datatable, numColumnsToDisplay) {
                this.numberOfColumns = datatable.numberOfColumns;
                this.numberOfRows = datatable.numberOfRows;
                // crop number of rows and columns if necessary and
                // map cells containing { isNan: true } to "NaN"
                var numberOfRowsToDisplay = Math.min(datatable.records.length, Visualization.Constants.maxNumberOfRowsToDisplay);
                var columns = datatable.features;
                this.records = new Array(numberOfRowsToDisplay);
                for (var i = 0; i < numberOfRowsToDisplay; ++i) {
                    var rowIn = datatable.records[i];
                    var length = Math.min(numColumnsToDisplay, rowIn.length);
                    var rowOut = new Array(length);
                    for (var j = 0; j < length; ++j) {
                        var cellValueIn = rowIn[j];
                        var cellValueOut;
                        if (!cellValueIn) {
                            cellValueOut = cellValueIn;
                        }
                        else if (cellValueIn.isNan) {
                            cellValueOut = DataLab.LocalizedResources.visualizationNaN;
                        }
                        else if (cellValueIn.isInf) {
                            cellValueOut = DataLab.LocalizedResources.visualizationInfinity;
                        }
                        else {
                            var shouldReducePrecision = typeof cellValueIn === "number" && Visualization.Constants.typesToNotReducePrecision.indexOf(columns[j].elementType) === -1;
                            cellValueOut = shouldReducePrecision ? reduceToFixedPrecision(cellValueIn, Visualization.Constants.maxPrecision) : cellValueIn;
                        }
                        rowOut[j] = cellValueOut;
                    }
                    this.records[i] = rowOut;
                }
            }
            return DataTableViewModel;
        })();
        Visualization.DataTableViewModel = DataTableViewModel;
        var VisualizationViewModel = (function (_super) {
            __extends(VisualizationViewModel, _super);
            function VisualizationViewModel(datatable, stats, layout) {
                var _this = this;
                _super.call(this);
                this.datatable = datatable;
                this.snapshots = ko.observableArray();
                this.entireDatasetIsPresent = true;
                this.statsDataTable = stats;
                this.statsAndGraphsIsCollapsed = ko.observable(false);
                this.statsIsCollapsed = ko.observable(false);
                this.visualizationIsCollapsed = ko.observable(false);
                this.statsAndGraphsIsCollapsed.subscribe(this.createHeightOfResizeBarSubscription(0, function (isCollapsed) {
                    return isCollapsed ? 0 : null;
                }));
                this.statsIsCollapsed.subscribe(this.createHeightOfResizeBarSubscription(0));
                this.visualizationIsCollapsed.subscribe(this.createHeightOfResizeBarSubscription(0));
                if (DataLab.Util.first(layout.records, function (r) {
                    return r.filter(function (rr) {
                        return rr != null;
                    }).length > 0;
                }, null)) {
                    this.entireDatasetIsPresent = false;
                }
                this.layout = this.entireDatasetIsPresent ? null : layout;
                var numericFeatures = DataLab.Util.map(DataLab.Util.filter(datatable.features, function (f) {
                    return DataLab.DataContract.isNumericFeature(f.featureType);
                }), function (f) {
                    return f.name;
                });
                numericFeatures.unshift("None");
                this.featureNames = DataLab.Util.map(datatable.features, function (f) {
                    return f.name;
                });
                this.featureNames.unshift("None");
                var featureTypes = DataLab.Util.map(datatable.features, function (f) {
                    return f.featureType;
                });
                this.minimizedGraphsTypeEnum = ko.observable(0 /* Histogram */);
                this.minimizedGraphsType = ko.computed(function () {
                    return Visualization.GraphType[_this.minimizedGraphsTypeEnum()];
                });
                this.addFeatureTypeToStatsTable(featureTypes);
                var numColumnsToDisplay = this.entireDatasetIsPresent ? this.datatable.numberOfColumns : this.layout.records.length;
                this.columns = ko.observableArray(this.constructColumnViewModels(numColumnsToDisplay));
                this.dataTableViewModel = new DataTableViewModel(datatable, numColumnsToDisplay);
                this.graphControl = ko.observable(Visualization.NullGraph);
                this.currentSelectedColumnIndex = ko.observable(-1);
                this.columnIsSelected = ko.computed(function () {
                    return _this.currentSelectedColumnIndex() >= 0;
                });
                this.currentSelectedColumnViewModel = ko.computed(function () {
                    if (_this.columnIsSelected()) {
                        return _this.columns()[_this.currentSelectedColumnIndex()];
                    }
                    else {
                        return null;
                    }
                });
                this.parametersAreVisible = ko.computed(function () {
                    return _this.entireDatasetIsPresent && _this.graphControl().parametersVisible() && _this.columnIsSelected();
                });
            }
            VisualizationViewModel.prototype.constructColumnViewModels = function (numColumnsToDisplay) {
                var _this = this;
                var columnViewModels = [];
                this.datatable.features.forEach(function (feature) {
                    if (!_this.entireDatasetIsPresent) {
                        if (feature.index >= numColumnsToDisplay) {
                            return;
                        }
                    }
                    var columnGraphControl = new Visualization.GraphControlViewModel(_this.featureNames, _this.datatable, _this.datatable.features[feature.index], _this.layout);
                    columnGraphControl.crossCompareFeature.subscribe(_this.createHeightOfResizeBarSubscription(0));
                    var minimizedGraphViewModel = _this.constructMinimizedGraphViewModel(feature.index);
                    var columnStatistics = _this.constructColumnStatistics(feature.index);
                    columnViewModels.push(new ColumnViewModel(feature.name, columnGraphControl, minimizedGraphViewModel, columnStatistics));
                });
                return columnViewModels;
            };
            VisualizationViewModel.prototype.constructMinimizedGraphViewModel = function (featureIndex) {
                var minimizedGraphViewModel = new Visualization.D3GraphViewModel(this.minimizedGraphsTypeEnum(), ko.observable(false), ko.observable(false), ko.observable(10), ko.observable(0), ko.observable(false), ko.observable(false), this.datatable, this.datatable.features[featureIndex], ko.observable(null), this.layout, featureIndex);
                this.minimizedGraphsTypeEnum.subscribe(function (val) {
                    minimizedGraphViewModel.graphType(val);
                });
                return minimizedGraphViewModel;
            };
            VisualizationViewModel.prototype.constructColumnStatistics = function (featureIndex) {
                var _this = this;
                var statNames = this.statsDataTable.features.map(function (feature) {
                    return feature.name;
                });
                var columnStats = this.statsDataTable.records[featureIndex];
                return columnStats.map(function (element, index) {
                    var statValue = element && element.toFixed ? reduceToFixedPrecision(element, Visualization.Constants.maxPrecisionOfStats) : element;
                    var statName = _this.getStatisticName(statNames[index]);
                    return {
                        name: statName,
                        value: statValue
                    };
                }).filter(function (stat) {
                    return !stat.value.isNan;
                });
            };
            VisualizationViewModel.prototype.getStatisticName = function (name) {
                var resources = DataLab.LocalizedResources;
                switch (name) {
                    case "Mean":
                        return resources.visualizationStatisticMean;
                    case "Median":
                        return resources.visualizationStatisticMedian;
                    case "Min":
                        return resources.visualizationStatisticMin;
                    case "Max":
                        return resources.visualizationStatisticMax;
                    case "Standard Deviation":
                        return resources.visualizationStatisticStandardDeviation;
                    case "Unique Values":
                        return resources.visualizationStatisticUniqueValues;
                    case "Missing Values":
                        return resources.visualizationStatisticMissingValues;
                    case "Feature Type":
                        return resources.visualizationStatisticFeatureType;
                    default:
                        return name;
                }
            };
            VisualizationViewModel.prototype.selectColumn = function (viewModel, event) {
                this.setHeightOfResizeBar(Visualization.Constants.transitionDuration);
                var targetElement = $(event.target).closest("td,th");
                var targetIndex = targetElement.parent().find("td,th").index(targetElement) - 1;
                if (targetIndex !== undefined && targetIndex >= 0) {
                    this.statsAndGraphsIsCollapsed(false);
                    if (!event.ctrlKey) {
                        Shell.Diagnostics.Telemetry.customEvent("ClickOnColumnToSelect", "Visualize", this.columns()[targetIndex].name);
                        this.columns().forEach(function (c) {
                            c.selected(false);
                        });
                        this.columns()[targetIndex].selected(true);
                        this.graphControl(this.columns()[targetIndex].graphControl);
                        var previousColumnIndex = this.currentSelectedColumnIndex();
                        this.currentSelectedColumnIndex(targetIndex);
                        if (targetIndex !== previousColumnIndex) {
                            this.setSelectedColumnStyle(targetIndex, previousColumnIndex);
                        }
                    }
                    else if (this.columnIsSelected()) {
                        Shell.Diagnostics.Telemetry.customEvent("CtrlClickOnColumnToCompareTo", "Visualize", this.datatable.features[targetIndex].name);
                        if (this.entireDatasetIsPresent) {
                            this.graphControl().setCrossCompareFeature(this.datatable.features[targetIndex].name);
                        }
                    }
                }
            };
            VisualizationViewModel.prototype.setSelectedColumnStyle = function (columnIndex, previousIndex) {
                var numberOfPlaceholderColumns = 1;
                var numberOfColumns = this.columns().length + numberOfPlaceholderColumns;
                var generateSelector = function (index) {
                    var adjustedColumnIndex = (index + numberOfPlaceholderColumns + 1) % numberOfColumns;
                    return DataLab.Util.format("#dataTable td:nth-of-type({0})", numberOfColumns + "n+" + adjustedColumnIndex);
                };
                var currentColumnSelector = generateSelector(columnIndex);
                var previousColumnSelector = generateSelector(previousIndex);
                $(currentColumnSelector).addClass("selected");
                $(previousColumnSelector).removeClass("selected");
            };
            VisualizationViewModel.prototype.setHeightOfResizeBar = function (delay, height) {
                if (height === void 0) { height = null; }
                setTimeout(function () {
                    var newHeight = height === null ? Math.max($('.statsAndGraphs .statsAndGraphsContent').height() + $('.statsAndGraphs .statsAndGraphsExpander').height(), $('.statsAndGraphs').height()) : height;
                    $('.statsAndGraphs .resize').height(newHeight);
                }, delay);
            };
            VisualizationViewModel.prototype.createHeightOfResizeBarSubscription = function (delay, heightComputation) {
                var _this = this;
                if (heightComputation === void 0) { heightComputation = null; }
                return function (value) {
                    return _this.setHeightOfResizeBar(delay, heightComputation !== null ? heightComputation(value) : null);
                };
            };
            VisualizationViewModel.prototype.setGraphType = function (graphType) {
                this.minimizedGraphsTypeEnum(graphType);
                this.columns().forEach(function (column) {
                    column.graphControl.setGraphType(graphType);
                });
            };
            VisualizationViewModel.prototype.setHistogramMode = function () {
                this.setGraphType(0 /* Histogram */);
                Shell.Diagnostics.Telemetry.featureUsage(25 /* HistogramMode */, 24 /* Visualization */, null, null, null, null);
            };
            VisualizationViewModel.prototype.setBoxchartMode = function () {
                this.setGraphType(1 /* BoxPlot */);
                Shell.Diagnostics.Telemetry.featureUsage(26 /* BoxchartMode */, 24 /* Visualization */, null, null, null, null);
            };
            VisualizationViewModel.prototype.takeSnapshot = function () {
                this.snapshots.unshift(new SnapshotViewModel(this.graphControl().feature));
                Shell.Diagnostics.Telemetry.customEvent("TakeSnapshot", "Visualize");
            };
            VisualizationViewModel.prototype.closeSnapshot = function (viewModel, e) {
                viewModel.visible(false);
                this.snapshots.remove(viewModel);
                Shell.Diagnostics.Telemetry.customEvent("CloseSnapshot", "Visualize");
            };
            VisualizationViewModel.prototype.addFeatureTypeToStatsTable = function (featureTypes) {
                var stats = this.statsDataTable;
                for (var i = 0; i < stats.records.length; i++) {
                    stats.records[i].push(featureTypes[i]);
                }
                stats.features.push({
                    featureType: "String",
                    name: "Feature Type",
                    elementType: "",
                    index: stats.features.length
                });
            };
            return VisualizationViewModel;
        })(DataLab.Util.Disposable);
        Visualization.VisualizationViewModel = VisualizationViewModel;
    })(Visualization = ExperimentEditor.Visualization || (ExperimentEditor.Visualization = {}));
})(ExperimentEditor || (ExperimentEditor = {}));

var ExperimentEditor;
(function (ExperimentEditor) {
    var CustomUX;
    (function (CustomUX) {
        var Constants;
        (function (Constants) {
            Constants.DarkBlue = "#3C679A";
            Constants.DarkRed = "#9D3D3A";
            Constants.Green = "#7D9844";
            Constants.Turquoise = "#668C83";
            Constants.Blue = "#388CA2";
            Constants.BurntOrange = "#CB7833";
            Constants.Red = "#BE4B48";
            Constants.DarkGreen = "#98B984";
            Constants.Purple = "#7D60A0";
            Constants.Teal = "#46AAC5";
            Constants.Orange = "#F69240";
            Constants.LightBlue = "#A5B6D3";
            Constants.LightRed = "#D5A5A4";
            Constants.LightGreen = "#C1D2A7";
            Constants.LightPurple = "#B6ABC5";
            Constants.Grey = "#F0F0F0";
            Constants.ColorTable = [Constants.DarkBlue, Constants.DarkRed, Constants.Green, Constants.Turquoise, Constants.Blue, Constants.BurntOrange, Constants.Red, Constants.DarkGreen, Constants.Purple, Constants.Teal, Constants.Orange, Constants.LightBlue, Constants.LightRed, Constants.LightGreen, Constants.LightPurple];
        })(Constants = CustomUX.Constants || (CustomUX.Constants = {}));
    })(CustomUX = ExperimentEditor.CustomUX || (ExperimentEditor.CustomUX = {}));
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="Constants.ts" />
/// <reference path="../../Global.ts" />
/// <reference path="../../../TypeScriptLib/d3.d.ts"/>
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var ExperimentEditor;
(function (ExperimentEditor) {
    var CustomUX;
    (function (CustomUX) {
        var PlotContainerViewModel = (function (_super) {
            __extends(PlotContainerViewModel, _super);
            function PlotContainerViewModel(plots) {
                var _this = this;
                _super.call(this);
                this.rocPlot = {
                    plotName: DataLab.LocalizedResources.rocPlotName,
                    xAxisLabel: DataLab.LocalizedResources.rocPlotXAxis,
                    yAxisLabel: DataLab.LocalizedResources.rocPlotYAxis,
                    xScale: null,
                    yScale: null
                };
                this.prPlot = {
                    plotName: DataLab.LocalizedResources.prPlotName,
                    xAxisLabel: DataLab.LocalizedResources.prPlotXAxis,
                    yAxisLabel: DataLab.LocalizedResources.prPlotYAxis,
                    xScale: null,
                    yScale: null
                };
                this.liftPlot = {
                    plotName: DataLab.LocalizedResources.liftPlotName,
                    xAxisLabel: DataLab.LocalizedResources.liftPlotXAxis,
                    yAxisLabel: DataLab.LocalizedResources.liftPlotYAxis,
                    xScale: null,
                    yScale: null
                };
                this.padding = 50;
                this.plotAreaWidth = 500;
                this.plotAreaHeight = 500;
                this.plotViewModels = plots;
                var plotDescriptions = [this.rocPlot, this.prPlot, this.liftPlot];
                this.chartNames = ko.observableArray(plotDescriptions.map(function (plot) {
                    return plot.plotName;
                }));
                this.colors = ko.observableArray(CustomUX.Constants.ColorTable);
                this.chartNameToDescription = {};
                for (var i = 0; i < plotDescriptions.length; i++) {
                    this.chartNameToDescription[plotDescriptions[i].plotName] = plotDescriptions[i];
                }
                this.currentChart = ko.observable(this.rocPlot.plotName);
                this.xAxisLabel = ko.computed(function () {
                    return _this.chartNameToDescription[_this.currentChart()].xAxisLabel;
                });
                this.yAxisLabel = ko.computed(function () {
                    return _this.chartNameToDescription[_this.currentChart()].yAxisLabel;
                });
                var getAllPlotsByName = function (plotName) {
                    return _this.plotViewModels.map(function (viewModel) {
                        return viewModel.getCurrentChart(plotName);
                    });
                };
                this.plotData = ko.computed(function () {
                    return getAllPlotsByName(_this.currentChart());
                });
                this.height = ko.observable(this.plotAreaHeight);
                this.width = ko.observable(this.plotAreaWidth);
                DataLab.Util.forEach(plotDescriptions, function (description) {
                    var plots = getAllPlotsByName(description.plotName);
                    var getAllDataValuesByIndex = function (index) {
                        return plots.map(function (plot) {
                            return plot.data.map(function (valuePair) {
                                return valuePair[index];
                            });
                        }).reduce(function (prev, current) {
                            return prev.concat(current);
                        });
                    };
                    var xValues = getAllDataValuesByIndex(0);
                    var yValues = getAllDataValuesByIndex(1);
                    var xDomain;
                    var yDomain;
                    if (description === _this.liftPlot) {
                        xDomain = [d3.min(xValues), d3.max(xValues)];
                        yDomain = [d3.min(yValues), d3.max(yValues)];
                    }
                    else {
                        xDomain = [0, 1];
                        yDomain = [0, 1];
                    }
                    description.xScale = d3.scale.linear().domain(xDomain).range([_this.padding, _this.width() - _this.padding]);
                    description.yScale = d3.scale.linear().domain(yDomain).range([_this.height() - _this.padding, _this.padding]);
                });
                this.xScale = ko.computed(function () {
                    return _this.chartNameToDescription[_this.currentChart()].xScale;
                });
                this.yScale = ko.computed(function () {
                    return _this.chartNameToDescription[_this.currentChart()].yScale;
                });
                this.setCurrentChart = (function (chartName) {
                    _this.currentChart(chartName);
                });
                this.setCurrentChart(this.rocPlot.plotName);
                this.svgLineFunction = ko.computed(function () {
                    return d3.svg.line().x(function (data) {
                        return _this.xScale()(data[0]);
                    }).y(function (data) {
                        return _this.yScale()(data[1]);
                    }).interpolate("linear");
                });
            }
            PlotContainerViewModel.prototype.drawAxes = function (xScale, yScale, chartType) {
                var plotSvg = d3.select(".chartArea");
                plotSvg.selectAll(".axis").remove();
                plotSvg.selectAll(".gridLine").remove();
                var xAxis = d3.svg.axis().scale(xScale).orient("bottom");
                var yAxis = d3.svg.axis().scale(yScale).orient("left");
                plotSvg.insert("g", ":first-child").attr("class", "axis").attr("id", "xAxis").attr("transform", "translate(0," + (this.height() - this.padding) + ")").call(xAxis);
                plotSvg.insert("g", ":first-child").attr("class", "axis").attr("id", "yAxis").attr("transform", "translate(" + this.padding + ",0)").call(yAxis);
                plotSvg.insert("g", ":first-child").attr("class", "gridLine").attr("transform", "translate(0," + (this.height() - this.padding) + ")").call(xAxis.tickSize(-(this.height() - 2 * this.padding), 0, 0).tickFormat(""));
                plotSvg.insert("g", ":first-child").attr("class", "gridLine").attr("transform", "translate(" + this.padding + ",0)").call(yAxis.tickSize(-(this.width() - 2 * this.padding), 0, 0).tickFormat(""));
                if (chartType === "roc") {
                    plotSvg.insert("path", ":first-child").attr("class", "gridLine diagonalGridLine").attr("d", "M " + xScale.range()[0] + " " + yScale.range()[0] + " L " + xScale.range()[1] + " " + yScale.range()[1]);
                }
            };
            return PlotContainerViewModel;
        })(DataLab.Util.Disposable);
        CustomUX.PlotContainerViewModel = PlotContainerViewModel;
        ko.bindingHandlers["d3Axes"] = {
            init: function () {
            },
            update: function (element, valueAccessor, allBindingsAccessor, targetViewModel, bindingContext) {
                var viewModel = bindingContext.$data;
                viewModel.drawAxes(valueAccessor().xScale, valueAccessor().yScale, viewModel.currentChart());
            }
        };
    })(CustomUX = ExperimentEditor.CustomUX || (ExperimentEditor.CustomUX = {}));
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="BinaryClassificationUX.ts" />
/// <reference path="PlotContainerViewModel.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var ExperimentEditor;
(function (ExperimentEditor) {
    var CustomUX;
    (function (CustomUX) {
        var BinaryClassificationComparisonUXViewModel = (function (_super) {
            __extends(BinaryClassificationComparisonUXViewModel, _super);
            function BinaryClassificationComparisonUXViewModel(parsedData) {
                var _this = this;
                _super.call(this);
                this.loaded = ko.observable(false);
                var reports = parsedData.reports;
                this.viewModels = [];
                for (var i = 0; i < reports.length; i++) {
                    this.viewModels.push(new CustomUX.BinaryClassificationUXViewModel(reports[i]));
                }
                this.currentViewModelIndex = ko.observable(0);
                this.currentViewModel = ko.computed(function () {
                    return _this.viewModels[_this.currentViewModelIndex()];
                });
                this.setCurrentViewModelIndex = (function (index) {
                    _this.currentViewModelIndex(index);
                });
                var plots = this.viewModels.map(function (report) { return report.plotViewModel; });
                this.plotContainer = ko.observable(new CustomUX.PlotContainerViewModel(plots));
                this.loaded(true);
            }
            return BinaryClassificationComparisonUXViewModel;
        })(DataLab.Util.Disposable);
        CustomUX.BinaryClassificationComparisonUXViewModel = BinaryClassificationComparisonUXViewModel;
    })(CustomUX = ExperimentEditor.CustomUX || (ExperimentEditor.CustomUX = {}));
})(ExperimentEditor || (ExperimentEditor = {}));

var ExperimentEditor;
(function (ExperimentEditor) {
    var D3Graph;
    (function (D3Graph) {
        var Constants;
        (function (Constants) {
            Constants.numericAxisLabelPrecision = 2;
            Constants.defaultBinCount = 10;
            Constants.defaultCategoryCount = 5;
        })(Constants = D3Graph.Constants || (D3Graph.Constants = {}));
    })(D3Graph = ExperimentEditor.D3Graph || (ExperimentEditor.D3Graph = {}));
})(ExperimentEditor || (ExperimentEditor = {}));
var ExperimentEditor;
(function (ExperimentEditor) {
    var D3Graph;
    (function (D3Graph) {
        D3Graph.Scales = [
            {
                name: "linear",
                index: 0,
                label: "{0}",
                func: function (d) {
                    return d;
                }
            },
            {
                name: "log",
                index: 1,
                label: "log({0})",
                func: function (d) {
                    return Math.log(d);
                }
            }
        ];
        // converts an object's key/value pairs to an array of properties
        function ObjectToArray(object) {
            var array = [];
            for (var property in object) {
                if (object.hasOwnProperty(property)) {
                    var nameValue = new Object();
                    nameValue.name = property;
                    nameValue.value = object[property];
                    array.push(nameValue);
                }
            }
            return array;
        }
        D3Graph.ObjectToArray = ObjectToArray;
        // for every unique value that occurs in "array", returns an array of those values 
        // "accessor" is a function that is applied to each element of "array" when comparing to other elements for uniqueness
        function UniqueValueCounts(array, accessor) {
            var counts = array.reduce(function (tempCounts, current) {
                var currentCountsArray = tempCounts[accessor(current)];
                if (currentCountsArray) {
                    currentCountsArray.push(current);
                }
                else {
                    tempCounts[accessor(current)] = [current];
                }
                return tempCounts;
            }, {});
            return counts;
        }
        D3Graph.UniqueValueCounts = UniqueValueCounts;
        // formats the numeric "axisLabel" to a fixed precision
        function NumericAxisFormatter(axisLabel) {
            if (axisLabel.toString().length >= 5) {
                return d3.format("0." + D3Graph.Constants.numericAxisLabelPrecision + "g")(axisLabel);
            }
            else {
                return axisLabel;
            }
        }
        D3Graph.NumericAxisFormatter = NumericAxisFormatter;
        // formats the string "axisLabel" to a fixed length
        function CategoricalAxisFormatter(axisLabel) {
            if (axisLabel.toString().length >= 11) {
                return axisLabel.toString().slice(0, 8) + "...";
            }
            else {
                return axisLabel;
            }
        }
        D3Graph.CategoricalAxisFormatter = CategoricalAxisFormatter;
        // appends svg elements corresponding to "xAxis" and "yAxis" to "svg"
        function AddAxes(svg, xAxis, yAxis, height, blPadding) {
            if (xAxis) {
                svg.append("g").attr("class", "axis").attr("id", "xAxis").attr("transform", "translate(0," + (height - blPadding) + ")").call(xAxis).selectAll("text").style("text-anchor", "end").attr("dy", ".65em").attr("transform", function (d) {
                    return "rotate(-35)";
                });
            }
            if (yAxis) {
                svg.append("g").attr("class", "axis").attr("id", "yAxis").attr("transform", "translate(" + blPadding + ",0)").call(yAxis);
            }
        }
        D3Graph.AddAxes = AddAxes;
        // appends axis labels to "svg"
        function AddAxisLabels(svg, xLabel, yLabel, height, width, blPadding, trPadding) {
            svg.append("text").attr("text-anchor", "middle").attr("x", blPadding + (width - blPadding - trPadding) / 2).attr("y", height - blPadding / 20).attr("class", "graphText").text(xLabel);
            svg.append("text").attr("text-anchor", "middle").attr("x", blPadding / 4).attr("y", height / 2 - trPadding / 2).attr("transform", "rotate(-90 " + (blPadding / 4) + "," + (height / 2 - trPadding / 2) + ")").attr("class", "graphText").text(yLabel);
        }
        D3Graph.AddAxisLabels = AddAxisLabels;
        // returns a string representing "scale" applied to "feature"
        function GenerateAxisLabel(feature, scale) {
            return scale.label.replace("{0}", feature.name);
        }
        D3Graph.GenerateAxisLabel = GenerateAxisLabel;
        // bins the dataset into categories by the categorical feature "feature"
        // the "numBins" most-populated categories will be returned 
        // if "withOtherBin" is true, all categories beyond the first "numBins" categories will be aggregated into a separate category labeled "Other"
        function CategoricalHistogramBins(dataset, feature, numBins, withOtherBin) {
            var featureIndex = feature.index;
            var values = ObjectToArray(UniqueValueCounts(dataset, function (d) {
                return d[featureIndex];
            }));
            // sort by number of elements per category, in descending order 
            values = values.sort(function (a, b) {
                return b.value.length - a.value.length;
            });
            // place the data into bins
            var bins = [];
            for (var i = 0; i < values.length; i++) {
                if (i === numBins && withOtherBin) {
                    var otherBin = new Object();
                    otherBin.x = "Other";
                    otherBin.dx = "";
                    otherBin.y = values[i].value.length;
                    otherBin.name = "Other";
                    otherBin.data = values[i].value;
                    bins.push(otherBin);
                }
                else if (i === numBins && !withOtherBin) {
                    break;
                }
                else if (i > numBins) {
                    bins[numBins].y += values[i].value.length;
                    bins[numBins].data.concat(values[i].value);
                }
                else {
                    var bin = new Object();
                    bin.x = values[i].name;
                    bin.dx = "";
                    bin.y = values[i].value.length;
                    bin.name = values[i].name;
                    bin.data = values[i].value;
                    bins.push(bin);
                }
            }
            return bins;
        }
        D3Graph.CategoricalHistogramBins = CategoricalHistogramBins;
        function BoxplotLayout(data) {
            // compute quartiles
            var quartileScale = d3.scale.quantile().domain(data).range([0, 1, 2, 3]);
            var quartiles = quartileScale.quantiles();
            // compute interquartile range and whisker bounds
            var firstQuartile = quartiles[0];
            var median = quartiles[1];
            var thirdQuartile = quartiles[2];
            var IQR = thirdQuartile - firstQuartile;
            var upperWhiskerBound = thirdQuartile + 1.5 * IQR;
            var lowerWhiskerBound = firstQuartile - 1.5 * IQR;
            // compute outliers and whisker endpoints
            var outliers = [];
            var sortedData = data.sort(d3.ascending);
            var index = 0;
            while (sortedData[index] < lowerWhiskerBound) {
                outliers.push(sortedData[index]);
                index++;
            }
            var lowestDataPointWithinLowerBound = sortedData[index]; // i.e. bottom whisker endpoint
            index = sortedData.length - 1;
            while (sortedData[index] > upperWhiskerBound) {
                outliers.push(sortedData[index]);
                index--;
            }
            var highestDataPointWithinUpperBound = sortedData[index]; // i.e. top whisker endpoint
            // return relevant data in layout
            var boxplotLayout = new Object();
            boxplotLayout["median"] = median;
            boxplotLayout["boxBottom"] = firstQuartile;
            boxplotLayout["boxTop"] = thirdQuartile;
            boxplotLayout["whiskerBottom"] = lowestDataPointWithinLowerBound;
            boxplotLayout["whiskerTop"] = highestDataPointWithinUpperBound;
            boxplotLayout["outliers"] = outliers;
            return boxplotLayout;
        }
        D3Graph.BoxplotLayout = BoxplotLayout;
        // appends svg boxplot elements centered at "midpoint" to "svg" with the given boxplot parameters
        function CreateBoxplotElements(svg, boxplot, yScale, midpoint, boxWidth, whiskerWidth, minimized) {
            var className = minimized ? "minimizedBoxplot" : "boxplot";
            var startY = yScale(boxplot.boxTop);
            var duration = minimized ? 0 : 500;
            // whiskers
            svg.append("line").attr("class", className).attr("x1", midpoint).attr("y1", startY).attr("x2", midpoint).attr("y2", startY).transition().attr("y1", yScale(boxplot.whiskerBottom)).attr("y2", yScale(boxplot.whiskerTop)).duration(duration);
            svg.append("line").attr("class", className).attr("x1", midpoint - whiskerWidth / 2).attr("y1", startY).attr("x2", midpoint + whiskerWidth / 2).attr("y2", startY).transition().attr("y1", yScale(boxplot.whiskerBottom)).attr("y2", yScale(boxplot.whiskerBottom)).duration(duration);
            svg.append("line").attr("class", className).attr("x1", midpoint - whiskerWidth / 2).attr("y1", startY).attr("x2", midpoint + whiskerWidth / 2).attr("y2", startY).transition().attr("y1", yScale(boxplot.whiskerTop)).attr("y2", yScale(boxplot.whiskerTop)).duration(duration);
            // box
            svg.append("rect").attr("class", className).attr("x", midpoint - boxWidth / 2).attr("y", yScale(boxplot.boxTop)).attr("width", boxWidth).attr("height", 0).transition().attr("height", yScale(boxplot.boxBottom) - yScale(boxplot.boxTop)).duration(duration);
            // median
            svg.append("line").attr("class", className).attr("x1", midpoint - boxWidth / 2).attr("y1", startY).attr("x2", midpoint + boxWidth / 2).attr("y2", startY).transition().attr("y1", yScale(boxplot.median)).attr("y2", yScale(boxplot.median)).duration(duration);
            // outliers
            svg.selectAll("circle").data(boxplot.outliers).enter().append("circle").attr("class", "scatterplotPoint").attr("cx", midpoint).attr("cy", function (d) {
                return yScale(d);
            }).attr("r", 0).transition().attr("r", minimized ? 1 : 3).duration(duration).delay(minimized ? 0 : 300);
        }
        D3Graph.CreateBoxplotElements = CreateBoxplotElements;
        var CrosstabLayout = (function () {
            function CrosstabLayout(data, xFeature, yFeature) {
                var groupedByXFeature = ObjectToArray(UniqueValueCounts(data, function (d) {
                    return d[xFeature.index];
                }));
                var groupedByYFeature = ObjectToArray(UniqueValueCounts(data, function (d) {
                    return d[yFeature.index];
                }));
                var groupedByXFeatureThenYFeature = groupedByXFeature.map(function (xGroup) {
                    return {
                        xValueName: xGroup.name,
                        yValues: (ObjectToArray(UniqueValueCounts(xGroup.value, function (d) {
                            return d[yFeature.index];
                        }))).map(function (yGroup) {
                            return {
                                xValueName: xGroup.name,
                                yValueName: yGroup.name,
                                count: yGroup.value.length,
                                percentOfTotal: yGroup.value.length / data.length
                            };
                        })
                    };
                });
                // flatten to a 1-dimensional array of instances
                this.instances = groupedByXFeatureThenYFeature.reduce(function (accumulatedInstances, xGroup) {
                    return accumulatedInstances.concat(xGroup.yValues);
                }, []);
                var mapToNames = function (category) {
                    return category.name;
                };
                this.xCategories = groupedByXFeature.map(mapToNames);
                this.yCategories = groupedByYFeature.map(mapToNames);
                this.numberOfXCategories = groupedByXFeature.length;
                this.numberOfYCategories = groupedByYFeature.length;
            }
            return CrosstabLayout;
        })();
        D3Graph.CrosstabLayout = CrosstabLayout;
    })(D3Graph = ExperimentEditor.D3Graph || (ExperimentEditor.D3Graph = {}));
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../../Global.ts" />
/// <reference path="../../../ViewModel/Visualization/VisualizationViewModel.ts" />
/// <reference path="D3Common.ts" />
var V = ExperimentEditor.Visualization;
var ExperimentEditor;
(function (ExperimentEditor) {
    var D3Graph;
    (function (D3Graph) {
        function HistogramLayout(dataset, feature, xTransform, yTransform, numBins) {
            var numericFeature = DataLab.DataContract.isNumericFeature(feature.featureType);
            var getX;
            if (numericFeature) {
                getX = function (d) {
                    return xTransform(parseFloat(d[feature.index]));
                };
            }
            else {
                getX = function (d) {
                    return d[feature.index];
                };
            }
            var numRecords;
            var bins;
            // bin the data and remove NaN values
            if (numericFeature) {
                var removeNaN = function (element, index, array) {
                    return (isFinite(array[index]));
                };
                var mappedDataset = dataset.map(getX);
                var filteredDataset = mappedDataset.filter(removeNaN);
                numRecords = filteredDataset.length;
                bins = d3.layout.histogram().bins(numBins)(filteredDataset);
            }
            else {
                var withOtherBin = false;
                numRecords = dataset.length;
                bins = D3Graph.CategoricalHistogramBins(dataset, feature, numBins, withOtherBin);
            }
            bins.NumberOfRecords = numRecords;
            return bins;
        }
        // appends the probability densisty and/or cumulative density curves to "svg"
        function CreateDfCurves(svg, height, blPadding, trPadding, bins, rectWidth, xScale, minX, maxX, graphPdf, graphCdf) {
            // create container for curves
            var distFunctions = svg.append("g");
            var numRecords = bins.NumberOfRecords;
            var dfScale = d3.scale.linear().domain([0, 1]).range([height - blPadding, trPadding]);
            var xFunc = function (offset) {
                return function (d) {
                    if (!d.endpoint) {
                        return xScale(d.x) + offset;
                    }
                    else {
                        return xScale(d.x);
                    }
                };
            };
            var pdf = d3.svg.line().x(xFunc(rectWidth / 2)).y(function (d) {
                return dfScale(d.numElements / numRecords);
            }).interpolate("basis");
            var cdf = d3.svg.area().x(xFunc(rectWidth)).y0(dfScale(0)).y1(function (d) {
                return dfScale(d.cy);
            }).interpolate("basis");
            // endpoints of the curves
            var leftPoint = {};
            leftPoint.x = minX;
            leftPoint.y = 0;
            leftPoint.numElements = 0;
            leftPoint.endpoint = true;
            var rightPoint = {};
            rightPoint.x = maxX;
            rightPoint.y = 0;
            rightPoint.numElements = 0;
            rightPoint.endpoint = true;
            var dfPoints = [leftPoint].concat(bins).concat([rightPoint]);
            for (var i = 0; i < dfPoints.length; i++) {
                var point = dfPoints[i];
                var dy = point.numElements / numRecords;
                if (i === 0)
                    point.cy = dy;
                else
                    point.cy = dfPoints[i - 1].cy + dy;
            }
            // cdf
            // start with a flat curve to transition into the actual curve
            var cdfStart = d3.svg.area().x(xFunc(rectWidth)).y0(dfScale(0)).y1(dfScale(0)).interpolate("basis");
            var cdfStartPoints = cdfStart(dfPoints);
            var cdfEndPoints = cdf(dfPoints);
            distFunctions.append("path").attr("d", cdfStartPoints).attr("class", "dfCurve cdf").attr("id", "cdfCurve").attr("data-startPoints", cdfStartPoints).attr("data-endPoints", cdfEndPoints).style("visibility", graphCdf ? "visible" : "hidden").transition().attr("d", cdfEndPoints).delay(150).duration(300);
            // pdf
            // start with a flat curve to transition into the actual curve
            var pdfStart = d3.svg.line().x(xFunc(rectWidth / 2)).y(dfScale(0)).interpolate("basis");
            var pdfStartPoints = pdfStart(dfPoints);
            var pdfEndPoints = pdf(dfPoints);
            distFunctions.append("path").attr("d", pdfStart(dfPoints)).attr("class", "dfCurve pdf").attr("id", "pdfCurve").attr("data-startPoints", pdfStartPoints).attr("data-endPoints", pdfEndPoints).style("visibility", graphPdf ? "visible" : "hidden").transition().attr("d", pdf(dfPoints)).delay(150).duration(300);
        }
        function createHistogram(svg, datatable, feature, xAxisScale, yAxisScale, binCounts, pdf, cdf, width, height, padding, layout, minimized) {
            var binCount = parseInt(binCounts);
            var trPadding = padding / 2;
            var blPadding = padding;
            var xTransform = xAxisScale.func;
            var yTransform = yAxisScale.func;
            var featureIndex = feature.index;
            var numericFeature = DataLab.DataContract.isNumericFeature(feature.featureType);
            var bins;
            if (layout) {
                // use precomputed graph layout
                var histogramLayout = layout.records[featureIndex][0]; // DataTable.GetGraphLayout(feature, "histogram");
                bins = histogramLayout.Bins;
                bins.NumberOfRecords = histogramLayout.NumberOfRecords;
            }
            else {
                // calculate layout
                bins = HistogramLayout(datatable.records, feature, xTransform, yTransform, binCount);
            }
            // apply scale to y axis and map NaN values to 0
            var tempNumRecords = bins.NumberOfRecords; // store this because the map operation removes this property from bins
            bins = bins.map(function (bin) {
                bin.numElements = bin.y;
                var scaledY = yTransform(bin.y);
                bin.y = isFinite(scaledY) ? scaledY : 0;
                return bin;
            });
            bins.NumberOfRecords = tempNumRecords;
            // adjust graph width if necessary
            var diffFromDefault = bins.length - D3Graph.Constants.defaultBinCount;
            if (diffFromDefault > 0) {
                width += diffFromDefault * 20;
                svg.attr("width", width);
            }
            // scales
            var getBinLowerBoundX = function (d) {
                return d.x;
            };
            var getBinUpperBoundX = function (d) {
                return d.x + d.dx;
            };
            var getBinY = function (d) {
                return d.y;
            };
            var minX = d3.min(bins, getBinLowerBoundX);
            var maxX = d3.max(bins, getBinUpperBoundX);
            var xScale;
            if (numericFeature) {
                xScale = d3.scale.linear().domain([minX, maxX]).range([blPadding, width - trPadding]);
            }
            else {
                xScale = d3.scale.ordinal().domain(["  "].concat(bins.map(function (d) {
                    return d.x;
                })).concat(["   "])).rangePoints([blPadding, width - trPadding]);
            }
            var yScale = d3.scale.linear().domain([0, d3.max(bins, getBinY)]).range([height - blPadding, trPadding]);
            // axes
            if (!minimized) {
                var tickValues = new Array();
                if (bins.length > 0 && numericFeature) {
                    tickValues.push(bins[0].x);
                }
                for (var i = 0; i < bins.length; i++) {
                    tickValues.push(bins[i].x + bins[i].dx);
                }
                var xAxis = d3.svg.axis().scale(xScale).tickValues(tickValues).orient("bottom");
                var yAxis = d3.svg.axis().scale(yScale).orient("left").tickFormat(D3Graph.NumericAxisFormatter);
                if (numericFeature) {
                    xAxis.tickFormat(D3Graph.NumericAxisFormatter);
                }
                else {
                    xAxis.tickFormat(D3Graph.CategoricalAxisFormatter);
                }
                D3Graph.AddAxes(svg, xAxis, yAxis, height, blPadding);
                // tooltips for x axis tick labels, since long labels are truncated
                d3.select("#xAxis").selectAll("g").selectAll("text").append("title").text(function (d) {
                    return d;
                });
                // axis labels and graph title
                var xAxisLabel = D3Graph.GenerateAxisLabel(feature, xAxisScale);
                var yAxisLabel = D3Graph.GenerateAxisLabel({ "name": "frequency" }, yAxisScale);
                D3Graph.AddAxisLabels(svg, xAxisLabel, yAxisLabel, height, width, blPadding, trPadding);
            }
            // data points
            var rectSpacing = minimized ? 1 : 6;
            var domainLength = numericFeature ? bins.length : bins.length + 2; // account for empty bins when using categorical data
            var rectWidth = ((width - blPadding - trPadding) / domainLength) - rectSpacing;
            var rects = svg.selectAll("rect").data(bins).enter().append("rect").attr("class", "histogramBar").attr("y", height - blPadding).attr("width", rectWidth).attr("height", 0);
            if (numericFeature) {
                rects.attr("x", function (d) {
                    return xScale(d.x) + (minimized ? rectSpacing : (rectSpacing / 2));
                });
            }
            else {
                rects.attr("x", function (d) {
                    return xScale(d.x) - rectWidth / 2;
                }); // center the bar over the category name
            }
            // transition the bars to their final height
            rects.transition().attr("height", function (d) {
                return height - blPadding - yScale(d.y);
            }).attr("y", function (d) {
                return yScale(d.y);
            }).duration(minimized ? 0 : 500);
            if (!minimized) {
                // tooltip
                rects.append("title").text(function (d) {
                    return d.numElements + " element" + (d.numElements === 1 ? "" : "s") + "\n" + D3Graph.NumericAxisFormatter((d.numElements / bins.NumberOfRecords) * 100) + "%";
                });
                // PDF/CDF curves
                if (numericFeature) {
                    CreateDfCurves(svg, height, blPadding, trPadding, bins, rectWidth, xScale, minX, maxX, pdf, cdf);
                }
            }
        }
        D3Graph.createHistogram = createHistogram;
    })(D3Graph = ExperimentEditor.D3Graph || (ExperimentEditor.D3Graph = {}));
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../../Global.ts" />
/// <reference path="../../../ViewModel/Visualization/VisualizationViewModel.ts" />
/// <reference path="D3Common.ts" />
var ExperimentEditor;
(function (ExperimentEditor) {
    var D3Graph;
    (function (D3Graph) {
        function createBoxplot(svg, datatable, feature, scale, width, height, padding, layout, minimized) {
            var featureIndex = feature["index"];
            var scaleFunc = scale["func"];
            var boxplot;
            var dataset = datatable.records;
            // calculate the boxplot layout
            if (layout) {
                // use precomputed graph layout
                boxplot = layout.records[featureIndex][1];
                if (!boxplot) {
                    return;
                }
            }
            else {
                var mappedDataset = dataset.map(function (d) {
                    return scaleFunc(parseFloat(d[featureIndex]));
                });
                var removeNaN = function (element, index, array) {
                    return (isFinite(array[index]));
                };
                var filteredDataset = mappedDataset.filter(removeNaN);
                boxplot = D3Graph.BoxplotLayout(filteredDataset);
            }
            // scale
            var potentialEndpoints = boxplot.outliers.concat([boxplot.whiskerBottom, boxplot.whiskerTop]);
            var minY = d3.min(potentialEndpoints);
            var maxY = d3.max(potentialEndpoints);
            var trPadding = padding / 2;
            var blPadding = padding;
            var yScale = d3.scale.linear().domain([minY, maxY]).range([height - blPadding, trPadding]);
            // axes
            if (!minimized) {
                var yAxis = d3.svg.axis().scale(yScale).orient("left").tickFormat(D3Graph.NumericAxisFormatter);
                D3Graph.AddAxes(svg, null, yAxis, height, blPadding);
                // axis labels and graph title
                var xAxisLabel = D3Graph.GenerateAxisLabel(feature, scale);
                D3Graph.AddAxisLabels(svg, xAxisLabel, "", height, width, blPadding, trPadding);
            }
            // boxplot elements
            var midpoint = blPadding + (width - blPadding - trPadding) / 2;
            var boxWidth = (width - blPadding - trPadding) / (minimized ? 4 : 6);
            var whiskerWidth = boxWidth * 0.8;
            D3Graph.CreateBoxplotElements(svg, boxplot, yScale, midpoint, boxWidth, whiskerWidth, minimized);
        }
        D3Graph.createBoxplot = createBoxplot;
    })(D3Graph = ExperimentEditor.D3Graph || (ExperimentEditor.D3Graph = {}));
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../../Global.ts" />
/// <reference path="../../../ViewModel/Visualization/VisualizationViewModel.ts" />
/// <reference path="D3Common.ts" />
var ExperimentEditor;
(function (ExperimentEditor) {
    var D3Graph;
    (function (D3Graph) {
        function createScatterplot(svg, datatable, xFeature, yFeature, xScale, yScale, width, height, padding) {
            var dataset = datatable.records;
            var xTransform = xScale.func;
            var yTransform = yScale.func;
            var trPadding = padding / 2;
            var blPadding = padding;
            var getX = function (d) {
                return xTransform(parseFloat(d[xFeature["index"]]));
            };
            var getY = function (d) {
                return yTransform(parseFloat(d[yFeature["index"]]));
            };
            // remove NaN values 
            var removeNaN = function (element, index, array) {
                return (isFinite(getX(array[index])) && isFinite(getY(array[index])));
            };
            var filteredDataset = dataset.filter(removeNaN);
            // scales
            var xAxisScale = d3.scale.linear().domain([d3.min(filteredDataset, getX), d3.max(filteredDataset, getX)]).range([blPadding, width - trPadding]);
            var yAxisScale = d3.scale.linear().domain([d3.min(filteredDataset, getY), d3.max(filteredDataset, getY)]).range([height - blPadding, trPadding]);
            // axes
            var xAxis = d3.svg.axis().scale(xAxisScale).orient("bottom").tickFormat(D3Graph.NumericAxisFormatter);
            var yAxis = d3.svg.axis().scale(yAxisScale).orient("left").tickFormat(D3Graph.NumericAxisFormatter);
            D3Graph.AddAxes(svg, xAxis, yAxis, height, blPadding);
            // axis labels
            var xAxisLabel = D3Graph.GenerateAxisLabel(xFeature, xScale);
            var yAxisLabel = D3Graph.GenerateAxisLabel(yFeature, yScale);
            D3Graph.AddAxisLabels(svg, xAxisLabel, yAxisLabel, height, width, blPadding, trPadding);
            // data points
            var circles = svg.selectAll("circle").data(filteredDataset).enter().append("circle").attr("class", "scatterplotPoint").attr("r", 0).attr("cx", function (d) {
                return xAxisScale(getX(d));
            }).attr("cy", function (d) {
                return yAxisScale(getY(d));
            });
            // transition the points in
            circles.transition().attr("r", 3).duration(500);
        }
        D3Graph.createScatterplot = createScatterplot;
    })(D3Graph = ExperimentEditor.D3Graph || (ExperimentEditor.D3Graph = {}));
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../../Global.ts" />
/// <reference path="../../../ViewModel/Visualization/VisualizationViewModel.ts" />
/// <reference path="D3Common.ts" />
var C = DataLab.DataContract;
var ExperimentEditor;
(function (ExperimentEditor) {
    var D3Graph;
    (function (D3Graph) {
        function createMultiboxplot(svg, datatable, categoricalFeature, numericFeature, numericScale, numCategoriesS, width, height, padding) {
            var numCategories = parseInt(numCategoriesS);
            var dataset = datatable.records;
            var trPadding = padding / 2;
            var blPadding = padding;
            var withOtherBin = false;
            var categories = D3Graph.CategoricalHistogramBins(dataset, categoricalFeature, numCategories, withOtherBin);
            // map each category.data (which contains data from all features) to an array containing
            // only numericFeature, remove NaN values, and apply the scale
            var numericFeatureIndex = numericFeature["index"];
            categories.map(function (category) {
                var onlyNumericFeature = category.data.map(function (d) {
                    return numericScale["func"](parseFloat(d[numericFeatureIndex]));
                });
                category.data = onlyNumericFeature.filter(function (element, index, array) {
                    return (isFinite(array[index]));
                });
                category.min = d3.min(category.data);
                category.max = d3.max(category.data);
                return category;
            });
            // adjust graph width if necessary
            var diffFromDefault = categories.length - D3Graph.Constants.defaultCategoryCount;
            if (diffFromDefault > 0) {
                width += diffFromDefault * 40;
                svg.attr("width", width);
            }
            // calculate min and max for y axis scale
            var minY = d3.min(categories.map(function (category) {
                return category.min;
            }));
            var maxY = d3.max(categories.map(function (category) {
                return category.max;
            }));
            // scales
            var xScale = d3.scale.ordinal().domain(["  "].concat(categories.map(function (d) {
                return d.name;
            })).concat(["   "])).rangePoints([blPadding, width - trPadding]);
            var yScale = d3.scale.linear().domain([minY, maxY]).range([height - blPadding, trPadding]);
            // axes
            var xAxis = d3.svg.axis().scale(xScale).orient("bottom").tickFormat(D3Graph.CategoricalAxisFormatter);
            var yAxis = d3.svg.axis().scale(yScale).orient("left").tickFormat(D3Graph.NumericAxisFormatter);
            D3Graph.AddAxes(svg, xAxis, yAxis, height, blPadding);
            // tooltips for x axis tick labels, since long labels are truncated
            d3.select("#xAxis").selectAll("g").selectAll("text").append("title").text(function (d) {
                return d;
            });
            // axis labels and graph title
            var xAxisLabel = categoricalFeature["name"];
            var yAxisLabel = D3Graph.GenerateAxisLabel(numericFeature, numericScale);
            D3Graph.AddAxisLabels(svg, xAxisLabel, yAxisLabel, height, width, blPadding, trPadding);
            var boxplotSpacing = 4;
            var boxplotWidth = (width - blPadding - trPadding - (categories.length + 2) * boxplotSpacing) / (categories.length + 2);
            var whiskerWidth = boxplotWidth * 0.8;
            for (var i = 0; i < categories.length; i++) {
                var category = categories[i];
                var subGraph = svg.append("g");
                if (category.data.length > 0) {
                    D3Graph.CreateBoxplotElements(subGraph, D3Graph.BoxplotLayout(category.data), yScale, xScale(category.x), boxplotWidth, whiskerWidth, false);
                }
            }
        }
        D3Graph.createMultiboxplot = createMultiboxplot;
    })(D3Graph = ExperimentEditor.D3Graph || (ExperimentEditor.D3Graph = {}));
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../../Global.ts" />
/// <reference path="../../../ViewModel/Visualization/VisualizationViewModel.ts" />
/// <reference path="D3Common.ts" />
var ExperimentEditor;
(function (ExperimentEditor) {
    var D3Graph;
    (function (D3Graph) {
        function createCrosstab(svg, datatable, xFeature, yFeature, xScale, yScale, width, height, padding) {
            var trPadding = padding / 2;
            var blPadding = padding + 50;
            var sideLength = 45;
            var layout = new D3Graph.CrosstabLayout(datatable.records, xFeature, yFeature);
            // adjust svg width and height if necessary
            var newWidth = sideLength * (layout.numberOfXCategories + 1) + trPadding + blPadding;
            var newHeight = sideLength * (layout.numberOfYCategories + 1) + trPadding + blPadding;
            if (newWidth > width) {
                width = newWidth;
                svg.attr("width", newWidth);
            }
            if (newHeight > height) {
                height = newHeight;
                svg.attr("height", newHeight);
            }
            // scales
            var xAxisScale = d3.scale.ordinal().domain(["  "].concat(layout.xCategories).concat(["   "])).rangePoints([blPadding, width - trPadding]);
            var yAxisScale = d3.scale.ordinal().domain(["  "].concat(layout.yCategories).concat(["   "])).rangePoints([height - blPadding, trPadding]);
            // axes
            var xAxis = d3.svg.axis().scale(xAxisScale).orient("bottom").tickFormat(D3Graph.CategoricalAxisFormatter);
            var yAxis = d3.svg.axis().scale(yAxisScale).orient("left").tickFormat(D3Graph.CategoricalAxisFormatter);
            D3Graph.AddAxes(svg, xAxis, yAxis, height, blPadding);
            // tooltips for axis tick labels, since long labels are truncated
            var axisTooltips = function (axisID) {
                d3.select(axisID).selectAll("g").selectAll("text").append("title").text(function (d) {
                    return d;
                });
            };
            axisTooltips("#xAxis");
            axisTooltips("#yAxis");
            // axis labels
            var xAxisLabel = D3Graph.GenerateAxisLabel(xFeature, xScale);
            var yAxisLabel = D3Graph.GenerateAxisLabel(yFeature, yScale);
            D3Graph.AddAxisLabels(svg, xAxisLabel, yAxisLabel, height, width, blPadding, trPadding);
            // crosstab rectangles
            var xPosition = function (offset) {
                return function (d) {
                    return xAxisScale(d.xValueName) - (offset ? 0 : sideLength / 2);
                };
            };
            var yPosition = function (offset) {
                return function (d) {
                    return yAxisScale(d.yValueName) - (offset ? 0 : sideLength / 2);
                };
            };
            var maxPercent = d3.max(layout.instances, function (d) {
                return d.percentOfTotal;
            });
            var rects = svg.append("g").selectAll("rect").data(layout.instances).enter().append("rect").attr("class", "crosstabRect").attr("width", sideLength).attr("height", sideLength).attr("fill-opacity", 0).attr("x", xPosition(false)).attr("y", yPosition(false));
            var text = svg.append("g").selectAll("text").data(layout.instances).enter().append("text").attr("class", "crosstabLabel").text(function (d) {
                return d.count;
            }).attr("x", xPosition(true)).attr("y", yPosition(true));
            // transition the rectangles in
            rects.transition().attr("fill-opacity", function (d) {
                return d.percentOfTotal / maxPercent;
            }).duration(500);
        }
        D3Graph.createCrosstab = createCrosstab;
    })(D3Graph = ExperimentEditor.D3Graph || (ExperimentEditor.D3Graph = {}));
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
/// <reference path="D3Graphing/D3Common.ts" />
/// <reference path="D3Graphing/Histogram.ts" />
/// <reference path="D3Graphing/Boxplot.ts" />
/// <reference path="D3Graphing/Scatterplot.ts" />
/// <reference path="D3Graphing/Multiboxplot.ts" />
/// <reference path="D3Graphing/Crosstab.ts" />
/// <reference path="../../ViewModel/Visualization/VisualizationViewModel.ts" />
var ExperimentEditor;
(function (ExperimentEditor) {
    var D3Graph;
    (function (D3Graph) {
        D3Graph.svgMap = Object.create(null);
        function updateProbabilityCurve(curve, visible) {
            var curveElement = d3.select(curve);
            curveElement.style("visibility", visible ? "visible" : "hidden");
            if (visible) {
                curveElement.attr("d", curveElement.attr("data-startPoints")).transition().attr("d", curveElement.attr("data-endPoints"));
            }
        }
        function CreateGraph(element, valueAccessor, targetViewModel) {
            var bindingOptions = valueAccessor();
            var viewModel = bindingOptions.data;
            if (!viewModel) {
                return;
            }
            var svgDiv = d3.select(element);
            svgDiv.select("*").remove();
            var width = bindingOptions.minWidth;
            var height = bindingOptions.height;
            var padding = bindingOptions.padding;
            var minimized = bindingOptions.minimized;
            var name = bindingOptions.name;
            var svg = svgDiv.append("svg").attr("width", width).attr("height", height).attr("class", "activeSvg");
            if (name) {
                D3Graph.svgMap[name] = $(element).find("svg")[0];
            }
            var xScale = viewModel.xlog() ? D3Graph.Scales[1] : D3Graph.Scales[0];
            var yScale = viewModel.ylog() ? D3Graph.Scales[1] : D3Graph.Scales[0];
            switch (viewModel.graphType()) {
                case 0 /* Histogram */:
                    // peek is used for probability curves so that we do not create dependencies, changing these will trigger partial update
                    ExperimentEditor.D3Graph.createHistogram(svg, viewModel.datatable, viewModel.feature, xScale, yScale, viewModel.binCount(), viewModel.probabilityDensity.peek(), viewModel.cumulativeDistibution.peek(), width, height, padding, viewModel.layout, minimized);
                    break;
                case 1 /* BoxPlot */:
                    ExperimentEditor.D3Graph.createBoxplot(svg, viewModel.datatable, viewModel.feature, xScale, width, height, padding, viewModel.layout, minimized);
                    break;
                case 2 /* ScatterPlot */:
                    ExperimentEditor.D3Graph.createScatterplot(svg, viewModel.datatable, viewModel.feature, viewModel.crossCompareFeature(), xScale, yScale, width, height, padding);
                    break;
                case 3 /* MultiboxPlot */:
                    // determine which feature is numeric and which is categorical
                    var numericFeature;
                    var categoricalFeature;
                    var numericScale;
                    if (DataLab.DataContract.isNumericFeature(viewModel.feature.featureType)) {
                        numericFeature = viewModel.feature;
                        categoricalFeature = viewModel.crossCompareFeature();
                        numericScale = yScale;
                    }
                    else {
                        numericFeature = viewModel.crossCompareFeature();
                        categoricalFeature = viewModel.feature;
                        numericScale = xScale;
                    }
                    ExperimentEditor.D3Graph.createMultiboxplot(svg, viewModel.datatable, categoricalFeature, numericFeature, numericScale, viewModel.categoryCount(), width, height, padding);
                    break;
                case 4 /* Crosstab */:
                    ExperimentEditor.D3Graph.createCrosstab(svg, viewModel.datatable, viewModel.feature, viewModel.crossCompareFeature(), xScale, yScale, width, height, padding);
                    break;
                default: break;
            }
            // partial update for probability curves
            if (!viewModel.subscribed) {
                viewModel.probabilityDensity.subscribe(function (val) {
                    updateProbabilityCurve("#pdfCurve", val);
                });
                viewModel.cumulativeDistibution.subscribe(function (val) {
                    updateProbabilityCurve("#cdfCurve", val);
                });
                viewModel.subscribed = true;
            }
        }
        D3Graph.CreateGraph = CreateGraph;
    })(D3Graph = ExperimentEditor.D3Graph || (ExperimentEditor.D3Graph = {}));
})(ExperimentEditor || (ExperimentEditor = {}));
var ExperimentEditor;
(function (ExperimentEditor) {
    ko.bindingHandlers["d3graph"] = {
        init: function (element, valueAccessor, allBindingsAccessor, targetViewModel) {
            ko.utils.domNodeDisposal.addDisposeCallback(element, function () {
                delete ExperimentEditor.D3Graph.svgMap[valueAccessor().name];
            });
        },
        update: function (element, valueAccessor, allBindingsAccessor, targetViewModel) {
            ExperimentEditor.D3Graph.CreateGraph(element, valueAccessor, targetViewModel);
        }
    };
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
/// <reference path="../ExperimentEditor/CustomUX.ts" />
/// <reference path="../../View/CustomBindingHandlers/d3graph.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var ExperimentEditor;
(function (ExperimentEditor) {
    var CustomUX;
    (function (CustomUX) {
        var MulticlassConfusionMatrixViewModel = (function (_super) {
            __extends(MulticlassConfusionMatrixViewModel, _super);
            function MulticlassConfusionMatrixViewModel(matrix) {
                var _this = this;
                _super.call(this);
                this.sideLength = 60;
                this.superHeaderPadding = 80;
                this.headerPadding = 100;
                this.rightPadding = 80;
                this.degreeOfRotation = 35;
                this.precision = 6;
                var hasMetrics = matrix.averageAccuracy !== undefined;
                if (hasMetrics) {
                    this.createMetricsTable(matrix);
                }
                this.showMetrics = ko.observable(hasMetrics);
                this.metricsIsCollapsed = ko.observable(false);
                this.confusionMatrixIsCollapsed = ko.observable(false);
                var totalPadding = this.superHeaderPadding + this.headerPadding + this.rightPadding;
                var computeDimension = ko.computed(function () {
                    return totalPadding + (_this.sideLength * matrix.classLabels.length);
                });
                this.height = computeDimension;
                this.width = computeDimension;
                this.xAxisScale = d3.scale.ordinal().domain(matrix.classLabels).rangePoints([this.headerPadding + this.superHeaderPadding, this.width() - this.rightPadding - this.sideLength]);
                this.yAxisScale = d3.scale.ordinal().domain(matrix.classLabels).rangePoints([this.headerPadding + this.superHeaderPadding, this.height() - this.rightPadding - this.sideLength]);
                this.xClassLabels = ko.observableArray(matrix.classLabels.map(function (label) { return new LabelViewModel(label, 0, 0, "translate(" + (_this.xAxisScale(label) - _this.headerPadding / 4) + "," + _this.superHeaderPadding + ") rotate(" + _this.degreeOfRotation + ")", true); }));
                this.yClassLabels = ko.observableArray(matrix.classLabels.map(function (label) { return new LabelViewModel(label, _this.superHeaderPadding, _this.yAxisScale(label), "", true); }));
                this.instances = this.convertFrequencyMatrixToInstances(matrix.frequencyMatrix, matrix.classLabels);
                this.superHeaders = ko.observableArray([
                    new LabelViewModel(DataLab.LocalizedResources.multiclassPredictedClass, this.width() / 2, this.superHeaderPadding / 2, "", false),
                    new LabelViewModel(DataLab.LocalizedResources.multiclassActualClass, 0, 0, "translate(" + (this.superHeaderPadding / 2) + "," + (this.height() / 2) + ") rotate(-90)", false)
                ]);
            }
            MulticlassConfusionMatrixViewModel.prototype.convertFrequencyMatrixToInstances = function (frequencyMatrix, classLabels) {
                var instances = [];
                for (var i = 0; i < frequencyMatrix.length; i++) {
                    var row = frequencyMatrix[i];
                    var rowSum = row.reduce(function (previous, current) { return previous + current; });
                    for (var j = 0; j < row.length; j++) {
                        var entry = row[j];
                        if (entry !== 0 || i === j) {
                            var trueLabel = classLabels[i];
                            var predictedLabel = classLabels[j];
                            var instance = new MulticlassConfusionMatrixInstanceViewModel(trueLabel, predictedLabel, entry, rowSum !== 0 ? entry / rowSum : 0, this.xAxisScale(predictedLabel) - this.sideLength / 2, this.yAxisScale(trueLabel) - this.sideLength / 2, this.sideLength);
                            instances.push(instance);
                        }
                    }
                }
                return ko.observableArray(instances);
            };
            MulticlassConfusionMatrixViewModel.prototype.createMetricsTable = function (matrix) {
                var _this = this;
                var reducePrecision = function (value) {
                    if (value.toFixed) {
                        return ExperimentEditor.Visualization.reduceToFixedPrecision(value, _this.precision);
                    }
                    else {
                        return value;
                    }
                    ;
                };
                this.metrics = [
                    [DataLab.LocalizedResources.multiclassOverallAccuracy, reducePrecision(matrix.overallAccuracy)],
                    [DataLab.LocalizedResources.multiclassAverageAccuracy, reducePrecision(matrix.averageAccuracy)],
                    [DataLab.LocalizedResources.multiclassMicroAveragedPrecision, reducePrecision(matrix.microAveragedPrecision)],
                    [DataLab.LocalizedResources.multiclassMacroAveragedPrecision, reducePrecision(matrix.macroAveragedPrecision)],
                    [DataLab.LocalizedResources.multiclassMicroAveragedRecall, reducePrecision(matrix.microAveragedRecall)],
                    [DataLab.LocalizedResources.multiclassMacroAveragedRecall, reducePrecision(matrix.macroAveragedRecall)]
                ];
            };
            return MulticlassConfusionMatrixViewModel;
        })(DataLab.Util.Disposable);
        CustomUX.MulticlassConfusionMatrixViewModel = MulticlassConfusionMatrixViewModel;
        var MulticlassConfusionMatrixInstanceViewModel = (function () {
            function MulticlassConfusionMatrixInstanceViewModel(trueLabel, predictedLabel, frequency, fractionOfActualClass, xCoordinate, yCoordinate, sideLength) {
                this.trueLabel = ko.observable(trueLabel);
                this.predictedLabel = ko.observable(predictedLabel);
                this.frequency = ko.observable(frequency);
                this.fractionOfActualClass = ko.observable(fractionOfActualClass);
                this.percentOfActualClass = ko.observable((fractionOfActualClass * 100).toFixed(1) + "%");
                this.isMainDiagonalEntry = ko.observable(trueLabel === predictedLabel);
                this.xCoordinate = ko.observable(xCoordinate);
                this.yCoordinate = ko.observable(yCoordinate);
                this.sideLength = ko.observable(sideLength);
            }
            return MulticlassConfusionMatrixInstanceViewModel;
        })();
        CustomUX.MulticlassConfusionMatrixInstanceViewModel = MulticlassConfusionMatrixInstanceViewModel;
        var LabelViewModel = (function () {
            function LabelViewModel(label, xCoordinate, yCoordinate, transform, formatLabel) {
                this.fullLabel = ko.observable(label);
                this.label = ko.observable(formatLabel ? ExperimentEditor.D3Graph.CategoricalAxisFormatter(label) : label);
                this.xCoordinate = ko.observable(xCoordinate);
                this.yCoordinate = ko.observable(yCoordinate);
                this.transform = ko.observable(transform);
            }
            return LabelViewModel;
        })();
        CustomUX.LabelViewModel = LabelViewModel;
    })(CustomUX = ExperimentEditor.CustomUX || (ExperimentEditor.CustomUX = {}));
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
/// <reference path="../ExperimentEditor/CustomUX.ts" />
/// <reference path="MulticlassConfusionMatrixViewModel.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var ExperimentEditor;
(function (ExperimentEditor) {
    var CustomUX;
    (function (CustomUX) {
        var MulticlassClassificationUXViewModel = (function (_super) {
            __extends(MulticlassClassificationUXViewModel, _super);
            function MulticlassClassificationUXViewModel(parsedData) {
                _super.call(this);
                this.loaded = ko.observable(false);
                var matrices = parsedData.matrices;
                var matrixViewModels = matrices.map(function (matrix) {
                    return new CustomUX.MulticlassConfusionMatrixViewModel(matrix);
                });
                this.viewModels = ko.observableArray(matrixViewModels);
                this.loaded(true);
            }
            return MulticlassClassificationUXViewModel;
        })(DataLab.Util.Disposable);
        CustomUX.MulticlassClassificationUXViewModel = MulticlassClassificationUXViewModel;
    })(CustomUX = ExperimentEditor.CustomUX || (ExperimentEditor.CustomUX = {}));
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
/// <reference path="../ExperimentEditor/CustomUX.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var ExperimentEditor;
(function (ExperimentEditor) {
    var CustomUX;
    (function (CustomUX) {
        var ROutputViewModel = (function (_super) {
            __extends(ROutputViewModel, _super);
            function ROutputViewModel(rOutputData) {
                var _this = this;
                _super.call(this);
                this.pngSrcBase = "data:image/png;base64,";
                var standardOutput = {
                    label: DataLab.LocalizedResources.rOutputStandardOutput,
                    content: rOutputData["Standard Output"],
                    show: true
                };
                var standardError = {
                    label: DataLab.LocalizedResources.rOutputStandardError,
                    content: rOutputData["Standard Error"],
                    show: false
                };
                this.showGraphicsDevice = ko.observable(true);
                this.outputLogs = ko.observableArray([new OutputLogViewModel(standardOutput), new OutputLogViewModel(standardError)]);
                this.pngSrcs = ko.observableArray(rOutputData["Graphics Device"].map(function (base64Data) {
                    return _this.pngSrcBase + base64Data;
                }));
            }
            return ROutputViewModel;
        })(DataLab.Util.Disposable);
        CustomUX.ROutputViewModel = ROutputViewModel;
        var OutputLogViewModel = (function (_super) {
            __extends(OutputLogViewModel, _super);
            function OutputLogViewModel(outputLogData) {
                _super.call(this);
                this.label = ko.observable(outputLogData.label);
                this.content = ko.observable(outputLogData.content);
                this.show = ko.observable(outputLogData.show);
            }
            return OutputLogViewModel;
        })(DataLab.Util.Disposable);
        CustomUX.OutputLogViewModel = OutputLogViewModel;
    })(CustomUX = ExperimentEditor.CustomUX || (ExperimentEditor.CustomUX = {}));
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
/// <reference path="../ExperimentEditor/CustomUX.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var ExperimentEditor;
(function (ExperimentEditor) {
    var CustomUX;
    (function (CustomUX) {
        var GenericMimeViewModel = (function (_super) {
            __extends(GenericMimeViewModel, _super);
            function GenericMimeViewModel(genericMimeData) {
                _super.call(this);
                this.pngSrcBase = "data:image/png;base64,";
                var sectionViewModels = genericMimeData.sections.map(function (section) {
                    return new MimeSectionViewModel(section);
                });
                this.mimeSections = ko.observableArray(sectionViewModels);
            }
            GenericMimeViewModel.prototype.getSectionTemplateByMimeType = function (dataType) {
                switch (dataType) {
                    case "img/png;base64":
                        return "mimePngEntry";
                    case "text/plain":
                    default:
                        return "mimeTextEntry";
                }
            };
            return GenericMimeViewModel;
        })(DataLab.Util.Disposable);
        CustomUX.GenericMimeViewModel = GenericMimeViewModel;
        var MimeSectionViewModel = (function (_super) {
            __extends(MimeSectionViewModel, _super);
            function MimeSectionViewModel(mimeSectionData) {
                _super.call(this);
                this.title = ko.observable(mimeSectionData.title);
                this.show = ko.observable(true);
                var subSections = mimeSectionData.values.map(function (subSection) {
                    return new MimeSubSectionViewModel(subSection);
                });
                this.values = ko.observableArray(subSections);
            }
            return MimeSectionViewModel;
        })(DataLab.Util.Disposable);
        CustomUX.MimeSectionViewModel = MimeSectionViewModel;
        var MimeSubSectionViewModel = (function (_super) {
            __extends(MimeSubSectionViewModel, _super);
            function MimeSubSectionViewModel(mimeSubSectionData) {
                _super.call(this);
                this.dataType = ko.observable(mimeSubSectionData.dataType);
                this.data = ko.observable(mimeSubSectionData.data);
            }
            return MimeSubSectionViewModel;
        })(DataLab.Util.Disposable);
        CustomUX.MimeSubSectionViewModel = MimeSubSectionViewModel;
    })(CustomUX = ExperimentEditor.CustomUX || (ExperimentEditor.CustomUX = {}));
})(ExperimentEditor || (ExperimentEditor = {}));

var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var ExperimentEditor;
(function (ExperimentEditor) {
    var CustomUX;
    (function (CustomUX) {
        var JSONViewModel = (function (_super) {
            __extends(JSONViewModel, _super);
            function JSONViewModel(jsonData) {
                _super.call(this);
                this.text = jsonData["object"];
            }
            return JSONViewModel;
        })(DataLab.Util.Disposable);
        CustomUX.JSONViewModel = JSONViewModel;
    })(CustomUX = ExperimentEditor.CustomUX || (ExperimentEditor.CustomUX = {}));
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
/// <reference path="../ExperimentEditor/CustomUX.ts" />
/// <reference path="../Visualization/VisualizationViewModel.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var ExperimentEditor;
(function (ExperimentEditor) {
    var CustomUX;
    (function (CustomUX) {
        var LearnerViewModel = (function (_super) {
            __extends(LearnerViewModel, _super);
            function LearnerViewModel(parsedData) {
                _super.call(this);
                var learner = parsedData.learner;
                this.learnerName = ko.observable(DataLab.Util.addSpaceAfterCapitals(learner.name));
                var tablesToDisplay = [];
                if (learner.settings) {
                    var settingsTable;
                    if (this.isDataTable(learner.settings)) {
                        settingsTable = this.constructLearnerTableViewModelFromDataTable(learner.settings, DataLab.LocalizedResources.learnerSettings, DataLab.Util.addSpaceAfterCapitals, null);
                    }
                    else {
                        settingsTable = this.constructLearnerTableViewModelFromObject(learner.settings, DataLab.LocalizedResources.learnerSettings, DataLab.LocalizedResources.learnerSettingsName, DataLab.LocalizedResources.learnerSettingsValue, DataLab.Util.addSpaceAfterCapitals, null);
                    }
                    tablesToDisplay.push(settingsTable);
                }
                if (learner.weights) {
                    var weightsTable;
                    if (this.isDataTable(learner.weights)) {
                        weightsTable = this.constructLearnerTableViewModelFromDataTable(learner.weights, DataLab.LocalizedResources.learnerFeatureWeights, null, this.reducePrecisionWithTypeCheck);
                    }
                    else {
                        weightsTable = this.constructLearnerTableViewModelFromObject(learner.weights, DataLab.LocalizedResources.learnerFeatureWeights, DataLab.LocalizedResources.learnerFeatureWeightsName, DataLab.LocalizedResources.learnerFeatureWeightsValue, null, this.reducePrecisionWithTypeCheck);
                    }
                    tablesToDisplay.push(weightsTable);
                }
                this.tables = ko.observableArray(tablesToDisplay);
            }
            LearnerViewModel.prototype.constructLearnerTableViewModelFromDataTable = function (table, headerLabel, nameFormatter, valueFormatter) {
                var _this = this;
                if (nameFormatter) {
                    DataLab.Util.forEach(table.records, function (row) {
                        row[0] = nameFormatter(row[0].toString());
                    });
                }
                if (valueFormatter) {
                    DataLab.Util.forEach(table.records, function (row) {
                        for (var i = 1; i < row.length; i++) {
                            row[i] = valueFormatter(row[i]);
                        }
                    });
                }
                var columnNames = table.features.map(function (column) { return _this.getLocalizedColumnName(column.name); });
                return new LearnerTableViewModel(table.records, headerLabel, columnNames);
            };
            LearnerViewModel.prototype.constructLearnerTableViewModelFromObject = function (objectToConstructFrom, header, nameHeader, valueHeader, nameFormatter, valueFormatter) {
                var propertyNames = DataLab.Util.getAllPropertyNames(objectToConstructFrom);
                return new LearnerTableViewModel(propertyNames.map(function (name) {
                    var row = {
                        name: nameFormatter ? nameFormatter(name) : name,
                        value: valueFormatter ? valueFormatter(objectToConstructFrom[name]) : objectToConstructFrom[name]
                    };
                    return [row.name, row.value];
                }), header, [nameHeader, valueHeader]);
            };
            LearnerViewModel.prototype.isDataTable = function (table) {
                return table.records !== undefined && table.features !== undefined && table.records instanceof Array && table.features instanceof Array;
            };
            LearnerViewModel.prototype.getLocalizedColumnName = function (columnName) {
                if (columnName === "Setting") {
                    return DataLab.LocalizedResources.learnerSettingsName;
                }
                if (columnName === "Value") {
                    return DataLab.LocalizedResources.learnerSettingsValue;
                }
                if (columnName === "Feature") {
                    return DataLab.LocalizedResources.learnerFeatureWeightsName;
                }
                if (columnName === "Weight Mean") {
                    return DataLab.LocalizedResources.learnerWeightMean;
                }
                if (columnName === "Weight Standard Deviation") {
                    return DataLab.LocalizedResources.learnerWeightStandardDeviation;
                }
                return columnName;
            };
            LearnerViewModel.prototype.reducePrecisionWithTypeCheck = function (value) {
                if (typeof (value) === "number") {
                    return DataLab.Util.reducePrecision(value, ExperimentEditor.Visualization.Constants.maxPrecision);
                }
                else {
                    return value;
                }
            };
            return LearnerViewModel;
        })(DataLab.Util.Disposable);
        CustomUX.LearnerViewModel = LearnerViewModel;
        var LearnerTableViewModel = (function (_super) {
            __extends(LearnerTableViewModel, _super);
            function LearnerTableViewModel(table, headerLabel, columnNames) {
                _super.call(this);
                this.table = table;
                this.headerLabel = ko.observable(headerLabel);
                this.columnNames = ko.observableArray(columnNames);
            }
            return LearnerTableViewModel;
        })(DataLab.Util.Disposable);
        CustomUX.LearnerTableViewModel = LearnerTableViewModel;
    })(CustomUX = ExperimentEditor.CustomUX || (ExperimentEditor.CustomUX = {}));
})(ExperimentEditor || (ExperimentEditor = {}));

var ExperimentEditor;
(function (ExperimentEditor) {
    var PanHelper = (function () {
        function PanHelper(containerDiv, mouseEventHandler) {
            // Add a toggle button for the pan control. We own containerDiv, so we don't need to remove panButton on disposal.
            var panButton = document.createElement("div");
            panButton.setAttribute("class", "xe-zoomIcon panButton");
            panButton.setAttribute("title", "Click to enable pan mode. Center click and drag, or, space and drag, to pan at any time.");
            containerDiv.appendChild(panButton);
            // We don't need to unregister these because we own panButton.            
            panButton.addEventListener("click", function (e) {
                mouseEventHandler(e);
            });
            panButton.addEventListener("mousedown", function (e) {
                e.stopPropagation();
            });
        }
        return PanHelper;
    })();
    ExperimentEditor.PanHelper = PanHelper;
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
var ExperimentEditor;
(function (ExperimentEditor) {
    var Bubble;
    (function (Bubble) {
        var ViewPort = (function () {
            function ViewPort() {
                this.left = ko.observable(0);
                this.top = ko.observable(0);
                this.width = ko.observable(0);
                this.height = ko.observable(0);
                this.refreshed = new ko.subscribable();
            }
            ViewPort.prototype.refresh = function () {
                var $window = $(window);
                this.left($window.scrollLeft());
                this.top($window.scrollTop());
                this.width($window.width());
                this.height($window.height());
                this.refreshed.notifySubscribers(this);
            };
            ViewPort.getInstance = function () {
                if (!ViewPort.instance) {
                    ViewPort.instance = new ViewPort();
                    ViewPort.instance.refresh();
                    $(window).resize(function (e) { return ViewPort.instance.refresh(); });
                    $(window).scroll(function (e) { return ViewPort.instance.refresh(); });
                }
                return ViewPort.instance;
            };
            return ViewPort;
        })();
        Bubble.ViewPort = ViewPort;
    })(Bubble = ExperimentEditor.Bubble || (ExperimentEditor.Bubble = {}));
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../../TypescriptLib/knockout.d.ts" />
/// <reference path="../../../TypescriptLib/Knockout-extensions.d.ts" />
/// <reference path="../../../../../../External/Typescript/jquery.d.ts" />
/// <reference path="../../../../ExperimentEditor/TypescriptLib/d3.d.ts" />
/// <reference path="../ExperimentEditor/CustomUX.ts" />
/// <reference path="../../View/ZoomControl.ts" />
/// <reference path="../../View/ZoomHelper.ts" />
/// <reference path="../../View/PanHelper.ts" />
/// <reference path="../../View/Bubble/ViewPort.ts" />
/// <reference path="../../View/CustomBindingHandlers/d3graph.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var ExperimentEditor;
(function (ExperimentEditor) {
    var CustomUX;
    (function (CustomUX) {
        function areNodeIdentifiersEqual(node1, node2) {
            if (node1.isLeaf()) {
                if (!node2.isLeaf()) {
                    return false;
                }
                return node1.getLeaf().offset == node2.getLeaf().offset;
            }
            if (node2.isLeaf()) {
                return false;
            }
            return node1.getInterior().offset == node2.getInterior().offset;
        }
        var NodeIdentifier = (function () {
            function NodeIdentifier(index) {
                this.index = index;
            }
            NodeIdentifier.fromLeaf = function (node) {
                return new NodeIdentifier(~node.offset);
            };
            NodeIdentifier.fromInterior = function (node) {
                return new NodeIdentifier(node.offset);
            };
            NodeIdentifier.interiorRoot = function () {
                return new NodeIdentifier(0);
            };
            NodeIdentifier.leafRoot = function () {
                return new NodeIdentifier(~0);
            };
            NodeIdentifier.prototype.isLeaf = function () {
                return this.index < 0;
            };
            NodeIdentifier.prototype.getLeaf = function () {
                if (!this.isLeaf()) {
                    throw "node is not leaf";
                }
                return { offset: ~this.index };
            };
            NodeIdentifier.prototype.getInterior = function () {
                if (this.isLeaf()) {
                    throw "node is not interior";
                }
                return { offset: this.index };
            };
            return NodeIdentifier;
        })();
        CustomUX.NodeIdentifier = NodeIdentifier;
        var TreeNode = (function () {
            function TreeNode(index, x, y, tree) {
                this.select = function (element) {
                    element.tree.selectNode(element.index);
                };
                this.selectText = function (element) {
                    if (element.tree.isNodeLoaded(element.index)) {
                        return;
                    }
                    if (element.tree.isLoadingNodes) {
                        return;
                    }
                    element.tree.clearSelection();
                    element.tree.loadSubtree(element.index.getInterior());
                };
                this.openPreview = function (element, event) {
                    var plc = $(event.currentTarget);
                    var offset = plc.offset();
                    element.tree.desiredOffset = { top: offset.top + parseFloat(plc.attr('height')) + 4, left: offset.left };
                    element.tree.hoverNode(element.index, function () {
                        $("#hoverSummary").show();
                        $("#hoverSummary").offset(element.tree.desiredOffset);
                    });
                };
                this.closePreview = function () {
                    $("#hoverSummary").hide();
                };
                this.index = index;
                this.x = 50 * x;
                this.y = 50 * y;
                this.r = ko.observable(0);
                this.tree = tree;
                this.highlight = ko.observable(false);
                this.text = ko.observable(null);
                this.shade = ko.observable(0);
                if (index.isLeaf()) {
                    return;
                }
                if (!this.tree.isNodeLoaded(index)) {
                    this.text("expand");
                }
            }
            TreeNode.prototype.clearLabel = function () {
                if (!this.tree.isNodeLoaded(this.index)) {
                    return;
                }
                this.text(null);
            };
            TreeNode.prototype.showFeature = function () {
                if (!this.tree.isNodeLoaded(this.index)) {
                    return;
                }
                this.text(this.tree.featureLabels[this.index.getInterior().offset]);
            };
            TreeNode.prototype.showPredicate = function () {
                if (!this.tree.isNodeLoaded(this.index)) {
                    return;
                }
                this.text(this.tree.predicateLabels[this.index.getInterior().offset]);
            };
            return TreeNode;
        })();
        CustomUX.TreeNode = TreeNode;
        var TreeEdge = (function () {
            function TreeEdge(start, end) {
                this.start = start;
                this.end = end;
                this.highlight = ko.observable(false);
                this.text = ko.observable(null);
            }
            return TreeEdge;
        })();
        CustomUX.TreeEdge = TreeEdge;
        var Tree = (function (_super) {
            __extends(Tree, _super);
            function Tree(tree, provider) {
                _super.call(this);
                this.hoverSummaryRows = ko.observable(null);
                this.preview = ko.observable(null);
                this.isLoadingNodes = false;
                this.captionMode = "none";
                this.buttonDragMode = false;
                this.spaceDragMode = false;
                var me = this;
                this.nodeProvider = {
                    getInteriorNodeStatistics: function (nodeId, nodeStatisticsHandler) {
                        provider.getInteriorNodeStatistics(me.serverInteriorIds[nodeId.offset], nodeStatisticsHandler);
                    },
                    getLeafNodeStatistics: function (nodeId, nodeStatisticsHandler) {
                        provider.getLeafNodeStatistics(me.serverLeafIds[nodeId.offset], nodeStatisticsHandler);
                    },
                    getSubtree: function (nodeId, subtreeHandler) {
                        provider.getSubtree(me.serverInteriorIds[nodeId.offset], subtreeHandler);
                    }
                };
                this.nodeStackInformation = ko.observable({ interiorRows: null, leafRows: null, interiorPreviews: null, leafPreview: null });
                this.nodeStackHeight = ko.observable("0");
                this.interiorNodes = ko.observableArray([]);
                this.featureLabels = [];
                this.predicateLabels = [];
                this.leftChild = [];
                this.rightChild = [];
                this.leafNodes = ko.observableArray([]);
                this.leftEdges = ko.observableArray([]);
                this.rightEdges = ko.observableArray([]);
                this.interiorEntropy = [];
                this.leafEntropy = [];
                this.interiorWeights = [];
                this.serverInteriorIds = [];
                this.leafWeights = [];
                this.serverLeafIds = [];
                // special-case a degenerate tree consisting of a single leaf node
                if (tree.interiorXs.length === 0) {
                    this.leafNodes.push(new TreeNode(NodeIdentifier.fromLeaf({ offset: 0 }), tree.leafXs[0], tree.leafYs[0], this));
                    return;
                }
                // set up tree with dummy single interior node, because it will immediately be replaced
                this.featureLabels.push(null);
                this.predicateLabels.push(null);
                this.leftChild.push(null);
                this.rightChild.push(null);
                this.interiorNodes.push(new TreeNode(NodeIdentifier.fromInterior({ offset: 0 }), 0, 0, this));
                this.interiorEntropy.push(null);
                this.interiorWeights.push(null);
                this.serverInteriorIds.push(null);
                this.replaceNodeWithTree({ offset: 0 }, tree);
            }
            Tree.prototype.nodeToParentMap = function (nodeIndex) {
                if (nodeIndex.isLeaf()) {
                    return { offset: this.leafNodeToParentNode[nodeIndex.getLeaf().offset] };
                }
                return { offset: this.interiorNodeToParentNode[nodeIndex.getInterior().offset] };
            };
            Tree.prototype.updateTreeViewHeight = function () {
                var totalHeight = $("#treeViewContainer").innerHeight();
                var nodeStackViewHeight = $("#nodeStackView").outerHeight();
                var fillHeight = totalHeight - nodeStackViewHeight;
                $("#treeView").height(fillHeight);
            };
            Tree.prototype.isRoot = function (node) {
                var treeHasLeafNodeRoot = this.interiorNodes().length == 0;
                if (treeHasLeafNodeRoot) {
                    return areNodeIdentifiersEqual(node, NodeIdentifier.leafRoot());
                }
                return areNodeIdentifiersEqual(node, NodeIdentifier.interiorRoot());
            };
            Tree.prototype.updateTreeViewWidth = function () {
                var totalWidth = $("#treeEnsembleViewContainer").innerWidth();
                var sidebarWidth = $("#sideBar").outerWidth();
                var fillWidth = totalWidth - sidebarWidth;
                $("#treeViewContainer").width(fillWidth);
            };
            Object.defineProperty(Tree.prototype, "viewCenter", {
                get: function () {
                    var treeView = $("#treeSvg");
                    return {
                        x: treeView.width() / 2,
                        y: treeView.height() / 2
                    };
                },
                enumerable: true,
                configurable: true
            });
            Tree.prototype.updateTreeViewLayout = function () {
                this.updateTreeViewHeight();
                this.updateTreeViewWidth();
            };
            Tree.prototype.getViewDimensions = function () {
                // Do not use the bounding box of svgRoot, as it causes bizarre behavior in FF and can mess things up in
                // Chrome and IE as well when the browser is zoomed.
                var containerDiv = $("#treeView").get(0);
                return {
                    x: containerDiv.getBoundingClientRect().left,
                    y: containerDiv.getBoundingClientRect().top,
                    width: containerDiv.clientWidth,
                    height: containerDiv.clientHeight
                };
            };
            Tree.prototype.setPanning = function (panning) {
                if (panning === false) {
                    $("#treeInterface").draggable("disable");
                    $("#treeInterface").removeClass("ui-state-disabled");
                    $("#treeViewContainer").css('cursor', 'auto');
                }
                else {
                    $("#treeInterface").draggable("enable");
                    $("#treeViewContainer").css('cursor', 'all-scroll');
                }
                this.draggable = panning;
            };
            Tree.prototype.togglePanning = function () {
                this.setPanning(!this.draggable);
            };
            Tree.prototype.updateCaptions = function () {
                var me = this;
                me.leftEdges().forEach(function (edge, index, array) {
                    edge.text("");
                });
                me.rightEdges().forEach(function (edge, index, array) {
                    edge.text("");
                });
                me.interiorNodes().forEach(function (node, index, array) {
                    node.clearLabel();
                });
                if (me.captionMode === "none") {
                    return;
                }
                else if (me.captionMode === "feature") {
                    me.interiorNodes().forEach(function (node, index, array) {
                        node.showFeature();
                    });
                }
                else if (me.captionMode === "predicate") {
                    me.interiorNodes().forEach(function (node, index, array) {
                        node.showPredicate();
                    });
                }
                else if (me.captionMode === "predicateAndEdge") {
                    me.leftEdges().forEach(function (edge, index, array) {
                        edge.text("True");
                    });
                    me.rightEdges().forEach(function (edge, index, array) {
                        edge.text("False");
                    });
                    me.interiorNodes().forEach(function (node, index, array) {
                        node.showPredicate();
                    });
                }
            };
            Tree.prototype.loadSubtree = function (nodeIndex) {
                var me = this;
                this.nodeProvider.getSubtree(nodeIndex, function (subtree) {
                    me.replaceNodeWithTree(nodeIndex, subtree);
                });
            };
            Tree.prototype.initialize = function () {
                var treeToolbar = $('#treeToolbar').get(0);
                this.zoomControl = new ExperimentEditor.ZoomControl(treeToolbar, $('#treeInterface').get(0));
                var me = this;
                var lastPosition;
                $("#treeInterface").draggable({
                    start: function (event, ui) {
                        lastPosition = { x: event.pageX, y: event.pageY };
                    },
                    drag: function (event, ui) {
                        var deltaX = event.pageX - lastPosition.x;
                        var deltaY = event.pageY - lastPosition.y;
                        lastPosition = { x: event.pageX, y: event.pageY };
                        me.zoomHelper.pan(deltaX, deltaY);
                        ui.position.left = 0;
                        ui.position.top = 0;
                    }
                });
                this.setPanning(false);
                // We own the zoomControl, so we don't need to unsubscribe
                var panHandler = new ExperimentEditor.PanHelper(treeToolbar, function (e) {
                    if (me.spaceDragMode === true) {
                        return;
                    }
                    me.buttonDragMode = !me.buttonDragMode;
                    me.togglePanning();
                });
                var createOption = function (value, label) {
                    var option = document.createElement("option");
                    option.value = value;
                    option.innerText = label;
                    return option;
                };
                var viewDropDown = document.createElement("select");
                viewDropDown.appendChild(createOption("none", "No captions"));
                viewDropDown.appendChild(createOption("feature", "Feature name captions"));
                viewDropDown.appendChild(createOption("predicate", "Split predicate captions"));
                viewDropDown.appendChild(createOption("predicateAndEdge", "Split predicate and edge captions"));
                viewDropDown.id = "viewMode";
                treeToolbar.appendChild(viewDropDown);
                $("#viewMode").css("margin-left", "11px"); // 12px - 1 for border
                $("#viewMode").css("height", "26px"); // 28px - 2 for border
                $("#viewMode").css("vertical-align", "top"); // 28px - 2 for border
                $("#viewMode").on('change', function (e) {
                    var valueSelected = this.value;
                    me.captionMode = valueSelected;
                    me.updateCaptions();
                });
                $("#treeInterface").keydown(function (event) {
                    if (event.which === 32 && me.buttonDragMode === false) {
                        me.setPanning(true);
                        me.spaceDragMode = true;
                    }
                });
                $("#treeInterface").keyup(function (event) {
                    if (event.which === 32 && me.spaceDragMode === true) {
                        me.setPanning(false);
                        me.spaceDragMode = false;
                    }
                });
                this.registerForDisposal(this.zoomControl);
                var svgRoot = $("#treeSvg").get(0);
                var svgTransformElement = $("#transformElement").get(0);
                var getViewDimensions = function () {
                    return me.getViewDimensions();
                };
                var coordinateHelper = new ExperimentEditor.CoordinateHelper(svgRoot, getViewDimensions, svgTransformElement);
                var topLeft = svgRoot.createSVGPoint();
                var updateTreeViewLayout = function (change) {
                    me.updateTreeViewLayout();
                };
                var getTopLeft = function () {
                    return topLeft;
                };
                var emptyCallback = function () {
                };
                var emptyOverlayDivCollection = {
                    length: 0,
                    item: function (index) {
                        throw "out of range";
                    }
                };
                var getWorkspaceBox = function () {
                    return svgTransformElement.getBBox();
                };
                this.zoomHelper = new ExperimentEditor.ZoomHelper(svgTransformElement, svgRoot, coordinateHelper, this.zoomControl, getViewDimensions, updateTreeViewLayout, getTopLeft, emptyCallback, emptyCallback, emptyOverlayDivCollection, getWorkspaceBox);
                this.zoomHelper.pan(0, 0);
                this.registerForDisposal(new DataLab.Util.DisposableKnockoutObject(ExperimentEditor.Bubble.ViewPort.getInstance().refreshed.subscribe(function () {
                    me.updateTreeViewLayout();
                })));
                this.updateTreeViewLayout();
                this.zoomHelper.fitExperimentWithoutAnimation();
            };
            Tree.prototype.assignParentNodes = function (parentToChild, leafNodeToParentNode, interiorNodeToParentNode) {
                for (var parent = 0; parent < parentToChild.length; ++parent) {
                    var child = parentToChild[parent];
                    if (child == null) {
                        continue;
                    }
                    if (child.isLeaf()) {
                        leafNodeToParentNode[child.getLeaf().offset] = parent;
                        continue;
                    }
                    interiorNodeToParentNode[child.getInterior().offset] = parent;
                }
            };
            Tree.prototype.setupNodeToParentMap = function (leftChild, rightChild) {
                this.leafNodeToParentNode = new Array(leftChild.length);
                this.interiorNodeToParentNode = new Array(rightChild.length);
                this.assignParentNodes(leftChild, this.leafNodeToParentNode, this.interiorNodeToParentNode);
                this.assignParentNodes(rightChild, this.leafNodeToParentNode, this.interiorNodeToParentNode);
            };
            Tree.prototype.nodePairToEdgeWithCollection = function (childNodeIndex, parentNodeIndex) {
                var isLeftChild = areNodeIdentifiersEqual(this.leftChild[parentNodeIndex.offset], childNodeIndex);
                var isRightChild = areNodeIdentifiersEqual(this.rightChild[parentNodeIndex.offset], childNodeIndex);
                var bothLeftAndRightChild = isLeftChild && isRightChild;
                var neitherLeftNorRightChild = !(isLeftChild || isRightChild);
                if (bothLeftAndRightChild || neitherLeftNorRightChild) {
                    throw "expected child to be exclusively either left or right not both";
                }
                if (isLeftChild) {
                    return { edge: this.leftEdges()[parentNodeIndex.offset], collection: this.leftEdges, splits: this.leftChild };
                }
                return { edge: this.rightEdges()[parentNodeIndex.offset], collection: this.rightEdges, splits: this.rightChild };
            };
            Tree.prototype.nodePairToEdge = function (childNodeIndex, parentNodeIndex) {
                return this.nodePairToEdgeWithCollection(childNodeIndex, parentNodeIndex).edge;
            };
            Tree.prototype.addNodes = function (startOffset, nodeXs, nodeYs, nodes, mapOffsetToIdentifier) {
                for (var i = startOffset; i < nodeXs.length; i++) {
                    var id = mapOffsetToIdentifier(i);
                    var node = new TreeNode(id, nodeXs[i], nodeYs[i], this);
                    nodes.push(node);
                }
            };
            Tree.prototype.createEdgeFromNodeSplit = function (nodeId, splitArray) {
                var startNode = this.interiorNodes()[nodeId.offset];
                var startPoint = { x: startNode.x, y: startNode.y };
                var endNodeIdentifier = splitArray[nodeId.offset];
                if (endNodeIdentifier == null) {
                    return null;
                }
                var endNode = endNodeIdentifier.isLeaf() ? this.leafNodes()[endNodeIdentifier.getLeaf().offset] : this.interiorNodes()[endNodeIdentifier.getInterior().offset];
                var endPoint = { x: endNode.x, y: endNode.y };
                var edge = new TreeEdge(startPoint, endPoint);
                return edge;
            };
            Tree.prototype.addEdges = function (startIndex, endIndex, splitArray, edges) {
                for (var i = startIndex; i.offset <= endIndex.offset; i = { offset: i.offset + 1 }) {
                    var edge = this.createEdgeFromNodeSplit(i, splitArray);
                    if (edge == null) {
                        continue;
                    }
                    edges.push(edge);
                }
            };
            Tree.prototype.setHighlightInteriorNode = function (node, highlight) {
                this.interiorNodes()[node.offset].highlight(highlight);
            };
            Tree.prototype.setHighlightLeafNode = function (node, highlight) {
                this.leafNodes()[node.offset].highlight(highlight);
            };
            Tree.prototype.setHighlightEdge = function (childNode, parentNode, highlight) {
                var edge = this.nodePairToEdge(childNode, parentNode);
                edge.highlight(highlight);
            };
            Tree.prototype.setHighlightNodesUpToRoot = function (nodeIndex, highlight) {
                var previousIndex = nodeIndex;
                var currentInteriorNode;
                if (nodeIndex.isLeaf()) {
                    this.setHighlightLeafNode(nodeIndex.getLeaf(), highlight);
                    if (this.interiorNodes().length === 0) {
                        return;
                    }
                    currentInteriorNode = this.nodeToParentMap(nodeIndex);
                    this.setHighlightEdge(previousIndex, currentInteriorNode, highlight);
                }
                else {
                    currentInteriorNode = nodeIndex.getInterior();
                }
                var previousInteriorNode;
                while (!this.isRoot(NodeIdentifier.fromInterior(currentInteriorNode))) {
                    this.setHighlightInteriorNode(currentInteriorNode, highlight);
                    previousInteriorNode = currentInteriorNode;
                    currentInteriorNode = this.nodeToParentMap(NodeIdentifier.fromInterior(previousInteriorNode));
                    this.setHighlightEdge(NodeIdentifier.fromInterior(previousInteriorNode), currentInteriorNode, highlight);
                }
                this.setHighlightInteriorNode(currentInteriorNode, highlight);
            };
            Tree.prototype.switchHighlightingToNodeToRoot = function (nodeOffset) {
                if (this.previouslyHighlighted) {
                    this.setHighlightNodesUpToRoot(this.previouslyHighlighted, false);
                }
                this.setHighlightNodesUpToRoot(nodeOffset, true);
                this.previouslyHighlighted = nodeOffset;
            };
            Tree.prototype.clearSelection = function () {
                if (this.previouslyHighlighted) {
                    this.setHighlightNodesUpToRoot(this.previouslyHighlighted, false);
                }
                this.previouslyHighlighted = null;
                this.nodeStackInformation({
                    interiorRows: null,
                    leafRows: null,
                    interiorPreviews: null,
                    leafPreview: null
                });
                this.nodeStackHeight("0");
                this.updateTreeViewHeight();
            };
            Tree.prototype.handleNodeStatistics = function (statistics, statisticHandler) {
                for (var prop in statistics) {
                    if (prop === "inner" || prop === "graph") {
                        continue;
                    }
                    statisticHandler(prop, statistics[prop].toString());
                }
                if (statistics.inner) {
                    var inner = statistics.inner;
                    for (var prop in inner) {
                        if (prop in statistics) {
                            continue;
                        }
                        statisticHandler(prop, inner[prop].toString());
                    }
                }
            };
            Tree.prototype.addGraphToPreviewSeries = function (preview, graph, length) {
                for (var i = 0; i < graph.xValues.length; ++i) {
                    var label = graph.xValues[i];
                    var prediction = graph.yPredictionValues[i];
                    var training = graph.yTrainingValues[i];
                    var row = preview.series.filter(function (row) {
                        return row.label == label;
                    })[0];
                    if (row) {
                        row.values.push({ predict: prediction, train: training });
                    }
                    else {
                        var newRow = { label: label, values: new Array(length) };
                        newRow.values.push({ predict: prediction, train: training });
                        preview.series.push(newRow);
                    }
                }
            };
            Tree.prototype.createPropertyValuePair = function (label, value) {
                var displayValue = value;
                if (value.length > 20) {
                    displayValue = displayValue.slice(0, 17) + '...';
                }
                return { label: label, tooltip: value, value: displayValue };
            };
            Tree.prototype.populateStatistics = function (nodesToGet, propertyMap, nodeStackInfo, propertyMapLength) {
                // if no statistics left to get then copy them out of property map
                if (nodesToGet.length === 0) {
                    for (var prop in propertyMap) {
                        nodeStackInfo.interiorRows.push({
                            label: prop,
                            series: propertyMap[prop]
                        });
                    }
                    this.nodeStackInformation(nodeStackInfo);
                    this.nodeStackHeight("auto");
                    this.updateTreeViewHeight();
                    return;
                }
                var nextNode = nodesToGet.pop();
                var me = this;
                if (nextNode.isLeaf()) {
                    this.nodeProvider.getLeafNodeStatistics(nextNode.getLeaf(), function (statistics) {
                        me.handleNodeStatistics(statistics, function (label, value) {
                            nodeStackInfo.leafRows.push(me.createPropertyValuePair(label, value));
                        });
                        if (statistics.graph) {
                            nodeStackInfo.leafPreview = me.graphToPreview(statistics.graph);
                        }
                        me.populateStatistics(nodesToGet, propertyMap, nodeStackInfo, propertyMapLength);
                    });
                    return;
                }
                this.nodeProvider.getInteriorNodeStatistics(nextNode.getInterior(), function (statistics) {
                    me.handleNodeStatistics(statistics, function (label, value) {
                        if (!(label in propertyMap)) {
                            propertyMap[label] = new Array(propertyMapLength);
                        }
                        propertyMap[label].push(me.createPropertyValuePair(label, value));
                    });
                    if (statistics.graph) {
                        me.addGraphToPreviewSeries(nodeStackInfo.interiorPreviews, statistics.graph, propertyMapLength);
                    }
                    for (var prop in propertyMap) {
                        if (propertyMap[prop].length === propertyMapLength - 1) {
                            propertyMap[prop].push(null);
                            continue;
                        }
                    }
                    me.populateStatistics(nodesToGet, propertyMap, nodeStackInfo, propertyMapLength + 1);
                });
            };
            Tree.prototype.selectNode = function (nodeIndex) {
                if (this.isLoadingNodes) {
                    return;
                }
                // do nothing if we're in dragging mode
                if (this.buttonDragMode || this.spaceDragMode) {
                    return;
                }
                this.switchHighlightingToNodeToRoot(nodeIndex);
                var nodeStackInfo = {
                    interiorRows: [],
                    leafRows: [],
                    interiorPreviews: { columnWidth: 5, series: [] },
                    leafPreview: null
                };
                var nodesToGet = [];
                nodesToGet.push(nodeIndex);
                if (!this.isRoot(nodeIndex)) {
                    nodeIndex = NodeIdentifier.fromInterior(this.nodeToParentMap(nodeIndex));
                    while (!this.isRoot(nodeIndex)) {
                        nodesToGet.push(nodeIndex);
                        nodeIndex = NodeIdentifier.fromInterior(this.nodeToParentMap(nodeIndex));
                    }
                    nodesToGet.push(nodeIndex); // = 0
                    nodesToGet.reverse();
                }
                var propertyMapLength = 0;
                var propertyMap = {};
                this.populateStatistics(nodesToGet, propertyMap, nodeStackInfo, 0);
            };
            Tree.prototype.isNodeLoaded = function (node) {
                if (node.isLeaf()) {
                    return true;
                }
                var leftChild = this.leftChild[node.getInterior().offset];
                return !!leftChild;
            };
            Tree.prototype.graphToPreview = function (graph) {
                var preview = {
                    columnWidth: 5,
                    labels: graph.xValues,
                    predictValues: graph.yPredictionValues,
                    trainValues: graph.yTrainingValues
                };
                return preview;
            };
            Tree.prototype.hoverNode = function (index, onShowSummary) {
                // do nothing if we're in dragging mode
                if (this.buttonDragMode || this.spaceDragMode) {
                    return;
                }
                var me = this;
                var statisticsHandler = function (statistics) {
                    var summaryTable = [];
                    me.handleNodeStatistics(statistics, function (label, value) {
                        summaryTable.push(me.createPropertyValuePair(label, value));
                    });
                    me.hoverSummaryRows(summaryTable);
                    if (statistics.graph) {
                        var graph = statistics.graph;
                        var preview = me.graphToPreview(graph);
                        me.preview(preview);
                    }
                    onShowSummary();
                };
                if (index.isLeaf()) {
                    this.nodeProvider.getLeafNodeStatistics(index.getLeaf(), statisticsHandler);
                }
                else {
                    this.nodeProvider.getInteriorNodeStatistics(index.getInterior(), statisticsHandler);
                }
            };
            Tree.prototype.replaceNodeWithTree = function (node, subtree) {
                this.isLoadingNodes = true;
                var numberOfOldInteriorNodes = this.interiorNodes().length;
                var numberOfOldLeafNodes = this.leafNodes().length;
                var shiftNodeIdentifier = function (id) {
                    if (id.isLeaf()) {
                        return NodeIdentifier.fromLeaf({ offset: id.getLeaf().offset + numberOfOldLeafNodes });
                    }
                    return NodeIdentifier.fromInterior({ offset: id.getInterior().offset + numberOfOldInteriorNodes - 1 });
                };
                // replace node with root from subtree
                var nodeOffsetToReplace = node.offset;
                this.predicateLabels[nodeOffsetToReplace] = subtree.predicate[0];
                this.featureLabels[nodeOffsetToReplace] = subtree.feature[0];
                this.interiorEntropy[nodeOffsetToReplace] = !subtree.interiorEntropy ? null : subtree.interiorEntropy[0];
                this.interiorWeights[nodeOffsetToReplace] = !subtree.interiorWeight ? null : subtree.interiorWeight[0];
                this.leftChild[nodeOffsetToReplace] = shiftNodeIdentifier(new NodeIdentifier(subtree.leftChild[0]));
                this.rightChild[nodeOffsetToReplace] = shiftNodeIdentifier(new NodeIdentifier(subtree.rightChild[0]));
                this.serverInteriorIds[nodeOffsetToReplace] = new NodeIdentifier(subtree.interiorIds[0]).getInterior();
                var numberOfInteriorNodesInSubtree = subtree.leftChild.length;
                for (var i = 1; i < numberOfInteriorNodesInSubtree; ++i) {
                    this.interiorEntropy.push(!subtree.interiorEntropy ? null : subtree.interiorEntropy[i]);
                    this.interiorWeights.push(!subtree.interiorWeight ? null : subtree.interiorWeight[i]);
                    this.predicateLabels.push(subtree.predicate[i]);
                    this.featureLabels.push(subtree.feature[i]);
                    this.serverInteriorIds.push(new NodeIdentifier(subtree.interiorIds[i]).getInterior());
                    if (subtree.leftChild[i] == null) {
                        this.leftChild.push(null);
                        this.rightChild.push(null);
                    }
                    else {
                        this.leftChild.push(shiftNodeIdentifier(new NodeIdentifier(subtree.leftChild[i])));
                        this.rightChild.push(shiftNodeIdentifier(new NodeIdentifier(subtree.rightChild[i])));
                    }
                }
                for (var i = 0; i < subtree.leafXs.length; ++i) {
                    this.leafEntropy.push(!subtree.leafEntropy ? null : subtree.leafEntropy[i]);
                    this.leafWeights.push(!subtree.leafWeight ? null : subtree.leafWeight[i]);
                    this.serverLeafIds.push(new NodeIdentifier(subtree.leafIds[i]).getLeaf());
                }
                this.setupNodeToParentMap(this.leftChild, this.rightChild);
                this.interiorNodes.replace(this.interiorNodes()[nodeOffsetToReplace], new TreeNode(new NodeIdentifier(nodeOffsetToReplace), subtree.interiorXs[0], subtree.interiorYs[0], this));
                var getInteriorNodeIndex = function (offset) {
                    return shiftNodeIdentifier(NodeIdentifier.fromInterior({ offset: offset }));
                };
                var getLeafNodeIndex = function (offset) {
                    return shiftNodeIdentifier(NodeIdentifier.fromLeaf({ offset: offset }));
                };
                // skip the first node because we have directly handled it above
                this.addNodes(1, subtree.interiorXs, subtree.interiorYs, this.interiorNodes, getInteriorNodeIndex);
                this.addNodes(0, subtree.leafXs, subtree.leafYs, this.leafNodes, getLeafNodeIndex);
                this.addEdges(node, node, this.leftChild, this.leftEdges);
                this.addEdges(node, node, this.rightChild, this.rightEdges);
                var numberOfNewInteriorNodes = numberOfInteriorNodesInSubtree - 1;
                var lastNewInteriorNode = { offset: this.leftChild.length - 1 };
                var firstNewInteriorNode = { offset: lastNewInteriorNode.offset - numberOfNewInteriorNodes + 1 };
                this.addEdges(firstNewInteriorNode, lastNewInteriorNode, this.leftChild, this.leftEdges);
                this.addEdges(firstNewInteriorNode, lastNewInteriorNode, this.rightChild, this.rightEdges);
                this.rebalanceWeights();
                this.rebalanceEntropies();
                this.updateCaptions();
                // replace edge between node and its parent
                if (this.isRoot(NodeIdentifier.fromInterior(node))) {
                    this.isLoadingNodes = false;
                    return;
                }
                var replacementNodeIdentifier = NodeIdentifier.fromInterior(node);
                var parentOfReplacementNode = this.nodeToParentMap(replacementNodeIdentifier);
                var edgeWithCollection = this.nodePairToEdgeWithCollection(replacementNodeIdentifier, parentOfReplacementNode);
                edgeWithCollection.collection.replace(edgeWithCollection.edge, this.createEdgeFromNodeSplit(parentOfReplacementNode, edgeWithCollection.splits));
                this.isLoadingNodes = false;
            };
            Tree.prototype.rebalanceWeights = function () {
                var setValueOnNode = function (node, value) {
                    node.r(0.6 * value + 0.1);
                };
                this.rebalanceValues(this.interiorWeights, this.leafWeights, this.interiorNodes, this.leafNodes, setValueOnNode);
            };
            Tree.prototype.rebalanceEntropies = function () {
                var setValueOnNode = function (node, value) {
                    node.shade(value);
                };
                this.rebalanceValues(this.interiorEntropy, this.leafEntropy, this.interiorNodes, this.leafNodes, setValueOnNode);
            };
            Tree.prototype.rebalanceValues = function (interiorValues, leafValues, interiorNodes, leafNodes, setValueOnNode) {
                var minInteriorValue = d3.min(interiorValues);
                var minLeafValue = d3.min(leafValues);
                var minValue = Math.min(minInteriorValue, minLeafValue);
                if (minValue == undefined) {
                    interiorNodes().forEach(function (node) {
                        setValueOnNode(node, 1);
                    });
                    leafNodes().forEach(function (node) {
                        setValueOnNode(node, 1);
                    });
                }
                var maxInteriorValue = d3.max(interiorValues);
                var maxLeafValue = d3.max(leafValues);
                var maxValue = Math.max(maxInteriorValue, maxLeafValue);
                // we want a logarithmic map from [minValue, maxValue] to [0, 1]
                var weightShiftFunction = function (val) {
                    return Math.log(val / minValue) / Math.log(maxValue / minValue);
                };
                var me = this;
                interiorNodes().forEach(function (node) {
                    var offset = node.index.getInterior().offset;
                    var value = interiorValues[offset];
                    if (value) {
                        var mappedValue = weightShiftFunction(value);
                        setValueOnNode(node, mappedValue);
                    }
                    else {
                        setValueOnNode(node, 1);
                    }
                });
                leafNodes().forEach(function (node) {
                    var offset = node.index.getLeaf().offset;
                    var value = leafValues[offset];
                    if (value) {
                        var mappedValue = weightShiftFunction(value);
                        setValueOnNode(node, mappedValue);
                    }
                    else {
                        setValueOnNode(node, 1);
                    }
                });
            };
            return Tree;
        })(DataLab.Util.Disposable);
        CustomUX.Tree = Tree;
        var TreeEnsembleViewModel = (function (_super) {
            __extends(TreeEnsembleViewModel, _super);
            function TreeEnsembleViewModel(data) {
                _super.call(this);
                this.showLoadMore = ko.observable(true);
                this.loadMore = function (vm) {
                    var treeStep = 20;
                    var currentlyLoaded = vm.treeThumbnailUrls().length;
                    var toBeLoaded = Math.min(currentlyLoaded + treeStep, vm.treeCount);
                    vm.loadTrees(currentlyLoaded, toBeLoaded);
                };
                this.onScroll = function (vm) {
                    var allTreesLoaded = vm.treeCount == vm.treeThumbnailUrls().length;
                    if (allTreesLoaded) {
                        return;
                    }
                    if (vm.isAlmostScrolledToBottom()) {
                        vm.loadMore(vm);
                    }
                };
                this.treeCount = data.learner.treeCount;
                this.dataProvider = data.dataProvider;
                this.treeThumbnailUrls = ko.observableArray([]);
                this.tree = ko.observable(null);
            }
            TreeEnsembleViewModel.prototype.unloadedTreesRemaining = function () {
                return this.treeCount > this.treeThumbnailUrls().length;
            };
            TreeEnsembleViewModel.prototype.isAlmostScrolledToBottom = function () {
                var scrolled = $("#sideBar").scrollTop();
                var underlyingRegion = $("#sideBar").children().outerHeight();
                var viewPort = $("#sideBar").innerHeight();
                var scrollFraction = (scrolled + viewPort) / underlyingRegion;
                var almostScrolledToBottom = scrollFraction > 0.9;
                return almostScrolledToBottom;
            };
            TreeEnsembleViewModel.prototype.dispose = function () {
                _super.prototype.dispose.call(this);
                // if there was an error during startup, then tree will be only partially constructed
                if (this.tree()) {
                    this.tree().dispose();
                }
                $(window).off('resize', '**', this.resizeHandler);
            };
            TreeEnsembleViewModel.prototype.loadTrees = function (startIndex, endIndex) {
                var me = this;
                for (var i = startIndex; i < endIndex; i++) {
                    var url = {
                        index: i,
                        thumbnailUrl: ko.observable(''),
                        select: function (viewModel) {
                            Shell.UI.Spinner.show();
                            me.dataProvider.getRootSubTreeStructure(viewModel.index, function (tree) {
                                if (me.tree()) {
                                    me.tree().dispose();
                                }
                                var nodeProvider = {
                                    getInteriorNodeStatistics: function (nodeId, interiorStatisticsHandler) {
                                        me.dataProvider.getInteriorNodeStatistics(viewModel.index, nodeId, interiorStatisticsHandler);
                                    },
                                    getLeafNodeStatistics: function (nodeId, leafSatisticsHandler) {
                                        me.dataProvider.getLeafNodeStatistics(viewModel.index, nodeId, leafSatisticsHandler);
                                    },
                                    getSubtree: function (nodeId, subtreeHandler) {
                                        me.dataProvider.getSubTreeStructure(viewModel.index, nodeId, subtreeHandler);
                                    }
                                };
                                me.tree(new Tree(tree, nodeProvider));
                                me.tree().initialize();
                                Shell.UI.Spinner.hide();
                            });
                        }
                    };
                    var startGetThumbnail = function (dummy_i, dummy) {
                        me.dataProvider.getTreeThumbnail(dummy_i, function (str) {
                            dummy.thumbnailUrl('data:image/png;base64,' + str);
                        });
                    };
                    startGetThumbnail(i, url);
                    this.treeThumbnailUrls.push(url);
                }
                this.showLoadMore(this.unloadedTreesRemaining());
            };
            TreeEnsembleViewModel.prototype.initialize = function () {
                var initialTreeCount = Math.min(this.treeCount, 30);
                this.loadTrees(0, initialTreeCount);
                while (this.isAlmostScrolledToBottom() && this.unloadedTreesRemaining()) {
                    this.loadMore(this);
                }
                var me = this;
                this.resizeHandler = function (event) {
                    while (me.isAlmostScrolledToBottom() && me.unloadedTreesRemaining()) {
                        me.loadMore(me);
                    }
                };
                $(window).resize(this.resizeHandler);
                if (this.treeThumbnailUrls().length > 0) {
                    var firstTreeThumbnail = this.treeThumbnailUrls()[0];
                    firstTreeThumbnail.select(firstTreeThumbnail);
                }
            };
            return TreeEnsembleViewModel;
        })(DataLab.Util.Disposable);
        CustomUX.TreeEnsembleViewModel = TreeEnsembleViewModel;
    })(CustomUX = ExperimentEditor.CustomUX || (ExperimentEditor.CustomUX = {}));
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
/// <reference path="../ExperimentEditor/CustomUX.ts" />
/// <reference path="../../ViewModel/CustomUX/Constants.ts" />
/// <reference path="../../View/CustomBindingHandlers/D3Graphing/D3Common.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var ExperimentEditor;
(function (ExperimentEditor) {
    var CustomUX;
    (function (CustomUX) {
        var ClusteringViewModel = (function (_super) {
            __extends(ClusteringViewModel, _super);
            function ClusteringViewModel(clusteringData) {
                var _this = this;
                _super.call(this);
                this.width = 500;
                this.height = 500;
                this.padding = 50;
                var clusters = clusteringData.clusters;
                this.computeScales(clusters);
                var viewModels = clusteringData.clusters.map(function (cluster) {
                    return new ClusterViewModel(cluster, _this.xScale, _this.yScale);
                });
                this.clusterViewModels = ko.observableArray(viewModels);
            }
            ClusteringViewModel.prototype.drawAxes = function () {
                var plotSvg = d3.select(".clusterSvg");
                var xAxis = d3.svg.axis().scale(this.xScale).orient("bottom");
                var yAxis = d3.svg.axis().scale(this.yScale).orient("left");
                plotSvg.insert("g", ":first-child").attr("class", "axis").attr("id", "xAxis").attr("transform", "translate(0," + (this.height - this.padding) + ")").call(xAxis);
                plotSvg.insert("g", ":first-child").attr("class", "axis").attr("id", "yAxis").attr("transform", "translate(" + this.padding + ",0)").call(yAxis);
                var xAxisLabel = DataLab.LocalizedResources.clusterPrincipalComponent + " 1";
                var yAxisLabel = DataLab.LocalizedResources.clusterPrincipalComponent + " 2";
                ExperimentEditor.D3Graph.AddAxisLabels(plotSvg, xAxisLabel, yAxisLabel, this.height, this.width, this.padding, this.padding);
            };
            ClusteringViewModel.prototype.computeScales = function (clusters) {
                var calculatePotentialMinMaxOfProperty = function (cluster, property) {
                    var center = cluster["centroid" + property];
                    var majorAxis = cluster["majorAxis" + property];
                    var minorAxis = cluster["minorAxis" + property];
                    return [center + majorAxis, center - majorAxis, center + minorAxis, center - minorAxis];
                };
                var xValues = clusters.map(function (cluster) {
                    return calculatePotentialMinMaxOfProperty(cluster, "X");
                });
                var yValues = clusters.map(function (cluster) {
                    return calculatePotentialMinMaxOfProperty(cluster, "Y");
                });
                var flattenAndReduce = function (arrays, reductionFunction) {
                    var flattened = [].concat.apply([], arrays);
                    return reductionFunction(flattened);
                };
                var potentialMinMaxValues = xValues.concat(yValues);
                var minValue = flattenAndReduce(potentialMinMaxValues, d3.min);
                var maxValue = flattenAndReduce(potentialMinMaxValues, d3.max);
                this.xScale = d3.scale.linear().domain([minValue, maxValue]).range([this.padding, this.width - this.padding]);
                this.yScale = d3.scale.linear().domain([minValue, maxValue]).range([this.height - this.padding, this.padding]);
            };
            return ClusteringViewModel;
        })(DataLab.Util.Disposable);
        CustomUX.ClusteringViewModel = ClusteringViewModel;
        var ClusterViewModel = (function () {
            function ClusterViewModel(cluster, xScale, yScale) {
                var _this = this;
                this.label = ko.observable(DataLab.LocalizedResources.clusterLabel + " " + cluster.label);
                this.color = ko.observable(CustomUX.Constants.ColorTable[cluster.label % CustomUX.Constants.ColorTable.length]);
                this.centroidX = ko.observable(xScale(cluster.centroidX));
                this.centroidY = ko.observable(yScale(cluster.centroidY));
                this.majorAxisX = cluster.majorAxisX;
                this.majorAxisY = cluster.majorAxisY;
                this.minorAxisX = cluster.minorAxisX;
                this.minorAxisY = cluster.minorAxisY;
                this.unscaledCentroidX = cluster.centroidX;
                this.unscaledCentroidY = cluster.centroidY;
                this.angleOfRotation = cluster.angleOfRotation;
                this.ellipseRotation = ko.computed(function () {
                    var angleOfRotationInDegrees = _this.angleOfRotation / (Math.PI / 180);
                    return DataLab.Util.format("rotate({0} {1} {2})", angleOfRotationInDegrees.toString(), _this.centroidX().toString(), _this.centroidY().toString());
                });
                this.majorAxisLength = ko.computed(function () {
                    return _this.computeDistance("majorAxis", xScale, yScale);
                });
                this.minorAxisLength = ko.computed(function () {
                    return _this.computeDistance("minorAxis", xScale, yScale);
                });
            }
            ClusterViewModel.prototype.computeDistance = function (propertyPrefix, xScale, yScale) {
                var lengthOfDegenerateDimension = 3;
                var xValue = this[propertyPrefix + "X"];
                var yValue = this[propertyPrefix + "Y"];
                if (xValue == 0 && yValue == 0) {
                    return lengthOfDegenerateDimension;
                }
                var xValueScaled = xScale(this.unscaledCentroidX + xValue);
                var yValueScaled = yScale(this.unscaledCentroidY + yValue);
                var xSquared = Math.pow(xValueScaled - this.centroidX(), 2);
                var ySquared = Math.pow(yValueScaled - this.centroidY(), 2);
                return Math.sqrt(xSquared + ySquared);
            };
            return ClusterViewModel;
        })();
        CustomUX.ClusterViewModel = ClusterViewModel;
        ko.bindingHandlers["clusteringAxes"] = {
            init: function () {
            },
            update: function (element, valueAccessor, allBindingsAccessor, targetViewModel, bindingContext) {
                var viewModel = bindingContext.$data;
                viewModel.drawAxes();
            }
        };
    })(CustomUX = ExperimentEditor.CustomUX || (ExperimentEditor.CustomUX = {}));
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
/// <reference path="../../ViewModel/Visualization/VisualizationViewModel.ts" />
/// <reference path="../../ViewModel/CustomUX/BinaryClassificationUX.ts" />
/// <reference path="../../ViewModel/CustomUX/BinaryClassificationComparisonUX.ts" />
/// <reference path="../../ViewModel/CustomUX/MulticlassClassificationUX.ts" />
/// <reference path="../../ViewModel/CustomUX/ROutputViewModel.ts" />
/// <reference path="../../ViewModel/CustomUX/GenericMimeViewModel.ts" />
/// <reference path="../../ViewModel/CustomUX/JSONViewModel.ts" />
/// <reference path="../../ViewModel/CustomUX/LearnerViewModel.ts" />
/// <reference path="../../ViewModel/CustomUX/TreeEnsembleViewModel.ts" />
/// <reference path="../../ViewModel/CustomUX/ClusteringViewModel.ts" />
var ExperimentEditor;
(function (ExperimentEditor) {
    var Visualization;
    (function (Visualization) {
        var VisualizationViewModelFactory = (function () {
            function VisualizationViewModelFactory() {
            }
            VisualizationViewModelFactory.prototype.createViewModelWithMarkup = function (visualizationData, portModel, workspace) {
                var visualizationType = visualizationData.visualizationType;
                var markup;
                var viewModel;
                switch (visualizationType) {
                    case "default":
                        var datatable = visualizationData.data;
                        var stats = visualizationData.statistics;
                        var layout = visualizationData.layout;
                        markup = ExperimentEditor._visualizationMarkup;
                        viewModel = new ExperimentEditor.Visualization.VisualizationViewModel(datatable, stats, layout);
                        break;
                    case "binaryClassifierEvaluation":
                        markup = ExperimentEditor._binaryClassificationComparisonMarkup;
                        viewModel = new ExperimentEditor.CustomUX.BinaryClassificationComparisonUXViewModel({
                            visualizationType: null,
                            reports: [visualizationData]
                        });
                        break;
                    case "binaryClassifierEvaluationComparison":
                        markup = ExperimentEditor._binaryClassificationComparisonMarkup;
                        viewModel = new ExperimentEditor.CustomUX.BinaryClassificationComparisonUXViewModel(visualizationData);
                        break;
                    case "multiclassClassifierEvaluation":
                        markup = ExperimentEditor._multiclassClassificationMarkup;
                        viewModel = new ExperimentEditor.CustomUX.MulticlassClassificationUXViewModel(visualizationData);
                        break;
                    case "rOutput":
                        markup = ExperimentEditor._rOutputMarkup;
                        viewModel = new ExperimentEditor.CustomUX.ROutputViewModel(visualizationData);
                        break;
                    case "genericMime":
                        markup = ExperimentEditor._genericMimeMarkup;
                        viewModel = new ExperimentEditor.CustomUX.GenericMimeViewModel(visualizationData);
                        break;
                    case "learner":
                        markup = ExperimentEditor._learnerMarkup;
                        viewModel = new ExperimentEditor.CustomUX.LearnerViewModel(visualizationData);
                        break;
                    case "json":
                        markup = ExperimentEditor._jSONMarkup;
                        viewModel = new ExperimentEditor.CustomUX.JSONViewModel(visualizationData);
                        break;
                    case "treeEnsemble":
                        if (!DataLab.Features.treeVisualizationEnabled()) {
                            var fallbackData = {
                                learner: visualizationData.learner.defaultLearner,
                                visualizationType: "learner"
                            };
                            markup = ExperimentEditor._learnerMarkup;
                            viewModel = new ExperimentEditor.CustomUX.LearnerViewModel(fallbackData);
                            break;
                        }
                        markup = ExperimentEditor._treeEnsembleMarkup;
                        var experimentId = portModel.parent.executedExperimentId;
                        var moduleId = portModel.parent.id;
                        var portId = portModel.name;
                        var provider = {
                            getTreeThumbnail: function (treeIndex, treeThumbnailHandler) {
                                workspace.getModuleVisualizationDataItem(experimentId, moduleId, portId, "tree" + treeIndex.toString() + "-thumbnail", "text", "plain", DataLab.DataContract.ResponseType.Text).done(function (image) {
                                    treeThumbnailHandler(image);
                                });
                            },
                            getRootSubTreeStructure: function (treeIndex, treeStructureHandler) {
                                workspace.getModuleVisualizationDataItem(experimentId, moduleId, portId, "tree" + treeIndex.toString() + "-layout", "application", "json", DataLab.DataContract.ResponseType.JSON).done(function (structure) {
                                    treeStructureHandler(structure);
                                });
                            },
                            getSubTreeStructure: function (treeIndex, subtreeRoot, treeStructureHandler) {
                                workspace.getModuleVisualizationDataItem(experimentId, moduleId, portId, "tree" + treeIndex.toString() + "-layout" + subtreeRoot.offset, "application", "json", DataLab.DataContract.ResponseType.JSON).done(function (structure) {
                                    treeStructureHandler(structure);
                                });
                            },
                            getInteriorNodeStatistics: function (treeIndex, nodeIndex, nodeStatisticsHandler) {
                                workspace.getModuleVisualizationDataItem(experimentId, moduleId, portId, "tree" + treeIndex.toString() + "-node" + nodeIndex.offset.toString() + "-statistics", "application", "json", DataLab.DataContract.ResponseType.JSON).done(nodeStatisticsHandler);
                            },
                            getLeafNodeStatistics: function (treeIndex, nodeIndex, nodeStatisticsHandler) {
                                var nodeIdentifier = ExperimentEditor.CustomUX.NodeIdentifier.fromLeaf(nodeIndex);
                                workspace.getModuleVisualizationDataItem(experimentId, moduleId, portId, "tree" + treeIndex.toString() + "-node" + nodeIdentifier.index.toString() + "-statistics", "application", "json", DataLab.DataContract.ResponseType.JSON).done(nodeStatisticsHandler);
                            }
                        };
                        var data = {
                            learner: visualizationData.learner,
                            dataProvider: provider,
                        };
                        viewModel = new ExperimentEditor.CustomUX.TreeEnsembleViewModel(data);
                        break;
                    case "clustering":
                        markup = ExperimentEditor._clusteringMarkup;
                        viewModel = new ExperimentEditor.CustomUX.ClusteringViewModel(visualizationData);
                        break;
                    default:
                        throw new Error("Unknown visualization type requested: " + visualizationType);
                        break;
                }
                return {
                    viewModel: viewModel,
                    markup: markup
                };
            };
            return VisualizationViewModelFactory;
        })();
        Visualization.VisualizationViewModelFactory = VisualizationViewModelFactory;
    })(Visualization = ExperimentEditor.Visualization || (ExperimentEditor.Visualization = {}));
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../ViewModel/ExperimentEditor/Entity.ts" />
/// <reference path="../ViewModel/ExperimentEditor/Module.ts" />
/// <reference path="../ViewModel/ExperimentEditor/CustomUX.ts" />
/// <reference path="../ViewModel/CustomUX/VisualizationViewModelFactory.ts" />
var ExperimentEditor;
(function (ExperimentEditor) {
    var EndpointDownloader = (function () {
        function EndpointDownloader() {
            this.endpointTooBig = new ko.subscribable();
        }
        EndpointDownloader.prototype.download = function (endpoint) {
            var url = endpoint.BaseUri + endpoint.Location + endpoint.AccessCredential;
            window.open(url);
        };
        EndpointDownloader.prototype.visualize = function (portModel, workspace, isModule) {
            var experimentId = portModel.parent.parent.experimentId();
            Shell.Diagnostics.Telemetry.featureUsage(19 /* Visualize */, 0, workspace.id, experimentId, null, JSON.stringify({ port: portModel.name, isModule: isModule, nodeName: portModel.parent.name }));
            Shell.UI.Spinner.show();
            var visualizationPromise;
            if (isModule) {
                visualizationPromise = workspace.getModuleVisualizationData(experimentId, portModel.parent.id, portModel.name);
            }
            else {
                visualizationPromise = workspace.getDatasetVisualizationData(portModel.parent.dataset.id);
            }
            visualizationPromise.done(function (visualizationData) {
                try {
                    var breadcrumbHeader = {
                        experimentName: portModel.parent.parent.description(),
                        moduleName: portModel.parent.name,
                        portName: portModel.friendlyName
                    };
                    var visualizationFactory = new ExperimentEditor.Visualization.VisualizationViewModelFactory();
                    var viewModelWithMarkup = visualizationFactory.createViewModelWithMarkup(visualizationData, portModel, workspace);
                    ExperimentEditor.CustomUX.open(viewModelWithMarkup.markup, viewModelWithMarkup.viewModel, "90%", "90%", null, breadcrumbHeader);
                }
                catch (e) {
                    var errorMessage = DataLab.LocalizedResources.errorParsingVisualizationFile;
                    var errorNotification = new Shell.UI.Notifications.Notification(errorMessage, "error");
                    errorNotification.setActions([Shell.UI.Notifications.Buttons.close()]);
                    Shell.UI.Notifications.add(errorNotification);
                    var logMessage = errorMessage + " " + e.message;
                    Shell.Diagnostics.Telemetry.customEvent("Visualization_Failed", "Visualization", logMessage);
                }
            }).fail(function (err) {
                var errorMessage = DataLab.LocalizedResources.errorGettingVisualizationData;
                var errorNotification = new Shell.UI.Notifications.Notification(DataLab.Util.format(errorMessage, err.xmlHttpRequest.responseText), "error");
                errorNotification.setActions([Shell.UI.Notifications.Buttons.close()]);
                Shell.UI.Notifications.add(errorNotification);
                var logMessage = errorMessage + " " + err.xmlHttpRequest.responseText;
                Shell.Diagnostics.Telemetry.customEvent("Visualization_Failed", "Visualization", logMessage);
            }).always(function () {
                Shell.UI.Spinner.hide();
            });
        };
        return EndpointDownloader;
    })();
    ExperimentEditor.EndpointDownloader = EndpointDownloader;
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../Global.ts" />
// A common mistake when using a Knockout observable is omitting parentheses when reading. Ex:
//   var o = ko.observable("Alice");
//   alert("Your name is " + o);
// Below we modify the creation of observable such that usage in value contexts throws an exception.
//
// Since each observable instance is an object, valueOf returns it unmodified.
// Here we also cause toString to return the instance (though it can really be any non-primitive).
// By ES5 8.12.18, a TypeError will be thrown if both valueOf and toString fail to return a primitive.
// In the Chrome dev tools, this has the side-effect that observables show up as "TypeError".
ko.observable.fn.toString = function () {
    return this;
};

/// <reference path="../Global.ts" />
/// <reference path="../Common/DialogInterfaces.ts" />
var ExperimentEditor;
(function (ExperimentEditor) {
    var azureFxDialogHostTemplate = $.templates("<div class='datalab-dialog'></div>");
    var AzureFxDialogHost = (function () {
        function AzureFxDialogHost() {
            this.dialogDismissedEvent = new ko.subscribable();
        }
        AzureFxDialogHost.prototype.isActiveDialog = function (dialog) {
            return dialog === this.activeDialog;
        };
        AzureFxDialogHost.prototype.closeActiveDialog = function () {
            this.assertDialogIsActive();
            var c = document.createEvent("CustomEvent");
            c.initEvent("close", true, true);
            this.activeDialogElement.fxDialog("close", c);
        };
        AzureFxDialogHost.prototype.showNewDialog = function (dialog) {
            var _this = this;
            if (this.activeDialog) {
                this.closeActiveDialog();
            }
            this.activeDialog = dialog;
            // DialogView needs to immediately apply a knockout template and apply bindings to the returned container.
            // However, Shell.UI.DialogPresenter does not immediately show the dialog (that will eventually happen in 
            // 'init' below). Here we attach the container to the DOM temporarily and make it invisible. We'd like to
            // leave the container orphaned until the dialog is ready, but knockout would prematurely dispose bindings.
            var dialogContentContainer = $("<div>").css({ 'display': 'none', 'class': 'datalab-azurefx-dialog-content' }).appendTo(document.body);
            var renderDialog = function (dialogElement) {
                _this.activeDialogElement = dialogElement;
                _this.activeDialogElement.find(".datalab-dialog").append(dialogContentContainer);
                dialogContentContainer.css({ 'display': '' });
            };
            var options = {
                template: azureFxDialogHostTemplate,
                init: function () {
                    renderDialog(this.element);
                },
                ok: function () {
                    var canBeAccepted = _this.activeDialog.canBeAccepted();
                    if (canBeAccepted) {
                        // okOrClose will only be called if we do not cancel dismissal.
                        dialogWasAccepted = true;
                    }
                    return canBeAccepted;
                },
                okOrClose: function () {
                    _this.onDialogDismissed(dialog, dialogWasAccepted);
                }
            };
            if (dialog.optionsOverrides) {
                $.extend(options, dialog.optionsOverrides);
            }
            var dialogWasAccepted = false;
            Shell.UI.DialogPresenter.show(options);
            return dialogContentContainer.get(0);
        };
        AzureFxDialogHost.prototype.onDialogDismissed = function (dialog, accepted) {
            if (!this.isActiveDialog(dialog)) {
                throw new Error("Attempted to dismiss a dialog other than the active one");
            }
            this.dialogDismissedEvent.notifySubscribers({
                dialog: this.activeDialog,
                accepted: accepted
            });
            this.activeDialog = null;
        };
        AzureFxDialogHost.prototype.assertDialogIsActive = function () {
            if (!this.activeDialog) {
                throw new Error("No dialog active");
            }
        };
        return AzureFxDialogHost;
    })();
    ExperimentEditor.AzureFxDialogHost = AzureFxDialogHost;
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../Global.ts" />
var ExperimentEditor;
(function (ExperimentEditor) {
    var ShellControls;
    (function (ShellControls) {
        function initChatControl() {
            var bindingElementChatDropdown = document.querySelector(".chat-support");
            var viewModel;
            if (bindingElementChatDropdown) {
                viewModel = new ChatViewModel();
                ko.applyBindings(viewModel, bindingElementChatDropdown);
            }
            var bindingElementChatLinkInHelp = document.querySelector(".chat-support-link-in-help-dropdown");
            if (bindingElementChatLinkInHelp) {
                if (!viewModel) {
                    viewModel = new ChatViewModel();
                }
                ko.applyBindings(viewModel, bindingElementChatLinkInHelp);
            }
        }
        ShellControls.initChatControl = initChatControl;
        var ChatViewModel = (function () {
            function ChatViewModel() {
                var _this = this;
                this.showChatButton = ko.observable(false);
                window.$zopim && window.$zopim(function () {
                    $zopim.livechat.setOnStatus(function (status) {
                        if (status === 'online') {
                            _this.showChatButton(true);
                        }
                        else {
                            _this.showChatButton(false);
                        }
                    });
                });
            }
            ChatViewModel.prototype.toggle = function () {
                window.$zopim && window.$zopim(function () {
                    if ($zopim.livechat.window.getDisplay()) {
                        $zopim.livechat.window.hide();
                    }
                    else {
                        $zopim.livechat.window.show();
                    }
                });
            };
            return ChatViewModel;
        })();
        ShellControls.ChatViewModel = ChatViewModel;
    })(ShellControls = ExperimentEditor.ShellControls || (ExperimentEditor.ShellControls = {}));
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../Global.ts" />
var ExperimentEditor;
(function (ExperimentEditor) {
    var CredentialsPivot = (function () {
        function CredentialsPivot(client, renderArea) {
            var _this = this;
            this.renderArea = renderArea;
            this.client = client;
            this.data = [];
            this.grid = $(this.renderArea).find('#grid').addClass('usersGrid').fxDataGrid({
                columns: [
                    { name: 'Type', field: 'type' },
                    { name: 'Credential', field: 'credential', }
                ],
                data: this.data,
                selectable: true,
                multiselect: true,
                resizable: true,
                rowSelect: function (selected, unselected) {
                    _this.removeCommand.setDisabled(_this.grid.fxDataGrid('getSelectedRows').length === 0);
                },
                noRows: DataLab.LocalizedResources.credentialsNone
            });
        }
        CredentialsPivot.prototype.setRemoveCommand = function (removeCommand) {
            this.removeCommand = removeCommand;
            this.removeCommand.setDisabled(this.grid.fxDataGrid('getSelectedRows').length === 0);
        };
        CredentialsPivot.prototype.keypartsToString = function (keyParts) {
            var toRet = "";
            DataLab.Util.forEach(keyParts.Parts, function (kp) {
                toRet += kp.Name + "=" + kp.Value;
            });
            return toRet;
        };
        CredentialsPivot.prototype.refreshFromService = function () {
            var _this = this;
            Shell.UI.Spinner.show();
            this.client.listCredentials().done(function (credentials) {
                Shell.UI.Spinner.hide();
                var gridData = [];
                DataLab.Util.forEach(credentials, function (c) {
                    gridData.push({
                        type: c.Type,
                        credential: _this.keypartsToString(c),
                        keyParts: c
                    });
                });
                $.observable(_this.data).refresh(gridData);
            });
        };
        CredentialsPivot.prototype.removeCredentials = function () {
            var _this = this;
            var rowCount = this.grid.fxDataGrid('getSelectedRows').length;
            var confirmation = new Shell.UI.Notifications.Confirmation('Remove ' + rowCount + ' Credentials(s)', 'active');
            confirmation.setActions([
                new Shell.UI.Notifications.Buttons.yes(function () {
                    _this.doRemoveCredentials();
                    Shell.Diagnostics.Telemetry.customEvent("RemoveCredentials_Yes", "ShellUICommands");
                }),
                new Shell.UI.Notifications.Buttons.no(function () {
                    Shell.UI.Notifications.remove(confirmation);
                    Shell.Diagnostics.Telemetry.customEvent("RemoveCredentials_No", "ShellUICommands");
                })
            ]);
            Shell.UI.Notifications.add(confirmation);
        };
        CredentialsPivot.prototype.doRemoveCredentials = function () {
            var _this = this;
            var selectedRows = this.grid.fxDataGrid('getSelectedRows');
            var promises = [];
            DataLab.Util.forEach(selectedRows, function (row) {
                var dataItem = row.dataItem;
                promises.push(_this.client.deleteCredential(dataItem.keyParts));
            });
            Shell.UI.Spinner.show();
            $.when.apply($, promises).always(function () {
                _this.refreshFromService();
            });
            Shell.Diagnostics.Telemetry.featureUsage(14 /* RemoveCredentials */, 15 /* Settings */, this.client.workspaceId, null, null, JSON.stringify({ amount: selectedRows.length }));
        };
        return CredentialsPivot;
    })();
    ExperimentEditor.CredentialsPivot = CredentialsPivot;
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../Global.ts" />
var ExperimentEditor;
(function (ExperimentEditor) {
    var DataImportsPivot = (function () {
        function DataImportsPivot(client, renderArea) {
            var _this = this;
            this.renderArea = renderArea;
            this.client = client;
            this.data = [];
            this.grid = $(this.renderArea).find('#grid').addClass('usersGrid').fxDataGrid({
                columns: [
                    { name: 'Name', field: 'name' },
                    { name: 'Description', field: 'description' },
                    { name: 'Status', field: 'status' }
                ],
                data: this.data,
                selectable: true,
                multiselect: true,
                resizable: true,
                rowSelect: function (selected, unselected) {
                    _this.removeCommand.setDisabled(_this.grid.fxDataGrid('getSelectedRows').length === 0);
                }
            });
        }
        DataImportsPivot.prototype.setRemoveCommand = function (removeCommand) {
            this.removeCommand = removeCommand;
            this.removeCommand.setDisabled(this.grid.fxDataGrid('getSelectedRows').length === 0);
        };
        DataImportsPivot.prototype.refreshFromService = function () {
            var _this = this;
            Shell.UI.Spinner.show();
            this.client.listDataImports().done(function (dataImports) {
                Shell.UI.Spinner.hide();
                var gridData = [];
                DataLab.Util.forEach(dataImports, function (dataImport) {
                    gridData.push({
                        id: dataImport.Id,
                        name: dataImport.DestinationName,
                        description: dataImport.DestinationDescription,
                        status: dataImport.ImportStatus.StatusCode + (dataImport.ImportStatus.StatusDetail ? ' - ' + dataImport.ImportStatus.StatusDetail : "") + (dataImport.ActivityId ? ", Service request ID: " + dataImport.ActivityId : "")
                    });
                });
                $.observable(_this.data).refresh(gridData);
            });
        };
        DataImportsPivot.prototype.removeDataImports = function () {
            var _this = this;
            var rowCount = this.grid.fxDataGrid('getSelectedRows').length;
            var confirmation = new Shell.UI.Notifications.Confirmation('Remove ' + rowCount + ' Data Import(s)', 'active');
            confirmation.setActions([
                new Shell.UI.Notifications.Buttons.yes(function () {
                    _this.doRemoveDataImports();
                    Shell.Diagnostics.Telemetry.customEvent("RemoveDataImport_Yes", "ShellUICommands");
                }),
                new Shell.UI.Notifications.Buttons.no(function () {
                    Shell.UI.Notifications.remove(confirmation);
                    Shell.Diagnostics.Telemetry.customEvent("RemoveDataImport_No", "ShellUICommands");
                })
            ]);
            Shell.UI.Notifications.add(confirmation);
        };
        DataImportsPivot.prototype.doRemoveDataImports = function () {
            var _this = this;
            var selectedRows = this.grid.fxDataGrid('getSelectedRows');
            var promises = [];
            DataLab.Util.forEach(selectedRows, function (row) {
                var dataItem = row.dataItem;
                promises.push(_this.client.deleteDataImport(dataItem.id));
            });
            Shell.UI.Spinner.show();
            $.when.apply($, promises).always(function () {
                _this.refreshFromService();
            });
        };
        return DataImportsPivot;
    })();
    ExperimentEditor.DataImportsPivot = DataImportsPivot;
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
/// <reference path="../../../DataLabViews/ExperimentView.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var ExperimentEditor;
(function (ExperimentEditor) {
    var Feedback;
    (function (Feedback) {
        var FeedbackControlViewModel = (function (_super) {
            __extends(FeedbackControlViewModel, _super);
            function FeedbackControlViewModel() {
                var _this = this;
                _super.call(this);
                this.MAX_LENGTH = 1000;
                this.isExpanded = ko.observable(false);
                this.isHappy = ko.observable(true);
                this.isSending = false;
                this.question = ko.observable(DataLab.LocalizedResources.feedbackWhatDidYouLike);
                this.feedbackText = ko.observable('');
                this.remainingLength = ko.computed(function () {
                    var difference = _this.MAX_LENGTH - _this.feedbackText().length;
                    return difference > 0 ? difference : 0;
                });
                this.remainingLengthText = ko.computed(function () { return DataLab.Util.format(DataLab.LocalizedResources.feedbackCharactersLeft || "", _this.remainingLength().toString()); });
                this.expand = function () {
                    if (_this.isExpanded() === false) {
                        _this.isExpanded(true);
                        Shell.Diagnostics.Telemetry.customEvent("Open", "HeaderBarFeedback");
                    }
                };
                this.collapse = function () {
                    _this.isExpanded(false);
                    Shell.Diagnostics.Telemetry.customEvent("Close", "HeaderBarFeedback");
                };
                this.smileyHappySelected = function () {
                    _this.isHappy(true);
                    _this.question(DataLab.LocalizedResources.feedbackWhatDidYouLike);
                    Shell.Diagnostics.Telemetry.customEvent("MoodSmileyHappy", "HeaderBarFeedback");
                };
                this.smileySadSelected = function () {
                    _this.isHappy(false);
                    _this.question(DataLab.LocalizedResources.feedbackIsThereSomethingWeCanDoBetter);
                    Shell.Diagnostics.Telemetry.customEvent("MoodSmileySad", "HeaderBarFeedback");
                };
                this.sendFeedback = function () {
                    if (_this.isSending === true) {
                        return false;
                    }
                    _this.isSending = true;
                    var feedbackObj = {
                        isHappy: _this.isHappy(),
                        src: 'feedbackBox',
                        content: _this.feedbackText(),
                    };
                    var feedbackStr = JSON.stringify(feedbackObj);
                    Shell.Diagnostics.Telemetry.feedbackInfo(feedbackStr, undefined);
                    Shell.Diagnostics.Telemetry.featureUsage(20 /* SendFeedback */, 21 /* Feedback */, null, null, null, JSON.stringify({ isHappy: _this.isHappy() }));
                    _this.feedbackText('');
                    _this.collapse();
                    _this.isSending = false;
                };
            }
            return FeedbackControlViewModel;
        })(DataLab.Util.Disposable);
        Feedback.FeedbackControlViewModel = FeedbackControlViewModel;
    })(Feedback = ExperimentEditor.Feedback || (ExperimentEditor.Feedback = {}));
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../Global.ts" />
/// <reference path="../ViewModel/ExperimentEditor/FeedbackControlViewModel.ts" />
var ExperimentEditor;
(function (ExperimentEditor) {
    var ShellControls;
    (function (ShellControls) {
        function initFeedbackControl() {
            var element = $(ExperimentEditor._feedbackControlMarkup);
            Impl.UI.HeaderBar.addControl(element);
            var bindingElement = element.get(0);
            var viewModel = new ExperimentEditor.Feedback.FeedbackControlViewModel();
            ko.applyBindings(viewModel, bindingElement);
            $('body').click(function (evt) {
                if (viewModel.isExpanded()) {
                    if ($(evt.target).parents('.datalab-feedback').length === 0) {
                        viewModel.collapse();
                    }
                }
            });
        }
        ShellControls.initFeedbackControl = initFeedbackControl;
    })(ShellControls = ExperimentEditor.ShellControls || (ExperimentEditor.ShellControls = {}));
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
/// <reference path="../../View/OnlineSearch.ts" />
var ExperimentEditor;
(function (ExperimentEditor) {
    var SSIMSearch;
    (function (SSIMSearch) {
        var Constants;
        (function (Constants) {
            Constants.resultsPerPage = 10;
            Constants.maxLengthOfDatasetName = 100;
            Constants.pageBatchSize = 5;
            Constants.maxDescription = 110;
        })(Constants = SSIMSearch.Constants || (SSIMSearch.Constants = {}));
        var SearchResultViewModel = (function () {
            function SearchResultViewModel(searchResult) {
                this.resultTitle = searchResult.Title;
                this.resultDescription = searchResult.Description;
                this.resultDataUrl = searchResult.DataSourceAddress;
                this.resultDataType = searchResult.DataSourceType;
                this.resultDataAuthentication = searchResult.DataSourceAuthentication;
                this.resultDataProtocol = searchResult.DataSourceProtocol;
                this.resultPreviewUrl = searchResult.DataPreviewAddress;
                this.iconUrl = searchResult.PublisherIconUrl;
                this.iconVisible = !!this.iconUrl;
                this.hovered = ko.observable(false);
                if (this.resultDescription && this.resultDescription.length > Constants.maxDescription) {
                    this.shortDescription = this.resultDescription.substr(0, Constants.maxDescription) + '...';
                }
                else {
                    this.shortDescription = this.resultDescription;
                }
            }
            return SearchResultViewModel;
        })();
        SSIMSearch.SearchResultViewModel = SearchResultViewModel;
        var SearchResultsPage = (function () {
            function SearchResultsPage(pageId, selected, currentPage) {
                var _this = this;
                this.pageId = pageId;
                this.selected = ko.observable(selected);
                var trackPageFunc = function (val) {
                    if (val) {
                        currentPage(_this.pageId);
                    }
                };
                this.selected.subscribe(trackPageFunc);
                trackPageFunc(selected);
            }
            return SearchResultsPage;
        })();
        SSIMSearch.SearchResultsPage = SearchResultsPage;
        SSIMSearch.windowHeight = null;
        var SearchTabViewModel = (function () {
            function SearchTabViewModel(client, parent) {
                var _this = this;
                this.searchResults = ko.observableArray();
                this.searchQuery = ko.observable("");
                this.hoveredItem = ko.observable(null);
                this.noResultsFound = ko.observable(false);
                this.searchResultCount = ko.observable(0);
                this.searchResultPages = ko.observableArray();
                this.currentPage = ko.observable(0);
                this.pageCount = ko.observable(0);
                this.headerText = ko.computed(function () {
                    return _this.searchResultCount() + " results";
                });
                this.previewTitle = ko.computed(function () {
                    return _this.hoveredItem() ? (_this.hoveredItem()).resultTitle : "";
                });
                this.previewDescription = ko.computed(function () {
                    return _this.hoveredItem() ? (_this.hoveredItem()).resultDescription : "";
                });
                this.selectedPreviewAddress = ko.computed(function () {
                    return _this.hoveredItem() ? (_this.hoveredItem()).resultPreviewUrl : "";
                });
                this.datalabPreviewUrl = ko.computed(function () {
                    return _this.selectedPreviewAddress() ? "/Home/Preview?url=" + _this.selectedPreviewAddress() : "";
                });
                this.previousEnabled = ko.computed(function () {
                    return (_this.currentPage() > 1);
                });
                this.nextEnabled = ko.computed(function () {
                    return (_this.pageCount() > _this.currentPage());
                });
                this.searchActive = ko.observable(false);
                this.previewLoadActive = ko.observable(false);
                this.spinnerActive = ko.computed(function () {
                    var returnValue = _this.searchActive() || _this.previewLoadActive();
                    if (returnValue) {
                        Shell.UI.Spinner.show();
                    }
                    else {
                        Shell.UI.Spinner.hide();
                    }
                    return returnValue;
                });
                this.refresh(client, parent);
            }
            SearchTabViewModel.prototype.refresh = function (client, searchView) {
                this.searchBoxFocus = true;
                this.parent = searchView;
                this.client = client;
            };
            SearchTabViewModel.prototype.selectItem = function (item) {
                this.parent.launchSaveDatasetDialog();
            };
            SearchTabViewModel.prototype.selectPreview = function (item) {
                // Show spinner only if address changes, because in that case load event won't fire, thus spinner won't disappear
                if (this.hoveredItem() !== item) {
                    DataLab.Util.forEach(this.searchResults(), function (sr) {
                        sr.hovered(false);
                    });
                    this.hoveredItem(item);
                    item.hovered(true);
                    this.previewLoadActive(true);
                }
            };
            SearchTabViewModel.prototype.doSearch = function (query, page, createPages) {
                var _this = this;
                this.searchActive(true);
                this.activeQuery = query;
                this.activePage = page;
                this.client.ssimSearch(query, page, Constants.resultsPerPage).done(function (d) {
                    if (query === _this.activeQuery && page === _this.activePage) {
                        var ssimSearchResults = d;
                        _this.searchResults.removeAll();
                        DataLab.Util.forEach(ssimSearchResults.SearchResults, function (ssimResult) {
                            ssimResult.Title = ssimResult.Title.trim();
                            _this.searchResults.push(new SearchResultViewModel(ssimResult));
                        });
                        _this.searchResultCount(ssimSearchResults.TotalResults);
                        _this.noResultsFound(_this.searchResults().length === 0);
                        if (createPages) {
                            _this.pageCount(Math.floor((ssimSearchResults.TotalResults - 1) / Constants.resultsPerPage) + 1);
                            for (var i = 0; i < Math.min(Constants.pageBatchSize, _this.pageCount()); i++) {
                                _this.searchResultPages.push(new SearchResultsPage(i + 1, false, _this.currentPage));
                            }
                            if (i > 0) {
                                _this.searchResultPages()[0].selected(true);
                            }
                        }
                        _this.searchActive(false);
                    }
                });
            };
            SearchTabViewModel.prototype.search = function () {
                this.searchResults.removeAll();
                this.searchResultPages.removeAll();
                this.hoveredItem(null);
                this.noResultsFound(false);
                this.searchResultCount(0);
                this.currentPage(0);
                this.pageCount(0);
                var queryToSend = encodeURIComponent(this.searchQuery().trim().replace(/</g, ''));
                if (queryToSend.length > Constants.maxLengthOfDatasetName) {
                    queryToSend = "";
                    this.searchQuery("");
                }
                if (queryToSend) {
                    this.currentQuery = queryToSend;
                    this.doSearch(queryToSend, 1, true);
                }
            };
            SearchTabViewModel.prototype.doSwitchPage = function (page) {
                this.hoveredItem(null);
                this.doSearch(this.currentQuery, page.pageId, false);
                DataLab.Util.forEach(this.searchResultPages(), function (p) {
                    p.selected(false);
                });
                page.selected(true);
            };
            // This functions loads couple of pages before and after the selected, so that selected one is in center
            SearchTabViewModel.prototype.center = function (target) {
                var span = Math.floor(Constants.pageBatchSize / 2);
                this.searchResultPages.removeAll();
                var toRet = null;
                var from = Math.max(1, target - span);
                var to = Math.min(from + Constants.pageBatchSize - 1, this.pageCount());
                if (to - from < Constants.pageBatchSize - 1) {
                    from = Math.max(1, this.pageCount() - Constants.pageBatchSize + 1);
                }
                for (var i = from; i <= to; i++) {
                    if (i > 0 && i <= this.pageCount()) {
                        var newPage = new SearchResultsPage(i, false, this.currentPage);
                        this.searchResultPages.push(newPage);
                        if (i === target) {
                            toRet = newPage;
                        }
                    }
                }
                return toRet;
            };
            SearchTabViewModel.prototype.switchPage = function (page) {
                this.doSwitchPage(this.center(page.pageId));
            };
            SearchTabViewModel.prototype.prevPage = function () {
                var targetPage = this.currentPage() - 1;
                this.doSwitchPage(this.center(targetPage));
            };
            SearchTabViewModel.prototype.nextPage = function () {
                var targetPage = this.currentPage() + 1;
                this.doSwitchPage(this.center(targetPage));
            };
            SearchTabViewModel.prototype.handleKeypress = function (data, key) {
                if (key.keyCode === 13 /* Return */) {
                    this.search();
                    return false;
                }
                return true;
            };
            SearchTabViewModel.prototype.iframeLoad = function (data, event) {
                this.previewLoadActive(false);
            };
            return SearchTabViewModel;
        })();
        SSIMSearch.SearchTabViewModel = SearchTabViewModel;
    })(SSIMSearch = ExperimentEditor.SSIMSearch || (ExperimentEditor.SSIMSearch = {}));
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
/// <reference path="../../View/OnlineSearch.ts" />
/// <reference path="SearchViewModels.ts" />
/// <reference path="../../../../ExperimentEditor/Typescript/View/DialogView.ts"/>
var ExperimentEditor;
(function (ExperimentEditor) {
    var SSIMSearch;
    (function (SSIMSearch) {
        var SaveDatasetViewModel = (function () {
            function SaveDatasetViewModel(selectedItem, workspace, client, activeNotifications) {
                this.dataset = new DataLab.Model.UnsavedResource(workspace, workspace.datasetCache, workspace.datasetUploadsInProgress, DataLab.Constants.DatasetName);
                this.dataset.name(selectedItem.resultTitle);
                this.dataset.description(selectedItem.resultDescription);
                this.dataUrl = selectedItem.resultDataUrl;
                this.selectedItem = selectedItem;
                this.workspace = workspace;
                this.client = client;
                this.activeNotifications = activeNotifications;
            }
            SaveDatasetViewModel.prototype.dismissed = function (result) {
                if (result.accepted) {
                    this.saveData();
                }
                else {
                    DataLab.Log.info("SSIM Dataset upload dialog cancelled");
                }
            };
            SaveDatasetViewModel.prototype.canBeAccepted = function () {
                // First we ensure that all fields are currently validating (initially they are quiet).
                // Attempting to dismiss this dialog should make all fields start complaining as needed.
                this.dataset.startValidating();
                return this.dataset.isValid();
            };
            SaveDatasetViewModel.prototype.saveData = function () {
                var _this = this;
                var deferred = $.Deferred();
                DataLab.Log.info("SSIM Dataset upload dialog accepted");
                var saveRequest = {
                    Name: this.dataset.name(),
                    Description: this.dataset.description(),
                    FamilyId: !this.dataset.familyId() ? "" : this.dataset.familyId(),
                    SsimDataSourceUrl: this.selectedItem.resultDataUrl,
                    DataSourceType: this.selectedItem.resultDataType,
                    DataSourceProtocol: this.selectedItem.resultDataProtocol,
                    DataSourceAuthentication: this.selectedItem.resultDataAuthentication
                };
                var pendingMessage = DataLab.LocalizedResources.ssimPendingDataset;
                var successMessage = DataLab.LocalizedResources.ssimUploadSuccess;
                var progress = new Shell.UI.Notifications.Progress(pendingMessage, "active", false);
                this.activeNotifications.push(progress);
                progress.setActions([new Shell.UI.Notifications.Buttons.ok(function () {
                    Shell.UI.Notifications.remove(progress);
                    DataLab.Util.removeElementFromArray(_this.activeNotifications, progress);
                })]);
                Shell.UI.Notifications.add(progress);
                var fail = function (message) {
                    progress.setTitle(message);
                    progress.setStatus("error");
                    deferred.reject(message);
                };
                this.client.saveSsimData(saveRequest).done(function (dataImportId) {
                    var repeater = new DataLab.Util.Repeater(function () {
                        return _this.client.getDataImport(dataImportId).done(function (dataImport) {
                            switch (dataImport.ImportStatus.StatusCode) {
                                case 3 /* Failed */:
                                    fail(DataLab.Util.format(DataLab.LocalizedResources.ssimUploadFailed, dataImport.ImportStatus.StatusDetail));
                                    repeater.stop();
                                    break;
                                case 4 /* Finished */:
                                    progress.setTitle(DataLab.Util.format(DataLab.LocalizedResources.ssimUpdatingCache, successMessage));
                                    progress.setValue(100);
                                    _this.client.listDatasetsAsync().done(function (datasets) {
                                        var dataset = DataLab.Util.first(datasets, function (d) {
                                            return d.Name === saveRequest.Name;
                                        }, null);
                                        _this.workspace.datasetCache.getItem(dataset.Id).done(function () {
                                            progress.setTitle(successMessage);
                                            progress.setStatus("success");
                                            deferred.resolve(successMessage);
                                        });
                                    });
                                    repeater.stop();
                                    break;
                                case 0 /* NotStarted */:
                                    progress.setTitle(pendingMessage);
                                    break;
                                case 2 /* Running */:
                                    progress.setTitle(DataLab.LocalizedResources.ssimDatasetUploading);
                                    progress.setValue(50);
                                    break;
                                default:
                                    fail(DataLab.LocalizedResources.ssimUnexpectedError);
                                    repeater.stop();
                                    break;
                            }
                        });
                    }, 500);
                    repeater.start();
                });
                return deferred.promise();
            };
            return SaveDatasetViewModel;
        })();
        SSIMSearch.SaveDatasetViewModel = SaveDatasetViewModel;
    })(SSIMSearch = ExperimentEditor.SSIMSearch || (ExperimentEditor.SSIMSearch = {}));
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../Global.ts" />
/// <reference path="../ViewModel/SSIMSearch/SaveSSIMDataDialog.ts" />
/// <reference path="../ViewModel/SSIMSearch/SearchViewModels.ts" />
/// <reference path="../../../ExperimentEditor/Typescript/View/DialogViewFactories.ts" />
var ExperimentEditor;
(function (ExperimentEditor) {
    var SSIMSearch;
    (function (SSIMSearch) {
        var searchTabViewModel = null;
        var SearchView = (function () {
            function SearchView(renderArea, client, workspace) {
                var _this = this;
                this.client = client;
                this.workspace = workspace;
                if (!searchTabViewModel) {
                    searchTabViewModel = new SSIMSearch.SearchTabViewModel(client, this);
                }
                else {
                    searchTabViewModel.refresh(client, this);
                }
                this.viewModel = searchTabViewModel;
                var bindElement = $("#idSearchTemplate").get(0);
                ko.applyBindings(this.viewModel, bindElement);
                this.activeNotifications = [];
                // Remove all notifications when we navigate out of 'online search' tab
                $(window).one('hashchange', function () {
                    _this.removeNotifications();
                    ko.cleanNode(bindElement);
                });
            }
            SearchView.prototype.removeNotifications = function () {
                this.activeNotifications.forEach(function (n) {
                    Shell.UI.Notifications.remove(n);
                });
                this.activeNotifications = [];
            };
            SearchView.prototype.launchSaveDatasetDialog = function () {
                var selectedItem = this.viewModel.hoveredItem();
                if (selectedItem) {
                    var datasetViewModel = new SSIMSearch.SaveDatasetViewModel(selectedItem, this.workspace, this.client, this.activeNotifications);
                    ExperimentEditor.DialogViews.SaveSSSIMDataset.show(datasetViewModel);
                }
            };
            return SearchView;
        })();
        SSIMSearch.SearchView = SearchView;
    })(SSIMSearch = ExperimentEditor.SSIMSearch || (ExperimentEditor.SSIMSearch = {}));
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../Global.ts" />
var ExperimentEditor;
(function (ExperimentEditor) {
    var PublishModelPackageDialogViewModel = (function () {
        function PublishModelPackageDialogViewModel(description, error) {
            this.packageName = ko.observable(description);
            this.error = error;
        }
        return PublishModelPackageDialogViewModel;
    })();
    ExperimentEditor.PublishModelPackageDialogViewModel = PublishModelPackageDialogViewModel;
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../Global.ts" />
var ExperimentEditor;
(function (ExperimentEditor) {
    var Constants;
    (function (Constants) {
        var UsersPivot;
        (function (UsersPivot) {
            UsersPivot.inviteText = DataLab.LocalizedResources.enterAddresses;
            UsersPivot.reinviteText = DataLab.LocalizedResources.incorrectEmailPleaseCorrect;
            UsersPivot.title = DataLab.LocalizedResources.inviteUsers;
            UsersPivot.userRoleDescription = DataLab.LocalizedResources.userActions;
            UsersPivot.ownerRoleDescription = DataLab.LocalizedResources.ownerActions;
            UsersPivot.invalidRowMarkupTemplate = "<span class='invitationDialogInvalidAddress' onclick=\"$(this).removeClass('invitationDialogInvalidAddress')\">%%EMAIL%%</span>;&nbsp;";
            UsersPivot.userActiveText = DataLab.LocalizedResources.workspaceUserInviteActiveText;
            UsersPivot.userInvitedText = DataLab.LocalizedResources.workspaceUserInviteInvitedText;
            UsersPivot.inviteDialogSize = [800, 520];
        })(UsersPivot = Constants.UsersPivot || (Constants.UsersPivot = {}));
    })(Constants = ExperimentEditor.Constants || (ExperimentEditor.Constants = {}));
    // html / text of the dialog are not included in the viewModel
    var InvitationDialogViewModel = (function () {
        function InvitationDialogViewModel() {
        }
        return InvitationDialogViewModel;
    })();
    ExperimentEditor.InvitationDialogViewModel = InvitationDialogViewModel;
    (function (EntityType) {
        EntityType[EntityType["User"] = 0] = "User";
        EntityType[EntityType["Invitation"] = 1] = "Invitation";
    })(ExperimentEditor.EntityType || (ExperimentEditor.EntityType = {}));
    var EntityType = ExperimentEditor.EntityType;
    var UsersPivot = (function () {
        function UsersPivot(client, renderArea) {
            var _this = this;
            this.client = client;
            this.renderArea = renderArea;
            this.data = [];
            this.grid = $(this.renderArea).find('#grid').addClass('usersGrid').fxDataGrid({
                columns: [
                    { name: DataLab.LocalizedResources.name, field: 'name' },
                    { name: DataLab.LocalizedResources.email, field: 'email', },
                    { name: DataLab.LocalizedResources.role, field: 'role' },
                    { name: DataLab.LocalizedResources.status, field: 'status' },
                ],
                data: this.data,
                selectable: true,
                multiselect: true,
                resizable: true,
                rowSelect: function (selected, unselected) {
                    _this.removeCommand.setDisabled(_this.grid.fxDataGrid('getSelectedRows').length === 0);
                }
            });
        }
        UsersPivot.prototype.refreshFromService = function () {
            var _this = this;
            Shell.UI.Spinner.show();
            this.client.listUsersAndInvitationsAsync().done(function (usersAndInvitations) {
                Shell.UI.Spinner.hide();
                _this.ownersCount = 0;
                var gridData = [];
                usersAndInvitations.forEach(function (userInvite) {
                    if (userInvite.User) {
                        var status = userInvite.Status;
                        var type = 0 /* User */;
                        var displayString = Constants.UsersPivot.userActiveText;
                        if (DataLab.WorkspaceManagement.InvitationStatus[status] == 0 /* Invited */) {
                            type = 1 /* Invitation */;
                            displayString = Constants.UsersPivot.userInvitedText;
                        }
                        gridData.push({
                            entityType: type,
                            id: userInvite.User.UserId,
                            name: userInvite.User.Name,
                            email: userInvite.User.Email,
                            role: userInvite.User.Role,
                            status: displayString,
                        });
                        if (type === 0 /* User */ && userInvite.User.Role === 'Owner') {
                            _this.ownersCount++;
                        }
                    }
                    else {
                        throw DataLab.LocalizedResources.userAndInvitationNull;
                    }
                });
                $.observable(_this.data).refresh(gridData);
            });
        };
        UsersPivot.prototype.removeEntity = function (item) {
            if (item.entityType === 0 /* User */) {
                return this.client.removeUser(item.id);
            }
            else if (item.entityType === 1 /* Invitation */) {
                return this.client.removeUser(item.email);
            }
        };
        UsersPivot.prototype.removeUsers = function () {
            var _this = this;
            var usersToRemove = this.grid.fxDataGrid('getSelectedRows');
            var usersToRemoveCount = usersToRemove.length;
            var ownersToRemove = 0;
            usersToRemove.forEach(function (user) {
                var dataItem = user.dataItem;
                if (dataItem.entityType === 0 /* User */ && dataItem.role === "Owner") {
                    ownersToRemove++;
                }
            });
            if (ownersToRemove === this.ownersCount) {
                this.addFailNotification(DataLab.LocalizedResources.cannotRemoveAllOwners);
                return;
            }
            var failedCount = 0;
            var confirmation;
            if (usersToRemoveCount > 1) {
                confirmation = new Shell.UI.Notifications.Confirmation(DataLab.Util.format(DataLab.LocalizedResources.removeUsers, usersToRemoveCount), 'active');
            }
            else {
                confirmation = new Shell.UI.Notifications.Confirmation(DataLab.Util.format(DataLab.LocalizedResources.removeUser, usersToRemove[0].dataItem.email), 'active');
            }
            confirmation.setActions([
                new Shell.UI.Notifications.Buttons.yes(function () {
                    _this.doRemoveUsers(usersToRemove);
                    Shell.Diagnostics.Telemetry.customEvent("RemoveUsers", "Settings", usersToRemove.length);
                }),
                new Shell.UI.Notifications.Buttons.no(function () {
                    Shell.UI.Notifications.remove(confirmation);
                    Shell.Diagnostics.Telemetry.customEvent("RemoveUsersAttemptCancelled", "Settings");
                })
            ]);
            Shell.UI.Notifications.add(confirmation);
        };
        UsersPivot.prototype.doRemoveUsers = function (usersToRemove) {
            var _this = this;
            var failedCount = 0;
            var promises = [];
            Shell.UI.Spinner.show();
            usersToRemove.forEach(function (user) {
                promises.push(_this.removeEntity(user.dataItem).fail(function () {
                    failedCount++;
                }));
            });
            $.when.apply($, promises).always(function () {
                _this.refreshFromService();
                if (failedCount > 0) {
                    _this.addFailNotification('Failed to remove ' + failedCount + ' out of ' + usersToRemove.length + ', Unknown error occured');
                }
            });
        };
        UsersPivot.prototype.launchInvitationDialog = function (htmlText) {
            var _this = this;
            var instructionText = htmlText ? Constants.UsersPivot.reinviteText : Constants.UsersPivot.inviteText;
            var dialog = $('<div/>');
            var addressesBox;
            dialog.fxsDialog({
                closing: function (val) {
                    if (val.completed) {
                        if (addressesBox.text()) {
                            _this.sendInvitations(addressesBox.text());
                        }
                    }
                },
                size: Constants.UsersPivot.inviteDialogSize
            });
            var dialogViewModel = dialog.fxsDialog('getViewModel');
            dialogViewModel.title(Constants.UsersPivot.title);
            dialogViewModel.content(ExperimentEditor._invitationDialogMarkup);
            $('.fxs-modalpresenter').fxsModalPresenter('open', dialog);
            addressesBox = dialog.find('.invitationDialogAddressesBox');
            addressesBox.html(htmlText);
            addressesBox.focus();
            this.viewModel = new InvitationDialogViewModel();
            this.viewModel.error = (htmlText !== "");
            this.viewModel.role = ko.observable();
            this.viewModel.instructions = instructionText;
            this.viewModel.roleDescription = ko.computed(function () {
                if (_this.viewModel.role() === 'Owner') {
                    return Constants.UsersPivot.ownerRoleDescription;
                }
                else {
                    return Constants.UsersPivot.userRoleDescription;
                }
            });
            this.viewModel.pressHandler = function (data, key) {
                // Change behavior of enter key as it causes different result across browsers, it will enter semicolon which is a valid delimiter
                if (key.keyCode === 13 /* Return */) {
                    addressesBox.html(addressesBox.html() + '; ');
                    // Move caret to the end of editable div
                    var range = document.createRange();
                    range.selectNodeContents(addressesBox.get(0));
                    range.collapse(false);
                    var selection = window.getSelection();
                    selection.removeAllRanges();
                    selection.addRange(range);
                    return false;
                }
                return true;
            };
            // prevent drag and drop of dialog controls on content editable elements
            // it will still be possible to drop content from outside of current browser window, e.g. list of email addresses from outlook
            var dragging = false;
            dialog.on('dragstart', function () {
                dragging = true;
            });
            dialog.on('drop', function () {
                if (dragging) {
                    dragging = false;
                    return false;
                }
                return true;
            });
            ko.applyBindings(this.viewModel, dialog.find('.invitationDialogContent').get(0));
        };
        UsersPivot.prototype.sendInvitations = function (inviteString) {
            var _this = this;
            if (!inviteString.trim()) {
                this.launchInvitationDialog('');
            }
            Shell.UI.Spinner.show();
            var role = this.viewModel.role();
            var invitationRequest = {
                Emails: inviteString,
                Role: role
            };
            var html;
            Shell.Diagnostics.Telemetry.customEvent("InviteUsers", "Settings", JSON.stringify(invitationRequest));
            this.client.sendInvitation(invitationRequest).done(function (rsp) {
                var response = rsp;
                var error = DataLab.Util.first(response, function (r) { return r.Failed; }, false);
                if (error) {
                    var html = '';
                    response.forEach(function (r) {
                        if (r.Failed) {
                            html += Constants.UsersPivot.invalidRowMarkupTemplate.replace('%%EMAIL%%', DataLab.Util.encodeAsHtml(r.Email));
                        }
                        else {
                            html += DataLab.Util.encodeAsHtml(r.Email) + ';&nbsp;';
                        }
                    });
                    setTimeout(function () {
                        _this.launchInvitationDialog(html);
                        Shell.UI.Spinner.hide();
                    }, 500);
                }
                else {
                    _this.refreshFromService();
                }
            }).fail(function (failureInfo) {
                Shell.UI.Spinner.hide();
                var msg = DataLab.Util.format(DataLab.LocalizedResources.invitationCouldNotSendInvitationTo, inviteString);
                var errorNotification = new Shell.UI.Notifications.Notification(msg, "error");
                errorNotification.setActions([new Shell.UI.Notifications.Buttons.ok()]);
                Shell.UI.Notifications.add(errorNotification);
            });
        };
        UsersPivot.prototype.setRemoveCommand = function (removeCommand) {
            this.removeCommand = removeCommand;
            this.removeCommand.setDisabled(this.grid.fxDataGrid('getSelectedRows').length === 0);
        };
        UsersPivot.prototype.addFailNotification = function (message) {
            var failNotification = new Shell.UI.Notifications.Notification(message, 'error');
            failNotification.setActions([
                new Shell.UI.Notifications.Buttons.close(function () {
                    Shell.UI.Notifications.remove(failNotification);
                })
            ]);
            Shell.UI.Notifications.add(failNotification);
        };
        return UsersPivot;
    })();
    ExperimentEditor.UsersPivot = UsersPivot;
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../Global.ts" />
var ExperimentEditor;
(function (ExperimentEditor) {
    var ShellControls;
    (function (ShellControls) {
        var _updateBar = null;
        var _client;
        var _friendlyName = null;
        var _description = null;
        var Constants;
        (function (Constants) {
            var WorkspacesBar;
            (function (WorkspacesBar) {
                WorkspacesBar.workspaceManagerClass = 'datalab-workspace-manager';
                WorkspacesBar.menuHeaderItemClass = 'workspaces-menu-header-item';
                WorkspacesBar.menuItemClass = 'workspaces-menu-item';
                WorkspacesBar.fxsSelectedItemClass = 'fxs-contextmenu-languagepicker-selected';
                WorkspacesBar.maxTopPosition = 600;
                WorkspacesBar.animationDuration = 500;
            })(WorkspacesBar = Constants.WorkspacesBar || (Constants.WorkspacesBar = {}));
        })(Constants = ShellControls.Constants || (ShellControls.Constants = {}));
        var WorkspacesBar;
        (function (WorkspacesBar) {
            WorkspacesBar.settingsNameFocusOnNameBox = false;
        })(WorkspacesBar = ShellControls.WorkspacesBar || (ShellControls.WorkspacesBar = {}));
        function createWorkspacesBar(client, isOwner) {
            _client = client;
            var workspaceManager = $('<div/>');
            Impl.UI.HeaderBar.addControl(workspaceManager);
            client.listWorkspacesAsync().done(function (w) {
                doCreate(workspaceManager, client.workspaceId, w, isOwner);
            });
        }
        ShellControls.createWorkspacesBar = createWorkspacesBar;
        function valueOrDefault(name) {
            return name ? name : '-';
        }
        ;
        function toolTipText(name, description) {
            return valueOrDefault(name) + '\r\n' + DataLab.LocalizedResources.description + valueOrDefault(description);
        }
        ;
        function doCreate(workspaceManager, workspaceId, workspaces, isOwner) {
            var workspaceManager;
            var selectedElement;
            var menuOpenHandler;
            var items = [];
            var currentWorkspace = DataLab.Util.first(workspaces, function (w) { return w.WorkspaceId === workspaceId; }, null);
            // The list of authorized workspaces may not have the current one in the event an admin is viewing a
            // workspace that belongs to another user. For simplicity, we populate a placeholder.
            if (!currentWorkspace) {
                currentWorkspace = {
                    WorkspaceId: workspaceId,
                    FriendlyName: "Workspace",
                    Description: ""
                };
                workspaces.push(currentWorkspace);
            }
            items.push({
                type: 'text',
                text: DataLab.LocalizedResources.workspaceBarWorkspaces,
                setup: function (element) {
                    element.addClass(Constants.WorkspacesBar.menuHeaderItemClass);
                }
            });
            workspaces.forEach(function (workspace) {
                items.push({
                    type: 'text',
                    text: valueOrDefault(workspace.FriendlyName),
                    setup: function (element) {
                        element.addClass(Constants.WorkspacesBar.menuItemClass).attr('title', toolTipText(workspace.FriendlyName, workspace.Description));
                        if (workspace === currentWorkspace) {
                            element.addClass(Constants.WorkspacesBar.fxsSelectedItemClass);
                            selectedElement = element;
                        }
                    },
                    click: function () {
                        if (workspace !== currentWorkspace) {
                            Shell.UI.Spinner.show();
                            Shell.Diagnostics.Telemetry.customEvent("SwitchWorkspace", "Settings", workspace.WorkspaceId);
                            window.location.href = '/Home/ViewWorkspace/' + workspace.WorkspaceId;
                        }
                    }
                });
            });
            items.push({ type: 'separator' });
            items.push({
                type: 'text',
                text: DataLab.LocalizedResources.workspaceBarUsefulActions,
                setup: function (element) {
                    element.addClass(Constants.WorkspacesBar.menuHeaderItemClass);
                }
            });
            items.push({
                type: 'text',
                text: DataLab.LocalizedResources.workspaceBarRenameWorkspace,
                click: function () {
                    Shell.UI.Navigation.navigate({
                        extension: 'Settings',
                        view: 'Name'
                    });
                    WorkspacesBar.settingsNameFocusOnNameBox = true;
                }
            });
            if (isOwner) {
                items.push({
                    type: 'text',
                    text: DataLab.LocalizedResources.workspaceBarManageWorkspaceUsers,
                    click: function () {
                        Shell.UI.Navigation.navigate({
                            extension: 'Settings',
                            view: 'Users'
                        });
                    }
                });
            }
            workspaceManager.fxsAvatarBar({ menuItems: items, name: '' });
            // Workspaces bar customization
            workspaceManager.addClass(Constants.WorkspacesBar.workspaceManagerClass);
            var menu = workspaceManager.find('.fxs-avatarbar-menu');
            // Two things are handled when menu is opened:
            // 1. Title has to removed from the avatar bar element otherwise it will appear when hoving over menu items that don't have title defined, e.g. WORKSPACES:
            // 2. Scroll to selected item if needed
            var hasScrolled = false;
            var maxTopPosition = 600;
            var animationDuration = 500;
            menuOpenHandler = function (opened) {
                if (opened) {
                    workspaceManager.removeAttr('title');
                    var topPosition = selectedElement.position().top;
                    if (topPosition > maxTopPosition && !hasScrolled) {
                        menu.animate({
                            scrollTop: topPosition
                        }, animationDuration);
                        hasScrolled = true;
                    }
                }
                else {
                    var toolTip = toolTipText(currentWorkspace.FriendlyName, currentWorkspace.Description);
                    workspaceManager.attr('title', toolTip);
                }
            };
            workspaceManager.fxsAvatarBar('getViewModel').menuOpen.subscribe(function (val) {
                menuOpenHandler(val);
            });
            _updateBar = function (name, description) {
                currentWorkspace.FriendlyName = valueOrDefault(name);
                currentWorkspace.Description = valueOrDefault(description);
                workspaceManager.fxsAvatarBar('getViewModel').name(currentWorkspace.FriendlyName);
                selectedElement.attr('title', toolTipText(name, description));
                selectedElement.find('a').text(currentWorkspace.FriendlyName);
                menuOpenHandler(workspaceManager.fxsAvatarBar('getViewModel').menuOpen());
            };
            // If name has been set by renaming on settings screen update name and description
            if (_friendlyName || _description) {
                currentWorkspace.FriendlyName = _friendlyName;
                currentWorkspace.Description = _description;
            }
            // Populate initial values for the current workspace (may change via the settings page).
            // For an admin user, we may be viewing a workspace not in the list. In that case, we give up and show a '-'.
            _updateBar(currentWorkspace.FriendlyName, currentWorkspace.Description);
        }
        function updateBar(settings) {
            // Update bar only if it has been created, otherwise set internal variables in order to update later
            if (_updateBar) {
                _updateBar(settings.friendlyName(), settings.description());
            }
            else {
                _friendlyName = settings.friendlyName();
                _description = settings.description();
            }
        }
        ShellControls.updateBar = updateBar;
    })(ShellControls = ExperimentEditor.ShellControls || (ExperimentEditor.ShellControls = {}));
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../Global.ts" />
/// <reference path="WorkspacesBar.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var ExperimentEditor;
(function (ExperimentEditor) {
    var radioToggleValues = [
        { text: "Yes", value: true },
        { text: "No", value: false }
    ];
    var WorkspaceSettings = (function (_super) {
        __extends(WorkspaceSettings, _super);
        function WorkspaceSettings(client, workspace, renderArea, readOnly) {
            var _this = this;
            if (readOnly === void 0) { readOnly = false; }
            _super.call(this);
            this.hasBeenEdited = ko.observable(false);
            this.spaceQuota = ko.observable();
            // TODO: need a custom binding for inline string formatting
            this.spaceQuotaNote = DataLab.Util.format(DataLab.LocalizedResources.workspacePageGetMoreStorage, DataLab.Util.format('<a href="{1}" target="_blank">{0}</a>', DataLab.LocalizedResources.workspacePageStorageLearnMore, DataLab.LocalizedResources.workspacePageStorageLearnMoreUrl));
            // read-only account info
            this.accountInfo = [];
            this.client = client;
            this.workspace = workspace;
            this.renderArea = renderArea;
            this.isReadOnly = readOnly;
            this.workspaceTypeText = ko.observable();
            $("#RegeneratePrimaryToken").click(function () {
                _this.showConfirmation(true);
            });
            $("#RegenerateSecondaryToken").click(function () {
                _this.showConfirmation(false);
            });
            $("#UseDefaultHDInsightRadio").fxRadio({
                values: radioToggleValues,
                trackedit: false,
                change: function (event, args) {
                    _this.workspaceSettings().useDefaultHDInsightSettings(args.value.value);
                    _this.settingsUpdated();
                }
            });
            // Ensure that workspaceSettings is correctly populated before certain actions are performed.
            Shell.UI.Spinner.show();
            var workspaceSettingsPromise = this.workspace.getWorkspaceSettingsAsync().done(function (settings) {
                _this.workspaceSettings = ko.observable(settings);
                _this.workspaceTypeText(_this.getTextForWorkspaceType(settings.type));
                ExperimentEditor.ShellControls.updateBar(_this.workspaceSettings());
                if (ExperimentEditor.ShellControls.WorkspacesBar.settingsNameFocusOnNameBox) {
                    _this.renderArea.find('#FriendlyName').focus().select();
                    ExperimentEditor.ShellControls.WorkspacesBar.settingsNameFocusOnNameBox = false;
                }
                $("#UseDefaultHDInsightRadio").fxRadio("option", "value", DataLab.Util.first(radioToggleValues, function (v) {
                    return v.value === _this.workspaceSettings().useDefaultHDInsightSettings();
                }));
                _this.accountInfo.push({ label: DataLab.LocalizedResources.workspaceId, value: settings.id });
                if (DataLab.Features.showSubscriptionInfoEnabled() && DataLab.Model.WorkspaceTypeExtensions.isProduction(settings.type)) {
                    if (settings.createdTime) {
                        _this.accountInfo.push({ label: DataLab.LocalizedResources.workspaceCreationTime, value: settings.createdTime.toLocaleString() });
                    }
                    if (settings.ownerEmail) {
                        _this.accountInfo.push({ label: DataLab.LocalizedResources.workspaceOwnersEmail, value: settings.ownerEmail });
                    }
                    if (settings.subscriptionId) {
                        _this.accountInfo.push({ label: DataLab.LocalizedResources.workspaceSubscriptionId, value: settings.subscriptionId });
                    }
                    if (settings.userStorage) {
                        _this.accountInfo.push({ label: DataLab.LocalizedResources.workspaceStorageAccount, value: settings.userStorage });
                    }
                }
                _this.hasBeenEdited(false);
                _this.registerForDisposal(new DataLab.Util.DisposableKOApplyBindings(_this, _this.renderArea.get(0)));
            }).fail(function () {
                throw new Error("Load workspace settings failed.");
            });
            var spaceQuotaPromise = null;
            if (DataLab.Features.storageUsageWidgetEnabled() && DataLab.Trial.isWorkspaceTypeFree() && DataLab.Features.enableWorkspaceQuotasEnabled()) {
                spaceQuotaPromise = this.workspace.getStorageSpaceQuotaAsync().done(function (quota) {
                    _this.spaceQuota({
                        used: quota.UsedStorage / 1073741824,
                        total: quota.MaximumStorage / 1073741824,
                        usedLabel: DataLab.LocalizedResources.workspacePageUsed,
                        totalLabel: DataLab.LocalizedResources.workspacePageAvailable,
                        unitLabel: DataLab.LocalizedResources.workspacePageGB,
                        unitLabelLong: DataLab.LocalizedResources.workspacePageGigabytes,
                        overCapacityLabel: DataLab.LocalizedResources.storageOverCapacity,
                    });
                }).fail(function () {
                    DataLab.Log.error("Storage quota request failed.");
                });
                ;
            }
            else {
                spaceQuotaPromise = $.Deferred().resolve();
            }
            $.when(workspaceSettingsPromise, spaceQuotaPromise).always(function () {
                Shell.UI.Spinner.hide();
            });
        }
        // note: doesn't update this.accountInfo
        WorkspaceSettings.prototype.refreshFromService = function () {
            var _this = this;
            Shell.UI.Spinner.show();
            this.workspace.getWorkspaceSettingsAsync().done(function (d) {
                _this.workspaceSettings(d);
                _this.workspaceTypeText(_this.getTextForWorkspaceType(d.type));
                ExperimentEditor.ShellControls.updateBar(_this.workspaceSettings());
                $("#UseDefaultHDInsightRadio").fxRadio("option", "value", DataLab.Util.first(radioToggleValues, function (v) {
                    return v.value === _this.workspaceSettings().useDefaultHDInsightSettings();
                }));
                _this.hasBeenEdited(false);
                Shell.UI.Spinner.hide();
            }).fail(function () {
                throw new Error("Load workspace settings failed.");
            });
        };
        WorkspaceSettings.prototype.settingsUpdated = function () {
            if (!this.hasBeenEdited()) {
                this.hasBeenEdited(true);
            }
        };
        WorkspaceSettings.prototype.showConfirmation = function (isPrimary) {
            var _this = this;
            var tokenType = isPrimary ? 'Primary' : 'Secondary';
            var confirmation = new Shell.UI.Notifications.Confirmation(DataLab.Util.format(DataLab.LocalizedResources.workspaceRegenerateAuthTokenConfirmation, tokenType, this.workspaceSettings().friendlyName()), 'active');
            confirmation.setActions(Shell.UI.Notifications.ButtonSets.yesNo(function () {
                _this.regenerateAuthorizationToken(isPrimary);
                Shell.Diagnostics.Telemetry.customEvent("RegenerateAuthToken", "Settings", "isPrimary = " + isPrimary.toString());
            }));
            Shell.UI.Notifications.add(confirmation);
        };
        WorkspaceSettings.prototype.update = function () {
            var _this = this;
            if (this.isReadOnly) {
                return;
            }
            // If there is an invalid field on the page, don't update.
            if (!this.workspaceSettings().validateAll()) {
                return;
            }
            Shell.UI.Spinner.show();
            Shell.Diagnostics.Telemetry.customEvent("SaveWorkspace", "Settings");
            this.workspace.updateWorkspaceSettings(this.workspaceSettings(), 0 /* None */).done(function () {
                ExperimentEditor.ShellControls.updateBar(_this.workspaceSettings());
                _this.refreshFromService();
                Shell.UI.Spinner.hide();
            }).fail(function (error) {
                if (error.xmlHttpRequest.status === 412) {
                    var progress = _this.errorNotificationProgress(DataLab.Util.format(DataLab.LocalizedResources.workspaceUnableToSaveYourChangesPleaseRefresh, DataLab.LocalizedResources.productName));
                    Shell.UI.Notifications.add(progress);
                    Shell.UI.Spinner.hide();
                }
                else {
                    throw new Error("Update workspace settings failed.");
                }
            });
        };
        WorkspaceSettings.prototype.regenerateAuthorizationToken = function (isPrimary) {
            var _this = this;
            var regenerateType = isPrimary ? 1 /* Primary */ : 2 /* Secondary */;
            Shell.UI.Spinner.show();
            this.workspace.updateWorkspaceSettings(this.workspaceSettings(), regenerateType).done(function () {
                _this.refreshFromService();
                Shell.UI.Spinner.hide();
            }).fail(function (error) {
                if (error.xmlHttpRequest.status === 412) {
                    var progress = _this.errorNotificationProgress(DataLab.Util.format(DataLab.LocalizedResources.workspaceUnableToRegenAuthToken, DataLab.LocalizedResources.productName));
                    Shell.UI.Notifications.add(progress);
                    Shell.UI.Spinner.hide();
                }
                else {
                    throw new Error("Regenerate authorization token failed.");
                }
            });
        };
        WorkspaceSettings.prototype.discard = function () {
            this.refreshFromService();
        };
        // helper function for creating a generic error notification progress for failed promises
        WorkspaceSettings.prototype.errorNotificationProgress = function (title) {
            var progress = new Shell.UI.Notifications.Progress(title, "active", true);
            progress.setStatus("error");
            progress.setActions([new Shell.UI.Notifications.Buttons.close()]);
            return progress;
        };
        WorkspaceSettings.prototype.getTextForWorkspaceType = function (type) {
            switch (type) {
                case 1 /* Free */:
                    return DataLab.LocalizedResources.workspacePageWorkspaceTypeFree;
                case 2 /* Anonymous */:
                    return DataLab.LocalizedResources.workspacePageWorkspaceTypeAnonymous;
                default:
                    if (DataLab.Model.WorkspaceTypeExtensions.isProduction(type)) {
                        return DataLab.LocalizedResources.workspacePageWorkspaceTypeProduction;
                    }
                    return null;
            }
        };
        return WorkspaceSettings;
    })(DataLab.Util.Disposable);
    ExperimentEditor.WorkspaceSettings = WorkspaceSettings;
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
var ExperimentEditor;
(function (ExperimentEditor) {
    var Bubble;
    (function (Bubble) {
        var LocalStorageUserSettings = (function () {
            function LocalStorageUserSettings() {
            }
            LocalStorageUserSettings.prototype.shouldShowBubble = function (bubbleId) {
                if (typeof (Storage) !== "undefined") {
                    var value = localStorage.getItem(LocalStorageUserSettings.storageNamespace + bubbleId);
                    if (value) {
                        return false;
                    }
                }
                return true;
            };
            LocalStorageUserSettings.prototype.neverShowAgain = function (bubbleId) {
                if (typeof (Storage) !== "undefined") {
                    localStorage.setItem(LocalStorageUserSettings.storageNamespace + bubbleId, "false");
                }
            };
            LocalStorageUserSettings.prototype.resetAll = function () {
                if (typeof (Storage) !== "undefined") {
                    var length = localStorage.length;
                    for (var i = length; i >= 0; i--) {
                        var key = localStorage.key(i);
                        if (key.indexOf(LocalStorageUserSettings.storageNamespace) === 0) {
                            localStorage.removeItem(key);
                        }
                    }
                }
            };
            LocalStorageUserSettings.storageNamespace = "bubble.";
            return LocalStorageUserSettings;
        })();
        Bubble.LocalStorageUserSettings = LocalStorageUserSettings;
    })(Bubble = ExperimentEditor.Bubble || (ExperimentEditor.Bubble = {}));
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
var ExperimentEditor;
(function (ExperimentEditor) {
    var Bubble;
    (function (Bubble) {
        // Bubble arrow direction
        (function (ArrowDirection) {
            ArrowDirection[ArrowDirection["None"] = 0] = "None";
            ArrowDirection[ArrowDirection["Up"] = 1] = "Up";
            ArrowDirection[ArrowDirection["Down"] = 2] = "Down";
            ArrowDirection[ArrowDirection["Left"] = 3] = "Left";
            ArrowDirection[ArrowDirection["Right"] = 4] = "Right";
        })(Bubble.ArrowDirection || (Bubble.ArrowDirection = {}));
        var ArrowDirection = Bubble.ArrowDirection;
        // Bubble arrow alignment
        (function (ArrowAlignment) {
            ArrowAlignment[ArrowAlignment["Left"] = 0] = "Left";
            ArrowAlignment[ArrowAlignment["Right"] = 1] = "Right";
            ArrowAlignment[ArrowAlignment["Center"] = 2] = "Center";
            ArrowAlignment[ArrowAlignment["Top"] = 3] = "Top";
            ArrowAlignment[ArrowAlignment["Bottom"] = 4] = "Bottom";
        })(Bubble.ArrowAlignment || (Bubble.ArrowAlignment = {}));
        var ArrowAlignment = Bubble.ArrowAlignment;
        // Bubble position data which controls bubble and arrow position
        var Position = (function () {
            function Position(x, y, arrowDirection, arrowAlignment) {
                if (x === void 0) { x = 0; }
                if (y === void 0) { y = 0; }
                if (arrowDirection === void 0) { arrowDirection = 0 /* None */; }
                if (arrowAlignment === void 0) { arrowAlignment = 2 /* Center */; }
                this.x = ko.observable(x);
                this.y = ko.observable(y);
                this.arrowAlignment = ko.observable(arrowAlignment);
                this.arrowDirection = ko.observable(arrowDirection);
            }
            return Position;
        })();
        Bubble.Position = Position;
    })(Bubble = ExperimentEditor.Bubble || (ExperimentEditor.Bubble = {}));
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var ExperimentEditor;
(function (ExperimentEditor) {
    var Bubble;
    (function (Bubble) {
        // Fixed position
        var FixedPositionLocator = (function () {
            function FixedPositionLocator(position) {
                this.position = position;
            }
            FixedPositionLocator.prototype.getPosition = function () {
                return this.position;
            };
            return FixedPositionLocator;
        })();
        Bubble.FixedPositionLocator = FixedPositionLocator;
        // Find position based on a rectangle on screen
        var RectPositionLocator = (function () {
            function RectPositionLocator(getRect, viewPort) {
                if (viewPort === void 0) { viewPort = Bubble.ViewPort.getInstance(); }
                this.getRect = getRect;
                this.viewPort = viewPort;
            }
            RectPositionLocator.getPositionFromRectAndViewPort = function (rect, viewPort, alignmentThrottle) {
                if (alignmentThrottle === void 0) { alignmentThrottle = 200; }
                var viewPortWidth = viewPort.width();
                var viewPortHeight = viewPort.height();
                if (!rect) {
                    return new Bubble.Position(viewPort.left() + viewPort.width() / 2, viewPort.top() + viewPort.height() / 2, 0 /* None */);
                }
                var xLeft = rect.left - viewPort.left();
                var xRight = viewPort.left() + viewPort.width() - rect.left - rect.width;
                var yTop = rect.top - viewPort.top();
                var yBottom = viewPort.top() + viewPort.height() - rect.top - rect.height;
                // The implementation only supports top/bottom left/right positions
                // TODO: have a better algorithm to calculate better positions
                var align = 2 /* Center */;
                var dir = 0 /* None */;
                var y = viewPort.top() + viewPort.height() / 2;
                var x = viewPort.left() + viewPort.width() / 2;
                // 1. determine bubble axis position (top, bottom, left, right)
                if (viewPortWidth > 0 && viewPortHeight > 0) {
                    var maxPerc;
                    var xLeftPerc = xLeft / viewPortWidth;
                    var xRightPerc = xRight / viewPortWidth;
                    dir = xLeftPerc > xRightPerc ? 4 /* Right */ : 3 /* Left */;
                    maxPerc = xLeftPerc > xRightPerc ? xLeftPerc : xRightPerc;
                    var yTopPerc = yTop / viewPortHeight;
                    var yBottomPerc = yBottom / viewPortHeight;
                    dir = yTopPerc > maxPerc && yTopPerc >= yBottomPerc ? 2 /* Down */ : dir;
                    dir = yBottomPerc > maxPerc && yBottomPerc >= yTopPerc ? 1 /* Up */ : dir;
                    switch (dir) {
                        case 3 /* Left */:
                            x = rect.left + rect.width;
                            y = rect.top + rect.height / 2;
                            break;
                        case 4 /* Right */:
                            x = rect.left;
                            y = rect.top + rect.height / 2;
                            break;
                        case 1 /* Up */:
                            x = rect.left + rect.width / 2;
                            y = rect.top + rect.height;
                            break;
                        case 2 /* Down */:
                            x = rect.left + rect.width / 2;
                            y = rect.top;
                            break;
                        default:
                            break;
                    }
                    if (dir === 3 /* Left */ || dir === 4 /* Right */) {
                        align = y < alignmentThrottle ? 3 /* Top */ : (viewPortHeight - y < alignmentThrottle ? 4 /* Bottom */ : align);
                    }
                    else if (dir === 1 /* Up */ || dir === 2 /* Down */) {
                        align = x < alignmentThrottle ? 0 /* Left */ : (viewPortWidth - x < alignmentThrottle ? 1 /* Right */ : align);
                    }
                }
                return new Bubble.Position(x, y, dir, align);
            };
            RectPositionLocator.prototype.getPosition = function () {
                return RectPositionLocator.getPositionFromRectAndViewPort(this.getRect(), this.viewPort);
            };
            return RectPositionLocator;
        })();
        Bubble.RectPositionLocator = RectPositionLocator;
        var HtmlElementPositionLocator = (function (_super) {
            __extends(HtmlElementPositionLocator, _super);
            function HtmlElementPositionLocator(selector) {
                _super.call(this, function () {
                    var target = selector();
                    if (!target) {
                        return null;
                    }
                    var rect = target.getBoundingClientRect();
                    return {
                        left: rect.left - 10,
                        top: rect.top - 10,
                        width: rect.width + 20,
                        height: rect.height + 20
                    };
                });
            }
            return HtmlElementPositionLocator;
        })(RectPositionLocator);
        Bubble.HtmlElementPositionLocator = HtmlElementPositionLocator;
        // Find position based on a JQuery selector
        var JQuerySelectorPositionLocator = (function (_super) {
            __extends(JQuerySelectorPositionLocator, _super);
            function JQuerySelectorPositionLocator(selector) {
                _super.call(this, function () {
                    var $target = selector();
                    if (!$target || !$target.length) {
                        return null;
                    }
                    return $target.get(0);
                });
            }
            return JQuerySelectorPositionLocator;
        })(HtmlElementPositionLocator);
        Bubble.JQuerySelectorPositionLocator = JQuerySelectorPositionLocator;
        var MultiJQuerySelectorPositionLocator = (function (_super) {
            __extends(MultiJQuerySelectorPositionLocator, _super);
            function MultiJQuerySelectorPositionLocator(selector) {
                _super.call(this, function () {
                    var selectors = selector instanceof Array ? selector : [selector];
                    var locators = [];
                    selectors.forEach(function (selector) {
                        var targetSelector = typeof selector === "string" ? function () { return $(selector); } : selector;
                        var locator = new JQuerySelectorPositionLocator(function () { return targetSelector(); });
                        if (locator.getRect()) {
                            locators.push(locator);
                        }
                    });
                    return MultiJQuerySelectorPositionLocator.computeBoundingBox(locators);
                });
            }
            MultiJQuerySelectorPositionLocator.computeBoundingBox = function (locators) {
                if (locators.length === 0) {
                    return null;
                }
                // compute bounding rectangle from all rectangles.
                var minLeft = Number.POSITIVE_INFINITY;
                var minTop = Number.POSITIVE_INFINITY;
                var maxRight = Number.NEGATIVE_INFINITY;
                var maxBottom = Number.NEGATIVE_INFINITY;
                locators.forEach(function (locator) {
                    var rect = locator.getRect();
                    minLeft = minLeft < rect.left ? minLeft : rect.left;
                    minTop = minTop < rect.top ? minTop : rect.top;
                    maxRight = maxRight > rect.left + rect.width ? maxRight : rect.left + rect.width;
                    maxBottom = maxBottom > rect.top + rect.height ? maxBottom : rect.top + rect.height;
                });
                return {
                    left: minLeft,
                    top: minTop,
                    width: maxRight - minLeft,
                    height: maxBottom - minTop
                };
            };
            return MultiJQuerySelectorPositionLocator;
        })(RectPositionLocator);
        Bubble.MultiJQuerySelectorPositionLocator = MultiJQuerySelectorPositionLocator;
    })(Bubble = ExperimentEditor.Bubble || (ExperimentEditor.Bubble = {}));
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
var ExperimentEditor;
(function (ExperimentEditor) {
    var Bubble;
    (function (Bubble) {
        var Step = (function () {
            function Step(title, content, locator, highlight, width, height) {
                if (width === void 0) { width = 400; }
                if (height === void 0) { height = 150; }
                this.title = ko.observable("");
                this.content = ko.observable("");
                this.title(title);
                this.content(content);
                this.width = ko.observable(width);
                this.height = ko.observable(height);
                this.position = function () { return locator.getPosition(); };
                this.highlight = function () {
                    if (!highlight) {
                        return null;
                    }
                    return highlight();
                };
                this.beforeLoadHandlerAsync = Step.voidPromise;
                this.loadHandlerAsync = Step.voidPromise;
                this.nextHandlerAsync = Step.voidPromise;
                this.backHandlerAsync = Step.voidPromise;
            }
            Step.voidPromise = function (bubbleViewModel) {
                var dfd = $.Deferred();
                dfd.resolve();
                return DataLab.Util.when(dfd.promise());
            };
            return Step;
        })();
        Bubble.Step = Step;
    })(Bubble = ExperimentEditor.Bubble || (ExperimentEditor.Bubble = {}));
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
var ExperimentEditor;
(function (ExperimentEditor) {
    var Bubble;
    (function (Bubble) {
        var BubbleViewModel = (function () {
            function BubbleViewModel() {
                var _this = this;
                this.steps = ko.observableArray();
                this.currentIndex = ko.observable(-1);
                this.visible = ko.observable(false);
                this.overlayVisible = ko.observable(false);
                this.showOverlay = ko.observable(true);
                this.totalSteps = ko.computed(function () { return _this.steps().length; });
                this.current = ko.observable();
                var prepareAndUpdateCurrentStep = ko.computed(function () {
                    if (_this.currentIndex() >= 0 && _this.currentIndex() < _this.totalSteps()) {
                        var nextStep = _this.steps()[_this.currentIndex()];
                        DataLab.Util.then(nextStep.beforeLoadHandlerAsync(_this), function () {
                            nextStep.loadHandlerAsync(_this).done(function () {
                                _this.current(nextStep);
                                _this.visible(true);
                            });
                        });
                    }
                });
                this.hasNext = ko.computed(function () { return _this.currentIndex() < (_this.totalSteps() - 1); });
                this.hasBack = ko.computed(function () { return _this.currentIndex() > 0; });
                this.arrowClassId = ko.computed(function () {
                    if (!_this.current() || !_this.current().position()) {
                        return "hidden";
                    }
                    var pos = _this.current().position();
                    if (pos.arrowDirection() === 1 /* Up */) {
                        return "arrow-up";
                    }
                    else if (pos.arrowDirection() === 4 /* Right */) {
                        return "arrow-right";
                    }
                    else if (pos.arrowDirection() === 2 /* Down */) {
                        return "arrow-down";
                    }
                    else if (pos.arrowDirection() === 3 /* Left */) {
                        return "arrow-left";
                    }
                    else {
                        return "hidden";
                    }
                });
                this.arrowX = ko.computed(function () {
                    if (!_this.current() || !_this.current().position()) {
                        return 0;
                    }
                    var cur = _this.current();
                    var pos = cur.position();
                    if (pos.arrowDirection() === 3 /* Left */) {
                        return 0;
                    }
                    else if (pos.arrowDirection() === 4 /* Right */) {
                        return cur.width() + 10;
                    }
                    else if (pos.arrowAlignment() === 0 /* Left */) {
                        return 30;
                    }
                    else if (pos.arrowAlignment() === 2 /* Center */) {
                        return cur.width() / 2;
                    }
                    else if (pos.arrowAlignment() === 1 /* Right */) {
                        return cur.width() - 30;
                    }
                    return 0;
                });
                this.arrowY = ko.computed(function () {
                    if (!_this.current() || !_this.current().position()) {
                        return 0;
                    }
                    var cur = _this.current();
                    var pos = cur.position();
                    if (pos.arrowDirection() === 1 /* Up */) {
                        return 0;
                    }
                    else if (pos.arrowDirection() === 2 /* Down */) {
                        return cur.height() + 10;
                    }
                    else if (pos.arrowAlignment() === 3 /* Top */) {
                        return 30;
                    }
                    else if (pos.arrowAlignment() === 2 /* Center */) {
                        return cur.height() / 2;
                    }
                    else if (pos.arrowAlignment() === 4 /* Bottom */) {
                        return cur.height() - 30;
                    }
                    return 0;
                });
                this.bubbleX = ko.computed(function () {
                    if (!_this.current() || !_this.current().position()) {
                        return 0;
                    }
                    var cur = _this.current();
                    var pos = cur.position();
                    var result = 0;
                    if (pos.arrowDirection() === 4 /* Right */) {
                        result = pos.x() - cur.width() - 20;
                    }
                    else if (pos.arrowDirection() === 3 /* Left */) {
                        result = pos.x();
                    }
                    else if (pos.arrowAlignment() === 0 /* Left */) {
                        result = pos.x() - 40;
                    }
                    else if (pos.arrowAlignment() === 2 /* Center */) {
                        result = pos.x() - cur.width() / 2 - 10;
                    }
                    else if (pos.arrowAlignment() === 1 /* Right */) {
                        result = pos.x() - cur.width() + 20;
                    }
                    // Don't render the bubble off the screen
                    var viewPortWidth = Bubble.ViewPort.getInstance().width();
                    if (result < 0) {
                        result = 0; // Move right
                    }
                    else if (result + cur.width() > viewPortWidth) {
                        result -= result + cur.width() - viewPortWidth; //move left
                    }
                    return result;
                });
                this.bubbleY = ko.computed(function () {
                    if (!_this.current() || !_this.current().position()) {
                        return 0;
                    }
                    var cur = _this.current();
                    var pos = cur.position();
                    var result = 0;
                    if (pos.arrowDirection() === 2 /* Down */) {
                        result = pos.y() - cur.height() - 20;
                    }
                    else if (pos.arrowDirection() === 1 /* Up */) {
                        result = pos.y();
                    }
                    else if (pos.arrowAlignment() === 3 /* Top */) {
                        result = pos.y() - 40;
                    }
                    else if (pos.arrowAlignment() === 2 /* Center */) {
                        result = pos.y() - cur.height() / 2 - 10;
                    }
                    else if (pos.arrowAlignment() === 4 /* Bottom */) {
                        result = pos.y() - cur.height() + 20;
                    }
                    // Don't render the bubble off the screen
                    var viewPortHeight = Bubble.ViewPort.getInstance().height();
                    if (result < 0) {
                        result = 0; // move down
                    }
                    else if (result + cur.height() > viewPortHeight) {
                        result -= result + cur.height() - viewPortHeight; // move up
                    }
                    return result;
                });
                this.width = ko.computed(function () {
                    if (!_this.current()) {
                        return 0;
                    }
                    return _this.current().width();
                });
                this.height = ko.computed(function () {
                    if (!_this.current()) {
                        return 0;
                    }
                    return _this.current().height();
                });
                this.title = ko.computed(function () {
                    if (!_this.current()) {
                        return "";
                    }
                    return _this.current().title();
                });
                this.content = ko.computed(function () {
                    if (!_this.current()) {
                        return "";
                    }
                    return _this.current().content();
                });
                this.hightlightRect = ko.computed(function () {
                    if (!_this.current() || !_this.current().highlight()) {
                        return null;
                    }
                    if (!_this.visible()) {
                        return { left: 0, top: 0, width: 0, height: 0 };
                    }
                    return _this.current().highlight();
                });
            }
            BubbleViewModel.prototype.addStep = function (step) {
                this.steps.push(step);
            };
            BubbleViewModel.prototype.setCurrentAsync = function (index) {
                var _this = this;
                var dfd = $.Deferred();
                if (this.current()) {
                    this.visible(false);
                    setTimeout(function () {
                        _this.currentIndex(index);
                        dfd.resolve(index);
                    }, 500);
                }
                else {
                    this.currentIndex(index);
                    dfd.resolve(index);
                }
                return dfd.promise();
            };
            // user explicitly click close button
            BubbleViewModel.prototype.close = function () {
                this.dismiss(true);
            };
            BubbleViewModel.prototype.dismiss = function (neverShowAgain) {
                if (neverShowAgain === void 0) { neverShowAgain = true; }
                Shell.Diagnostics.Telemetry.featureUsage(80 /* UserDismiss */, 79 /* BubbleTutorial */, null, null, null, JSON.stringify({
                    TourId: this.id,
                    Step: this.currentIndex(),
                    NeverShowAgain: neverShowAgain
                }));
                if (neverShowAgain && this.userSettings) {
                    this.userSettings.neverShowAgain(this.id);
                }
                this.steps.removeAll();
                this.setCurrentAsync(-1);
                this.visible(false);
                this.overlayVisible(false);
            };
            BubbleViewModel.prototype.show = function () {
                this.overlayVisible(true);
                this.visible(true);
            };
            BubbleViewModel.prototype.nextAsync = function () {
                var _this = this;
                if (!this.hasNext()) {
                    return;
                }
                this.visible(false);
                return DataLab.Util.then(this.current().nextHandlerAsync(this), function () {
                    return _this.setCurrentAsync(_this.currentIndex() + 1);
                });
            };
            BubbleViewModel.prototype.backAsync = function () {
                var _this = this;
                if (!this.hasBack()) {
                    return;
                }
                this.visible(false);
                return DataLab.Util.then(this.current().backHandlerAsync(this), function () {
                    return _this.setCurrentAsync(_this.currentIndex() - 1);
                });
            };
            BubbleViewModel.prototype.gotoAsync = function (index) {
                return this.setCurrentAsync(index);
            };
            BubbleViewModel.prototype.copyFromAsync = function (options) {
                var _this = this;
                this.dismiss();
                this.id = options.id;
                this.userSettings = options.userSettings;
                this.showOverlay(options.showOverlay);
                this.dismissOnClick = options.dismissOnClick;
                this.dismissOnResize = options.dismissOnResize;
                this.dismissOnScroll = options.dismissOnScroll;
                options.steps.forEach(function (s) { return _this.steps.push(s); });
                return this.setCurrentAsync(options.start);
            };
            BubbleViewModel.prototype.onResize = function () {
                if (this.dismissOnResize && this.overlayVisible()) {
                    this.dismiss();
                }
            };
            BubbleViewModel.prototype.onScroll = function () {
                if (this.dismissOnScroll && this.overlayVisible()) {
                    this.dismiss();
                }
            };
            BubbleViewModel.prototype.onClick = function (e) {
                if (this.dismissOnClick && this.overlayVisible()) {
                    var bubbleX = this.bubbleX() + 10;
                    var bubbleY = this.bubbleY() + 10;
                    if (e.pageX < bubbleX || e.pageX > bubbleX + this.width() || e.pageY < bubbleY || e.pageY > bubbleY + this.height()) {
                        this.dismiss();
                    }
                }
            };
            return BubbleViewModel;
        })();
        Bubble.BubbleViewModel = BubbleViewModel;
    })(Bubble = ExperimentEditor.Bubble || (ExperimentEditor.Bubble = {}));
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
/// <reference path="usersettings.ts" />
/// <reference path="viewport.ts" />
/// <reference path="position.ts" />
/// <reference path="positionlocators.ts" />
/// <reference path="step.ts" />
/// <reference path="bubbleviewmodel.ts" />
var ExperimentEditor;
(function (ExperimentEditor) {
    var Bubble;
    (function (Bubble) {
        var Options = (function () {
            function Options(id) {
                this.dismissOnScroll = false;
                this.dismissOnResize = false;
                this.dismissOnClick = false;
                this.steps = [];
                this.start = 0;
                this.userSettings = new Bubble.LocalStorageUserSettings();
                this.alwaysShow = false;
                this.showOverlay = true;
                this.autoDismiss = false;
                this.autoDismissDelayMS = 4000;
                if (!id) {
                    throw new Error("Bubble options ID is required.");
                }
                this.id = id;
            }
            Options.prototype.addStepByPosition = function (x, y, title, content, width, height) {
                var step = new Bubble.Step(title, content, new Bubble.RectPositionLocator(function () {
                    return {
                        left: x,
                        top: y,
                        width: 0,
                        height: 0
                    };
                }), null, width, height);
                this.steps.push(step);
                return step;
            };
            Options.prototype.addStepByJquerySelector = function (selector, title, content, width, height) {
                var locator;
                if (selector instanceof Array) {
                    locator = new Bubble.MultiJQuerySelectorPositionLocator(selector);
                }
                else {
                    var targetSelector = typeof selector === "string" ? function () { return $(selector); } : selector;
                    locator = new Bubble.JQuerySelectorPositionLocator(targetSelector);
                }
                var step = new Bubble.Step(title, content, locator, function () { return locator.getRect(); }, width, height);
                this.steps.push(step);
                return step;
            };
            Options.prototype.addStepByGraphNode = function (node, title, content) {
                return this.addStepByJquerySelector("#node-" + node.id, title, content);
            };
            Options.prototype.addStepAtCenter = function (title, content, width, height) {
                var step = new Bubble.Step(title, content, new Bubble.RectPositionLocator(function () { return null; }), null, width, height);
                this.steps.push(step);
                return step;
            };
            return Options;
        })();
        Bubble.Options = Options;
        var _instance;
        function showAsync(options) {
            Bubble.dismiss();
            if (!_instance) {
                _instance = new Bubble.BubbleViewModel();
                var containerDiv = Bubble.getBubbleContainer();
                ko.applyBindings(_instance, containerDiv);
                $(window).on("resize", function (e) { return _instance.onResize(); });
                $(window).on("scroll", function (e) { return _instance.onScroll(); });
                $(document).on("click", function (e) { return _instance.onClick(e); });
            }
            if (options.alwaysShow || (options.userSettings && options.userSettings.shouldShowBubble(options.id))) {
                return _instance.copyFromAsync(options).then(function () {
                    _instance.show();
                    if (options.autoDismiss) {
                        setTimeout(function () { return dismiss(); }, options.autoDismissDelayMS);
                    }
                    return _instance;
                });
            }
            return DataLab.Util.when(_instance);
        }
        Bubble.showAsync = showAsync;
        function dismiss() {
            if (_instance) {
                _instance.dismiss();
            }
        }
        Bubble.dismiss = dismiss;
        function getBubbleContainer() {
            var $container = $("#bubble-container");
            if ($container.length) {
                return $container.get(0);
            }
            $container = $(ExperimentEditor._bubbleMarkup);
            $container.appendTo("body");
            return $container.get(0);
        }
        Bubble.getBubbleContainer = getBubbleContainer;
    })(Bubble = ExperimentEditor.Bubble || (ExperimentEditor.Bubble = {}));
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
var ExperimentEditor;
(function (ExperimentEditor) {
    ko.bindingHandlers["attrWithNamespace"] = {
        init: function (element, valueAccessor) {
        },
        update: function (element, valueAccessor) {
            // obj behaves as a map, keys are attributes that point to the attribute value
            var obj = ko.utils.unwrapObservable(valueAccessor());
            for (var key in obj) {
                var value = obj[key];
                // XML does not allow nested namespaces so there should only be one ':'
                var qualifiedAttribute = key.split(":");
                if (qualifiedAttribute.length === 2) {
                    var namespace = element.lookupNamespaceURI(qualifiedAttribute[0]);
                    element.setAttributeNS(namespace, qualifiedAttribute[1], ko.utils.unwrapObservable(value));
                }
                else if (qualifiedAttribute.length < 2) {
                    element.setAttribute(qualifiedAttribute[0], ko.utils.unwrapObservable(value));
                }
                else {
                    throw new Error("Found key has multiple ':' and thus is not a valid fully qualified XML attribute ");
                }
            }
        }
    };
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
/// <reference path="../../ViewModel/ExperimentEditor/ColumnPickerViewModel.ts" />
var ExperimentEditor;
(function (ExperimentEditor) {
    var maxResults = 1000;
    var getAutocompleteInstanceFromElement = function (element) {
        return $(element).data("ui-autocomplete");
    };
    var setAutocomplete = function (element, valueAccessor) {
        var blurElement = function () {
            if ($.contains(document.documentElement, element))
                $(element).blur();
        };
        var getAutocompleteInstance = function () {
            return getAutocompleteInstanceFromElement(element);
        };
        var sourceArray = ko.utils.unwrapObservable(valueAccessor)().array();
        var truncationWarning;
        var selectedTruncationWarning = false;
        if (getAutocompleteInstance()) {
            $(element).autocomplete("destroy");
        }
        var displayFullResults = false;
        var cachedFullMenuElement;
        var valueAccessorObj = ko.utils.unwrapObservable(valueAccessor)();
        // if true, allow user to enter any name even if it's not in the autocomplete list
        var allowAnyEntry = "allowAnyEntry" in valueAccessorObj ? valueAccessorObj.allowAnyEntry() : false;
        var autoCompleteElement = $(element).autocomplete({
            columnSelectorSelectionMade: false,
            search: function () {
                if (element !== document.activeElement) {
                    // TFS 4077577 - Bug in IE where placeholder causes 'input' event to be fired, which triggers autocomplete search, even if
                    //  the input doesn't have focus. If we detect that, abort the search by canceling the event by returning false.
                    return false;
                }
            },
            source: function (request, response) {
                var results = $.ui.autocomplete.filter(sourceArray, request.term);
                if (!request.term) {
                    displayFullResults = true;
                }
                if (results.length > maxResults) {
                    var removedResults = results.splice(maxResults, results.length - maxResults);
                    truncationWarning = DataLab.Util.formatWithPluralOption(removedResults.length, DataLab.LocalizedResources.autocompleteTruncatedWarningLabelSingular, DataLab.LocalizedResources.autocompleteTruncatedWarningLabelPlural);
                    if (typeof results[0] === "string") {
                        results.push(truncationWarning);
                    }
                    else {
                        var result = { label: truncationWarning, value: truncationWarning };
                        results.push(result);
                    }
                }
                response(results);
            },
            minLength: 0,
            allowAnyEntry: allowAnyEntry,
            select: function (event, ui) {
                if (truncationWarning && ui.item.value === truncationWarning) {
                    selectedTruncationWarning = true;
                    event.preventDefault();
                    return false;
                }
                // this is needed in case when autocomplete option is selected with mouse, as observable on the box is not updated in that case
                var observable = ko.utils.unwrapObservable(valueAccessor)().dependentObservable;
                if (observable) {
                    observable(ui.item.value);
                }
                // If this is from the columnPicker
                if (event.target.classList[0] === "itemTextBoxInput") {
                    // clears the input in case of selection with mouse
                    var oldValue = ui.item.value;
                    ui.item.value = "";
                    setTimeout(function () {
                        ui.item.value = oldValue;
                    }, 0);
                    // clears the input in case of selection with carriage return
                    $(element).val("");
                    this.columnSelectorSelectionMade = true;
                    // focus again in case of selection using carriage return.
                    $(this).focus();
                }
            },
            open: function () {
                // The following code ensures that the menu bottom is always bounded within
                // the experiment container element. Everytime the menu is opened (which
                // includes initial open as well as every time the user types in more
                // characters and different results are returned) we potentially set a new
                // "bottom" value for that menu.
                //
                // We could append the autocomplete element to something other than the
                // document body (custom UX window?). This would have the benefit of the
                // anchor element and the autocomplete element sharing the same offsetParent,
                // which would mean we could set the "bottom" of the element to 0 in the CSS
                // and get rid of all this code. This would have the added benefit that if the
                // window were resized, the autocomplete element would continue to be properly
                // anchored/positioned. The problem with this is that it would force the
                // autocomplete element to not overflow outside of the custom UX window, which
                // would leave very little room for it. The current behavior of the
                // autocomplete element extending far below the custom UX window is desirable.
                //
                // So, since position and visibility cannot be separated, we must continue to
                // attach the menu element to the document body and dynamically set the
                // "bottom" of the menu element so that it doesn't extend below the experiment
                // container.
                var menuElement = $(element).autocomplete("widget");
                // Unset the bottom property to see where it would be if not overriden
                menuElement.css("bottom", "");
                var menuBottom = menuElement.offset().top + menuElement.outerHeight(false);
                var experimentContainerElement = $(".experiment-container").first();
                if (experimentContainerElement.length > 0) {
                    var experimentContainerBottom = experimentContainerElement.offset().top + experimentContainerElement.outerHeight(false);
                    // Now override the bottom property if necessary
                    if (menuBottom > experimentContainerBottom) {
                        var cssBottom = $(window).height() - experimentContainerBottom;
                        menuElement.css("bottom", cssBottom);
                    }
                }
                // Everytime the autocompleter is opened, create a one-time callback on 
                // window resize to blur the autocomplete element.  This will close the autocomplete
                // box, which will no longer be in the correct position.  The user can then re-open 
                // the autocomplete box.  This makes more sense than just repositioning the autocomplete
                // box because the box is ephemeral and resizing the user agent should close the box,
                // just like clicking outside of the box closes it.
                $(window).unbind("resize", blurElement);
                $(window).one("resize", blurElement);
            },
            close: function (event, ui) {
                if (this.columnSelectorSelectionMade) {
                    this.columnSelectorSelectionMade = false;
                    $(this).focus();
                }
            }
        });
        // Override the built-in close method to allow preventing close when clicking the truncation message
        var autocompleteInstance = getAutocompleteInstance();
        var originalCloseMethod = autocompleteInstance.close;
        autocompleteInstance.close = function (event) {
            if (selectedTruncationWarning) {
                selectedTruncationWarning = false;
                event.preventDefault();
                event.stopImmediatePropagation();
            }
            else {
                originalCloseMethod.apply(this, arguments);
            }
        };
        var originaSuggestMethod = autocompleteInstance._suggest;
        var lastSuggestWasDisplayFullResults = false;
        autocompleteInstance._suggest = function (items) {
            var skipRender = displayFullResults && lastSuggestWasDisplayFullResults;
            lastSuggestWasDisplayFullResults = displayFullResults;
            if (skipRender) {
                // 1) Skip re-rendering the menu
                var ul = this.menu.element;
                this.isNewMenu = true;
                this.menu.refresh();
                // size and position menu
                ul.show();
                // 2) and skip re-sizing it.
                ul.position($.extend({
                    of: this.element
                }, this.options.position));
                if (this.options.autoFocus) {
                    this.menu.next();
                }
            }
            else {
                originaSuggestMethod.apply(this, arguments);
            }
        };
        autocompleteInstance._renderMenu = function (ul, items) {
            var _this = this;
            // Perf optimization: cache full menu for more responsiveness with large #s of items
            if (displayFullResults) {
                if (!cachedFullMenuElement) {
                    cachedFullMenuElement = document.createDocumentFragment();
                    $.each(items, function (index, item) {
                        _this._renderItemData(cachedFullMenuElement, item);
                    });
                }
                $(cachedFullMenuElement).clone(true).appendTo(ul);
            }
            else {
                $.each(items, function (index, item) {
                    _this._renderItemData(ul, item);
                });
            }
            displayFullResults = false;
        };
    };
    ko.bindingHandlers["autocomplete"] = {
        init: function (element, valueAccessor) {
            setAutocomplete(element, valueAccessor);
        }
    };
    ko.bindingHandlers["columnPickerAutocomplete"] = {
        init: function (element, valueAccessor) {
            setAutocomplete(element, valueAccessor);
            $(element).autocomplete("widget").addClass("columnPickerAutocomplete");
            var ac = getAutocompleteInstanceFromElement(element);
            ac._renderItem = function (ul, item) {
                var content = item.isInaccurate ? $("<i>").text(item.label) : item.label;
                return $("<li></li>").data("item.autocomplete", item).append($("<a></a>").append(content)).appendTo(ul);
            };
            $(element).autocomplete().focus(function () {
                $(element).autocomplete('search');
            });
            $(element).keydown(function (event) {
                // carriage return (13) does not trigger the select event in the autocomplete, so we manually trigger.
                if (event.which === 13) {
                    var names = DataLab.Util.Str.getArrayFromCommaSeparatedString($(element).val());
                    names.forEach(function (trimmedName) {
                        ac.option().source({ term: trimmedName }, function (results) {
                            if (results.length > 0 || ac.option().allowAnyEntry) {
                                ac._trigger('select', 'autocompleteselect', { item: { value: trimmedName } });
                            }
                        });
                    });
                }
            });
        }
    };
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
/// <reference path="../Balloon.ts" />
var ExperimentEditor;
(function (ExperimentEditor) {
    // This balloon binding causes the balloon to show whenever the user hovers over this element
    ko.bindingHandlers["hoverBalloon"] = {
        init: function (element, valueAccessor) {
            $(element).off("mouseover focus", showBalloonHandler);
            $(element).off("mouseout blur", hideBalloonHandler);
            $(element).on("mouseover focus", showBalloonHandler);
            $(element).on("mouseout blur", hideBalloonHandler);
            var options = valueAccessor();
            function hideBalloonHandler(eventObject) {
                ExperimentEditor.Balloon.hide(element);
            }
            function showBalloonHandler(eventObject) {
                var options = valueAccessor();
                var message = ko.utils.unwrapObservable(options.message);
                if (message) {
                    ExperimentEditor.Balloon.show(message, element);
                }
            }
            if (options.forceBalloon) {
                // Subscribe to forceBalloon. This will show the balloon for a limited time
                // and then close it
                var forceBalloonSubscription = options.forceBalloon.subscribe(function () {
                    var message = ko.utils.unwrapObservable(options.message);
                    ExperimentEditor.Balloon.show(message, element);
                });
                // We have to dispose of our subscription when the node is destroyed to avoid
                // a memory leak
                ko.utils.domNodeDisposal.addDisposeCallback(element, function () {
                    forceBalloonSubscription.dispose();
                });
            }
        }
    };
    // This balloon binding triggers when the message is a nonempty string
    ko.bindingHandlers["balloon"] = {
        init: function (element, valueAccessor) {
        },
        update: function (element, valueAccessor) {
            var options = valueAccessor();
            var message = ko.utils.unwrapObservable(options.message);
            if (message) {
                ExperimentEditor.Balloon.show(message, element);
            }
            else {
                ExperimentEditor.Balloon.hide(element);
            }
        }
    };
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
var ExperimentEditor;
(function (ExperimentEditor) {
    var CheckboxBindings;
    (function (CheckboxBindings) {
        ko.bindingHandlers["checkboxvalue"] = {
            init: function (checkbox, valueAccessor) {
                var value = valueAccessor().value;
                var choices = valueAccessor().choices;
                // By convention, we will always have the affirmative choice first.
                checkbox.checked = value() === choices()[0].value;
                checkbox.addEventListener("change", function (e) {
                    value(checkbox.checked ? choices()[0].value : choices()[1].value);
                });
            },
            update: function (checkbox, valueAccessor) {
                var value = ko.utils.unwrapObservable(valueAccessor().value);
                var choices = ko.utils.unwrapObservable(valueAccessor().choices);
                // By convention, we will always have the affirmative choice first.
                checkbox.checked = value === choices[0].value;
            }
        };
    })(CheckboxBindings = ExperimentEditor.CheckboxBindings || (ExperimentEditor.CheckboxBindings = {}));
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
/// <reference path="../../Common/MouseCapture.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var ExperimentEditor;
(function (ExperimentEditor) {
    var CollapseResize;
    (function (CollapseResize) {
        var CollapseState;
        (function (CollapseState) {
            CollapseState.Minimized = "minimized";
            CollapseState.Maximized = "maximized";
            CollapseState.Minimizing = "minimizing";
            CollapseState.Maximizing = "maximizing";
        })(CollapseState || (CollapseState = {}));
        var CollapseResizeManager = (function (_super) {
            __extends(CollapseResizeManager, _super);
            /**
              * Manages state and interaction between collapse, jQueryCollapse, and resize bindings. Can be set up for
              * the following modes: collapse, collapse + resize, resize, jQueryCollapse, jQueryCollapse + resize.
              * @param {HTMLElement} containerElement the drawer element. This is the elememnt whose dimensions change on resize, collapse, etc.
              * @param {string} direction where the drawer will resize/collapse from
             **/
            function CollapseResizeManager(containerElement, direction, id) {
                _super.call(this);
                this.containerElement = containerElement;
                this.resizeIsInitialized = false;
                this.collapseIsInitialized = false;
                this.jQueryCollapseIsInitialized = false;
                if (!id) {
                    throw new Error("Must define an id for collapse and resize bindings.");
                }
                this.id = id;
                switch (direction) {
                    case "top":
                    case "left":
                        this.resizeDirection = -1;
                        break;
                    case "bottom":
                    case "right":
                        this.resizeDirection = 1;
                        break;
                    default:
                        throw new Error("location must be 'top,' 'bottom,' 'left,' or 'right.'");
                }
                switch (direction) {
                    case "top":
                    case "bottom":
                        this.resizeDimension = "height";
                        this.mouseDimension = "clientY";
                        break;
                    case "left":
                    case "right":
                        this.resizeDimension = "width";
                        this.mouseDimension = "clientX";
                        break;
                    default:
                        throw new Error("location must be 'top,' 'bottom,' 'left,' or 'right.'");
                }
                this.expandedSize = $(containerElement)[this.resizeDimension]();
                this.direction = direction;
            }
            /**
              * Used by the resize binding. Initialize the manager for resizing.
              * @param {number} minSize the minimum size of the drawer in pixels
              * @param {number} maxSize the maximum size of the drawer in pixels
             **/
            CollapseResizeManager.prototype.initForResize = function (minSize, maxSize) {
                var _this = this;
                if (this.resizeIsInitialized) {
                    throw new Error("Resize is already initialized on this element.");
                }
                this.minSize = minSize;
                this.maxSize = maxSize;
                var startSize = null;
                ;
                var mouseDownCoordinate = null;
                var dragElement = document.createElement("div");
                var cssName = "resize " + this.direction;
                dragElement.setAttribute("class", cssName);
                this.containerElement.appendChild(dragElement);
                var mouseDown = function (e) {
                    e.stopPropagation();
                    e.preventDefault();
                    mouseDownCoordinate = e[_this.mouseDimension];
                    startSize = $(_this.containerElement)[_this.resizeDimension]();
                };
                var mouseMove = function (e) {
                    e.stopPropagation();
                    e.preventDefault();
                    var currentMouseCoordinate = e[_this.mouseDimension];
                    var newSize = _this.resizeDirection * (currentMouseCoordinate - mouseDownCoordinate);
                    newSize = Math.min(_this.maxSize, Math.max(_this.minSize, startSize + newSize));
                    var animationFrame = null;
                    // Throttle redrawing the drawer so we aren't overloading the browser with style updates that
                    // cause reflow
                    if (!animationFrame) {
                        animationFrame = requestAnimationFrame(function () {
                            _this.resize(newSize);
                            animationFrame = null;
                        });
                    }
                };
                var mouseUp = function (e) {
                    e.stopPropagation();
                    e.preventDefault();
                };
                dragElement.addEventListener("mousedown", mouseDown);
                this.registerForDisposal(new ExperimentEditor.MouseCapture(dragElement, mouseMove, mouseUp));
                this.resizeIsInitialized = true;
                var initialSize = this.resizeState ? this.resizeState : minSize;
                // Init the element to its last known size of the minimum size if there is no last size.
                this.resize(initialSize);
            };
            /**
              * Used by the Collapse binding. Initializes the manager for handling collapsing/expanding drawers.
              * @param {KnockoutObservable<boolean>} collapsed an observable indicating whether the collapsing thing is expanded or collapsed
              * @param {number} collapsedSize the minimized size of the drawer.
              * @param {KnockoutSubscribable?} openCloseAnimationEnded an optional subscribable that gets notifications when the drawer opens or closes.
             **/
            CollapseResizeManager.prototype.initForCollapse = function (collapsed, collapsedSize, openCloseAnimationEnded) {
                var _this = this;
                if (this.jQueryCollapseIsInitialized) {
                    throw new Error("Already using jQueryCollapse. Can't use collapse.");
                }
                if (this.collapseIsInitialized) {
                    throw new Error("Collapse is already initialized for this element.");
                }
                this.collapsed = collapsed;
                this.lastExpandStateWasCollapsed = collapsed();
                this.collapsedSize = collapsedSize;
                this.openCloseAnimationEnded = openCloseAnimationEnded;
                if (this.resizeDimension === "height") {
                    $(this.containerElement).addClass("transitionHeight");
                }
                else {
                    $(this.containerElement).addClass("transitionWidth");
                }
                $(this.containerElement).addClass(collapsed() ? "minimized" : "maximized");
                // This function transitions us from mimizing or maximizing to minimized or maximized respectively.
                // If the user supplied an animation complete subscribable, we notify them with the current state.
                var animationEndedHandler = function (e) {
                    var drawerState;
                    e.stopPropagation();
                    // We only want to fiddle styles for transition events that originated on containerElement
                    if (e.target !== e.currentTarget) {
                        return;
                    }
                    if ($(_this.containerElement).hasClass(CollapseState.Minimizing)) {
                        drawerState = CollapseState.Minimized;
                    }
                    else if ($(_this.containerElement).hasClass(CollapseState.Maximizing)) {
                        drawerState = CollapseState.Maximized;
                    }
                    else {
                        throw new Error("Drawer is in an unexpected state");
                    }
                    _this.setDrawerClass(drawerState);
                    if (openCloseAnimationEnded) {
                        openCloseAnimationEnded.notifySubscribers(drawerState);
                    }
                    DataLab.TestMessaging.postMessage({ type: DataLab.TestMessaging.Constants.AnimationComplete });
                };
                // Add an events that let us change the class state machine when animation completes
                this.containerElement.addEventListener("webkitTransitionEnd", animationEndedHandler);
                this.containerElement.addEventListener("transitionend", animationEndedHandler);
                this.containerElement.addEventListener("MSTransitionEnd", animationEndedHandler);
                this.collapseIsInitialized = true;
                if (this.collapseState !== null) {
                    this.collapsed(this.collapseState);
                }
            };
            /**
              * Used by the jQueryCollapse binding. Initialize the manager to perform jQuery's slideToggle.
              * Note this implementation can go between size auto and 0 correctly, but can't use any other minimum size and can't be interrupted.
              * @param {KnockoutObservable<boolean>} collpased an observable indicating whether the drawer is in the collapsed state or not.
              * @param {KnockoutSubscribable} openCloseAnimationEnded? an optional subscribable that gets notified when the drawer fully opens or closes
             **/
            CollapseResizeManager.prototype.initForJQueryCollapse = function (collapsed, contentSelector, openCloseAnimationEnded) {
                if (this.collapseIsInitialized) {
                    throw new Error("Already using collapse. Can't use jQueryCollapse.");
                }
                if (this.jQueryCollapseIsInitialized) {
                    throw new Error("JQueryCollapse is already initialized for this element.");
                }
                this.collapsed = collapsed;
                this.openCloseAnimationEnded = openCloseAnimationEnded;
                this.collapseElement = contentSelector ? this.containerElement.querySelector(contentSelector) : this.containerElement;
                this.jQueryCollapseIsInitialized = true;
                this.collapseIsInitialized = true;
                // Try to load the last collapsed state from session storage
                if (this.collapseState !== null) {
                    this.collapsed(this.collapseState);
                }
                this.lastExpandStateWasCollapsed = collapsed();
                if (this.collapsed()) {
                    this.collapseElement.style["display"] = "none";
                }
                $(this.containerElement).addClass(collapsed() ? "minimized" : "maximized");
            };
            /**
              * Try to resize the box, contingent on size being between the maximum and minimum allowed size
              * @param {number} size how big do you want the box to be
             **/
            CollapseResizeManager.prototype.resize = function (size) {
                if (this.resizeIsInitialized) {
                    // Can't resize when collapsed
                    if ((!this.collapseIsInitialized || (this.collapseIsInitialized && !this.collapsed())) && size >= this.minSize && size <= this.maxSize) {
                        this.expandedSize = size;
                        this.containerElement.style[this.resizeDimension] = size + "px";
                    }
                }
                else {
                    throw new Error('Tried to resize an uninitialized CollapseResizeManager');
                }
                this.resizeState = size;
            };
            CollapseResizeManager.prototype.updateJQueryCollapsedState = function () {
                var _this = this;
                // If the last state we observed is out of sync with the current collapse state,
                // we need to expand or collapse
                if (this.lastExpandStateWasCollapsed !== this.collapsed()) {
                    this.setDrawerClass(this.collapsed() ? CollapseState.Minimizing : CollapseState.Maximizing);
                    var collapseState = this.collapsed();
                    $(this.collapseElement).slideToggle(400, function () {
                        _this.setDrawerClass(collapseState ? CollapseState.Minimized : CollapseState.Maximized);
                        if (_this.openCloseAnimationEnded) {
                            _this.openCloseAnimationEnded.notifySubscribers(collapseState ? CollapseState.Minimized : CollapseState.Maximized);
                        }
                        DataLab.TestMessaging.postMessage({ type: DataLab.TestMessaging.Constants.AnimationComplete });
                    });
                    this.lastExpandStateWasCollapsed = collapseState;
                    this.collapseState = collapseState;
                }
            };
            CollapseResizeManager.prototype.updateCollapsedState = function () {
                // If the collapsed state is out of sync, we need to expand or collapse. When expanding or collapsing,
                // we need to set the minimizing/maximizing class BEFORE setting the height, as IE and FF seem 
                // to sporadically perform animations if you do them in the reverse order.
                if (this.lastExpandStateWasCollapsed !== this.collapsed()) {
                    if (this.collapsed()) {
                        this.setDrawerClass(CollapseState.Minimizing);
                        this.containerElement.style[this.resizeDimension] = this.collapsedSize + "px";
                    }
                    else {
                        this.setDrawerClass(CollapseState.Maximizing);
                        this.containerElement.style[this.resizeDimension] = this.expandedSize + "px";
                    }
                    this.lastExpandStateWasCollapsed = this.collapsed();
                    this.collapseState = this.collapsed();
                }
            };
            Object.defineProperty(CollapseResizeManager.prototype, "resizeState", {
                get: function () {
                    return JSON.parse(CollapseResizeManager.sessionStorage.getItem("Resize_" + this.id));
                },
                set: function (val) {
                    CollapseResizeManager.sessionStorage["Resize_" + this.id] = val;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(CollapseResizeManager.prototype, "collapseState", {
                get: function () {
                    return JSON.parse(CollapseResizeManager.sessionStorage.getItem("Collapse_" + this.id));
                },
                set: function (val) {
                    CollapseResizeManager.sessionStorage["Collapse_" + this.id] = val;
                },
                enumerable: true,
                configurable: true
            });
            CollapseResizeManager.prototype.setDrawerClass = function (className) {
                $(this.containerElement).removeClass('minimized maximized minimizing maximizing');
                $(this.containerElement).addClass(className);
            };
            CollapseResizeManager.sessionStorage = sessionStorage ? sessionStorage : DataLab.Util.sessionStorage;
            return CollapseResizeManager;
        })(DataLab.Util.Disposable);
        CollapseResize.CollapseResizeManager = CollapseResizeManager;
    })(CollapseResize = ExperimentEditor.CollapseResize || (ExperimentEditor.CollapseResize = {}));
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
/// <reference path="CollapseResizeManager.ts" />
var ExperimentEditor;
(function (ExperimentEditor) {
    var CollapseResize;
    (function (CollapseResize) {
        ko.bindingHandlers["collapsepanel"] = {
            init: function (element, valueAccessor) {
                var collapseButtonElement = element.querySelector(valueAccessor().collapseButtonSelector);
                if (!collapseButtonElement) {
                    throw new Error("Could not find collapse button with selector '" + valueAccessor().collapseButtonSelector + ".'");
                }
                collapseButtonElement.addEventListener("click", function (e) {
                    e.preventDefault();
                    e.stopPropagation();
                    valueAccessor().collapsed(!valueAccessor().collapsed());
                });
                if (typeof (valueAccessor().collapsed) !== "function") {
                    throw new Error("Required binding parameter 'collapsed' is undefined or not an observable.");
                }
                if (valueAccessor().collapsedSize === undefined || valueAccessor().collapsedSize === null) {
                    throw new Error("Required binding parameter 'collapsedSize' is undefined.");
                }
                if (!element["collapseResizeManager"]) {
                    element["collapseResizeManager"] = new CollapseResize.CollapseResizeManager(element, valueAccessor().collapseFrom, valueAccessor().id);
                    DataLab.Util.Disposable.exemptFromDiposablesInContextAssertion(element["collapseResizeManager"]);
                    element["collapseResizeManager"].initForCollapse(valueAccessor().collapsed, valueAccessor().collapsedSize, valueAccessor().animationEnded);
                    ko.utils.domNodeDisposal.addDisposeCallback(element, function () {
                        element["collapseResizeManager"].dispose();
                    });
                }
                else {
                    var collapseResizeManager = element["collapseResizeManager"];
                    if (valueAccessor().id !== collapseResizeManager.id) {
                        throw new Error("When using collapse with other bindings, the 'id' fields must match");
                    }
                    if (collapseResizeManager.direction !== valueAccessor().collapseFrom) {
                        throw new Error("When using resize and collapse together, 'collapseFrom' must equal resize's 'location'");
                    }
                    collapseResizeManager.initForCollapse(valueAccessor().collapsed, valueAccessor().collapsedSize, valueAccessor().animationEnded);
                }
            },
            update: function (element, valueAccessor) {
                var collapseResizeManager = element["collapseResizeManager"];
                collapseResizeManager.updateCollapsedState();
            }
        };
    })(CollapseResize = ExperimentEditor.CollapseResize || (ExperimentEditor.CollapseResize = {}));
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
/// <reference path="../../ViewModel/ExperimentEditor/ColumnPickerViewModel.ts" />
var ExperimentEditor;
(function (ExperimentEditor) {
    var ColumnPicker;
    (function (ColumnPicker) {
        ko.bindingHandlers["columnPickerRuleDisplay"] = {
            init: function (element, valueAccessor) {
            },
            update: function (element, valueAccessor) {
                var jsonRules = ko.utils.unwrapObservable(valueAccessor());
                var headerRow = "<span class=\"columnPickerRuleDisplayHeader\">" + DataLab.LocalizedResources.selectToolRulesDisplayLabel + "</span>";
                $(element).html(headerRow);
                var result = [];
                if (jsonRules.length !== 0) {
                    try {
                        var rulesObject = ColumnPicker.ColumnPickerViewModel.parseRules(jsonRules, function (rule, ruleType) {
                            result.push(convertRuleToEnglish(rule));
                        });
                    }
                    catch (e) {
                        DataLab.Log.exception(e, "Failed to parse column picker rules JSON when attempting rule display.");
                    }
                }
                if (result.length > 0) {
                    $(element).html(headerRow + "<br>" + result.join("<br>"));
                }
                else {
                    $(element).html(headerRow + "<br>" + DataLab.LocalizedResources.launchSelectionToolToMakeSelection + "<br>");
                }
            }
        };
        // @TODO Needs to be localized - TFS Defect 2734858
        function convertRuleToEnglish(rule) {
            var ruleIdentifier = ColumnPicker.RuleType.findRule(rule.ruleType, rule.exclude);
            var name = ruleIdentifier.name;
            if (ruleIdentifier.exclude && ruleIdentifier.id !== "AllColumns")
                name = "Exclude " + name;
            else
                name = name.charAt(0).toUpperCase() + name.substr(1);
            var ruleIdentifierName = "<span class=\"columnPickerRuleDisplayRuleName\">" + name + "</span>";
            if (ruleIdentifier.id === "AllColumns" || ruleIdentifier.id === "Features" || ruleIdentifier.id === "Labels" || ruleIdentifier.id === "Scores") {
                return ruleIdentifierName;
            }
            else if (ruleIdentifier.id === "ColumnTypes") {
                return ruleIdentifierName + ": " + rule.columnTypes.join() + ", " + rule.columnKinds.join();
            }
            else {
                return ruleIdentifierName + ": " + DataLab.Util.encodeAsHtml(rule.columns.join());
            }
        }
    })(ColumnPicker = ExperimentEditor.ColumnPicker || (ExperimentEditor.ColumnPicker = {}));
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
/// <reference path="../MenuControl.ts" />
var ExperimentEditor;
(function (ExperimentEditor) {
    function ContextMenuEventHandler(e, target, menuBuilder) {
        e.preventDefault();
        e.stopPropagation();
        // Remove any existing active context menus
        $('.datalab-contextMenu').remove();
        var menuData = menuBuilder.build(target);
        if (menuData) {
            var menuViewmodel = new ExperimentEditor.MenuViewModel(menuData, target);
            // The mouse semantics given an open context menu are as follows:
            // 1) If the user mousedowns outside the menu, close it.
            // 2) If the user mousedowns on an item, then mouseups outside the menu, close it.
            // 3) If the user mousedowns on an item then mouseups in the menu, do the action of the
            //    thing they mouseupped on.
            function mouseButtonCloseContextMenu(e) {
                // If the user mousedowns or up outside the menu, close it and unregister handlers. 
                if ($(e.target).closest(".datalab-contextMenu").length === 0) {
                    ExperimentEditor.MenuControl.removeContextMenu();
                    unregisterCloseHandlers();
                }
                else if ($(e.target).closest(".datalab-contextMenu .enabled").length > 0 && $(e.target).closest(".datalab-contextMenu .hasSubmenu").length === 0 && e.type === "mouseup") {
                    unregisterCloseHandlers();
                }
            }
            // If the user browser navs using browser navigation or some nonsense, destroy the context menu
            function hashChangeCloseContextMenu() {
                ExperimentEditor.MenuControl.removeContextMenu();
                unregisterCloseHandlers();
            }
            function keyDownCloseContextMenu(e) {
                if (e.keyCode === 27 /* Escape */) {
                    ExperimentEditor.MenuControl.removeContextMenu();
                    unregisterCloseHandlers();
                }
            }
            function contextMenuPreventDefault() {
                return false;
            }
            function registerCloseHandlers() {
                $("body").on('contextmenu', "div.datalab-contextMenu", contextMenuPreventDefault);
                document.addEventListener("mousedown", mouseButtonCloseContextMenu, true);
                document.addEventListener("mouseup", mouseButtonCloseContextMenu, true);
                document.addEventListener("keydown", keyDownCloseContextMenu);
                window.addEventListener("hashchange", hashChangeCloseContextMenu);
            }
            function unregisterCloseHandlers() {
                $("body").off('contextmenu', "div.datalab-contextMenu", contextMenuPreventDefault);
                document.removeEventListener("mousedown", mouseButtonCloseContextMenu, true);
                document.removeEventListener("mouseup", mouseButtonCloseContextMenu, true);
                document.removeEventListener("keydown", keyDownCloseContextMenu);
                window.removeEventListener("hashchange", hashChangeCloseContextMenu);
            }
            if (menuViewmodel) {
                registerCloseHandlers();
                ExperimentEditor.MenuControl.spawnMenu(menuViewmodel, e);
            }
        }
        return false;
    }
    ExperimentEditor.ContextMenuEventHandler = ContextMenuEventHandler;
    ko.bindingHandlers["contextMenu"] = {
        init: function (element, valueAccessor, allBindingsAccessor, targetViewModel) {
            /// <summary>
            /// Initialization of contextMenu ko.bindingHandlers
            /// </summary>
            /// <param name="element" type="Element">
            /// The DOM element involved in this binding
            /// </param>
            /// <param name="valueAccessor" type="() => any">
            /// A JavaScript function that you can call to get the current model property that is involved in this binding. 
            /// Call this without passing any parameters (i.e., call valueAccessor()) to get the current model property value.
            /// </param>
            /// <param name="allBindingsAccessor" type="() => any">
            /// A JavaScript function that you can call to get all the model properties bound to this DOM element. Like valueAccessor, 
            /// call it without any parameters to get the current bound model properties.
            /// </param>
            /// <param name="viewModel" type="any">
            /// The view model object that was passed to ko.applyBindings. Inside a nested binding context, this parameter will be set 
            /// to the current data item (e.g., inside a with: person binding, viewModel will be set to person).
            /// </param>
            /// <param name="bindingContext" type="any">
            /// An object that holds the binding context available to this element's bindings. This object includes special properties 
            /// including $parent, $parents, and $root that can be used to access data that is bound against ancestors of this context.
            /// </param>
            // On right-click
            $(element).on('contextmenu', function (e) {
                var menuBuilder = ko.utils.unwrapObservable(valueAccessor());
                ContextMenuEventHandler(e, targetViewModel, menuBuilder);
            });
        }
    };
    ko.bindingHandlers["subMenu"] = {
        init: function (element, valueAccessor) {
            var context = ko.utils.unwrapObservable(valueAccessor());
            if (ko.utils.unwrapObservable(context.activate)) {
                var width = ko.utils.unwrapObservable(context.width);
                // Hide the submenu
                $(element).children(".datalab-contextMenu").hide();
                $(element).hover(function () {
                    $(element).children(".datalab-contextMenu").first().toggle().position({
                        my: "left top",
                        at: "right top",
                        offset: "-2 0",
                        of: element,
                        collision: "flip flip"
                    });
                });
            }
        }
    };
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
/// <reference path="../MenuControl.ts" />
var ExperimentEditor;
(function (ExperimentEditor) {
    var DropMenu;
    (function (DropMenu) {
        // Drop menus have the same semantics as those in office:
        // 1) When the user mousedowns on the dropmenu element, the menu appears
        // 2) If the user mouseups on an enabled and actionable menu item, the menu item will close the menu.
        //    We just have to unregister the handlers
        // 3) The first time the user mouseups on something other than an actionable item, don't close the menu
        // 4) If we've hit case 3, then mousedown or mouseup outside the menu will close the menu. Case 2 still holds as well
        // 5) The escape key or a hashchange will also close the menu
        // 6) A mousedown on the same object that opened the menu will close the menu without opening another.
        ko.bindingHandlers["dropMenu"] = {
            init: function (element, valueAccessor, allBindingsAccessor, targetViewModel) {
                element.addEventListener("mousedown", function (e) {
                    e.preventDefault();
                    e.stopPropagation();
                    var initiatingElement = e.target;
                    var hasReceivedFirstMouseUp = false;
                    var unregisterEventHandlers = function () {
                        document.removeEventListener("mousedown", closeMenu, true);
                        document.removeEventListener("mouseup", closeMenu, true);
                        document.querySelector("html").removeEventListener("keydown", closeMenu);
                        window.removeEventListener("hashchange", closeMenu, true);
                    };
                    function closeMenu(e) {
                        // If the user presses escape, triggers a hashchange, or mousedowns outside the menu,
                        // close the menu.
                        if (e.type === "hashchange" || (e.type === "keydown" && e.keyCode === 27 /* Escape */) || (e.type === "mousedown" && $(e.target).closest(".datalab-contextMenu").length === 0)) {
                            // If the user clicks on the same element that created the menu, stopPropagation
                            // to prevent another menu from opening.
                            if (e.type === "mousedown" && e.target === initiatingElement) {
                                e.stopPropagation();
                            }
                            // Close the menu
                            initiatingElement = null;
                            ExperimentEditor.MenuControl.removeContextMenu();
                            unregisterEventHandlers();
                        }
                        else if (e.type === "mouseup" && $(e.target).closest(".datalab-contextMenu .enabled").length > 0 && $(e.target).closest(".datalab-contextMenu .hasSubmenu").length === 0) {
                            initiatingElement = null;
                            unregisterEventHandlers();
                        }
                        else if (e.type === "mouseup" && !hasReceivedFirstMouseUp) {
                            hasReceivedFirstMouseUp = true;
                        }
                        else if (e.type === "mouseup" && $(e.target).closest(".datalab-contextMenu").length === 0) {
                            initiatingElement = null;
                            ExperimentEditor.MenuControl.removeContextMenu();
                            unregisterEventHandlers();
                        }
                    }
                    // If the user left clicks, install the close event listeners and spawn the menu
                    if (e.button === 0 /* Left */) {
                        document.addEventListener("mousedown", closeMenu, true);
                        document.addEventListener("mouseup", closeMenu, true);
                        document.querySelector("html").addEventListener("keydown", closeMenu);
                        window.addEventListener("hashchange", closeMenu, true);
                        hasReceivedFirstMouseUp = false;
                        var menuBuilder = valueAccessor();
                        var menu = menuBuilder.build(targetViewModel);
                        if (menu) {
                            var menuViewModel = new ExperimentEditor.MenuViewModel(menu, targetViewModel);
                            ExperimentEditor.MenuControl.spawnMenu(menuViewModel, e.target);
                        }
                    }
                });
            }
        };
    })(DropMenu = ExperimentEditor.DropMenu || (ExperimentEditor.DropMenu = {}));
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
var ExperimentEditor;
(function (ExperimentEditor) {
    function enableCharacterLimitWarning(element, bindingOptions) {
        var textArea = element.find("textArea");
        var charLimit = bindingOptions.maxCharacters;
        var limitElement = element.find(".characterLimitReachedWarning");
        var charCountElement = limitElement.find(".charactersLeftCount");
        var limitVisible = false;
        function handleCharacterCount() {
            var charCount = textArea.val().length;
            var charactersLeft = charLimit - charCount;
            if (charactersLeft < 40) {
                charCountElement.text("" + charactersLeft);
                if (!limitVisible) {
                    limitVisible = true;
                    limitElement.show();
                }
            }
            else {
                if (limitVisible) {
                    limitElement.hide();
                    limitVisible = false;
                }
            }
        }
        textArea.on({
            "keyup change": handleCharacterCount,
            "paste": function () {
                window.setTimeout(handleCharacterCount, 1);
            }
        });
    }
    ko.bindingHandlers["editableTextArea"] = {
        // element is the div that contains the text area
        init: function (element, valueAccessor, allBindingAccessor, bindingOptions, bindingContext) {
            // Harminder originally wrote this to take the binding options off the view model, I'm modifying it so 
            // that binding options passed in as actual binding options override view model properties so that this 
            // can be used as a custom binding.
            var possibleBindingOptions = ko.utils.unwrapObservable(valueAccessor());
            if (Object.getOwnPropertyNames(possibleBindingOptions).length > 0) {
                bindingOptions = possibleBindingOptions;
            }
            var textArea = $(element).find("textarea");
            if (!textArea.get(0)) {
                throw "Couldn't find text area in editableTextArea binding.";
            }
            $(element).addClass("editableTextAreaWrapper");
            textArea.addClass("editableTextArea");
            if (bindingOptions.maxCharacters) {
                textArea.attr("maxlength", bindingOptions.maxCharacters);
            }
            if (bindingOptions.placeholderText) {
                textArea.attr("placeholder", bindingOptions.placeholderText);
            }
            if (bindingOptions.isReadOnly) {
                textArea.attr("readonly", "true");
            }
            if (bindingOptions.showMaxCharacterWarning) {
                enableCharacterLimitWarning($(element), bindingOptions);
            }
        },
        update: function (element, valueAccessor) {
        }
    };
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
var ExperimentEditor;
(function (ExperimentEditor) {
    var textLargerThanDiv = function (element, text) {
        $(element).text(text);
        if (element.clientHeight < element.scrollHeight) {
            return true;
        }
        return false;
    };
    ko.bindingHandlers["ellipsisDiv"] = {
        init: function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
        },
        update: function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
            var text = ko.utils.unwrapObservable(valueAccessor);
            // Cannot add ellipsis to an element with no height. Set it to have text and return. 
            if ($(element).height() === 0 || !$(element).is(':visible')) {
                $(element).text(text());
                return;
            }
            var longString = text();
            // if text fits, have utility set it and return.
            if (!textLargerThanDiv(element, longString)) {
                return;
            }
            // otherwise, figure out where to add the ellipses.
            var ellipsis = "\u2026";
            var low = 0;
            var high = longString.length;
            var position = Math.floor(high / 2);
            var stringSlice = longString.slice(0, position);
            var leftCharBad = textLargerThanDiv(element, stringSlice + ellipsis);
            var rightCharBad = leftCharBad ? false : textLargerThanDiv(element, stringSlice + longString[position] + ellipsis);
            while (leftCharBad || !rightCharBad) {
                if (leftCharBad) {
                    high = position;
                    position = Math.floor(low + (high - low) / 2);
                }
                else if (!rightCharBad) {
                    low = position;
                    position = Math.floor(low + (high - low) / 2);
                }
                stringSlice = longString.slice(0, position);
                leftCharBad = textLargerThanDiv(element, stringSlice + ellipsis);
                rightCharBad = leftCharBad ? false : textLargerThanDiv(element, stringSlice + longString[position] + ellipsis);
            }
            // add string with ellipsis
            $(element).text(stringSlice + ellipsis);
        }
    };
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
var ExperimentEditor;
(function (ExperimentEditor) {
    var FadeVisible;
    (function (FadeVisible) {
        ko.bindingHandlers["fadeVisible"] = {
            init: function (element, valueAccessor) {
                var value = valueAccessor();
                $(element).toggle(ko.utils.unwrapObservable(value));
            },
            update: function (element, valueAccessor) {
                var value = valueAccessor();
                ko.utils.unwrapObservable(value) ? $(element).fadeIn() : $(element).fadeOut();
            }
        };
    })(FadeVisible = ExperimentEditor.FadeVisible || (ExperimentEditor.FadeVisible = {}));
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
var ExperimentEditor;
(function (ExperimentEditor) {
    // The file: binding is a one-way binding (element -> observable) which reflects a
    // single file selected by an <input type="file"> element. Multi-select file inputs are not supported.
    // The binding takes a single observable as its value. The observable fits the interface DataLab.IKOObservable_File.
    // The value will be set to null when no files are selected.
    ko.bindingHandlers["file"] = {
        init: function (element, valueAccessor) {
            if (!(element instanceof HTMLInputElement)) {
                throw new Error("The 'file' binding must be applied to an <input> element");
            }
            function updateValue() {
                var value = valueAccessor();
                if (!ko.isObservable(value)) {
                    throw new Error("The parameter to the 'file' binding must be an observable");
                }
                // Checking element.value is in principle redundant with checking the length of the files array.
                // IE however has a bug such that clearing the file input with e.g. the Esc key will generate a change event
                // with element.value set to "" and the files array still populated. We want to treat that case as if no file is selected.
                if (element.files && element.files.length > 0 && element.value) {
                    if (element.files.length > 1) {
                        throw new Error("The 'file' binding does not support multi-select file input elements");
                    }
                    value(element.files[0]);
                }
                else {
                    value(null);
                }
            }
            element.addEventListener("change", function () {
                updateValue();
            });
            updateValue();
        },
        update: function (element, valueAccessor) {
        }
    };
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
var ExperimentEditor;
(function (ExperimentEditor) {
    var ColumnPicker;
    (function (ColumnPicker) {
        ko.bindingHandlers["itemTextBox"] = {
            init: function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
                $(element).keydown(function (event) {
                    // Add to a div and measure the width
                    $(".textWidthSpan").text($(element).val());
                    var textWidth = $(".textWidthSpan").width();
                    var cursorPosition = element.selectionStart;
                    // If the key pressed  is backspace, and the  cursor is in the  first position, 
                    // pop the last element off the selected columns list
                    if (event.which === 8 && cursorPosition === 0) {
                        var columnNameLists = ko.utils.unwrapObservable(valueAccessor);
                        var invalidColumns = columnNameLists().invalidColumnNames;
                        var selectedColumns = columnNameLists().validColumnNames;
                        if (invalidColumns().length > 0) {
                            invalidColumns().pop();
                            invalidColumns.valueHasMutated();
                        }
                        else {
                            selectedColumns().pop();
                            selectedColumns.valueHasMutated();
                        }
                        $(element).focus();
                    }
                    // In IE carriage return (13) does not trigger the change event on this observable. So we blur and refocus to trigger it.
                    if (event.which === 13) {
                        $(element).blur();
                        $(element).focus();
                    }
                });
                // Blurring this input box will start validation
                element.addEventListener("blur", function () {
                    var columnName;
                    // determine if in schema case or no schema case
                    if (allBindingsAccessor().value) {
                        columnName = allBindingsAccessor().value;
                    }
                    else if (allBindingsAccessor().columnPickerAutocomplete && allBindingsAccessor().columnPickerAutocomplete.dependentObservable) {
                        columnName = allBindingsAccessor().columnPickerAutocomplete.dependentObservable;
                    }
                    else {
                        return;
                    }
                    columnName.startValidating();
                    columnName.validate();
                });
            }
        };
    })(ColumnPicker = ExperimentEditor.ColumnPicker || (ExperimentEditor.ColumnPicker = {}));
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
/// <reference path="CollapseResizeManager.ts" />
var ExperimentEditor;
(function (ExperimentEditor) {
    var CollapseResize;
    (function (CollapseResize) {
        ko.bindingHandlers["jQueryCollapse"] = {
            init: function (element, valueAccessor) {
                var collapseButtonElement = element.querySelector(valueAccessor().collapseButtonSelector);
                if (!collapseButtonElement) {
                    throw new Error("Could not find collapse button with selector '" + valueAccessor().collapseButtonSelector + ".'");
                }
                collapseButtonElement.addEventListener("click", function (e) {
                    e.preventDefault();
                    e.stopPropagation();
                    valueAccessor().collapsed(!valueAccessor().collapsed());
                });
                if (typeof (valueAccessor().collapsed) !== "function") {
                    throw new Error("Required binding parameter 'collapsed' is undefined or not an observable.");
                }
                if (!element["collapseResizeManager"]) {
                    element["collapseResizeManager"] = new CollapseResize.CollapseResizeManager(element, valueAccessor().collapseFrom, valueAccessor().id);
                    element["collapseResizeManager"].initForJQueryCollapse(valueAccessor().collapsed, valueAccessor().contentSelector, valueAccessor().animationEnded);
                }
                else {
                    var collapseResizeManager = element["collapseResizeManager"];
                    if (valueAccessor().id !== collapseResizeManager.id) {
                        throw new Error("When using jQueryCollapse with resize, ids must match.");
                    }
                    if (collapseResizeManager.direction !== valueAccessor().collapseFrom) {
                        throw new Error("When using resize and collapse together, 'collapseFrom' must equal resize's 'location'");
                    }
                    element["collapseResizeManager"].initForJQueryCollapse(valueAccessor().collapsed, valueAccessor().animationEnded);
                }
            },
            update: function (element, valueAccessor) {
                var collapseResizeManager = element["collapseResizeManager"];
                collapseResizeManager.updateJQueryCollapsedState();
            }
        };
    })(CollapseResize = ExperimentEditor.CollapseResize || (ExperimentEditor.CollapseResize = {}));
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" /> 
var ExperimentEditor;
(function (ExperimentEditor) {
    ko.bindingHandlers["multiSelectMenu"] = {
        init: function (element, valueAccessor, allBindingsAccessor) {
            var options = allBindingsAccessor().menuOptions || {};
            var enumItems = valueAccessor();
            var $menu = $(element).find("ul");
            var button = $(element.children[0]);
            $menu.hide();
            $menu[0].style.marginTop = button[0].offsetHeight.toString() + "px";
            button.click(function () {
                $menu.toggle();
            });
            var domClickCheck = function (event) {
                if (!($(event.target).closest($menu).length || $(event.target).closest(button).length)) {
                    $menu.hide();
                }
            };
            options.select = function (event, ui) {
                $.each($menu.find("li"), function (i, el) {
                    if (el === ui.item[0]) {
                        var oldValue = enumItems()[i].isSelected();
                        enumItems()[i].isSelected(!oldValue);
                    }
                });
                enumItems.valueHasMutated();
                event.preventDefault();
            };
            $(document).on('click', domClickCheck);
            $menu.menu(options);
            ko.utils.domNodeDisposal.addDisposeCallback(element, function () {
                $menu.menu("destroy");
                $(document).off('click', domClickCheck);
            });
        }
    };
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
var ExperimentEditor;
(function (ExperimentEditor) {
    ko.bindingHandlers["oninit"] = {
        init: function (element, valueAccessor, allBindingsAccessor, targetViewModel) {
            valueAccessor()(element);
        }
    };
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
/// <reference path="../../ViewModel/ExperimentEditor/CustomUX.ts" />
/// <reference path="../../../TypeScriptLib/jqueryui.d.ts" />
var ExperimentEditor;
(function (ExperimentEditor) {
    ko.bindingHandlers["placeholder"] = {
        init: function (element, valueAccessor, allBindings, viewModel, bindingContext) {
            var underlyingObservable = valueAccessor();
            ko.applyBindingsToNode(element, { attr: { placeholder: underlyingObservable } }, viewModel);
        }
    };
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
var ExperimentEditor;
(function (ExperimentEditor) {
    ko.bindingHandlers["readonly"] = {
        init: function (element, valueAccessor) {
        },
        update: function (element, valueAccessor) {
            var isReadOnly = ko.utils.unwrapObservable(valueAccessor());
            var hasReadOnlyAttr = element.getAttribute("readonly") !== null;
            if (isReadOnly && !hasReadOnlyAttr) {
                element.setAttribute("readonly", "readonly");
            }
            else if (!isReadOnly && hasReadOnlyAttr) {
                element.removeAttribute("readonly");
            }
        }
    };
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
/// <reference path="../../Common/MouseCapture.ts" />
/// <reference path="CollapseResizeManager.ts" />
var ExperimentEditor;
(function (ExperimentEditor) {
    var CollapseResize;
    (function (CollapseResize) {
        ko.bindingHandlers["resize"] = {
            init: function (element, valueAccessor) {
                var options = valueAccessor();
                if ($(element).closest(options.parentContainerSelector).length === 0) {
                    throw new Error("Could not find the parent container with selector '" + options.parentContainerSelector + ".'");
                }
                var resizeDimension;
                if (options.direction === "top" || options.direction === "bottom") {
                    resizeDimension = "height";
                }
                else if (options.direction === "left" || options.direction === "right") {
                    resizeDimension = "width";
                }
                else {
                    throw new Error("location must be either 'top,' 'left,' 'bottom,' or 'right.'");
                }
                options.minSize = options.minSize ? options.minSize : 0;
                options.maxSize = options.maxSize ? options.maxSize : $(element).closest(options.parentContainerSelector)[resizeDimension]();
                if (!element["collapseResizeManager"]) {
                    element["collapseResizeManager"] = new CollapseResize.CollapseResizeManager(element, options.direction, options.id);
                    DataLab.Util.Disposable.exemptFromDiposablesInContextAssertion(element["collapseResizeManager"]);
                    element["collapseResizeManager"].initForResize(options.minSize, options.maxSize);
                    ko.utils.domNodeDisposal.addDisposeCallback(element, function () {
                        element["collapseResizeManager"].dispose();
                    });
                }
                else {
                    var collapseResizeManager = element["collapseResizeManager"];
                    if (options.id !== collapseResizeManager.id) {
                        throw new Error("When using resize binding with collapse or JQueryCollapse, ids must match.");
                    }
                    if (collapseResizeManager.direction !== options.direction) {
                        throw new Error("When using collapse and resize bindings together, 'location' must equal collapse's 'collapseFrom.'");
                    }
                    collapseResizeManager.initForResize(options.minSize, options.maxSize);
                }
            },
            update: function (element, valueAccessor) {
            }
        };
    })(CollapseResize = ExperimentEditor.CollapseResize || (ExperimentEditor.CollapseResize = {}));
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
/// <reference path="../../ViewModel/ExperimentEditor/CustomUX.ts" />
/// <reference path="../../../TypeScriptLib/jqueryui.d.ts" />
var ExperimentEditor;
(function (ExperimentEditor) {
    var CustomUX;
    (function (CustomUX) {
        ko.bindingHandlers["slideVisible"] = {
            init: function (element, shouldShow, allBindingsAccessor) {
                var animating = allBindingsAccessor().animating;
                var shouldShowUnwrapped = ko.utils.unwrapObservable(shouldShow());
                animating(false);
                if (shouldShowUnwrapped) {
                    $(element).show();
                }
                else {
                    $(element).hide();
                }
            },
            update: function (element, shouldShow, allBindingsAccessor) {
                var animating = allBindingsAccessor().animating;
                var shouldShowUnwrapped = ko.utils.unwrapObservable(shouldShow());
                var isShown = $(element).css('display') !== 'none';
                if (isShown !== shouldShowUnwrapped) {
                    animating(true);
                    if (shouldShowUnwrapped == true) {
                        $(element).show("slide", {
                            direction: 'down',
                            complete: function () {
                                animating(false);
                            }
                        });
                    }
                    else {
                        $(element).hide("slide", {
                            direction: 'down',
                            complete: function () {
                                animating(false);
                            }
                        });
                    }
                }
            }
        };
    })(CustomUX = ExperimentEditor.CustomUX || (ExperimentEditor.CustomUX = {}));
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
var ExperimentEditor;
(function (ExperimentEditor) {
    ko.bindingHandlers["slider"] = {
        init: function (element, valueAccessor, allBindingsAccessor) {
            var options = allBindingsAccessor().sliderOptions || {};
            var observable = ko.utils.unwrapObservable(valueAccessor());
            options.slide = function (event, ui) {
                observable[0](ui.values[0]);
                observable[1](ui.values[1]);
            };
            $(element).slider(options);
            ko.utils.domNodeDisposal.addDisposeCallback(element, function () {
                $(element).slider("destroy");
            });
        },
        //If the slider is not the only means of editing the slider values, this will keep the slider up to date
        //ensure that the same validation for changing the slider occurs on the other input methods.
        update: function (element, valueAccessor) {
            var valueArray = ko.utils.unwrapObservable(valueAccessor());
            var min = parseFloat(ko.utils.unwrapObservable(valueArray[0]));
            var max = parseFloat(ko.utils.unwrapObservable(valueArray[1]));
            var value = [min, max];
            if (isNaN(value[0])) {
                value = [0, 1];
            }
            $(element).slider("values", value);
        }
    };
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
var ExperimentEditor;
(function (ExperimentEditor) {
    ko.bindingHandlers["stopBinding"] = {
        init: function (element, valueAccessor) {
            return { controlsDescendantBindings: true };
        }
    };
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
var ExperimentEditor;
(function (ExperimentEditor) {
    ko.bindingHandlers["usageBar"] = {
        update: function (element, valueAccessor, allBindingsAccessor, data, context) {
            var options = ko.utils.unwrapObservable(valueAccessor());
            if ($(element).hasClass('fx-usagebars')) {
                $(element).fxUsageBars("destroy");
            }
            if (options) {
                $(element).fxUsageBars({
                    thisEntityName: options.usedLabel,
                    totalEntityName: options.totalLabel,
                    overCapacityName: options.overCapacityLabel,
                    quotas: [{
                        usedByThis: options.used,
                        totalQuota: options.total,
                        unitLabel: options.unitLabel,
                        unitLabelLong: options.unitLabelLong,
                        roundingDecimals: 2
                    }],
                });
            }
        }
    };
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
/// <reference path="Balloon.ts" />
var ExperimentEditor;
(function (ExperimentEditor) {
    var ValidateBindings;
    (function (ValidateBindings) {
        ko.bindingHandlers["validate"] = {
            init: function (element, valueAccessor) {
                // Use the hoverBalloon binding too
                ko.bindingHandlers["hoverBalloon"].init(element, function () {
                    var options = ko.utils.unwrapObservable(valueAccessor());
                    var value = options.value;
                    return {
                        message: value.errorMessage,
                        forceBalloon: options.forceBalloon
                    };
                }, null, null, null);
            },
            update: function (element, valueAccessor) {
                var options = ko.utils.unwrapObservable(valueAccessor());
                // Let the binding trigger on value
                ko.utils.unwrapObservable(options.value);
                $(element).removeClass("fx-validation-invalid");
                if (options.value.errorMessage()) {
                    $(element).addClass("fx-validation-invalid");
                }
            }
        };
    })(ValidateBindings = ExperimentEditor.ValidateBindings || (ExperimentEditor.ValidateBindings = {}));
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
/// <reference path="Validate.ts" />
var ExperimentEditor;
(function (ExperimentEditor) {
    var ValidateBindings;
    (function (ValidateBindings) {
        /**
          * Valid binding parameters include:
          * value: IValidatableObservable containing the value of the text box
          * disabled: IKOObservable_bool indicating whether the textbox is disabled or not
          * revalidate: KnockoutObservable that forces the fxTextBox to rerun validation
         **/
        ko.bindingHandlers["validatedInputBox"] = {
            init: function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
                if (!valueAccessor().value) {
                    throw Error("The fxTextBox binding must have a value parameter");
                }
                if (!valueAccessor().value.validate) {
                    throw Error("The fxTextBox binding must accept an IValidatableObservable for its binding argument");
                }
                var options = ko.utils.unwrapObservable(valueAccessor());
                var value = options.value;
                $(element).on("input keyup", function () {
                    var options = ko.utils.unwrapObservable(valueAccessor());
                    options.value(element.value);
                });
                // Blurring this input box will start validation
                element.addEventListener("blur", function () {
                    var options = ko.utils.unwrapObservable(valueAccessor());
                    // Handle the case where the value somehow got updated without triggering an input event.
                    // This seems possible in some browsers with esoteric scenarios.
                    options.value(element.value);
                    options.value.startValidating();
                    options.value.validate();
                });
                element.value = options.value();
                ko.bindingHandlers["validate"].init(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext);
            },
            update: function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
                var disabled = false;
                if (valueAccessor().disabled !== undefined) {
                    disabled = ko.utils.unwrapObservable(valueAccessor().disabled);
                }
                var options = ko.utils.unwrapObservable(valueAccessor());
                // If the input's value is already the same as the observable (i.e. the input event trigger the update), 
                // don't update it, as it causes the user to lose their caret position
                if (element.value !== options.value()) {
                    element.value = options.value();
                }
                ko.bindingHandlers["validate"].update(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext);
            }
        };
    })(ValidateBindings = ExperimentEditor.ValidateBindings || (ExperimentEditor.ValidateBindings = {}));
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
/// <reference path="d3graph.ts" />
var ExperimentEditor;
(function (ExperimentEditor) {
    // animation is done with CSS transitions, and it is done in multiple steps
    // requestAnimationFrame is used to invoke browser layout engine so that we can take
    // another action (step) when CSS changes take effect
    ko.bindingHandlers["d3graphcopy"] = {
        init: function (element, valueAccessor, allBindingsAccessor, targetViewModel) {
            var d3Original = $(ExperimentEditor.D3Graph.svgMap[valueAccessor().name]);
            var animationDuration = parseInt(valueAccessor().animationDuration);
            var clone = d3Original.clone();
            var leftStart = d3Original.offset().left;
            var topStart = d3Original.parent().offset().top;
            var snapshotWidth = d3Original.outerWidth();
            var leftEnd = $(element).offset().left;
            var topEnd = $(element).offset().top;
            // animating element needs to be on top of the visualization UI in order to be visible
            $(element).css('width', d3Original.width() + "px");
            var snapshotContainer = $(element).parent().parent();
            snapshotContainer.css({ 'width': '0px', 'visibility': 'hidden' });
            clone.appendTo($('body')).css({ "position": "fixed", 'top': topStart + 'px', 'left': leftStart + 'px' });
            requestAnimationFrame(function () {
                clone.css('transition-duration', animationDuration + 'ms').css('transition-property', 'left').css('visibility', 'hidden');
                snapshotContainer.css({ 'transition-property': 'width', 'transition-duration': animationDuration + 'ms' });
                requestAnimationFrame(function () {
                    clone.css('left', leftEnd + 'px');
                    snapshotContainer.css('width', snapshotWidth + 'px');
                    setTimeout(function () {
                        clone.appendTo($(element)).css({ 'position': 'static', 'transition-duration': 0 });
                        clone.css('visibility', '');
                        snapshotContainer.css({ 'height': '', 'visibility': 'visible' });
                        // calculate the padding so that snapshot and original images are inline
                        $(element).css('padding-top', (topStart - topEnd) + 'px');
                    }, animationDuration);
                });
            });
        }
    };
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
var ExperimentEditor;
(function (ExperimentEditor) {
    ko.bindingHandlers["fxUpload"] = {
        init: function (element, valueAccessor, allBindingsAccessor, targetViewModel) {
            var bindingOptions = valueAccessor();
            $(element).fxUpload(bindingOptions);
        }
    };
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
var ExperimentEditor;
(function (ExperimentEditor) {
    function handleInitOrUpdate(element, valueAccessor) {
        var text = valueAccessor();
        var copyButtonOwner = $(element);
        if (copyButtonOwner.is(":data(fxs-fxsCopyButton)")) {
            copyButtonOwner.fxsCopyButton("destroy");
        }
        copyButtonOwner.fxsCopyButton({ text: text() });
    }
    ko.bindingHandlers["fxsCopyButton"] = {
        init: handleInitOrUpdate,
        update: handleInitOrUpdate
    };
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
/// <reference path="../../View/DialogView.ts" />
var ExperimentEditor;
(function (ExperimentEditor) {
    var ApiCodeDialogViewModel = (function () {
        function ApiCodeDialogViewModel(targetObject, workspaceId, workspaceToken) {
            var _this = this;
            this.language = ko.observable();
            this.useSecondaryToken = ko.observable();
            this.languages = ["Python"];
            this.workspaceTokenToUse = DataLab.Util.deferredComputed(function () {
                var isWorkspaceOwner = DataLab.User.isWorkspaceOwner;
                if (isWorkspaceOwner) {
                    return _this.useSecondaryToken() ? _this.workspaceToken.secondary : _this.workspaceToken.primary;
                }
                else {
                    return "Unavailable";
                }
            });
            this.datasetName = DataLab.Util.deferredComputed(function () {
                var datasetName;
                if (_this.targetObject instanceof DataLab.Model.OutputPort) {
                    var port = _this.targetObject;
                    if (port.parent instanceof DataLab.Model.DatasetNode) {
                        datasetName = port.parent.name;
                    }
                    else if (port.parent instanceof DataLab.Model.ModuleNode) {
                        datasetName = port.descriptor.name;
                    }
                }
                else if (_this.targetObject instanceof DataLab.Model.Dataset) {
                    datasetName = _this.targetObject.name(); // .peek()?
                }
                if (!datasetName) {
                    throw new Error("No dataset name found");
                }
                return datasetName;
            });
            this.longCodeTemplates_DataOutputPort = {
                "Python": DataLab.Util.deferredComputed(function () {
                    return "from azureml import Workspace\n" + "ws = Workspace(\n" + "    workspace_id='" + _this.workspaceId + "',\n" + "    authorization_token='" + _this.workspaceTokenToUse() + "'\n" + ")\n" + "ds = ws.datasets['" + _this.datasetName() + "']\n" + "frame = ds.to_dataframe()";
                })
            };
            this.longCodeTemplates_InterOutputPort = {
                "Python": DataLab.Util.deferredComputed(function () {
                    var port = _this.targetObject;
                    var experimentId = port.parent.parent.experimentId();
                    if (experimentId === null && port.parent.parent.parentExperimentId !== null) {
                        experimentId = port.parent.parent.parentExperimentId;
                    }
                    var node_id = port.parent.id;
                    var type_id = port.descriptor.allowedDataTypes[0].dataTypeId;
                    return "from azureml import Workspace\n" + "ws = Workspace(\n" + "    workspace_id='" + _this.workspaceId + "',\n" + "    authorization_token='" + _this.workspaceTokenToUse() + "'\n" + ")\n" + "experiment = ws.experiments['" + experimentId + "']\n" + "ds = experiment.get_intermediate_dataset(\n" + "    node_id='" + node_id + "',\n" + "    port_name='" + _this.datasetName() + "',\n" + "    data_type_id='" + type_id + "'\n" + ")\n" + "frame = ds.to_dataframe()";
                })
            };
            this.longCode = DataLab.Util.deferredComputed(function () {
                var language = _this.language();
                var longCode;
                // Dispatch based on the type of the target object. This has
                // already been validated.
                if (_this.targetObject instanceof DataLab.Model.OutputPort) {
                    var port = _this.targetObject;
                    if (_this.showLongCode) {
                        //Dataset Modules
                        if (port.parent instanceof DataLab.Model.DatasetNode) {
                            longCode = _this.longCodeTemplates_DataOutputPort[language]();
                        }
                        else if (port.parent instanceof DataLab.Model.ModuleNode) {
                            longCode = _this.longCodeTemplates_InterOutputPort[language]();
                        }
                    }
                }
                else if (_this.targetObject instanceof DataLab.Model.Dataset) {
                    var longCode = _this.longCodeTemplates_DataOutputPort[language]();
                }
                if (!longCode) {
                    throw new Error("Could not compute longCode");
                }
                return longCode;
            });
            // Ensure targetObject is a valid type or else fail to construct
            // the view model
            if (!(targetObject instanceof DataLab.Model.OutputPort) && !(targetObject instanceof DataLab.Model.Dataset)) {
                throw new TypeError("Unsupported type");
            }
            this.targetObject = targetObject;
            this.showLongCode = workspaceToken != undefined;
            this.workspaceId = workspaceId;
            this.showExtraHelp = !DataLab.User.isWorkspaceOwner;
            this.workspaceToken = { primary: workspaceToken.primary(), secondary: workspaceToken.secondary() };
            this.showPreviewTag = DataLab.Features.enableOutputPortApiCodeExperience().match(/\bPreview\b/) != null;
            this.language(this.languages[0]);
        }
        ApiCodeDialogViewModel.prototype.canBeAccepted = function () {
            return true;
        };
        ApiCodeDialogViewModel.prototype.dismissed = function (result) {
        };
        ApiCodeDialogViewModel.prototype.showDialog = function () {
            var p = ExperimentEditor.DialogViews.ShowApiCode.show(this);
            // TODO: Uncomment this when the copy button styling supports textarea.
            /*$("#long-code").fxsCopyButton({
                ariaLabelledBy: "long-code-label",
                labelElement: $("#long-code-textarea"),
                getClipboardText: function () { return $("#long-code-text").val(); }
            });*/
            $("#long-code-text").click(function () {
                $(this).select();
            });
            return p;
        };
        return ApiCodeDialogViewModel;
    })();
    ExperimentEditor.ApiCodeDialogViewModel = ApiCodeDialogViewModel;
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
var ExperimentEditor;
(function (ExperimentEditor) {
    var UserWorkspacesHelper = (function () {
        function UserWorkspacesHelper() {
        }
        UserWorkspacesHelper.getUserWorkspaces = function () {
            if (UserWorkspacesHelper.userWorkspacesPromise) {
                return UserWorkspacesHelper.userWorkspacesPromise;
            }
            else {
                UserWorkspacesHelper.userWorkspacesPromise = DataLab.Util.then(DataLab.Workspace.listWorkspacesAsync(), function (workspaces) {
                    return workspaces.sort(function (a, b) { return a.FriendlyName.localeCompare(b.FriendlyName); });
                });
                return UserWorkspacesHelper.userWorkspacesPromise;
            }
        };
        return UserWorkspacesHelper;
    })();
    ExperimentEditor.UserWorkspacesHelper = UserWorkspacesHelper;
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
/// <reference path="../../View/DialogView.ts" />
/// <reference path="../experimenteditor/UserWorkspaceHelpers.ts" />
var ExperimentEditor;
(function (ExperimentEditor) {
    var CopyExperimentDialogViewModel = (function () {
        function CopyExperimentDialogViewModel(experimentName, experimentId) {
            var _this = this;
            this.experimentId = experimentId;
            this.experimentName = DataLab.Validation.validatableObservable(experimentName, function (name) {
                // String must contain a non-whitespace character
                if (/\S/.test(name)) {
                    return null;
                }
                else {
                    return DataLab.LocalizedResources.experimentNameError;
                }
            });
            this.experimentName.subscribe(function () {
                _this.experimentName.startValidating();
                _this.experimentName.validate();
            });
            this.workspaces = ko.observableArray([]);
            ExperimentEditor.UserWorkspacesHelper.getUserWorkspaces().done(function (workspaces) {
                workspaces.forEach(function (workspace) {
                    if (workspace.WorkspaceId !== DataLab.Workspace.id) {
                        _this.workspaces.push(workspace);
                    }
                });
            }).fail(function () {
                // In this case this.workspaces will remain empty. This will keep this.workpsaceInfoAvailable as false and a label will be shown to users.
            });
            this.workspaceInfoAvailable = ko.computed(function () {
                return _this.workspaces().length > 0;
            });
            this.destinationWorkspace = ko.observable(null);
            this.validatedFields = [this.experimentName];
        }
        CopyExperimentDialogViewModel.prototype.dismissed = function (result) {
            var _this = this;
            if (result.accepted) {
                Shell.Diagnostics.Telemetry.customEvent("CopyExperimentStarted", "CopyExperiment", JSON.stringify({ "experimentId": this.experimentId, "experimentName": this.experimentName(), "destinationWorkspaceId": this.destinationWorkspace().WorkspaceId }));
                Shell.Diagnostics.Telemetry.featureUsage(81 /* CopyExperimentAcrossWorkspace */, 3 /* ShellUICommands */, DataLab.Workspace.id, null, null, JSON.stringify({ "experimentId": this.experimentId, "experimentName": this.experimentName, "destinationWorkspaceId": this.destinationWorkspace().WorkspaceId }));
                var progress = new Shell.UI.Notifications.Progress(DataLab.Util.format(DataLab.LocalizedResources.copyExperimentDialogCopyExperimentStarted, this.experimentName(), this.destinationWorkspace().FriendlyName), "active", false);
                Shell.UI.Notifications.add(progress);
                progress.setValue(10);
                var pollingExperimentPackage = DataLab.Util.then(DataLab.Workspace.createExperimentStoragePackageAsync(this.experimentId, true, this.experimentName()), function (response) {
                    return _this.pollOnPackage(response, progress);
                });
                var experimentSubmissionPromise = DataLab.Util.then(pollingExperimentPackage, function (experimentPackage) {
                    return DataLab.Workspace.createExperimentFromStoragePackageAsync(_this.destinationWorkspace().WorkspaceId, experimentPackage.Location);
                });
                experimentSubmissionPromise.done(function (response) {
                    progress.setValue(100);
                    var urlBase = "/Home/ViewWorkspace/" + _this.destinationWorkspace().WorkspaceId;
                    var urlHash = Shell.UI.Navigation.calculateNavigationPath({ extension: DataLabViews.experimentExtensionName, type: "Experiment", name: response.ExperimentId, view: "ViewExperiment" });
                    var copyUrl = urlBase + urlHash;
                    progress.setTitle(DataLab.Util.format(DataLab.LocalizedResources.copyExperimentDialogCopyExperimentSucceeded, _this.experimentName(), _this.destinationWorkspace().FriendlyName));
                    progress.setActions([{ text: DataLab.LocalizedResources.copyExperimentDialogLinkToCopy, url: '/Content/Images/icon-behavior-arrow-link.png', click: function () {
                        window.location.href = copyUrl;
                    } }, Shell.UI.Notifications.Buttons.close(function () {
                    })]);
                    progress.setStatus("success");
                    Shell.Diagnostics.Telemetry.customEvent("CopyExperimentSucceeded", "CopyExperiment", JSON.stringify({ "experimentId": _this.experimentId, "experimentName": _this.experimentName(), "destinationWorkspaceId": _this.destinationWorkspace().WorkspaceId, "destinationURL": copyUrl }));
                }).fail(function (error) {
                    progress.setTitle(DataLab.Util.format(DataLab.LocalizedResources.copyExperimentDialogCopyExperimentFailed, _this.experimentName(), _this.destinationWorkspace().FriendlyName, error.message));
                    progress.setActions([Shell.UI.Notifications.Buttons.close(function () {
                    })]);
                    progress.setStatus("error");
                    Shell.Diagnostics.Telemetry.customEvent("CopyExperimentFailed", "CopyExperiment", JSON.stringify({ "experimentId": _this.experimentId, "experimentName": _this.experimentName(), "destinationWorkspaceId": _this.destinationWorkspace().WorkspaceId }));
                });
            }
            else {
                Shell.Diagnostics.Telemetry.customEvent("CopyExperimentDialogClosed", "AllExperimentsView");
            }
        };
        CopyExperimentDialogViewModel.prototype.canBeAccepted = function () {
            // First we ensure that all fields are currently validating (initially they are quiet).
            // Attempting to dismiss this dialog should make all fields start complaining as needed.
            this.validatedFields.forEach(function (f) { return f.startValidating(); });
            return this.workspaceInfoAvailable() && this.validatedFields.every(function (f) { return f.isValid(); });
        };
        CopyExperimentDialogViewModel.prototype.pollOnPackage = function (experimentPackage, progress) {
            var pollingDeferred = $.Deferred();
            this.pollOnPackageHandler(experimentPackage, 0, pollingDeferred, progress);
            return DataLab.Util.when(pollingDeferred.promise());
        };
        CopyExperimentDialogViewModel.prototype.pollOnPackageHandler = function (experimentPackage, retryCount, resultPromise, progress) {
            var _this = this;
            DataLab.Workspace.getExperimentStoragePackageAsync(experimentPackage.Location).done(function (updatedPackage) {
                // Multiply by 80 because 10% is already taken up by the create package, and 10% at the end by the submit experiment
                var progressValue = updatedPackage.ItemsComplete === 0 ? 0 : (updatedPackage.ItemsComplete / (updatedPackage.ItemsComplete + updatedPackage.ItemsPending)) * 80;
                // Set progress value but leave ~10 percent for the experiment submission
                progress.setValue(10 + Math.floor(progressValue));
                if (updatedPackage.Status === "Pending") {
                    // Poll for ~1 hour and then fail
                    if (retryCount > 15) {
                        resultPromise.reject(new Error("Exceeded retry count"));
                    }
                    var interval = Math.pow(2, retryCount) * 100;
                    setTimeout(function () {
                        _this.pollOnPackageHandler(updatedPackage, retryCount + 1, resultPromise, progress);
                    }, interval);
                }
                else if (updatedPackage.Status === "Complete") {
                    resultPromise.resolve(updatedPackage);
                }
                else {
                    resultPromise.reject(new Error("Unknown status returned for package"));
                }
            }).fail(function (error) { return resultPromise.reject(error); });
        };
        return CopyExperimentDialogViewModel;
    })();
    ExperimentEditor.CopyExperimentDialogViewModel = CopyExperimentDialogViewModel;
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
/// <reference path="../../View/DialogView.ts" />
/// <reference path="../experimenteditor/UserWorkspaceHelpers.ts" />
var ExperimentEditor;
(function (ExperimentEditor) {
    var WorkspaceWithDisplayName = (function () {
        function WorkspaceWithDisplayName(workspace, displayName) {
            this.workspace = workspace;
            this.displayName = displayName;
            if (!this.displayName)
                this.displayName = workspace.FriendlyName;
        }
        return WorkspaceWithDisplayName;
    })();
    ExperimentEditor.WorkspaceWithDisplayName = WorkspaceWithDisplayName;
    var CopyExperimentFromGalleryDialogViewModel = (function () {
        function CopyExperimentFromGalleryDialogViewModel(packageUri, communityUri, destinationWorkspace) {
            var _this = this;
            this.packageUri = packageUri;
            this.communityUri = communityUri;
            this.workspaces = ko.observableArray([]);
            ExperimentEditor.UserWorkspacesHelper.getUserWorkspaces().done(function (workspaces) {
                workspaces.forEach(function (workspace) {
                    var isCurrentWorkspace = workspace.WorkspaceId === DataLab.Workspace.id;
                    var displayName;
                    if (workspaces.length > 1 && isCurrentWorkspace) {
                        displayName = DataLab.Util.format(DataLab.LocalizedResources.workspaceWithCurrentLabel, workspace.FriendlyName);
                    }
                    else {
                        displayName = workspace.FriendlyName;
                    }
                    if (isCurrentWorkspace) {
                        var workspaceWithDisplayName = new WorkspaceWithDisplayName(workspace, displayName);
                        _this.workspaces.push(workspaceWithDisplayName);
                        _this.destinationWorkspace(workspaceWithDisplayName);
                    }
                    else {
                        _this.workspaces.push(new WorkspaceWithDisplayName(workspace, displayName));
                    }
                });
            }).fail(function () {
                // In this case this.workspaces will remain empty. This will keep this.workpsaceInfoAvailable as false and a label will be shown to users.
            });
            this.workspaceInfoAvailable = ko.computed(function () {
                return _this.workspaces().length > 0;
            });
            this.destinationWorkspace = ko.observable(null);
        }
        CopyExperimentFromGalleryDialogViewModel.prototype.dismissed = function (result) {
            if (result.accepted) {
                CopyExperimentFromGalleryDialogViewModel.copyExperiment(this.packageUri, this.communityUri, this.destinationWorkspace().workspace);
            }
            else {
                Shell.Diagnostics.Telemetry.customEvent("CopyExperimentFromGalleryDialogClosed", "AllExperimentsView");
            }
        };
        CopyExperimentFromGalleryDialogViewModel.copyExperiment = function (packageUri, communityUri, destinationWorkspace) {
            Shell.Diagnostics.Telemetry.featureUsage(105 /* CopyExperimentFromGallery */, 0 /* None */, DataLab.Workspace.id, null, null, JSON.stringify({ "packageUri": packageUri, "communityUri": communityUri, "destinationWorkspaceId": destinationWorkspace.WorkspaceId }));
            return ExperimentEditor.Community.copyCommunityExperimentToWorkspaceAndNavigateToExperiment(destinationWorkspace.WorkspaceId, destinationWorkspace.FriendlyName, packageUri, communityUri);
        };
        CopyExperimentFromGalleryDialogViewModel.prototype.canBeAccepted = function () {
            return this.workspaceInfoAvailable();
        };
        return CopyExperimentFromGalleryDialogViewModel;
    })();
    ExperimentEditor.CopyExperimentFromGalleryDialogViewModel = CopyExperimentFromGalleryDialogViewModel;
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
/// <reference path="../../View/DialogView.ts" />
var ExperimentEditor;
(function (ExperimentEditor) {
    var CreateWebServiceFromTransformDialogViewModel = (function () {
        function CreateWebServiceFromTransformDialogViewModel(name, handler) {
            this.name = ko.observable();
            this.description = ko.observable();
            this.name(name);
            this.handler = handler;
        }
        CreateWebServiceFromTransformDialogViewModel.prototype.canBeAccepted = function () {
            return true;
        };
        CreateWebServiceFromTransformDialogViewModel.prototype.dismissed = function (result) {
            if (result.accepted) {
                this.handler(this.name(), this.description());
            }
        };
        return CreateWebServiceFromTransformDialogViewModel;
    })();
    ExperimentEditor.CreateWebServiceFromTransformDialogViewModel = CreateWebServiceFromTransformDialogViewModel;
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
/// <reference path="../../View/DialogView.ts" />
/// <reference path="../ExperimentEditor/PortViewModel.ts" />
var ExperimentEditor;
(function (ExperimentEditor) {
    var UploadDatasetDialogViewModel = (function () {
        function UploadDatasetDialogViewModel(workspace) {
            var _this = this;
            /** Fired if the user initiates dataset upload (by accepting the dialog).
                The event value is a DataLab.Util.IProgressPromise representing the in-progress upload.
                The promise generates progress events for the upload. */
            this.datasetUploadStartedEvent = new ko.subscribable();
            this.workspace = workspace;
            var allDataTypes = DataLab.Util.values(this.workspace.applicationCache.dataTypeRegistry.dataTypes);
            this.dataTypes = allDataTypes.filter(function (f) { return f.allowUpload; });
            this.dataset = new DataLab.Model.UnsavedResource(workspace, workspace.datasetCache, workspace.datasetUploadsInProgress, DataLab.Constants.DatasetName);
            this.fileToUpload = DataLab.Validation.validatableObservable(null, function (val) {
                var maxSize = DataLab.Features.chunkedUploadInStudioEnabled() ? ExperimentEditor.Constants.maxUploadSizeInBytesNew : ExperimentEditor.Constants.maxUploadSizeInBytes;
                var maxSizeDescription = DataLab.Features.chunkedUploadInStudioEnabled() ? ExperimentEditor.Constants.maxUploadSizeDescriptionNew : ExperimentEditor.Constants.maxUploadSizeDescription;
                if (!val) {
                    return DataLab.LocalizedResources.selectUploadFile;
                }
                else if (DataLab.Features.trialLimitationsEnabled() && val.size > DataLab.Trial.getMaxDatasetUploadSize()) {
                    return DataLab.Util.format(DataLab.LocalizedResources.fileTooLargeAnonymous, DataLab.Util.formatDataSize(DataLab.Trial.getMaxDatasetUploadSize(), 3));
                }
                else if (val.size > maxSize) {
                    return DataLab.Util.format(DataLab.LocalizedResources.fileTooLarge, maxSizeDescription);
                }
                else if (val.size === 0) {
                    return DataLab.LocalizedResources.fileEmpty;
                }
                return null;
            });
            // To streamline the upload experience, we try to populate the name and data type
            // fields based on the selected filename (even if already populated).
            this.fileToUpload.subscribe(function (newFile) {
                if (!newFile) {
                    return;
                }
                var hintDataset = DataLab.Util.first(_this.workspace.datasetCache.items(), function (d) {
                    return d.filename === newFile.name;
                }, null);
                if (hintDataset) {
                    _this.dataset.deprecate(true);
                    _this.dataset.resourceToDeprecate(hintDataset.name());
                    _this.dataset.hint(true);
                }
                else {
                    _this.dataset.name(newFile.name);
                    _this.dataset.hint(false);
                }
                _this.selectDataTypeForFileName(newFile.name);
            });
            this.validatedFields = [this.dataset, this.dataset.dataType, this.fileToUpload];
        }
        UploadDatasetDialogViewModel.prototype.getDataTypeCaption = function (datatype) {
            var caption = datatype.name;
            if (datatype.fileExtension) {
                caption = caption + " (." + datatype.fileExtension + ")";
            }
            return caption;
        };
        UploadDatasetDialogViewModel.prototype.dismissed = function (result) {
            this.dataset.updateAvailableResources.dispose();
            if (result.accepted) {
                DataLab.Log.info("Dataset upload dialog accepted");
                this.upload();
            }
            else {
                DataLab.Log.info("Dataset upload dialog cancelled");
            }
        };
        UploadDatasetDialogViewModel.prototype.canBeAccepted = function () {
            // First we ensure that all fields are currently validating (initially they are quiet).
            // Attempting to dismiss this dialog should make all fields start complaining as needed.
            this.validatedFields.forEach(function (f) { return f.startValidating(); });
            return this.validatedFields.every(function (f) { return f.isValid(); });
        };
        UploadDatasetDialogViewModel.prototype.upload = function () {
            this.workspace.datasetUploadsInProgress().push(this.dataset.name());
            var uploadPromise = this.workspace.uploadDatasetAsync(this.fileToUpload(), this.dataset.name(), this.dataset.dataType(), this.fileToUpload().name, this.dataset.description(), this.dataset.familyId());
            this.datasetUploadStartedEvent.notifySubscribers(uploadPromise);
        };
        UploadDatasetDialogViewModel.prototype.selectDataTypeForFileName = function (fileName) {
            var dataTypesMatchingExtension = this.workspace.applicationCache.dataTypeRegistry.findDataTypesForFileName(fileName).filter(function (f) { return f.allowUpload; });
            if (dataTypesMatchingExtension.length > 0) {
                this.dataset.dataType(dataTypesMatchingExtension[0]);
            }
            else {
                var anyType = this.workspace.applicationCache.dataTypeRegistry.tryGetDataTypeWithId(DataLab.Model.WellKnownDataTypeIds.Any);
                if (anyType && anyType.allowUpload) {
                    this.dataset.dataType(anyType);
                }
            }
        };
        return UploadDatasetDialogViewModel;
    })();
    ExperimentEditor.UploadDatasetDialogViewModel = UploadDatasetDialogViewModel;
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
/// <reference path="../../View/DialogView.ts" />
/// <reference path="../ExperimentEditor/PortViewModel.ts" />
var ExperimentEditor;
(function (ExperimentEditor) {
    var UploadModuleDialogViewModel = (function () {
        function UploadModuleDialogViewModel(workspace) {
            var _this = this;
            // Not sure that we need dataTypes. In this dialog we are always uploading a zip.
            // public dataTypes: DataLab.Model.DataType[];
            /** Fired if the user initiates zip package upload (by accepting the dialog).
                The event value is a DataLab.Util.IProgressPromise representing the in-progress upload.
                The promise generates progress events for the upload. */
            this.modulePackageUploadStartedEvent = new ko.subscribable();
            this.workspace = workspace;
            var allDataTypes = DataLab.Util.values(this.workspace.applicationCache.dataTypeRegistry.dataTypes);
            var dataTypeReg = new DataLab.Model.DataTypeRegistry(allDataTypes);
            // Get data types associated with .zip files and ensure they are eligable for upload.
            var dataTypes = dataTypeReg.findDataTypesForFileExtension(".zip").filter(function (f) { return f.allowUpload; });
            // TODO check use of datasetCache and wheter it is appropriate for the temporary zip file required for module registration            
            this.zipFile = new DataLab.Model.UnsavedResource(workspace, workspace.datasetCache, workspace.customModulePackageUploadsInProgress, DataLab.Constants.CustomModulePackageName);
            this.fileToUpload = DataLab.Validation.validatableObservable(null, function (val) {
                if (!val) {
                    return DataLab.LocalizedResources.selectUploadFile;
                }
                else if (val.size > ExperimentEditor.Constants.maxModulePackageUploadSizeInBytes) {
                    return DataLab.Util.format(DataLab.LocalizedResources.fileTooLarge, ExperimentEditor.Constants.maxModulePackageUploadSizeDescription);
                }
                else if (val.size === 0) {
                    return DataLab.LocalizedResources.fileEmpty;
                }
                else if (dataTypeReg.findDataTypesForFileName(val.name).filter(function (f) { return dataTypes.filter(function (x) { return f === x; }).length > 0; }).length === 0) {
                    return DataLab.LocalizedResources.fileInvalidType;
                }
                return null;
            });
            // To streamline the upload experience, we try to populate the name and data type
            // fields based on the selected filename (even if already populated).
            this.fileToUpload.subscribe(function (newFile) {
                if (!newFile) {
                    return;
                }
                else {
                    _this.zipFile.name(newFile.name);
                }
                _this.zipFile.hint(false);
                _this.selectDataTypeForFileName(newFile.name);
                // TODO:
                // Possibly examine existing uploaded custom modules and warn if updating any.                
            });
            this.validatedFields = [this.zipFile, this.zipFile.dataType, this.fileToUpload];
        }
        UploadModuleDialogViewModel.prototype.getDataTypeCaption = function (datatype) {
            var caption = datatype.name;
            if (datatype.fileExtension) {
                caption = caption + " (." + datatype.fileExtension + ")";
            }
            return caption;
        };
        UploadModuleDialogViewModel.prototype.dismissed = function (result) {
            this.zipFile.updateAvailableResources.dispose();
            if (result.accepted) {
                DataLab.Log.info("Module upload dialog accepted");
                this.upload();
            }
            else {
                DataLab.Log.info("Module upload dialog cancelled");
            }
        };
        UploadModuleDialogViewModel.prototype.canBeAccepted = function () {
            // First we ensure that all fields are currently validating (initially they are quiet).
            // Attempting to dismiss this dialog should make all fields start complaining as needed.
            this.validatedFields.forEach(function (f) { return f.startValidating(); });
            return this.validatedFields.every(function (f) { return f.isValid(); });
        };
        UploadModuleDialogViewModel.prototype.upload = function () {
            this.workspace.customModulePackageUploadsInProgress().push(this.zipFile.name());
            var uploadPromise = this.workspace.uploadCustomModulePackageAsync(this.fileToUpload(), this.zipFile.name(), this.zipFile.dataType(), this.fileToUpload().name, this.zipFile.description(), this.zipFile.familyId());
            this.modulePackageUploadStartedEvent.notifySubscribers(uploadPromise);
        };
        UploadModuleDialogViewModel.prototype.selectDataTypeForFileName = function (fileName) {
            var dataTypesMatchingExtension = this.workspace.applicationCache.dataTypeRegistry.findDataTypesForFileName(fileName).filter(function (f) { return f.allowUpload; });
            if (dataTypesMatchingExtension.length > 0) {
                this.zipFile.dataType(dataTypesMatchingExtension[0]);
            }
            else {
                var anyType = this.workspace.applicationCache.dataTypeRegistry.tryGetDataTypeWithId(DataLab.Model.WellKnownDataTypeIds.Any);
                if (anyType && anyType.allowUpload) {
                    this.zipFile.dataType(anyType);
                }
            }
        };
        return UploadModuleDialogViewModel;
    })();
    ExperimentEditor.UploadModuleDialogViewModel = UploadModuleDialogViewModel;
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var ExperimentEditor;
(function (ExperimentEditor) {
    var NewDrawerMenu;
    (function (NewDrawerMenu) {
        var NewDatasetMenuViewModel = (function (_super) {
            __extends(NewDatasetMenuViewModel, _super);
            function NewDatasetMenuViewModel() {
                _super.call(this);
                this.detailMessage = ko.observable(DataLab.LocalizedResources.newDatasetMenuHeader);
            }
            return NewDatasetMenuViewModel;
        })(DataLab.Util.Disposable);
        NewDrawerMenu.NewDatasetMenuViewModel = NewDatasetMenuViewModel;
        function NewDatasetMenuInitialize() {
            NewDrawerMenu.NewDrawerMenuDestroy();
            var menuElement = $(ExperimentEditor._newDatasetMenuMarkup).prependTo(".fxs-drawerdetails-details-box");
            ko.applyBindings(new NewDatasetMenuViewModel(), menuElement[0]);
        }
        NewDrawerMenu.NewDatasetMenuInitialize = NewDatasetMenuInitialize;
    })(NewDrawerMenu = ExperimentEditor.NewDrawerMenu || (ExperimentEditor.NewDrawerMenu = {}));
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
var ExperimentEditor;
(function (ExperimentEditor) {
    var NewDrawerMenu;
    (function (NewDrawerMenu) {
        function NewDrawerMenuDestroy() {
            var newDrawerMenuElement = $(".fxs-drawerdetails-details-box");
            newDrawerMenuElement.children().each(function (index, element) {
                var newDrawerMenuViewModel = ko.dataFor(element);
                if (newDrawerMenuViewModel instanceof DataLab.Util.Disposable) {
                    newDrawerMenuViewModel.dispose();
                }
                else {
                    newDrawerMenuViewModel = null;
                }
            });
            newDrawerMenuElement.empty();
        }
        NewDrawerMenu.NewDrawerMenuDestroy = NewDrawerMenuDestroy;
        function openSampleAsCopy(experimentId, description, runAfterCopy) {
            var numTimesNavigateCalled = !window.newExperimentGeneration ? 1 : ++window.newExperimentGeneration.numTimesNavigateCalled;
            window.newExperimentGeneration = {
                id: experimentId,
                numTimesNavigateCalled: numTimesNavigateCalled,
                createCopy: function () {
                    var view = cdm.getActiveItem();
                    view.xeViewModel.copy(DataLab.Util.format(DataLab.LocalizedResources.newExperimentMenuTemplateCopyName, description));
                    if (runAfterCopy) {
                        runAfterCopy();
                    }
                }
            };
            DataLabViews.navigateToExperiment(experimentId);
        }
        NewDrawerMenu.openSampleAsCopy = openSampleAsCopy;
    })(NewDrawerMenu = ExperimentEditor.NewDrawerMenu || (ExperimentEditor.NewDrawerMenu = {}));
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
var ExperimentEditor;
(function (ExperimentEditor) {
    var Community;
    (function (Community) {
        var ActivityType;
        (function (ActivityType) {
            ActivityType[ActivityType["Unknown"] = 0] = "Unknown";
            ActivityType[ActivityType["View"] = 1] = "View";
            ActivityType[ActivityType["Publish"] = 2] = "Publish";
            ActivityType[ActivityType["Comment"] = 3] = "Comment";
            ActivityType[ActivityType["Open"] = 4] = "Open";
            ActivityType[ActivityType["Clone"] = 5] = "Clone";
            ActivityType[ActivityType["Share"] = 6] = "Share";
        })(ActivityType || (ActivityType = {}));
        var Activity = (function () {
            function Activity() {
            }
            return Activity;
        })();
        Community.activityServiceUrl = "";
        // Use the user activity client to send user activities, entity id is required, userid and context are optional
        var UserActivityClient = (function () {
            function UserActivityClient(activityServiceUrl) {
                this.activityServiceUrl = activityServiceUrl;
            }
            UserActivityClient.prototype.view = function (entityId, userId, context) {
                this.postActivity(entityId, userId, context, 1 /* View */);
            };
            UserActivityClient.prototype.download = function (entityId, userId, context) {
                this.postActivity(entityId, userId, context, 4 /* Open */);
            };
            UserActivityClient.prototype.publish = function (entityId, userId, context) {
                this.postActivity(entityId, userId, context, 2 /* Publish */);
            };
            UserActivityClient.prototype.comment = function (entityId, userId, context) {
                this.postActivity(entityId, userId, context, 3 /* Comment */);
            };
            UserActivityClient.prototype.open = function (entityId, userId, context) {
                this.postActivity(entityId, userId, context, 4 /* Open */);
            };
            UserActivityClient.prototype.clone = function (entityId, userId, context) {
                this.postActivity(entityId, userId, context, 5 /* Clone */);
            };
            UserActivityClient.prototype.share = function (entityId, userId, context) {
                this.postActivity(entityId, userId, context, 6 /* Share */);
            };
            UserActivityClient.prototype.postActivity = function (entityId, userId, context, activityType) {
                var activity = new Activity();
                activity.EntityId = entityId;
                activity.UserId = userId;
                activity.Context = context;
                activity.ActivityType = activityType;
                $.ajax(this.activityServiceUrl + "/Add", {
                    data: JSON.stringify(activity),
                    contentType: "application/json",
                    type: "POST"
                });
            };
            return UserActivityClient;
        })();
        Community.UserActivityClient = UserActivityClient;
        // @TODO Defect 4158533 - Remove this code after this bug is resolved and we can get the entity ID directly from Community.
        function getEntityIdFromCommunityUri(communityUri) {
            if (!communityUri) {
                return "";
            }
            return communityUri.substr(communityUri.lastIndexOf("/") + 1); // entityId (for now!) is last path segment
        }
        Community.getEntityIdFromCommunityUri = getEntityIdFromCommunityUri;
        function copyCommunityExperimentToThisWorkspaceAndNavigateToExperiment(packageUri, communityUri, templateEntityId) {
            return copyCommunityExperimentToWorkspaceAndNavigateToExperiment(DataLab.Workspace, DataLab.Workspace.friendlyName, packageUri, communityUri, templateEntityId);
        }
        Community.copyCommunityExperimentToThisWorkspaceAndNavigateToExperiment = copyCommunityExperimentToThisWorkspaceAndNavigateToExperiment;
        function copyCommunityExperimentToWorkspaceAndNavigateToExperiment(workspaceOrWorkspaceId /*string|DataLab.Model.Workspace*/, workspaceFriendlyName, packageUri, communityUri, templateEntityId) {
            Shell.UI.Spinner.show();
            var promise = copyCommunityExperiment(workspaceOrWorkspaceId, workspaceFriendlyName, packageUri, communityUri, templateEntityId);
            return DataLab.Util.then(promise, function (submitResult) {
                if (submitResult.ExperimentId) {
                    if (typeof workspaceOrWorkspaceId === 'string' && workspaceOrWorkspaceId.toLowerCase() !== DataLab.Workspace.id.toLowerCase()) {
                        // we need to load the target workspace
                        var urlBase = "/Home/ViewWorkspace/" + workspaceOrWorkspaceId;
                        var urlHash = Shell.UI.Navigation.calculateNavigationPath({ extension: DataLabViews.experimentExtensionName, type: "Experiment", name: submitResult.ExperimentId, view: "ViewExperiment" });
                        var copyUrl = urlBase + urlHash;
                        window.location.href = copyUrl;
                    }
                    else {
                        DataLabViews.navigateToExperiment(submitResult.ExperimentId);
                    }
                }
                else {
                    var notification = new Shell.UI.Notifications.Notification(DataLab.Util.format(DataLab.LocalizedResources.newExperimentMenuCannotOpen, communityUri), "error");
                    notification.setActions([Shell.UI.Notifications.Buttons.close()]);
                    Shell.UI.Notifications.add(notification);
                    DataLab.Log.error("Open gallery experiment failed with return value null. " + communityUri);
                    Shell.UI.Spinner.hide();
                }
            }).fail(function () {
                var notification = new Shell.UI.Notifications.Notification(DataLab.Util.format(DataLab.LocalizedResources.newExperimentMenuOpenCallFailed, communityUri), "error");
                notification.setActions([Shell.UI.Notifications.Buttons.close()]);
                Shell.UI.Notifications.add(notification);
                DataLab.Log.error("Call to open gallery experiment failed. " + communityUri);
                Shell.UI.Spinner.hide();
            }).always(Shell.UI.Spinner.hide);
        }
        Community.copyCommunityExperimentToWorkspaceAndNavigateToExperiment = copyCommunityExperimentToWorkspaceAndNavigateToExperiment;
        function copyCommunityExperiment(workspaceOrWorkspaceId /*string|DataLab.Model.Workspace*/, workspaceFriendlyName, packageUri, communityUri, templateEntityId) {
            var workspaceId;
            var getCommunityExperimentIdAsyncFunction;
            if (typeof workspaceOrWorkspaceId === "string") {
                workspaceId = workspaceOrWorkspaceId;
                var client = new DataLab.DataContract.Client(workspaceId, "");
                getCommunityExperimentIdAsyncFunction = client.getCommunityExperimentIdAsync.bind(client);
            }
            else {
                var workspace = workspaceOrWorkspaceId;
                workspaceId = workspace.id;
                getCommunityExperimentIdAsyncFunction = workspace.getCommunityExperimentIdAsync.bind(workspace);
            }
            var entityId = templateEntityId ? templateEntityId : getEntityIdFromCommunityUri(communityUri);
            var promise = getCommunityExperimentIdAsyncFunction(workspaceId, packageUri, communityUri);
            promise.done(function () {
                if (entityId) {
                    var userActivityClient = new UserActivityClient(Community.activityServiceUrl);
                    userActivityClient.download(entityId, "", "");
                }
            });
            return promise;
        }
        Community.copyCommunityExperiment = copyCommunityExperiment;
        ;
    })(Community = ExperimentEditor.Community || (ExperimentEditor.Community = {}));
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
/// <reference path="../experimenteditor/CommunityHelpers.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var ExperimentEditor;
(function (ExperimentEditor) {
    var NewDrawerMenu;
    (function (NewDrawerMenu) {
        // Classes that specify the contract with Catalog and Search services.
        var CatalogQueryResult = (function () {
            function CatalogQueryResult(count, val) {
                this.total_count = count;
                this.value = val;
            }
            return CatalogQueryResult;
        })();
        NewDrawerMenu.CatalogQueryResult = CatalogQueryResult;
        var CatalogExperiment = (function () {
            function CatalogExperiment() {
            }
            CatalogExperiment.CatalogExperimentSampleSortFunction = function (left, right) {
                if (left.id === right.id) {
                    return 0;
                }
                // Numbered samples are first
                if (CatalogExperiment.numberedSampleRegEx.test(left.name) && !CatalogExperiment.numberedSampleRegEx.test(right.name)) {
                    return -1;
                }
                else if (!CatalogExperiment.numberedSampleRegEx.test(left.name) && CatalogExperiment.numberedSampleRegEx.test(right.name)) {
                    return 1;
                }
                else if (CatalogExperiment.numberedSampleRegEx.test(left.name) && CatalogExperiment.numberedSampleRegEx.test(right.name)) {
                    var leftNum = left.name.match(CatalogExperiment.numberedSampleRegEx)[2];
                    var rightNum = right.name.match(CatalogExperiment.numberedSampleRegEx)[2];
                    if (leftNum === rightNum) {
                        return 0;
                    }
                    return leftNum < rightNum ? -1 : 1;
                }
                else {
                    if (left.name === right.name) {
                        return 0;
                    }
                    return left.name < right.name ? -1 : 1;
                }
            };
            CatalogExperiment.numberedSampleRegEx = /^(Sample|Tutorial) ([1-9][0-9]*):.*/;
            return CatalogExperiment;
        })();
        NewDrawerMenu.CatalogExperiment = CatalogExperiment;
        var Author = (function () {
            function Author() {
            }
            return Author;
        })();
        NewDrawerMenu.Author = Author;
        var Content = (function () {
            function Content() {
            }
            return Content;
        })();
        NewDrawerMenu.Content = Content;
        // Base URIs for services set up in DataLab.js. Get values from configuration files.
        NewDrawerMenu.galleryBaseUrl = "";
        NewDrawerMenu.catalogSearchBaseUri = "";
        NewDrawerMenu.catalogQueryBaseUri = "";
        NewDrawerMenu.msftAuthorId = "";
        // Class facilitating calls to catalog and search services. 
        var NewExperimentMenuFromCatalogUtil = (function () {
            function NewExperimentMenuFromCatalogUtil() {
            }
            // Example: http://catalog-int.cloudapp.net/experiments?$skip=0&$top=20
            // &$orderby=trending
            // &$filter=author/email_address eq 'azuremlt@microsoft.com' 
            // and (tags/any(t: t eq "Call center") or tags/any(t: t eq "Compression")) 
            // and (algorithms/any(a: a eq "Poisson Regression") or algorithms/any(a: a eq "Two-Class Logistic Regression")) 
            // and (modules/any(m: m eq "Initialize Model\Classification\Multiclass Logistic Regression") or modules/any(m: m eq "Data Transformation\Scale and Reduce\Clip Values"))
            // search example: http://index-int.cloudapp.net/experiments?$search='fraud'&$orderby=trending&$skip=0&$top=20 
            NewExperimentMenuFromCatalogUtil.galleryTopNSamplesFilterTemplate = function (allSamples) {
                if (allSamples === void 0) { allSamples = false; }
                return allSamples ? "$skip=0&$orderby=trending desc&$filter=author/id eq '" + NewDrawerMenu.msftAuthorId + "'" : "$skip=0&$top={0}&$orderby=trending desc&$filter=author/id eq '" + NewDrawerMenu.msftAuthorId + "'";
            };
            NewExperimentMenuFromCatalogUtil.queryCatalog = function (uri, filter) {
                if (filter === void 0) { filter = null; }
                var result = jQuery.Deferred();
                $.ajax({
                    type: 'get',
                    url: uri + "/experiments" + (filter ? ("?" + filter) : "")
                }).done(function (data) {
                    result.resolve(data);
                }).fail(function () {
                    result.reject();
                });
                return DataLab.Util.when(result.promise());
            };
            NewExperimentMenuFromCatalogUtil.getTopSamples = function (numberSamples) {
                if (numberSamples) {
                    return NewExperimentMenuFromCatalogUtil.queryCatalog(NewDrawerMenu.catalogQueryBaseUri, DataLab.Util.format(NewExperimentMenuFromCatalogUtil.galleryTopNSamplesFilterTemplate(), numberSamples.toString()));
                }
                else {
                    return NewExperimentMenuFromCatalogUtil.queryCatalog(NewDrawerMenu.catalogQueryBaseUri, NewExperimentMenuFromCatalogUtil.galleryTopNSamplesFilterTemplate(true));
                }
            };
            NewExperimentMenuFromCatalogUtil.getTopExperiments = function (numberExperiments) {
                return NewExperimentMenuFromCatalogUtil.queryCatalog(NewDrawerMenu.catalogQueryBaseUri, DataLab.Util.format(NewExperimentMenuFromCatalogUtil.galleryTopNFilterTemplate, numberExperiments.toString()));
            };
            NewExperimentMenuFromCatalogUtil.searchCatalog = function (searchTerm, numberExperiments) {
                var searchTermEncoded = encodeURIComponent(searchTerm);
                return NewExperimentMenuFromCatalogUtil.queryCatalog(NewDrawerMenu.catalogSearchBaseUri, DataLab.Util.format(NewExperimentMenuFromCatalogUtil.searchFilterTemplate, searchTermEncoded, numberExperiments.toString()));
            };
            NewExperimentMenuFromCatalogUtil.sortSamplesResult = function (samplesResult, catalogExperimentSortMethod) {
                if (samplesResult) {
                    return new CatalogQueryResult(samplesResult.total_count, samplesResult.value.sort(catalogExperimentSortMethod));
                }
            };
            NewExperimentMenuFromCatalogUtil.galleryTopNFilterTemplate = "$skip=0&$top={0}";
            NewExperimentMenuFromCatalogUtil.searchFilterTemplate = "$search='{0}'&$orderby=trending&$skip=0&$top={1}";
            return NewExperimentMenuFromCatalogUtil;
        })();
        NewDrawerMenu.NewExperimentMenuFromCatalogUtil = NewExperimentMenuFromCatalogUtil;
        var ExperimentCardViewModel = (function () {
            function ExperimentCardViewModel(isBlank, isTourExperiment, id, searchString, catalogItem) {
                var _this = this;
                this.isBlank = isBlank;
                this.isTourExperiment = isTourExperiment;
                this.id = id;
                this.title = "";
                this.isVisible = ko.computed(function () {
                    var regex = new RegExp(DataLab.Util.escapeRegExpString(searchString().trim()), "ig");
                    return regex.test(_this.title);
                });
                if (catalogItem) {
                    this.title = catalogItem.name;
                    this.packageUri = catalogItem.content.package_link;
                    this.description = catalogItem.description;
                    this.summary = catalogItem.summary;
                    this.authorName = catalogItem.author.name;
                    this.authorId = catalogItem.author.id;
                    this.authorAvatarUrl = ko.observable("/Content/Images/fxs.avatarbar.default-avatar-large.png");
                    var canLoadDummy = new Image();
                    canLoadDummy.onload = function () {
                        _this.authorAvatarUrl(catalogItem.author.avatar_url);
                    };
                    canLoadDummy.src = catalogItem.author.avatar_url;
                    this.updateDate = catalogItem.updated_at;
                    this.imgUrl = catalogItem.image_url;
                    this.entityId = catalogItem.id;
                    this.detailsUrl = "/Details/" + this.entityId;
                    this.tags = catalogItem.tags;
                    this.rating = catalogItem.rating;
                    this.commentCount = catalogItem.comment_count;
                    this.algorithms = catalogItem.algorithms;
                    this.algorithmList = this.algorithms && this.algorithms.length > 0 ? this.algorithms.join(', ') : "";
                    this.viewCount = catalogItem.view_count, this.downloadCount = catalogItem.download_count, this.isMsft = (this.authorId === NewDrawerMenu.msftAuthorId);
                    var daysAgo = Math.floor((Date.now() - Date.parse(catalogItem.updated_at)) / 86400000);
                    this.daysAgoText = daysAgo + " day" + (daysAgo > 1 ? "s" : "") + " ago";
                    this.overlayIsActive = ko.observable(false);
                    this.activateOverlay = function () {
                        _this.overlayIsActive(true);
                    };
                    this.deactivateOverlay = function () {
                        _this.overlayIsActive(false);
                    };
                    this.viewInGalleryLink = NewDrawerMenu.galleryBaseUrl + "/Details/" + this.entityId;
                }
            }
            return ExperimentCardViewModel;
        })();
        NewDrawerMenu.ExperimentCardViewModel = ExperimentCardViewModel;
        var NewExperimentCatalogMenuViewModel = (function (_super) {
            __extends(NewExperimentCatalogMenuViewModel, _super);
            function NewExperimentCatalogMenuViewModel() {
                var _this = this;
                _super.call(this);
                this.samplesQueryResults = ko.observable(null);
                this.tourExperimentTemplate = ko.observable(null);
                this.loading = ko.observable(false);
                this.searchTextInstantValue = ko.observable("");
                this.searchTextDelayedValue = this.searchTextInstantValue.extend({ rateLimit: { timeout: 300, method: "notifyWhenChangesStop" } });
                this.viewMoreSamplesMargin = ko.observable("0px");
                this.setViewMoreLabelMargin = function () {
                    var tileWidth = 230;
                    var tileMargin = 24;
                    var containerWidth = $(".experiment-card-list").width();
                    var numCardsInRow = Math.floor(containerWidth / (tileWidth + tileMargin));
                    var labelMargin = containerWidth - (numCardsInRow * (tileWidth + tileMargin)) + tileMargin / 2;
                    _this.viewMoreSamplesMargin(labelMargin + "px");
                };
                this.generateCardList = function (catalogQueryResult) {
                    var experiments = [];
                    if (catalogQueryResult && catalogQueryResult.value) {
                        catalogQueryResult.value.forEach(function (catalogItem) {
                            var menuItem = new ExperimentCardViewModel(false, false, null, _this.searchTextDelayedValue, catalogItem);
                            experiments.push(menuItem);
                        });
                    }
                    return experiments;
                };
                this.sampleExperiments = ko.computed(function () {
                    var experiments = _this.generateCardList(_this.samplesQueryResults());
                    if (_this.tourExperimentTemplate()) {
                        var tourExperiment = new ExperimentCardViewModel(false, true, _this.tourExperimentTemplate().experimentId, _this.searchTextDelayedValue);
                        experiments.unshift(tourExperiment);
                    }
                    var blankItem = new ExperimentCardViewModel(true, false, DataLabViews.ExperimentType.draftExperimentId, _this.searchTextDelayedValue);
                    experiments.unshift(blankItem);
                    return experiments;
                }, this);
                this.viewMoreSamplesLink = NewDrawerMenu.galleryBaseUrl;
                this.onExperimentSelected = function (template) {
                    Shell.UI.Drawer.close();
                    if (template.isBlank) {
                        DataLabViews.navigateToExperiment(DataLabViews.ExperimentType.draftExperimentId);
                        return;
                    }
                    if (template.isTourExperiment) {
                        Shell.Diagnostics.Telemetry.featureUsage(92 /* GuidedExperimentOpenFromDrawer */, 84 /* GuidedExperiment */, DataLab.Workspace.id);
                        ExperimentEditor.GuidedExperiment.launch();
                        return;
                    }
                    ExperimentEditor.Community.copyCommunityExperimentToThisWorkspaceAndNavigateToExperiment(template.packageUri, template.viewInGalleryLink, template.entityId);
                };
            }
            return NewExperimentCatalogMenuViewModel;
        })(DataLab.Util.Disposable);
        NewDrawerMenu.NewExperimentCatalogMenuViewModel = NewExperimentCatalogMenuViewModel;
        function NewExperimentCatalogMenuInitialize() {
            NewDrawerMenu.NewDrawerMenuDestroy();
            var viewModel = new NewExperimentCatalogMenuViewModel();
            viewModel.loading(true);
            var menuElement = $(ExperimentEditor._newExperimentMenuWithCommunityMarkup).prependTo(".fxs-drawerdetails-details-box");
            viewModel.setViewMoreLabelMargin();
            ko.applyBindings(viewModel, menuElement[0]);
            if (NewExperimentMenuFromCatalogUtil.newExperimentMenuSamplesCache && (NewDrawerMenu.NewExperimentTemplateList.guidedExperimentTemplate || !DataLab.Features.guidedExperimentEnabled())) {
                if (DataLab.Features.guidedExperimentEnabled()) {
                    viewModel.tourExperimentTemplate(NewDrawerMenu.NewExperimentTemplateList.guidedExperimentTemplate);
                }
                viewModel.samplesQueryResults(NewExperimentMenuFromCatalogUtil.newExperimentMenuSamplesCache);
                viewModel.loading(false);
                return;
            }
            var getTourSamplePromise = NewDrawerMenu.NewExperimentTemplateList.guidedExperimentTemplate ? DataLab.Util.when(NewDrawerMenu.NewExperimentTemplateList.guidedExperimentTemplate) : NewDrawerMenu.NewExperimentTemplateList.initializeTutorialTemplate(window.DataLab.Workspace);
            DataLab.Util.when(NewExperimentMenuFromCatalogUtil.getTopSamples().done(function (samplesData) {
                var sortedSamplesData = NewExperimentMenuFromCatalogUtil.sortSamplesResult(samplesData, CatalogExperiment.CatalogExperimentSampleSortFunction);
                NewExperimentMenuFromCatalogUtil.newExperimentMenuSamplesCache = sortedSamplesData;
                viewModel.samplesQueryResults(sortedSamplesData);
            }), getTourSamplePromise.done(function () {
                viewModel.tourExperimentTemplate(NewDrawerMenu.NewExperimentTemplateList.guidedExperimentTemplate);
            })).fail(function () {
            }).always(function () {
                viewModel.loading(false);
            });
        }
        NewDrawerMenu.NewExperimentCatalogMenuInitialize = NewExperimentCatalogMenuInitialize;
    })(NewDrawerMenu = ExperimentEditor.NewDrawerMenu || (ExperimentEditor.NewDrawerMenu = {}));
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var ExperimentEditor;
(function (ExperimentEditor) {
    var NewDrawerMenu;
    (function (NewDrawerMenu) {
        var NewExperimentTemplate = (function () {
            function NewExperimentTemplate(experimentId, description) {
                this.experimentId = experimentId;
                this.description = description;
                this.isGuidedExperiment = false;
                if (experimentId === DataLabViews.ExperimentType.draftExperimentId) {
                    this.experimentIcon = "/Content/SampleExperimentIcons/PlusBlankExperiment.svg";
                    this.title = this.description;
                }
                else {
                    // Guided Tour is a sample based on samples 3 and 5. It takes on the Sample 3 image for now. 
                    if (description === DataLab.Constants.GuidedExperimentDescription) {
                        this.title = this.description;
                        this.experimentIcon = "/Content/SampleExperimentIcons/GuidedExperimentShortTile.svg";
                        this.isGuidedExperiment = true;
                    }
                    else {
                        this.title = this.description.replace(/^Sample Experiment(:\s|\s-\s)/, "");
                        // Create proper icon name. Currently samples 1-7 have icons and others use a placeholder.
                        if (NewExperimentTemplate.numberedSampleRegEx.test(this.description)) {
                            var sampleNum = this.description.match(NewExperimentTemplate.numberedSampleRegEx)[1];
                            this.experimentIcon = Number(sampleNum) <= 7 ? "/Content/SampleExperimentIcons/" + "Sample" + sampleNum + ".svg" : "/Content/SampleExperimentIcons/MachineLearningSample.svg";
                        }
                        else {
                            this.experimentIcon = "/Content/SampleExperimentIcons/MachineLearningSample.svg";
                        }
                    }
                }
            }
            NewExperimentTemplate.templateSortFunction = function (left, right) {
                if (left.experimentId === right.experimentId) {
                    return 0;
                }
                // Blank experiment is first
                if (left.experimentId === DataLabViews.ExperimentType.draftExperimentId) {
                    return -1;
                }
                if (right.experimentId === DataLabViews.ExperimentType.draftExperimentId) {
                    return 1;
                }
                if (NewExperimentTemplate.numberedSampleRegEx.test(left.description) && !NewExperimentTemplate.numberedSampleRegEx.test(right.description)) {
                    return -1;
                }
                else if (!NewExperimentTemplate.numberedSampleRegEx.test(left.description) && NewExperimentTemplate.numberedSampleRegEx.test(right.description)) {
                    return 1;
                }
                else if (NewExperimentTemplate.numberedSampleRegEx.test(left.description) && NewExperimentTemplate.numberedSampleRegEx.test(right.description)) {
                    var leftNum = left.description.match(NewExperimentTemplate.numberedSampleRegEx)[1];
                    var rightNum = right.description.match(NewExperimentTemplate.numberedSampleRegEx)[1];
                    return leftNum < rightNum ? -1 : 1;
                }
                else {
                    return 0;
                }
            };
            NewExperimentTemplate.numberedSampleRegEx = /^\sSample ([1-9][0-9]*):.*/;
            return NewExperimentTemplate;
        })();
        NewDrawerMenu.NewExperimentTemplate = NewExperimentTemplate;
        var NewExperimentTemplateList = (function () {
            function NewExperimentTemplateList() {
            }
            NewExperimentTemplateList.initializeTutorialTemplate = function (workspace) {
                if (!workspace || !workspace.listExperimentsAsync) {
                    return;
                }
                var filter = { includeNonLeaf: false, includeArchived: false };
                return DataLab.Util.then(workspace.listExperimentsAsync(filter), function (experimentList) {
                    experimentList.forEach(function (experimentListItem) {
                        var experimentWorkspaceId = experimentListItem.ExperimentId.split('.')[0];
                        var templateItem = new NewExperimentTemplate(experimentListItem.ExperimentId, experimentListItem.Description);
                        if (experimentWorkspaceId && experimentWorkspaceId !== workspace.id && templateItem.isGuidedExperiment && !NewExperimentTemplateList.guidedExperimentTemplate) {
                            NewExperimentTemplateList.guidedExperimentTemplate = templateItem;
                        }
                    });
                });
            };
            NewExperimentTemplateList.initialize = function (workspace) {
                if (!workspace || !workspace.listExperimentsAsync) {
                    return;
                }
                var filter = { includeNonLeaf: false, includeArchived: false };
                return DataLab.Util.then(workspace.listExperimentsAsync(filter), function (experimentList) {
                    NewExperimentTemplateList.templateList = [];
                    if (DataLab.Trial.isWorkspaceTypeAnonymous()) {
                        experimentList = experimentList.filter(DataLab.Trial.filterSample);
                    }
                    experimentList.forEach(function (experimentListItem) {
                        var experimentWorkspaceId = experimentListItem.ExperimentId.split('.')[0];
                        if (experimentWorkspaceId && experimentWorkspaceId !== workspace.id) {
                            var templateItem = new NewExperimentTemplate(experimentListItem.ExperimentId, experimentListItem.Description);
                            if (templateItem.isGuidedExperiment) {
                                NewExperimentTemplateList.guidedExperimentTemplate = templateItem;
                            }
                            else {
                                NewExperimentTemplateList.templateList.push(templateItem);
                            }
                        }
                    });
                    NewExperimentTemplateList.templateList.sort(NewExperimentTemplate.templateSortFunction);
                    if (DataLab.Features.guidedExperimentEnabled() && NewExperimentTemplateList.guidedExperimentTemplate) {
                        NewExperimentTemplateList.templateList.unshift(NewExperimentTemplateList.guidedExperimentTemplate);
                    }
                });
            };
            NewExperimentTemplateList.templateList = [];
            NewExperimentTemplateList.guidedExperimentTemplate = null;
            return NewExperimentTemplateList;
        })();
        NewDrawerMenu.NewExperimentTemplateList = NewExperimentTemplateList;
        var NewExperimentMenuTemplateViewModel = (function () {
            function NewExperimentMenuTemplateViewModel(template, searchString) {
                var _this = this;
                this.id = template.experimentId;
                this.title = template.title;
                this.description = template.description;
                this.icon = template.experimentIcon;
                this.isBlankTemplate = template.experimentId === DataLabViews.ExperimentType.draftExperimentId;
                this.isGuidedExperiment = template.isGuidedExperiment;
                this.isVisible = ko.computed(function () {
                    var regex = new RegExp(DataLab.Util.escapeRegExpString(searchString()), "ig");
                    return regex.test(_this.title);
                });
            }
            return NewExperimentMenuTemplateViewModel;
        })();
        NewDrawerMenu.NewExperimentMenuTemplateViewModel = NewExperimentMenuTemplateViewModel;
        var NewExperimentMenuViewModel = (function (_super) {
            __extends(NewExperimentMenuViewModel, _super);
            function NewExperimentMenuViewModel() {
                var _this = this;
                _super.call(this);
                this.sampleExperimentTemplates = ko.observable([]);
                this.searchText = ko.observable("");
                this.sampleExperiments = ko.computed(function () {
                    var samples = [];
                    _this.sampleExperimentTemplates().forEach(function (template) {
                        samples.push(new NewExperimentMenuTemplateViewModel(template, _this.searchText));
                    });
                    var blankTemplate = new NewExperimentTemplate(DataLabViews.ExperimentType.draftExperimentId, DataLab.LocalizedResources.newExperimentMenuBlankExperiment);
                    samples.unshift(new NewExperimentMenuTemplateViewModel(blankTemplate, _this.searchText));
                    return samples;
                }, this);
                this.onExperimentSelected = function (template) {
                    if (template.isGuidedExperiment) {
                        Shell.Diagnostics.Telemetry.featureUsage(92 /* GuidedExperimentOpenFromDrawer */, 84 /* GuidedExperiment */, DataLab.Workspace.id);
                        ExperimentEditor.GuidedExperiment.launch();
                        return;
                    }
                    if (template.id === DataLabViews.ExperimentType.draftExperimentId) {
                        Shell.UI.Drawer.close();
                        DataLabViews.navigateToExperiment(DataLabViews.ExperimentType.draftExperimentId);
                        return;
                    }
                    Shell.UI.Drawer.close();
                    ExperimentEditor.NewDrawerMenu.openSampleAsCopy(template.id, template.description);
                };
            }
            return NewExperimentMenuViewModel;
        })(DataLab.Util.Disposable);
        NewDrawerMenu.NewExperimentMenuViewModel = NewExperimentMenuViewModel;
        function NewExperimentMenuInitialize() {
            ExperimentEditor.NewDrawerMenu.NewDrawerMenuDestroy();
            var viewModel = new NewExperimentMenuViewModel();
            var menuElement = $(ExperimentEditor._newExperimentMenuMarkup).prependTo(".fxs-drawerdetails-details-box");
            ko.applyBindings(viewModel, menuElement[0]);
            if (NewExperimentTemplateList.templateList && NewExperimentTemplateList.templateList.length > 0) {
                viewModel.sampleExperimentTemplates(NewExperimentTemplateList.templateList);
            }
            else {
                var loadTemplatesPromise = ExperimentEditor.NewDrawerMenu.NewExperimentTemplateList.initialize(window.DataLab.Workspace);
                loadTemplatesPromise.done(function () {
                    viewModel.sampleExperimentTemplates(NewExperimentTemplateList.templateList);
                }).always(function () {
                });
            }
        }
        NewDrawerMenu.NewExperimentMenuInitialize = NewExperimentMenuInitialize;
    })(NewDrawerMenu = ExperimentEditor.NewDrawerMenu || (ExperimentEditor.NewDrawerMenu = {}));
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var ExperimentEditor;
(function (ExperimentEditor) {
    var NewDrawerMenu;
    (function (NewDrawerMenu) {
        var NewModuleMenuViewModel = (function (_super) {
            __extends(NewModuleMenuViewModel, _super);
            function NewModuleMenuViewModel() {
                _super.call(this);
                this.detailMessage = ko.observable(DataLab.LocalizedResources.newModuleMenuHeader);
            }
            return NewModuleMenuViewModel;
        })(DataLab.Util.Disposable);
        NewDrawerMenu.NewModuleMenuViewModel = NewModuleMenuViewModel;
        function NewModuleMenuInitialize() {
            NewDrawerMenu.NewDrawerMenuDestroy();
            var menuElement = $(ExperimentEditor._newModuleMenuMarkup).prependTo(".fxs-drawerdetails-details-box");
            ko.applyBindings(new NewModuleMenuViewModel(), menuElement[0]);
        }
        NewDrawerMenu.NewModuleMenuInitialize = NewModuleMenuInitialize;
    })(NewDrawerMenu = ExperimentEditor.NewDrawerMenu || (ExperimentEditor.NewDrawerMenu = {}));
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
var ExperimentEditor;
(function (ExperimentEditor) {
    var StockImage = (function () {
        function StockImage() {
        }
        return StockImage;
    })();
    ExperimentEditor.StockImage = StockImage;
    var CommunityStockImages = (function () {
        function CommunityStockImages() {
        }
        CommunityStockImages.init = function (galleryStockImagesUrl) {
            CommunityStockImages.Gallery.forEach(function (imgInfo) {
                imgInfo.url = galleryStockImagesUrl + "/" + imgInfo.url;
            });
        };
        CommunityStockImages.Gallery = [
            { category: "1", url: "Gallery_StockImages_AdTargeting.svg" },
            { category: "1", url: "Gallery_StockImages_Aerospace.svg" },
            { category: "1", url: "Gallery_StockImages_Agriculture.svg" },
            { category: "1", url: "Gallery_StockImages_AnomalyDetection.svg" },
            { category: "1", url: "Gallery_StockImages_BinaryClassification.svg" },
            { category: "1", url: "Gallery_StockImages_Construction.svg" },
            { category: "1", url: "Gallery_StockImages_CustomerChurnAnalysis.svg" },
            { category: "1", url: "Gallery_StockImages_DecisionForest.svg" },
            { category: "1", url: "Gallery_StockImages_DecisionTree.svg" },
            { category: "1", url: "Gallery_StockImages_Education.svg" },
            { category: "1", url: "Gallery_StockImages_EnergyUtility.svg" },
            { category: "1", url: "Gallery_StockImages_EquipmentMonitoring.svg" },
            { category: "1", url: "Gallery_StockImages_Finance.svg" },
            { category: "1", url: "Gallery_StockImages_Forecasting.svg" },
            { category: "1", url: "Gallery_StockImages_FraudDetection.svg" },
            { category: "1", url: "Gallery_StockImages_General.svg" },
            { category: "1", url: "Gallery_StockImages_GeneralStats.svg" },
            { category: "1", url: "Gallery_StockImages_GovernmentPublicService.svg" },
            { category: "1", url: "Gallery_StockImages_Healthcare.svg" },
            { category: "1", url: "Gallery_StockImages_HypothesisTesting.svg" },
            { category: "1", url: "Gallery_StockImages_ImageRecognition.svg" },
            { category: "1", url: "Gallery_StockImages_KMeanClustering.svg" },
            { category: "1", url: "Gallery_StockImages_LinearRegression.svg" },
            { category: "1", url: "Gallery_StockImages_LogisticRegression.svg" },
            { category: "1", url: "Gallery_StockImages_Manufacturer.svg" },
            { category: "1", url: "Gallery_StockImages_MarketingAdvertising.svg" },
            { category: "1", url: "Gallery_StockImages_Media.svg" },
            { category: "1", url: "Gallery_StockImages_MulticlassClassification.svg" },
            { category: "1", url: "Gallery_StockImages_NeuralNetwork.svg" },
            { category: "1", url: "Gallery_StockImages_Pharma.svg" },
            { category: "1", url: "Gallery_StockImages_Recommendations.svg" },
            { category: "1", url: "Gallery_StockImages_Retail.svg" },
            { category: "1", url: "Gallery_StockImages_SentimentAnalysis.svg" },
            { category: "1", url: "Gallery_StockImages_SpamFiltering.svg" },
            { category: "1", url: "Gallery_StockImages_Sports.svg" },
            { category: "1", url: "Gallery_StockImages_SupportVectorMachine.svg" },
            { category: "1", url: "Gallery_StockImages_Technology.svg" },
            { category: "1", url: "Gallery_StockImages_TextAnalysis.svg" },
            { category: "1", url: "Gallery_StockImages_TravelLeisure.svg" }
        ];
        return CommunityStockImages;
    })();
    ExperimentEditor.CommunityStockImages = CommunityStockImages;
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var ExperimentEditor;
(function (ExperimentEditor) {
    var ExperimentDataFlowWalker = (function (_super) {
        __extends(ExperimentDataFlowWalker, _super);
        function ExperimentDataFlowWalker(nodes, connections) {
            var _this = this;
            _super.call(this);
            this.wsInputNodes = [];
            this.wsOutputNodes = [];
            this.portsMap = {};
            this.nodes = nodes;
            this.connections = connections;
            this.registerForDisposal(new DataLab.Util.DisposableSubscription(this.nodes.subscribe(function () {
                _this.reloadNodes();
                _this.walk();
            })), new DataLab.Util.DisposableSubscription(this.connections.subscribe(function () {
                _this.reloadConnections();
                _this.walk();
            })));
            this.reloadNodes();
            this.reloadConnections();
            this.walk();
        }
        ExperimentDataFlowWalker.prototype.walk = function () {
            var _this = this;
            // Step 1: find all ancestor nodes for ws output nodes
            var wsFlowNodes = [];
            this.wsOutputNodes.forEach(function (p) {
                _this.findReachableNodes(p, wsFlowNodes);
            });
            if (!wsFlowNodes.length) {
                wsFlowNodes = DataLab.Util.values(this.nodes());
            }
            // Step 2: prune input nodes from the ws flow
            if (wsFlowNodes.length && this.wsInputNodes.length) {
                this.wsInputNodes.forEach(function (wsInput) {
                    // ws input node may connects multiple nodes
                    var wsInputNodeOutputPort = DataLab.Util.first(wsInput.outputPorts);
                    _this.getPortMap(wsInputNodeOutputPort).forEach(function (inputPort) {
                        _this.getPortMap(inputPort).forEach(function (outputPort) {
                            // find the connected nodes other than the ws input port node
                            if (outputPort !== wsInputNodeOutputPort) {
                                _this.pruneInputNodes(outputPort.parent, wsFlowNodes, inputPort);
                            }
                        });
                    });
                });
            }
            // Step 3: mark data flow 
            DataLab.Util.forEach(this.nodes(), function (n) {
                n.belongsToExperimentFlow(!(n instanceof ExperimentEditor.WebServicePort));
                n.belongsToWebServiceFlow(wsFlowNodes.indexOf(n) >= 0);
            });
        };
        ExperimentDataFlowWalker.prototype.reloadNodes = function () {
            var _this = this;
            this.wsInputNodes = [];
            this.wsOutputNodes = [];
            DataLab.Util.forEach(this.nodes(), function (n) {
                if (n instanceof ExperimentEditor.WebServicePort) {
                    var wsPort = n;
                    if (wsPort.webServicePortNode.type === 0 /* Input */) {
                        _this.wsInputNodes.push(wsPort);
                    }
                    else {
                        _this.wsOutputNodes.push(wsPort);
                    }
                }
            });
        };
        ExperimentDataFlowWalker.prototype.reloadConnections = function () {
            var _this = this;
            this.portsMap = {};
            DataLab.Util.forEach(this.connections(), function (c) {
                _this.putPortMap(c.inputPort, c.outputPort);
                _this.putPortMap(c.outputPort, c.inputPort);
            });
        };
        ExperimentDataFlowWalker.prototype.findReachableNodes = function (node, reachableNodes) {
            var _this = this;
            if (reachableNodes.indexOf(node) < 0) {
                reachableNodes.push(node);
                DataLab.Util.forEach(node.inputPorts, function (port) {
                    DataLab.Util.forEach(_this.getPortMap(port), function (outputPort) {
                        _this.findReachableNodes(outputPort.parent, reachableNodes);
                    });
                });
            }
        };
        ExperimentDataFlowWalker.prototype.putPortMap = function (port1, port2) {
            var id = this.getPortId(port1);
            if (!this.portsMap[id]) {
                this.portsMap[id] = [port2];
            }
            else if (this.portsMap[id].indexOf(port2) < 0) {
                this.portsMap[id].push(port2);
            }
            else {
            }
        };
        ExperimentDataFlowWalker.prototype.pruneInputNodes = function (inputNode, wsFlowNodes, wsInputPort) {
            var _this = this;
            var index = wsFlowNodes.indexOf(inputNode);
            if (index < 0) {
                return;
            }
            var outputConnectionCount = 0;
            DataLab.Util.forEach(inputNode.outputPorts, function (outputPort) {
                _this.getPortMap(outputPort).forEach(function (inputPort) {
                    if (inputPort !== wsInputPort && wsFlowNodes.indexOf(inputPort.parent) >= 0) {
                        outputConnectionCount++;
                    }
                });
            });
            if (!outputConnectionCount) {
                wsFlowNodes.splice(index, 1);
                DataLab.Util.forEach(inputNode.inputPorts, function (inputPort) {
                    _this.getPortMap(inputPort).forEach(function (outputPort) {
                        _this.pruneInputNodes(outputPort.parent, wsFlowNodes, wsInputPort);
                    });
                });
            }
        };
        ExperimentDataFlowWalker.prototype.getPortMap = function (port) {
            var id = this.getPortId(port);
            if (!this.portsMap[id]) {
                return [];
            }
            else {
                return this.portsMap[id];
            }
        };
        ExperimentDataFlowWalker.prototype.getPortId = function (port) {
            return port.portModel.parent.id + ":" + port.portModel.name;
        };
        return ExperimentDataFlowWalker;
    })(DataLab.Util.Disposable);
    ExperimentEditor.ExperimentDataFlowWalker = ExperimentDataFlowWalker;
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
/// <reference path="../palettecontrol/paletteviewmodel.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var ExperimentEditor;
(function (ExperimentEditor) {
    var ExperimentWebServiceConstants = (function () {
        function ExperimentWebServiceConstants() {
        }
        ExperimentWebServiceConstants.InputPortId = "input";
        ExperimentWebServiceConstants.OutputPortId = "output";
        return ExperimentWebServiceConstants;
    })();
    ExperimentEditor.ExperimentWebServiceConstants = ExperimentWebServiceConstants;
    var ExperimentWebServiceViewModel = (function (_super) {
        __extends(ExperimentWebServiceViewModel, _super);
        function ExperimentWebServiceViewModel() {
            _super.call(this);
            this.inputPalleteItem = new ExperimentEditor.PaletteItem(DataLab.Model.WebServicePortType[0 /* Input */], "Input", "Web Service Input Port", ExperimentEditor.Constants.EntityType.WebServicePort);
            this.outputPalleteItem = new ExperimentEditor.PaletteItem(DataLab.Model.WebServicePortType[1 /* Output */], "Output", "Web Service Output Port", ExperimentEditor.Constants.EntityType.WebServicePort);
            this.webServiceCategory = new ExperimentEditor.PaletteCategory(DataLab.Constants.ResourceCategory.WebService);
            this.webServiceCategory.items.push(this.inputPalleteItem);
            this.webServiceCategory.items.push(this.outputPalleteItem);
        }
        return ExperimentWebServiceViewModel;
    })(DataLab.Util.Disposable);
    ExperimentEditor.ExperimentWebServiceViewModel = ExperimentWebServiceViewModel;
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="CommunityStockImages.ts" />
var ExperimentEditor;
(function (ExperimentEditor) {
    var ImageSelectorViewModel = (function () {
        function ImageSelectorViewModel() {
            var _this = this;
            this.imageUploadViewModel = new ExperimentEditor.ImageUploadViewModel(0.5, { maxWidth: 960, maxHeight: 640 });
            this.selectedStockImgUrl = ko.observable("");
            this.stockImages = [];
            this.PlaceHolderImageURL = "/Content/Images/image-placeholder.svg";
            this.selectedImageThumbnailSrc = ko.computed(function () {
                if (_this.imageUploadViewModel.finalImageContent())
                    return _this.imageUploadViewModel.finalImageContent().dataUrl;
                else
                    return _this.selectedStockImgUrl() ? _this.selectedStockImgUrl() : _this.PlaceHolderImageURL;
            });
            this.hasImage = ko.computed(function () {
                return Boolean(_this.selectedImageThumbnailSrc() != _this.PlaceHolderImageURL);
            });
            this.selectStockImage = function (data, event) {
                _this.selectedStockImgUrl(data.url);
                $(".imgGallery").removeClass("imgGallerySelected");
                $(event.currentTarget).addClass("imgGallerySelected");
                // user has selected stock image => discard whatever was uploaded
                _this.imageUploadViewModel.clearImage();
            };
            this.fillStockImages();
        }
        ImageSelectorViewModel.prototype.fillStockImages = function () {
            var _this = this;
            ExperimentEditor.CommunityStockImages.Gallery.forEach(function (imgInfo) {
                _this.stockImages.push(imgInfo);
            });
        };
        return ImageSelectorViewModel;
    })();
    ExperimentEditor.ImageSelectorViewModel = ImageSelectorViewModel;
})(ExperimentEditor || (ExperimentEditor = {}));

var ExperimentEditor;
(function (ExperimentEditor) {
    var ImagesUtil = DataLab.Util.Images;
    var ImageUploadViewModel = (function () {
        function ImageUploadViewModel(maxSizeInMegabytes, imageResizeOptions) {
            var _this = this;
            this.maxSizeInMegabytes = maxSizeInMegabytes;
            this.imageResizeOptions = imageResizeOptions;
            this.finalImageContent = ko.observable();
            this.selectedImage = ko.observable();
            this.errorMessage = ko.observable();
            this.isProcessingSelectedImage = ko.observable(false);
            this.selectedImage.subscribe(function (file) {
                if (file) {
                    _this.processSelectedImage(file);
                }
            });
        }
        ImageUploadViewModel.prototype.clearImage = function () {
            this.finalImageContent(null);
            this.selectedImage(null);
            this.errorMessage(null);
        };
        ImageUploadViewModel.prototype.processSelectedImage = function (file) {
            var _this = this;
            this.isProcessingSelectedImage(true);
            this.finalImageContent(null);
            this.errorMessage(null);
            return ImagesUtil.resizeFileIfNecessary(file, this.imageResizeOptions, this.maxSizeInMegabytes).done(function (imageContent) {
                _this.finalImageContent(imageContent);
            }).fail(function (error) {
                _this.errorMessage(error.message);
            }).always(function (result) {
                _this.isProcessingSelectedImage(false);
            });
        };
        return ImageUploadViewModel;
    })();
    ExperimentEditor.ImageUploadViewModel = ImageUploadViewModel;
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
var ExperimentEditor;
(function (ExperimentEditor) {
    var ProjectExperimentViewModel = (function () {
        function ProjectExperimentViewModel(experimentId, role, project) {
            var _this = this;
            this.experimentId = ko.observable(null);
            this.experimentId(experimentId);
            this.role = role;
            this.roleName = ko.computed(function () {
                switch (_this.role) {
                    case DataLab.DataContract.ExperimentRole.Training:
                        return DataLab.LocalizedResources.trainingExperimentTabContent;
                    case DataLab.DataContract.ExperimentRole.Scoring:
                        return DataLab.LocalizedResources.scoringExperimentTabContent;
                    default:
                        return DataLab.LocalizedResources.computingExperimentTabContent;
                }
            });
            this.active = ko.computed(function () {
                return _this.experimentId() === project.experimentId();
            });
        }
        ProjectExperimentViewModel.prototype.navigate = function () {
            if (!this.active()) {
                Shell.Diagnostics.Telemetry.featureUsage(77 /* SwitchExperiment */, 72 /* ScoringExperiment */, null, this.experimentId(), null, this.role);
                Shell.UI.Navigation.navigate({
                    extension: DataLabViews.experimentExtensionName,
                    type: DataLabViews.ExperimentType.name,
                    name: this.experimentId()
                });
            }
        };
        return ProjectExperimentViewModel;
    })();
    ExperimentEditor.ProjectExperimentViewModel = ProjectExperimentViewModel;
    var ProjectViewModel = (function () {
        function ProjectViewModel(workspace, getExperiment) {
            var _this = this;
            this.experimentVMs = ko.observableArray();
            this.modified = ko.observable(false);
            this.loaded = ko.observable(false);
            if (!workspace) {
                throw new Error("ProjectViewModel:constructor workspace can't be null");
            }
            this.workspace = workspace;
            this.experiment = ko.computed(getExperiment);
            this.experimentId = ko.computed(function () {
                return _this.experiment().experimentId() || _this.experiment().parentExperimentId;
            });
            this.hasScoringGraph = ko.computed(function () {
                return !!_this.findExperiment(function (vm) { return vm.role === DataLab.DataContract.ExperimentRole.Scoring; });
            });
            this.init();
        }
        // This method is called when experiment is opened and view model is recreated
        // The experiment can be existing one or new created one, use the experimentId to distinct
        ProjectViewModel.prototype.init = function () {
            var _this = this;
            this.reset();
            // If it's draft experiment, skip fetching project
            if (!this.experimentId()) {
                return;
            }
            // Otherwise, fetch project
            this.workspace.listProjects(this.experimentId()).done(function (projects) {
                if (projects && projects.length && projects[0].Experiments && projects[0].Experiments.length) {
                    // If the experiment has project, update the experiments list
                    _this.experimentVMs.removeAll();
                    _this.projectId = projects[0].ProjectId;
                    projects[0].Experiments.forEach(function (experiment) {
                        var experimentVM = new ProjectExperimentViewModel(experiment.ExperimentId, experiment.Role, _this);
                        _this.experimentVMs.push(experimentVM);
                    });
                    _this.loaded(true);
                }
            });
        };
        ProjectViewModel.prototype.reset = function () {
            this.loaded(false);
            this.modified(false);
            this.projectId = null;
            this.experimentVMs.removeAll();
        };
        ProjectViewModel.prototype.addExperiment = function (id, role) {
            var experimentVM = new ProjectExperimentViewModel(id, role, this);
            this.experimentVMs.push(experimentVM);
            this.modified(true);
            return experimentVM;
        };
        ProjectViewModel.prototype.save = function () {
            var _this = this;
            if (!this.modified()) {
                return;
            }
            var experiments = this.experimentVMs().map(function (vm) {
                return {
                    ExperimentId: vm.experimentId(),
                    Role: vm.role
                };
            });
            if (this.projectId) {
                return this.workspace.updateProject(this.projectId, {
                    Experiments: experiments
                }).done(function (project) {
                    _this.modified(false);
                });
            }
            else {
                return this.workspace.createProject({
                    Experiments: experiments
                }).done(function (project) {
                    _this.projectId = project.ProjectId;
                    _this.modified(false);
                });
            }
        };
        ProjectViewModel.prototype.findExperiment = function (filter) {
            var vms = this.experimentVMs();
            for (var i = 0; i < vms.length; i++) {
                var vm = vms[i];
                if (filter(vm)) {
                    return vm;
                }
            }
            return null;
        };
        return ProjectViewModel;
    })();
    ExperimentEditor.ProjectViewModel = ProjectViewModel;
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
/// <reference path="../../View/Bubble/PositionLocators.ts"/>
/// <reference path="../../View/Bubble/BubbleViewModel.ts"/>
var ExperimentEditor;
(function (ExperimentEditor) {
    var GuidedTour = (function () {
        function GuidedTour() {
        }
        // Checks whether the drawer animation has completed based on the height of the drawer
        GuidedTour.drawerAnimationDone = function () {
            var dfd = $.Deferred();
            var currentHeight = $(".fxs-drawer-inner").height();
            var interval = window.setInterval(function () {
                var newHeight = $(".fxs-drawer-inner").height();
                if (newHeight === currentHeight) {
                    // The height of the drawer did not change within last 100ms; consider the animation done
                    window.clearInterval(interval);
                    dfd.resolve();
                }
                else {
                    currentHeight = newHeight;
                }
            }, 100);
            return DataLab.Util.when(dfd.promise());
        };
        GuidedTour.waitFor = function (conditionCallback, completedCallback, maxWaitInMs) {
            var waitPerInterval = 200;
            var totalIntervals = Math.ceil(maxWaitInMs / waitPerInterval);
            var interval = window.setInterval(function () {
                var completedSuccessfully = conditionCallback();
                if (completedSuccessfully || totalIntervals-- < 0) {
                    window.clearInterval(interval);
                    completedCallback(completedSuccessfully);
                }
            }, waitPerInterval);
        };
        // Waits for the blankExperimentCard to become visible
        GuidedTour.blankExperimentCardVisible = function () {
            var dfd = $.Deferred();
            // 1: Open the drawer
            Shell.UI.Drawer.open();
            ExperimentEditor.GuidedTour.waitFor(function () {
                var drawerIsOpening = $(".fxs-drawer-open").length > 0;
                if (drawerIsOpening) {
                    // 2: Wait for the drawer to open
                    ExperimentEditor.GuidedTour.drawerAnimationDone().done(function () {
                        // 3: Make sure that the blankExperimentCard is visible
                        ExperimentEditor.GuidedTour.waitFor(function () {
                            return $(ExperimentEditor.GuidedTour.getBlankExperimentSelector()).length > 0;
                        }, function (success) {
                            /* Note that there aren't any rejects in this logic.  We want to get the user to progress in guided tour even if we couldn't find some element*/
                            dfd.resolve();
                        }, 20000); // wait up to 20s for the studio to load the samples from the service
                    });
                }
                return drawerIsOpening;
            }, function (success) {
                if (!success) {
                    /* If opening the drawer wasn't sucessful, resolve the deferred so that user can go to next step in the guided tour,
                     * In case of success, the inner condition will resolve the deferred.
                     */
                    dfd.resolve();
                }
            }, 5000);
            return DataLab.Util.when(dfd.promise());
        };
        GuidedTour.closeDrawer = function () {
            var dfd = $.Deferred();
            // 1: Open the drawer
            Shell.UI.Drawer.close();
            window.setTimeout(function () {
                // Wait for the drawer animation to complete
                ExperimentEditor.GuidedTour.drawerAnimationDone().done(function () {
                    dfd.resolve();
                });
            }, 100);
            return DataLab.Util.when(dfd.promise());
        };
        GuidedTour.getBlankExperimentSelector = function () {
            return DataLab.Features.galleryInPlusNewInterimEnabled() ? ".blankExperimentCard:visible" : ".experiment-tile:first";
        };
        GuidedTour.getOption = function () {
            var _this = this;
            var options = new ExperimentEditor.Bubble.Options("GuidedTour");
            options.dismissOnScroll = false;
            options.dismissOnResize = false;
            options.dismissOnClick = false;
            options.alwaysShow = true;
            /* New button */
            var step1 = options.addStepByJquerySelector(".fxs-drawertaskbar-newbutton", DataLab.LocalizedResources.guidedTourNewButtonTitle, DataLab.LocalizedResources.guidedTourNewButtonContent, 415, 150);
            step1.beforeLoadHandlerAsync = function (bubbleViewModel) {
                _this.logGuidedTourStep(1);
                return ExperimentEditor.GuidedTour.closeDrawer();
            };
            /* Experiment card */
            var step2 = options.addStepByJquerySelector(ExperimentEditor.GuidedTour.getBlankExperimentSelector(), DataLab.LocalizedResources.guidedTourDrawerTitle, DataLab.LocalizedResources.guidedTourDrawerContent);
            // Close the drawer and navigate to blank experiment for step 3
            step2.beforeLoadHandlerAsync = function (bubbleViewModel) {
                _this.logGuidedTourStep(2);
                return ExperimentEditor.GuidedTour.blankExperimentCardVisible();
            };
            /* Main nav */
            var step3 = options.addStepByJquerySelector("#fxshell-navpane", DataLab.LocalizedResources.guidedTourMainNavTitle, DataLab.LocalizedResources.guidedTourMainNavContent);
            step3.beforeLoadHandlerAsync = function (bubbleViewModel) {
                _this.logGuidedTourStep(3);
                var dfd = $.Deferred();
                Shell.UI.Drawer.close();
                if (cdm.currentContext.viewPath === "ViewExperiment") {
                    dfd.resolve();
                }
                else {
                    // Navigate to the draft/blank experiment
                    DataLabViews.navigateToExperiment("Draft");
                    $(document).one("experimentLoaded", function () {
                        var navpaneCollapsed = false;
                        ExperimentEditor.GuidedTour.waitFor(function () {
                            navpaneCollapsed = $(".fxshell-navpane-collapsed").length !== 0;
                            if (navpaneCollapsed) {
                                dfd.resolve();
                            }
                            return navpaneCollapsed;
                        }, function (success) {
                            dfd.resolve();
                        }, 1000);
                    });
                }
                return DataLab.Util.when(dfd.promise());
            };
            /* Modules */
            var step4 = options.addStepByJquerySelector(".xe-utilityPanelRoot", DataLab.LocalizedResources.guidedTourModulesPaneTitle, DataLab.LocalizedResources.guidedTourModulesPaneContent);
            this.addLoggingLoadHandlerToStep(step4, 4);
            /* Experiment Editor */
            var step5 = options.addStepByJquerySelector(".experimentEditorRoot", DataLab.LocalizedResources.guidedTourCanvasTitle, DataLab.LocalizedResources.guidedTourCanvasContent);
            this.addLoggingLoadHandlerToStep(step5, 5);
            /* Properties pane */
            var step6 = options.addStepByJquerySelector(".propertyEditorContainer", DataLab.LocalizedResources.guidedTourPropertiesPaneTitle, DataLab.LocalizedResources.guidedTourPropertiesPaneContent);
            this.addLoggingLoadHandlerToStep(step6, 6);
            /* Chat window */
            if ($(".chat-support").is(':visible')) {
                var step7 = options.addStepByJquerySelector(".chat-support", DataLab.LocalizedResources.guidedTourChatWindowTitle, DataLab.LocalizedResources.guidedTourChatWindowContent);
                this.addLoggingLoadHandlerToStep(step7, 7);
            }
            /* Commands */
            var content = DataLab.LocalizedResources.guidedTourCommandsContent;
            if (DataLab.Features.guidedExperimentEnabled()) {
                content += [
                    "<br/>",
                    "<span class='bubble-content-small'>",
                    DataLab.LocalizedResources.guidedTourNavigateToExperimentContent,
                    "<a class='start-guided-experiment'>",
                    DataLab.LocalizedResources.guidedTourClickHere,
                    "</a>",
                    "</span>"
                ].join('');
            }
            var step8 = options.addStepByJquerySelector(".fxs-drawercommands-commands-global", DataLab.LocalizedResources.guidedTourCommandsTitle, content);
            this.addLoggingLoadHandlerToStep(step8, 8);
            return options;
        };
        GuidedTour.logGuidedTourStep = function (stepNumber) {
            Shell.Diagnostics.Telemetry.featureUsage(DataLab.Constants.FeatureId["GuidedTourStep" + stepNumber], 83 /* GuidedTour */, DataLab.Workspace.id);
        };
        GuidedTour.addLoggingLoadHandlerToStep = function (step, stepNumber) {
            var _this = this;
            step.beforeLoadHandlerAsync = function (bubbleViewModel) {
                _this.logGuidedTourStep(stepNumber);
                return DataLab.Util.when(null);
            };
        };
        GuidedTour.launchGuidedExperiment = function () {
            ExperimentEditor.Bubble.dismiss();
            Shell.Diagnostics.Telemetry.featureUsage(93 /* GuidedExperimentOpenFromGuidedTour */, 83 /* GuidedTour */, DataLab.Workspace.id);
            ExperimentEditor.GuidedExperiment.launch();
        };
        GuidedTour.launch = function () {
            /*
             * Hack: no straight forward way of doing this.  When the welcome dialog is closed, it opens the
             * drawer. Due the animation delays, it is not optimal to just close the drawer.
             * The following code sets a global variable so that the open/close handler doesn't
             * expand the drawer
             */
            // Close all dialogs
            window.__guidedTourActive = true;
            var dialog = $(".fx-dialog");
            if (dialog.get(0) && dialog.is(":data(fx-fxDialog)")) {
                dialog.fxDialog("close", document.createEvent("CustomEvent"));
                delete window.__guidedTourActive;
            }
            var isOnViewExperimentPage = cdm.currentContext.viewPath === "ViewExperiment";
            window.setTimeout(function () {
                DataLab.Util.then(ExperimentEditor.Bubble.showAsync(ExperimentEditor.GuidedTour.getOption()), function (instance) {
                    if (!isOnViewExperimentPage) {
                        // If the user is not on the view experiment page, open the drawer when guided tour is finished. 
                        var subscription = instance.overlayVisible.subscribe(function () {
                            Shell.UI.Drawer.open();
                            subscription.dispose();
                        });
                    }
                });
            });
            if (DataLab.Features.guidedExperimentEnabled()) {
                var selector = "#bubble-container .start-guided-experiment";
                $("body").off("click", selector, ExperimentEditor.GuidedTour.launchGuidedExperiment).on("click", selector, ExperimentEditor.GuidedTour.launchGuidedExperiment);
            }
        };
        return GuidedTour;
    })();
    ExperimentEditor.GuidedTour = GuidedTour;
    var GuidedExperiment = (function () {
        function GuidedExperiment() {
        }
        GuidedExperiment.getOption = function () {
            var _this = this;
            var titleContent = DataLab.LocalizedResources.guidedExperimentExperimentDescriptionContent;
            var datasetContent = "<img class=\"guidedExperimentDatasetGif\" src=\"/Libraries/Images/GuidedExperiment/DragAnimation.gif\"/>" + "<span>" + DataLab.LocalizedResources.guidedExperimentDatasetContent + "</span>";
            var transformationContent = DataLab.LocalizedResources.guidedExperimentTransformationsContent;
            var splitContent = DataLab.LocalizedResources.guidedExperimentSplitContent;
            var machineLearningModulesContent = DataLab.LocalizedResources.guidedExperimentMachineLearningModulesContent;
            var runContent = DataLab.LocalizedResources.guidedExperimentRunContent;
            var visualizeContent = "<img class=\"guidedExperimentDatasetGif\" src=\"/Libraries/Images/GuidedExperiment/Visualize.gif\"/>" + "<div class=\"guidedExperimentContentText\">" + DataLab.LocalizedResources.guidedExperimentVisualizeContent + "</div>";
            if (cdm.currentActiveItem instanceof DataLabViews.ExperimentView) {
                if (cdm.getActiveItem().xeControlContainer.xeControl.initOnly.zoomHelper.fitExperimentWithoutAnimation) {
                    cdm.getActiveItem().xeControlContainer.xeControl.initOnly.zoomHelper.fitExperimentWithoutAnimation();
                }
                var experiment = cdm.currentActiveItem.xeViewModel.experiment;
                var cleanMissingDataModuleFamilyId = "506153734175476c4f62416c57734963.d2c5ca2f732341a39b7eda917c99f0c4", cleanMissingDataModuleSelector = "";
                var projectColumnModuleFamilyId = "506153734175476c4f62416c57734963.1ec722fab6234e26a44ea50c6d726223", projectColumnModuleSelector = "";
                var splitModuleFamilyId = "506153734175476c4f62416c57734963.70530644c97a4ab685f788bf30a8be5f", splitModuleSelector = "";
                var classifierModuleFamilyId = "506153734175476c4f62416c57734963.e3c522f853d948298ea45c6a6b75330c", classifierModuleSelector = "";
                var trainModelModuleFamilyId = "506153734175476c4f62416c57734963.5cc7053eaa30450d96c0dae4be720977", trainModelModuleSelector = "";
                var scoreModuleFamilyId = "506153734175476c4f62416c57734963.401b4f92e7244d5abe81d5b0ff9bdb33", scoreModuleSelector = "";
                var adultCensusIncomeDatasetId = "506153734175476c4f62416c57734963.72eb09476cd64015b9d1d2129b4a0ecc", adultCensusIncomeDatasetSelector = "";
                experiment.nodes.forEach(function (node) {
                    if (node instanceof DataLab.Model.ModuleNode) {
                        var moduleNode = node;
                        switch (moduleNode.module_.familyId) {
                            case cleanMissingDataModuleFamilyId:
                                cleanMissingDataModuleSelector = ExperimentEditor.GuidedExperiment.getNodeSelector(moduleNode.id);
                                break;
                            case projectColumnModuleFamilyId:
                                projectColumnModuleSelector = ExperimentEditor.GuidedExperiment.getNodeSelector(moduleNode.id);
                                break;
                            case splitModuleFamilyId:
                                splitModuleSelector = ExperimentEditor.GuidedExperiment.getNodeSelector(moduleNode.id);
                                break;
                            case classifierModuleFamilyId:
                                classifierModuleSelector = ExperimentEditor.GuidedExperiment.getNodeSelector(moduleNode.id);
                                break;
                            case trainModelModuleFamilyId:
                                trainModelModuleSelector = ExperimentEditor.GuidedExperiment.getNodeSelector(moduleNode.id);
                                break;
                            case scoreModuleFamilyId:
                                scoreModuleSelector = ExperimentEditor.GuidedExperiment.getNodeSelector(moduleNode.id);
                                break;
                            default:
                                break;
                        }
                    }
                    else if (node instanceof DataLab.Model.DatasetNode) {
                        var datasetNode = node;
                        switch (datasetNode.dataset.familyId) {
                            case adultCensusIncomeDatasetId:
                                adultCensusIncomeDatasetSelector = ExperimentEditor.GuidedExperiment.getNodeSelector(datasetNode.id);
                                break;
                            default:
                                break;
                        }
                    }
                });
                GuidedExperiment.options = new ExperimentEditor.Bubble.Options("GuidedExperiment");
                GuidedExperiment.options.dismissOnScroll = false;
                GuidedExperiment.options.dismissOnResize = false;
                GuidedExperiment.options.dismissOnClick = false;
                GuidedExperiment.options.alwaysShow = true;
                var steps = [
                    GuidedExperiment.options.addStepByJquerySelector(".experiment-description", DataLab.LocalizedResources.guidedExperimentExperimentDescriptionTitle, titleContent, 400, 150),
                    GuidedExperiment.options.addStepByJquerySelector(adultCensusIncomeDatasetSelector, DataLab.LocalizedResources.guidedExperimentThisIsADatasetTitle, datasetContent, 400, 380),
                    GuidedExperiment.options.addStepByJquerySelector([cleanMissingDataModuleSelector, projectColumnModuleSelector], DataLab.LocalizedResources.guidedExperimentTransformationsTitle, transformationContent, 400, 170),
                    GuidedExperiment.options.addStepByJquerySelector(splitModuleSelector, DataLab.LocalizedResources.guidedExperimentSplitTitle, splitContent, 400, 170),
                    GuidedExperiment.options.addStepByJquerySelector([classifierModuleSelector, trainModelModuleSelector], DataLab.LocalizedResources.guidedExperimentMachineLearningModulesTitle, machineLearningModulesContent, 410, 200),
                    GuidedExperiment.options.addStepByJquerySelector(".fxs-command-action-play", DataLab.LocalizedResources.guidedExperimentRunTitle, runContent, 400, 150),
                    GuidedExperiment.options.addStepByJquerySelector(scoreModuleSelector, DataLab.LocalizedResources.guidedExperimentVisualizeTitle, visualizeContent, 400, 380)
                ];
                steps.forEach(function (step, stepNumber) {
                    _this.addLoggingLoadHandlerToStep(step, stepNumber + 1);
                });
                return GuidedExperiment.options;
            }
            else {
                return null;
            }
        };
        GuidedExperiment.logGuidedExperimentStep = function (stepNumber) {
            Shell.Diagnostics.Telemetry.featureUsage(DataLab.Constants.FeatureId["GuidedExperimentStep" + stepNumber], 84 /* GuidedExperiment */, DataLab.Workspace.id);
        };
        GuidedExperiment.addLoggingLoadHandlerToStep = function (step, stepNumber) {
            var _this = this;
            step.beforeLoadHandlerAsync = function (bubbleViewModel) {
                _this.logGuidedExperimentStep(stepNumber);
                return DataLab.Util.when(null);
            };
        };
        GuidedExperiment.getNodeSelector = function (nodeId) {
            return "rect[id^=\"node-" + nodeId + "\"]";
        };
        GuidedExperiment.launch = function () {
            if (!DataLab.Features.guidedExperimentEnabled()) {
                return;
            }
            Shell.UI.Drawer.close();
            ExperimentEditor.NewDrawerMenu.openSampleAsCopy(ExperimentEditor.NewDrawerMenu.NewExperimentTemplateList.guidedExperimentTemplate.experimentId, ExperimentEditor.NewDrawerMenu.NewExperimentTemplateList.guidedExperimentTemplate.description, function () {
                $(document).one("experimentLoaded", function () {
                    var navpaneCollapsedInterval = window.setInterval(function () {
                        if ($(".fxshell-navpane-collapsed").get(0)) {
                            window.clearInterval(navpaneCollapsedInterval);
                            //make sure the drawer is not up.
                            if (!$(".fxs-drawer-open").get(0)) {
                                ExperimentEditor.Bubble.showAsync(ExperimentEditor.GuidedExperiment.getOption());
                            }
                        }
                    }, 100);
                });
            });
        };
        return GuidedExperiment;
    })();
    ExperimentEditor.GuidedExperiment = GuidedExperiment;
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
var ExperimentEditor;
(function (ExperimentEditor) {
    // Base class for long running async operation
    var AsyncOperation = (function () {
        function AsyncOperation() {
            this.isRunning = ko.observable(false);
            this.addNotification = function (notification) {
                Shell.UI.Notifications.add(notification);
            };
            this.removeNotification = function (notification) {
                Shell.UI.Notifications.remove(notification);
            };
        }
        AsyncOperation.prototype.runAsync = function () {
            var _this = this;
            this.isRunning(true);
            try {
                return this.runInternalAsync().always(function () {
                    _this.isRunning(false);
                }).done(function () {
                    _this.progressSuccess();
                }).fail(function (error) {
                    var message = (error && error.message) ? error.message : "";
                    _this.progressError(message);
                });
            }
            catch (error) {
                // Unexpected exception
                var message = (error && error.message) ? error.message : "";
                this.progressError(message);
                DataLab.Log.error(message);
                return this.reject(error);
            }
        };
        AsyncOperation.prototype.runInternalAsync = function () {
            throw new Error("The method is abstract.");
        };
        AsyncOperation.prototype.reject = function (error) {
            return $.Deferred().reject(error).promise();
        };
        AsyncOperation.prototype.startProgress = function (title) {
            this.progress = new Shell.UI.Notifications.Progress(title, "active", true);
            this.step = null;
            this.progress.setActions([new Shell.UI.Notifications.Buttons.close()]);
            this.addNotification(this.progress);
        };
        AsyncOperation.prototype.addStep = function (title) {
            if (this.step) {
                this.step.setStatus("success");
            }
            if (this.progress) {
                this.step = this.progress.addStep(title, "active");
            }
        };
        AsyncOperation.prototype.updateCurrentStep = function (title) {
            if (this.step) {
                this.step.setTitle(title);
            }
        };
        AsyncOperation.prototype.progressSuccess = function () {
            if (this.step) {
                this.step.setStatus("success");
            }
            if (this.progress) {
                this.progress.setStatus("success");
            }
        };
        AsyncOperation.prototype.progressError = function (errorMessage) {
            if (this.progress) {
                this.progress.setStatus("error");
                if (this.step) {
                    this.step.setStatus("error");
                    this.step.setDetailsText(errorMessage);
                }
                else {
                    this.progress.setDetailsText(errorMessage);
                }
            }
        };
        return AsyncOperation;
    })();
    ExperimentEditor.AsyncOperation = AsyncOperation;
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
/// <reference path="AsyncOperation.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var ExperimentEditor;
(function (ExperimentEditor) {
    var Util = DataLab.Util;
    var Model = DataLab.Model;
    var AddWebServicePortAnimationOperation = (function (_super) {
        __extends(AddWebServicePortAnimationOperation, _super);
        function AddWebServicePortAnimationOperation() {
            _super.apply(this, arguments);
            this.webServiceInputPorts = [];
            this.webServiceOutputPorts = [];
            this.webServiceInputPortNodes = [];
            this.webServiceOutputPortNodes = [];
        }
        AddWebServicePortAnimationOperation.prototype.initialize = function (experiment, workspace) {
            this.experiment = experiment;
            this.workspace = workspace;
        };
        AddWebServicePortAnimationOperation.prototype.runInternalAsync = function () {
            var _this = this;
            var animation = new ExperimentEditor.MoveNodesAnimationOperation();
            animation.initialize(Util.values(this.experiment.nodes()));
            Util.forEach(this.webServiceInputPorts, function (port) {
                if (port) {
                    var inputNode = _this.experiment.addWebServicePort(0 /* Input */, port.parent.x(), port.parent.y(), null, _this.workspace.applicationCache.dataTypeRegistry, port);
                    animation.AddMovement({
                        node: inputNode,
                        direction: 0 /* up */
                    });
                    _this.webServiceInputPortNodes.push(inputNode);
                }
            });
            Util.forEach(this.webServiceOutputPorts, function (port) {
                if (port) {
                    var outputNode = _this.experiment.addWebServicePort(1 /* Output */, port.parent.x(), port.parent.y(), null, _this.workspace.applicationCache.dataTypeRegistry, port);
                    animation.AddMovement({
                        node: outputNode,
                        direction: 1 /* down */
                    });
                    _this.webServiceOutputPortNodes.push(outputNode);
                }
            });
            return animation.runAsync();
        };
        return AddWebServicePortAnimationOperation;
    })(ExperimentEditor.AsyncOperation);
    ExperimentEditor.AddWebServicePortAnimationOperation = AddWebServicePortAnimationOperation;
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
/// <reference path="AsyncOperation.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var ExperimentEditor;
(function (ExperimentEditor) {
    var AnimationContext = (function () {
        function AnimationContext() {
            this.context = {};
        }
        return AnimationContext;
    })();
    ExperimentEditor.AnimationContext = AnimationContext;
    var AnimationOperation = (function (_super) {
        __extends(AnimationOperation, _super);
        function AnimationOperation() {
            _super.apply(this, arguments);
            this.totalSteps = 50;
            this.interval = 10;
            this.currentStep = 0;
            this.animations = [];
        }
        AnimationOperation.prototype.runInternalAsync = function () {
            var _this = this;
            var dfd = $.Deferred();
            if (this.animations.length) {
                this.intervalId = setInterval(function () {
                    _this.currentStep++;
                    _this.animations.forEach(function (a) { return a.stepFunc(_this.currentStep, a.context); });
                    if (_this.currentStep >= _this.totalSteps) {
                        clearInterval(_this.intervalId);
                        dfd.resolve();
                    }
                }, 10);
            }
            else {
                dfd.resolve();
            }
            return dfd.promise();
        };
        return AnimationOperation;
    })(ExperimentEditor.AsyncOperation);
    ExperimentEditor.AnimationOperation = AnimationOperation;
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var ExperimentEditor;
(function (ExperimentEditor) {
    var Vertex = (function () {
        function Vertex(name) {
            this.x = 0;
            this.y = 0;
            this.pos = 0;
            this.isDummy = false;
            this.inEdges = [];
            this.outEdges = [];
            this.name = name;
        }
        Vertex.prototype.sortEdges = function () {
            this.inEdges.sort(function (a, b) {
                return a.compare(b, false);
            });
            this.outEdges.sort(function (a, b) {
                return a.compare(b, true);
            });
        };
        Vertex.prototype.switch = function (target) {
            if (target.layer !== this.layer) {
                return;
            }
            this.layer.vectors.splice(this.pos, 1, target);
            target.layer.vectors.splice(target.pos, 1, this);
            var temp = this.pos;
            this.pos = target.pos;
            target.pos = temp;
        };
        Vertex.prototype.getEdges = function (dir) {
            return dir ? this.outEdges : this.inEdges;
        };
        Vertex.prototype.getSortedEdges = function (dir) {
            return this.getEdges(dir).sort(function (a, b) {
                return a.compare(b, dir);
            });
        };
        Vertex.prototype.getConnectedVertexes = function (dir) {
            return this.getEdges(dir).map(function (e) { return dir ? e.to : e.from; });
        };
        Vertex.prototype.toString = function () {
            var strs = [];
            strs.push("name: " + this.name);
            strs.push("pos: " + this.pos);
            strs.push("x, y: " + this.x + ", " + this.y);
            strs.push("inEdges: " + this.inEdges.map(function (e) { return "{" + e.from.pos + "," + e.fromPortPos + "}"; }).join(", "));
            strs.push("outEdges: " + this.outEdges.map(function (e) { return "{" + e.to.pos + "," + e.toPortPos + "}"; }).join(", "));
            return strs.join("; ");
        };
        return Vertex;
    })();
    ExperimentEditor.Vertex = Vertex;
    var Edge = (function () {
        function Edge() {
            this.fromPortPos = 0;
            this.toPortPos = 0;
        }
        Edge.prototype.compare = function (e, top) {
            if (this.from === e.from && this.fromPortPos === e.fromPortPos && this.to === e.to && this.toPortPos === e.toPortPos) {
                return 0;
            }
            if (top) {
                if (this.from.pos > e.from.pos || this.fromPortPos > e.fromPortPos || this.to.pos > e.to.pos || this.toPortPos > e.toPortPos) {
                    return 1;
                }
                return -1;
            }
            else {
                if (this.to.pos > e.to.pos || this.toPortPos > e.toPortPos || this.from.pos > e.from.pos || this.fromPortPos > e.fromPortPos) {
                    return 1;
                }
                return -1;
            }
        };
        Edge.prototype.compareEnd = function (e, top) {
            if (top) {
                if (this.from.pos > e.from.pos || this.fromPortPos > e.fromPortPos) {
                    return 1;
                }
                else if (this.from.pos === e.from.pos && this.fromPortPos === e.fromPortPos) {
                    return 0;
                }
                return -1;
            }
            else {
                if (this.to.pos > e.to.pos || this.toPortPos > e.toPortPos) {
                    return 1;
                }
                else if (this.to.pos === e.to.pos && this.toPortPos === e.toPortPos) {
                    return 0;
                }
                return -1;
            }
        };
        return Edge;
    })();
    ExperimentEditor.Edge = Edge;
    var Layer = (function () {
        function Layer(level) {
            this.vectors = [];
            this.level = 0;
            this.level = level;
        }
        Layer.prototype.init = function () {
            var factor = 1.0 / this.vectors.length;
            this.vectors.forEach(function (v, i) {
                v.pos = i;
                v.rank = i * factor;
            });
        };
        Layer.prototype.pushVertex = function (v) {
            if (v.layer) {
                v.layer.removeVertex(v);
            }
            this.vectors.push(v);
            v.layer = this;
        };
        Layer.prototype.removeVertex = function (v) {
            DataLab.Util.removeElementFromArray(this.vectors, v);
            v.layer = null;
        };
        Layer.prototype.sortByRank = function () {
            this.vectors.sort(function (a, b) {
                return a.rank - b.rank;
            });
            this.vectors.forEach(function (v, i) {
                v.pos = i;
            });
        };
        Layer.prototype.reorder = function (dir) {
            if (this.countCrosses(dir) > 0) {
                this.reorderByRank(dir);
                this.reorderIfReduceCross(dir);
                this.init();
            }
        };
        Layer.prototype.reorderByRank = function (dir) {
            var rankChanged = false;
            this.vectors.forEach(function (v1) {
                var connected = v1.getConnectedVertexes(!dir);
                if (connected.length > 0) {
                    v1.rank = connected.map(function (v2) { return v2.rank; }).reduce(function (a, b) {
                        return a + b;
                    }) / connected.length;
                    rankChanged = true;
                }
            });
            rankChanged && this.sortByRank();
        };
        Layer.prototype.countCrosses = function (dir) {
            var totalCrosses = 0;
            var temp = [];
            this.vectors.forEach(function (v) {
                var edges = dir ? v.outEdges : v.inEdges;
                edges.sort(function (a, b) { return a.compare(b, dir); });
                edges.forEach(function (e) {
                    var i = temp.length - 1;
                    for (; i >= 0; i--) {
                        if (temp[i].compare(e, !dir) <= 0) {
                            break;
                        }
                    }
                    temp.splice(i + 1, 0, e);
                    totalCrosses += temp.length - i - 2;
                });
            });
            return totalCrosses;
        };
        Layer.prototype.reorderIfReduceCross = function (dir) {
            var totalCount = 0;
            var length = this.vectors.length;
            for (var i = 1; i < length; i++) {
                var prev = this.vectors[i - 1];
                var cur = this.vectors[i];
                var prevEdges = prev.getEdges(dir);
                var curEdges = cur.getEdges(dir);
                var crossCount = 0;
                var sameCount = 0;
                curEdges.forEach(function (e1) {
                    prevEdges.forEach(function (e2) {
                        var compare = e2.compareEnd(e1, !dir);
                        compare > 0 && crossCount++;
                        compare === 0 && sameCount++;
                    });
                });
                var nonCrossCount = prevEdges.length - crossCount - sameCount;
                if (nonCrossCount < crossCount) {
                    prev.switch(cur);
                    var temp = crossCount;
                    crossCount = nonCrossCount;
                    nonCrossCount = temp;
                }
                totalCount += crossCount;
            }
            return totalCount;
        };
        return Layer;
    })();
    ExperimentEditor.Layer = Layer;
    var LayoutGraph = (function () {
        function LayoutGraph() {
            this.V = [];
            this.E = [];
            this.L = [];
        }
        // Setup layers by longest path to root
        LayoutGraph.prototype.setupLayers = function () {
            var _this = this;
            var roots = this.V.filter(function (v) {
                return !v.inEdges.length;
            });
            var layer = this.tryGetLayer(0);
            roots.forEach(function (v) {
                layer.pushVertex(v);
            });
            var nodes = [];
            while (roots.length) {
                roots.forEach(function (v) {
                    var level = v.layer.level + 1;
                    v.outEdges.forEach(function (e) {
                        if (e.to.layer && e.to.layer.level >= level) {
                            return;
                        }
                        nodes.push(e.to);
                        layer = _this.tryGetLayer(level);
                        layer.pushVertex(e.to);
                    });
                });
                roots = nodes;
                nodes = [];
            }
        };
        LayoutGraph.prototype.setupGraph = function (nodes) {
            var _this = this;
            if (!nodes) {
                nodes = [];
            }
            var nodeVertexMap = {};
            nodes.forEach(function (node) {
                var v = new Vertex();
                v.graphNode = node;
                v.x = node.x();
                v.y = node.y();
                _this.V.push(v);
                nodeVertexMap[node.graphNode.id] = v;
            });
            nodes.forEach(function (node) {
                if (!node.outputPorts) {
                    return;
                }
                var fromPortPos = 0;
                DataLab.Util.forEach(node.outputPorts, function (outputPort) {
                    var connectedPorts = outputPort.portModel.connectedPorts();
                    if (connectedPorts) {
                        var toPortPos = 0;
                        DataLab.Util.forEach(connectedPorts, function (inputPort) {
                            var e = new Edge();
                            e.from = nodeVertexMap[node.graphNode.id];
                            e.to = nodeVertexMap[inputPort.parent.id];
                            e.fromPortPos = fromPortPos;
                            e.toPortPos = toPortPos;
                            _this.pushEdge(e);
                            toPortPos++;
                        });
                    }
                    fromPortPos++;
                });
            });
        };
        LayoutGraph.prototype.init = function () {
            this.L.forEach(function (l) {
                l.init();
            });
        };
        LayoutGraph.prototype.reorder = function (dir) {
            this.L.forEach(function (l) {
                l.reorder(dir);
            });
        };
        LayoutGraph.prototype.tryGetLayer = function (level) {
            if (level > this.L.length) {
                throw new Error("Cannot skip layers when adding layer");
            }
            if (level === this.L.length) {
                this.L.push(new Layer(level));
            }
            return this.L[level];
        };
        // Create dummy vertex which connects edges across multiple layers
        LayoutGraph.prototype.setupDummies = function () {
            var _this = this;
            var longEdges = [];
            this.E.forEach(function (e) {
                var from = e.from;
                var fromPortPos = e.fromPortPos;
                for (var l = e.from.layer.level + 1; l < e.to.layer.level; l++) {
                    var dummy = new Vertex();
                    dummy.isDummy = true;
                    var layer = _this.tryGetLayer(l);
                    layer.pushVertex(dummy);
                    var dummyEdge = new Edge();
                    dummyEdge.from = from;
                    dummyEdge.fromPortPos = fromPortPos;
                    dummyEdge.to = dummy;
                    dummyEdge.toPortPos = 0;
                    _this.pushEdge(dummyEdge);
                    from = dummy;
                    fromPortPos = 0;
                }
                if (from !== e.from) {
                    var dummyEdge = new Edge();
                    dummyEdge.from = from;
                    dummyEdge.fromPortPos = fromPortPos;
                    dummyEdge.to = e.to;
                    dummyEdge.toPortPos = e.toPortPos;
                    longEdges.push(e);
                }
            });
            longEdges.forEach(function (e) {
                _this.removeEdge(e);
            });
        };
        LayoutGraph.prototype.pushEdge = function (e) {
            this.E.push(e);
            e.from.outEdges.push(e);
            e.to.inEdges.push(e);
        };
        LayoutGraph.prototype.removeEdge = function (e) {
            DataLab.Util.removeElementFromArray(this.E, e);
            DataLab.Util.removeElementFromArray(e.from.outEdges, e);
            DataLab.Util.removeElementFromArray(e.to.inEdges, e);
        };
        LayoutGraph.prototype.setPositions = function (xDistance, yDistance) {
            this.L.forEach(function (l) {
                l.vectors.forEach(function (v) {
                    v.x = v.pos * xDistance;
                    v.y = l.level * yDistance;
                });
            });
        };
        LayoutGraph.prototype.setPositionsToGraphNode = function () {
            var animationOperation = new ExperimentEditor.AnimationOperation();
            this.V.forEach(function (v) {
                if (v.graphNode) {
                    animationOperation.animations.push({
                        context: {
                            graphNode: v.graphNode,
                            dx: (v.x - v.graphNode.x()) / animationOperation.totalSteps,
                            dy: (v.y - v.graphNode.y()) / animationOperation.totalSteps
                        },
                        stepFunc: function (step, context) {
                            var graphNode = context.graphNode;
                            graphNode.x(graphNode.x() + context.dx);
                            graphNode.y(graphNode.y() + context.dy);
                        }
                    });
                }
            });
            return animationOperation.runAsync();
        };
        LayoutGraph.removeFromArray = function (item, array) {
            var index = array.indexOf(item);
            if (index >= 0) {
                array.splice(index);
            }
        };
        return LayoutGraph;
    })();
    ExperimentEditor.LayoutGraph = LayoutGraph;
    var AutoLayoutOperation = (function (_super) {
        __extends(AutoLayoutOperation, _super);
        function AutoLayoutOperation(nodes) {
            _super.call(this);
            this.XDistance = 375;
            this.YDistance = 120;
            this.graph = new LayoutGraph();
            this.graph.setupGraph(nodes);
        }
        AutoLayoutOperation.prototype.runInternalAsync = function () {
            this.graph.setupLayers();
            this.graph.setupDummies();
            this.graph.init();
            this.graph.reorder(true);
            this.graph.reorder(false);
            this.graph.setPositions(this.XDistance, this.YDistance);
            return this.graph.setPositionsToGraphNode();
        };
        return AutoLayoutOperation;
    })(ExperimentEditor.AsyncOperation);
    ExperimentEditor.AutoLayoutOperation = AutoLayoutOperation;
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
/// <reference path="../../view/bubble/bubble.ts" />
/// <reference path="../palettecontrol/paletteviewmodel.ts" />
var ExperimentEditor;
(function (ExperimentEditor) {
    var Util = DataLab.Util;
    var LocalizedResources = DataLab.LocalizedResources;
    var GuideTours = (function () {
        function GuideTours() {
        }
        GuideTours.showPrepareWebServiceTourAsync = function (portNode, paletteVM, webServiceCategoryName) {
            var options = new ExperimentEditor.Bubble.Options("PrepareWebServiceTour");
            if (portNode) {
                options.addStepByGraphNode(portNode, LocalizedResources.createScoreTutorialInputOutputNodesTitle, LocalizedResources.createScoreTutorialInputOutputNodesContent);
            }
            options.addStepByJquerySelector("#displayFlowSwitch .displayFlowSwitchIcon", LocalizedResources.createScoreTutorialDataFlowTitle, LocalizedResources.createScoreTutorialDataFlowContent);
            paletteVM.applyPaletteSearch("");
            paletteVM.categories().forEach(function (cat) {
                if (cat.name() === webServiceCategoryName) {
                    cat.isCollapsed(false);
                }
                else {
                    cat.isCollapsed(true);
                }
            });
            options.addStepByJquerySelector(function () {
                var webServiceMenuText = $("div.paletteCategory-title:contains('" + webServiceCategoryName + "')");
                if (!webServiceMenuText.length) {
                    return null;
                }
                return webServiceMenuText.first().parent().parent().parent().parent();
            }, LocalizedResources.createScoreTutorialAddInputOutputNodesTitle, LocalizedResources.createScoreTutorialAddInputOutputNodesContent);
            options.addStepByJquerySelector(function () {
                var runExperimentCommandDiv = $("div.fxs-command-text").filter(function (index, element) {
                    return $(element).text() === LocalizedResources.commandsRun;
                });
                if (!runExperimentCommandDiv.length) {
                    return;
                }
                return runExperimentCommandDiv.first().parent().parent();
            }, LocalizedResources.runExperimentCommandTourTitle, LocalizedResources.runExperimentCommandTourContent);
            return ExperimentEditor.Bubble.showAsync(options);
        };
        GuideTours.showCreatingScoringExperimentTourAsync = function (portNode, paletteVM, webServiceCategoryName, trainedModelNode) {
            var options = new ExperimentEditor.Bubble.Options("CreateScoringGraphTour");
            options.addStepByJquerySelector("ul.project-experiments-tabs > li.active", LocalizedResources.createScoreTutorialNewExperimentTitle, LocalizedResources.createScoreTutorialNewExperimentContent);
            if (portNode) {
                options.addStepByGraphNode(portNode, LocalizedResources.createScoreTutorialInputOutputNodesTitle, LocalizedResources.createScoreTutorialInputOutputNodesContent);
            }
            options.addStepByJquerySelector("#displayFlowSwitch .displayFlowSwitchIcon", LocalizedResources.createScoreTutorialDataFlowTitle, LocalizedResources.createScoreTutorialDataFlowContent);
            paletteVM.applyPaletteSearch("");
            paletteVM.categories().forEach(function (cat) {
                if (cat.name() === webServiceCategoryName) {
                    cat.isCollapsed(false);
                }
                else {
                    cat.isCollapsed(true);
                }
            });
            options.addStepByJquerySelector(function () {
                var webServiceMenuText = $("div.paletteCategory-title:contains('" + webServiceCategoryName + "')");
                if (!webServiceMenuText.length) {
                    return null;
                }
                return webServiceMenuText.first().parent().parent().parent().parent();
            }, LocalizedResources.createScoreTutorialAddInputOutputNodesTitle, LocalizedResources.createScoreTutorialAddInputOutputNodesContent);
            options.addStepByGraphNode(trainedModelNode, LocalizedResources.createScoreTutorialTrainedModelTitle, LocalizedResources.createScoreTutorialTrainedModelContent);
            options.addStepByJquerySelector(function () {
                var runExperimentCommandDiv = $("div.fxs-command-text").filter(function (index, element) {
                    return $(element).text() === LocalizedResources.commandsRun;
                });
                if (!runExperimentCommandDiv.length) {
                    return;
                }
                return runExperimentCommandDiv.first().parent().parent();
            }, LocalizedResources.runExperimentCommandTourTitle, LocalizedResources.runExperimentCommandTourContent);
            return ExperimentEditor.Bubble.showAsync(options);
        };
        GuideTours.showCreatingScoringGraphCommandTour = function () {
            var options = new ExperimentEditor.Bubble.Options("CreateScoringGraphCommandTour");
            options.showOverlay = false;
            options.dismissOnClick = true;
            options.addStepByJquerySelector(function () {
                var createScoringGraphCommandDiv = $("div.fxs-command-text").filter(function (index, element) {
                    return $(element).text() === LocalizedResources.createScoreGraphCommandTitle;
                });
                if (!createScoringGraphCommandDiv.length) {
                    return;
                }
                return createScoringGraphCommandDiv.first().parent().parent();
            }, LocalizedResources.createScoreCommandTourTitle, LocalizedResources.createScoreCommandTourContent);
            ExperimentEditor.Bubble.showAsync(options);
        };
        GuideTours.showUpdatingScoringGraphCommandTour = function () {
            var options = new ExperimentEditor.Bubble.Options("UpdateScoringGraphCommandTour");
            options.showOverlay = false;
            options.dismissOnClick = true;
            options.addStepByJquerySelector(function () {
                var updateScoringGraphCommandDiv = $("div.fxs-command-text").filter(function (index, element) {
                    return $(element).text() === LocalizedResources.updateScoreGraphCommandTitle;
                });
                if (!updateScoringGraphCommandDiv.length) {
                    return;
                }
                return updateScoringGraphCommandDiv.first().parent().parent();
            }, LocalizedResources.updateScoreCommandTourTitle, LocalizedResources.updateScoreCommandTourContent);
            ExperimentEditor.Bubble.showAsync(options);
        };
        GuideTours.showPublishWebServiceCommandTour = function () {
            var options = new ExperimentEditor.Bubble.Options("PublishWebServiceCommandTour");
            options.showOverlay = false;
            options.dismissOnClick = true;
            options.addStepByJquerySelector(function () {
                var publishWSCommandDiv = $("div.fxs-command-text").filter(function (index, element) {
                    return $(element).text() === LocalizedResources.publishWebServiceCommandTitle;
                });
                if (!publishWSCommandDiv.length) {
                    return;
                }
                return publishWSCommandDiv.first().parent().parent();
            }, LocalizedResources.publishWebServiceCommandTourTitle, LocalizedResources.publishWebServiceCommandTourContent);
            ExperimentEditor.Bubble.showAsync(options);
        };
        GuideTours.showMultipleTrainModuleSelectionTour = function () {
            var options = new ExperimentEditor.Bubble.Options("MultipleTrainModuleSelectionTour");
            options.addStepAtCenter(LocalizedResources.multipleTrainModuleSelectionTourTitle, Util.format(LocalizedResources.multipleTrainModuleSelectionTourContent, "<br><img src='/Libraries/Images/GuidedScoring/train_module_snapshot.png'/><br>"), 400, 300);
            options.alwaysShow = true;
            options.dismissOnScroll = false;
            ExperimentEditor.Bubble.showAsync(options);
        };
        return GuideTours;
    })();
    ExperimentEditor.GuideTours = GuideTours;
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
var ExperimentEditor;
(function (ExperimentEditor) {
    var Util = DataLab.Util;
    var Model = DataLab.Model;
    var ModelHelpers = (function () {
        function ModelHelpers() {
        }
        ModelHelpers.isDesiredModuleNode = function (node, category) {
            if (node instanceof Model.ModuleNode) {
                var moduleNode = node;
                return moduleNode.module_.category === category;
            }
            return false;
        };
        ModelHelpers.isScoreModuleNode = function (node) {
            return ModelHelpers.isDesiredModuleNode(node, DataLab.Constants.ResourceCategory.ScoreModule);
        };
        ModelHelpers.isApplyTransformModuleNode = function (node) {
            if (node instanceof Model.ModuleNode) {
                var moduleNode = node;
                return moduleNode.module_.familyId.indexOf(DataLab.Constants.WellKnownResource.ApplyTransformationFamilyId) > -1;
            }
            return false;
        };
        ModelHelpers.isModuleFamily = function (module_, familyId) {
            return module_.familyId ? module_.familyId.indexOf(familyId) > -1 : false;
        };
        ModelHelpers.isModuleCategory = function (module_, category) {
            return module_.category === category;
        };
        ModelHelpers.formatResourceName = function (name) {
            var result = name ? name.replace(/[\/\\#\?:]/g, "").trim() : "";
            if (result.length > 110) {
                result = result.substr(0, 110);
            }
            return result;
        };
        ModelHelpers.getUniqueResourceName = function (resourceCache, name) {
            var names = Util.map(resourceCache.items(), function (tm) {
                return tm.name().toLowerCase();
            });
            if (names.indexOf(name.toLowerCase()) < 0) {
                return name;
            }
            var i = 1;
            var newName = name + " " + i.toString();
            while (names.indexOf(newName.toLowerCase()) > -1) {
                newName = name + " " + (++i).toString();
            }
            return newName;
        };
        ModelHelpers.parseModelFamilyId = function (familyId) {
            if (familyId) {
                var parts = familyId.split('.');
                if (parts && parts.length > 1) {
                    return parts[1];
                }
            }
            return null;
        };
        ModelHelpers.parseExperimentFamilyId = function (experimentId) {
            if (!experimentId) {
                throw new Error("Experiment id cannot be null");
            }
            var segments = experimentId.split(".");
            if (segments.length < 3) {
                throw new Error("invalid experiment id: " + experimentId);
            }
            return segments[2];
        };
        ModelHelpers.searchTrainingModuleInTrainingGraph = function (experiment, moduleNodeId) {
            var trainModuleNodes = ModelHelpers.getTrainingModuleNodes(experiment);
            if (!trainModuleNodes.length) {
                // TODO: user removed train module, we should warn user that we can't find train module any more.
                return null;
            }
            var foundTrainingModuleNode = null;
            trainModuleNodes.forEach(function (tmNode) {
                if (tmNode.id === moduleNodeId) {
                    foundTrainingModuleNode = tmNode;
                    return false;
                }
                return true;
            });
            return foundTrainingModuleNode;
        };
        ModelHelpers.searchTrainedModelInScoreGraph = function (experiment, experimentFamilyId) {
            var trainedModelNodes = Util.values(experiment.trainedModels);
            var foundTrainedModelNode = null;
            trainedModelNodes.forEach(function (tmNode) {
                if (tmNode.trainedModel.experimentId.indexOf(experimentFamilyId) > 0) {
                    foundTrainedModelNode = tmNode;
                    return false;
                }
                return true;
            });
            return foundTrainedModelNode;
        };
        ModelHelpers.searchTransformNodeInScoreGraph = function (experiment, experimentFamilyId, transformResource) {
            var transformNodes = Util.values(experiment.transformModules);
            return Util.first(transformNodes, function (node) {
                if (node) {
                    if (node.transform.experimentId.indexOf(experimentFamilyId) > 0 && node.transform.name() === transformResource.name()) {
                        return true;
                    }
                }
            }, null);
        };
        ModelHelpers.searchSavedTrainedModel = function (trainedModelCache, experimentFamilyId, moduleId, outputName) {
            return Util.first(trainedModelCache.items(), function (tm) {
                if (tm.experimentId && tm.experimentId.indexOf(experimentFamilyId) > 0) {
                    return (tm.moduleId === moduleId && tm.outputName === outputName);
                }
                else {
                    return false;
                }
            }, null);
        };
        ModelHelpers.getTrainingModuleNodes = function (experiment) {
            var trainModuleNodes = [];
            Util.forEach(experiment.nodes(), function (node) {
                if (node instanceof Model.ModuleNode) {
                    var moduleNode = node;
                    if (moduleNode.module_.category === DataLab.Constants.ResourceCategory.TrainModule) {
                        trainModuleNodes.push(moduleNode);
                    }
                }
            });
            return trainModuleNodes;
        };
        return ModelHelpers;
    })();
    ExperimentEditor.ModelHelpers = ModelHelpers;
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../../Global.ts" />
/// <reference path="../modelhelpers.ts" />
/// <reference path="../ModelHelpers.ts" />
// Interface
var ExperimentEditor;
(function (ExperimentEditor) {
    var Context = (function () {
        function Context() {
            this.workspace = null;
            this.inputNode = null;
            this.outputNode = null;
            this.trainedModelNode = null;
            this.experimentEditorViewModel = null;
            this.asyncOperation = null;
        }
        return Context;
    })();
    ExperimentEditor.Context = Context;
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../../Global.ts" />
/// <reference path="../modelhelpers.ts" />
/// <reference path="Context.ts" />

/// <reference path="../../../Global.ts" />
/// <reference path="../modelhelpers.ts" />
/// <reference path="../asyncoperation.ts" />
/// <reference path="../guidetours.ts" />
/// <reference path="IExperimentProcessor.ts" />
/// <reference path="Context.ts" />
/// <reference path="../AnimationOperation.ts" />
var ExperimentEditor;
(function (ExperimentEditor) {
    var Util = DataLab.Util;
    var TrainedModelExperimentProcessorBase = (function () {
        function TrainedModelExperimentProcessorBase(workspace) {
            this.trainedModelPort = null;
            this.webServiceInputPorts = [];
            this.webServiceOutputPorts = [];
            this.scoreNodes = [];
            this.workspace = workspace;
            this.trainedModelCache = workspace.trainedModelCache;
        }
        // Create trained model from training graph
        TrainedModelExperimentProcessorBase.prototype.preProcess = function (trainingExperiment, context) {
            var _this = this;
            return this.searchTrainingModuleInGraph(trainingExperiment, context).then(function (trainModuleNode) {
                return _this.createTrainedModelAsync(trainingExperiment, trainModuleNode, context);
            }).then(function (trainedModel) {
                _this.trainedModel = trainedModel;
            });
        };
        TrainedModelExperimentProcessorBase.prototype.process = function (scoringExperiment, context) {
            return Util.when("");
        };
        TrainedModelExperimentProcessorBase.prototype.postProcess = function (scoringExperiment, context) {
            return Util.when("");
        };
        TrainedModelExperimentProcessorBase.prototype.searchTrainingModuleInGraph = function (experiment, context) {
            this.trainModuleNode = null;
            var trainModuleNodes = ExperimentEditor.ModelHelpers.getTrainingModuleNodes(experiment);
            if (!trainModuleNodes.length) {
                return context.asyncOperation.reject(new Error("No train module found in the training experiment."));
            }
            // If there is more than one train module in the graph, check selection
            // If no or more than one train modules selected, prompt user to select one train module to continue
            // If only one is selected, continue
            if (trainModuleNodes.length > 1) {
                var selectedNodes = Util.values(context.experimentEditorViewModel.selectionManager.selectedGraphNodes());
                if (selectedNodes && selectedNodes.length === 1 && trainModuleNodes.indexOf(selectedNodes[0].graphNode) >= 0) {
                    this.trainModuleNode = selectedNodes[0].graphNode;
                }
                else {
                    ExperimentEditor.GuideTours.showMultipleTrainModuleSelectionTour();
                    return context.asyncOperation.reject(new Error("There are more than one train module in the training experiment. Please select one and retry."));
                }
            }
            else if (trainModuleNodes.length === 1) {
                this.trainModuleNode = trainModuleNodes[0];
            }
            return Util.when(this.trainModuleNode);
        };
        TrainedModelExperimentProcessorBase.prototype.createTrainedModelAsync = function (experiment, trainModuleNode, context) {
            var trainedModelPorts = Util.filter(trainModuleNode.outputPorts, function (port) { return port.isTrainModulePort(); });
            if (!trainedModelPorts || !trainedModelPorts.length) {
                return context.asyncOperation.reject(new Error("No outputs found as trained model."));
            }
            // Take the first port which can be output trained model
            this.trainedModelPort = trainedModelPorts[0];
            var currentExperimentFamilyId = ExperimentEditor.ModelHelpers.parseExperimentFamilyId(experiment.experimentId());
            var trainedModel = ExperimentEditor.ModelHelpers.searchSavedTrainedModel(this.trainedModelCache, currentExperimentFamilyId, this.trainedModelPort.parent.id, this.trainedModelPort.name);
            // use graph name [trained model] as trained model name
            if (trainedModel) {
                return this.saveTrainedModel(this.workspace, this.trainedModelPort, trainedModel.name(), ExperimentEditor.ModelHelpers.parseModelFamilyId(trainedModel.familyId), trainedModel.description());
            }
            else {
                var trainedModelName = ExperimentEditor.ModelHelpers.getUniqueResourceName(this.trainedModelCache, ExperimentEditor.ModelHelpers.formatResourceName(experiment.description()) + " [trained model]");
                return this.saveTrainedModel(this.workspace, this.trainedModelPort, trainedModelName);
            }
        };
        TrainedModelExperimentProcessorBase.prototype.saveTrainedModel = function (workspace, port, name, familyId, description) {
            return new ExperimentEditor.SaveTrainedModelOperation(workspace, port, name, familyId, description, false).runAsync();
        };
        return TrainedModelExperimentProcessorBase;
    })();
    ExperimentEditor.TrainedModelExperimentProcessorBase = TrainedModelExperimentProcessorBase;
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../../Global.ts" />
/// <reference path="../modelhelpers.ts" />
/// <reference path="../asyncoperation.ts" />
/// <reference path="../guidetours.ts" />
/// <reference path="IExperimentProcessor.ts" />
/// <reference path="TrainedModelExperimentProcessorBase.ts" />
/// <reference path="Context.ts" />
/// <reference path="../AnimationOperation.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var ExperimentEditor;
(function (ExperimentEditor) {
    var Util = DataLab.Util;
    var Model = DataLab.Model;
    var TrainedModelExperimentCreateProcessor = (function (_super) {
        __extends(TrainedModelExperimentCreateProcessor, _super);
        function TrainedModelExperimentCreateProcessor(workspace) {
            _super.call(this, workspace);
        }
        // Create trained model from training graph
        TrainedModelExperimentCreateProcessor.prototype.preProcess = function (trainingExperiment, context) {
            return _super.prototype.preProcess.call(this, trainingExperiment, context);
        };
        // 1. Add trained model in to new graph
        // 2. Add or reuse existing score module
        // 3. Connect trained model to score module
        // 4. Copy train module dataset inputs to score module inputs if neccesary
        // 5. Traverse the graph to mark up nodes which connecting to score module and mark them as preserved nodes
        TrainedModelExperimentCreateProcessor.prototype.process = function (scoringExperiment, context) {
            var _this = this;
            return this.searchTrainingModuleInGraph(scoringExperiment, context).then(function (trainModuleNode) {
                context.trainedModelNode = _this.addTrainedModelToGraph(scoringExperiment, _this.trainedModel, context);
                // animate create scoring node
                return _this.findOrCreateScoreModuleNodeAsync(scoringExperiment, context);
            }).then(function (scoreModuleNode) {
                _this.scoreModuleNode = scoreModuleNode;
            });
        };
        // 1. Remove nodes that has not been tranversed
        // 2. Set publish input and output
        TrainedModelExperimentCreateProcessor.prototype.postProcess = function (scoringExperiment, context) {
            var _this = this;
            return this.removeUnusedNodesAsync(scoringExperiment, this.scoreModuleNode).then(function () {
                // animate add ports
                return _this.addWebServiceInputOutputPortsAsync(scoringExperiment, context);
            });
        };
        TrainedModelExperimentCreateProcessor.prototype.addTrainedModelToGraph = function (experiment, tm, context) {
            return context.experimentEditorViewModel.addTrainedModelById(tm.id, this.trainModuleNode.x(), this.trainModuleNode.y()).graphNode;
        };
        TrainedModelExperimentCreateProcessor.prototype.findOrCreateScoreModuleNodeAsync = function (experiment, context) {
            var _this = this;
            var dfd = $.Deferred();
            var scoreModuleNode;
            if (this.trainedModelPort) {
                var foundPort = Util.first(this.trainedModelPort.connectedNonWebServicePorts(), function (port) { return ExperimentEditor.ModelHelpers.isScoreModuleNode(port.parent); }, null);
                scoreModuleNode = foundPort ? foundPort.parent : null;
            }
            if (!scoreModuleNode) {
                var scoreModule = Util.first(this.workspace.moduleCache.items(), function (m) {
                    return m.familyId.indexOf(DataLab.Constants.WellKnownResource.ScoreGenericModuleFamilyId) > -1;
                });
                scoreModuleNode = context.experimentEditorViewModel.addModuleById(scoreModule.id, this.trainedModelPort.parent.x(), this.trainedModelPort.parent.y()).graphNode;
                var animation = new ExperimentEditor.MoveNodesAnimationOperation();
                animation.initialize(Util.values(experiment.nodes()));
                animation.AddMovement({
                    node: scoreModuleNode,
                    direction: 1 /* down */
                });
                animation.runAsync().done(function () {
                    var scoreDatasetPort = Util.first(scoreModuleNode.inputPorts, function (port) { return port.isDatasetDataType(); });
                    var trainDatasetPort = Util.first(_this.trainModuleNode.inputPorts, function (port) { return port.isDatasetDataType(); }, null);
                    if (trainDatasetPort) {
                        var datasetSourcePort = trainDatasetPort.connectedOutputPort;
                        if (datasetSourcePort) {
                            datasetSourcePort.connectTo(scoreDatasetPort);
                        }
                    }
                    dfd.resolve(scoreModuleNode);
                });
            }
            else {
                dfd.resolve(scoreModuleNode);
            }
            return dfd.then(function (scoreModuleNode) {
                // Disconnect score module from train module and connect it with trained model node
                var scoreInputPort = Util.first(scoreModuleNode.inputPorts);
                var trainedModelOutputPort = Util.first(context.trainedModelNode.outputPorts);
                scoreInputPort.disconnect(scoreInputPort.connectedNonWebServicePorts());
                scoreInputPort.connectTo(trainedModelOutputPort);
                return scoreModuleNode;
            }).promise();
        };
        TrainedModelExperimentCreateProcessor.prototype.removeUnusedNodesAsync = function (experiment, scoreModuleNode) {
            var _this = this;
            this.traverseScoreGraphNodes(scoreModuleNode);
            var nodesToRemove = Util.filter(experiment.nodes(), function (node) { return _this.scoreNodes.indexOf(node) < 0; });
            var animationOperation = new ExperimentEditor.AnimationOperation();
            nodesToRemove.forEach(function (n) {
                animationOperation.animations.push({
                    context: {
                        graphNode: n,
                        dx: (_this.trainModuleNode.x() - n.x()) / animationOperation.totalSteps,
                        dy: (_this.trainModuleNode.y() - n.y()) / animationOperation.totalSteps,
                    },
                    stepFunc: function (step, context) {
                        var graphNode = context.graphNode;
                        graphNode.x(graphNode.x() + context.dx);
                        graphNode.y(graphNode.y() + context.dy);
                    }
                });
            });
            return animationOperation.runAsync().done(function () {
                nodesToRemove.forEach(function (n) { return n.remove(); });
            });
        };
        // Tranverse nodes that will be kept in score graph
        // All the other nodes that has not been traversed will be removed from the graph
        TrainedModelExperimentCreateProcessor.prototype.traverseScoreGraphNodes = function (node) {
            var _this = this;
            if (!node) {
                return;
            }
            // Mark first dataset output of score module to be web service output port
            if (ExperimentEditor.ModelHelpers.isScoreModuleNode(node) && !this.webServiceOutputPorts.length) {
                var datasetOutputPort = Util.first(node.outputPorts, function (port) { return port.isDatasetDataType(); }, null);
                if (datasetOutputPort) {
                    this.webServiceOutputPorts.push(datasetOutputPort);
                }
            }
            if (this.scoreNodes.indexOf(node) < 0) {
                this.scoreNodes.push(node);
            }
            Util.forEach(node.inputPorts, function (port) {
                var connectedOutputPort = port.connectedOutputPort;
                if (!connectedOutputPort || !connectedOutputPort.parent) {
                    return;
                }
                // Set web service input the connected node is the root of the branch
                if (Util.isEmpty(connectedOutputPort.parent.inputPorts) && port.isDatasetDataType()) {
                    if (!_this.webServiceInputPorts.length) {
                        _this.webServiceInputPorts.push(port);
                    }
                }
                if (connectedOutputPort.parent instanceof Model.ModuleNode) {
                    var parentModuleNode = connectedOutputPort.parent;
                    // Skip split module
                    if (ExperimentEditor.ModelHelpers.isModuleFamily(parentModuleNode.module_, DataLab.Constants.WellKnownResource.SplitModuleFamilyId)) {
                        var splitIputPort = Util.first(parentModuleNode.inputPorts);
                        if (splitIputPort.connectedOutputPort) {
                            port.disconnect(port.connectedNonWebServicePorts());
                            port.connectTo(splitIputPort.connectedOutputPort);
                            _this.traverseScoreGraphNodes(port.parent);
                        }
                        return;
                    }
                }
                _this.traverseScoreGraphNodes(connectedOutputPort.parent);
            });
        };
        TrainedModelExperimentCreateProcessor.prototype.addWebServiceInputOutputPortsAsync = function (experiment, context) {
            var _this = this;
            var animation = new ExperimentEditor.MoveNodesAnimationOperation();
            animation.initialize(Util.values(experiment.nodes()));
            Util.forEach(this.webServiceInputPorts, function (port) {
                if (port) {
                    context.inputNode = experiment.addWebServicePort(0 /* Input */, port.parent.x(), port.parent.y(), null, _this.workspace.applicationCache.dataTypeRegistry, port);
                    animation.AddMovement({
                        node: context.inputNode,
                        direction: 0 /* up */
                    });
                }
            });
            Util.forEach(this.webServiceOutputPorts, function (port) {
                if (port) {
                    context.outputNode = experiment.addWebServicePort(1 /* Output */, port.parent.x(), port.parent.y(), null, _this.workspace.applicationCache.dataTypeRegistry, port);
                    animation.AddMovement({
                        node: context.outputNode,
                        direction: 1 /* down */
                    });
                }
            });
            experiment.isWebServiceExperiment(true);
            context.experimentEditorViewModel.experimentViewModel().displayFlowType(ExperimentEditor.Constants.ExperimentDataFlowType.WebService);
            return animation.runAsync();
        };
        return TrainedModelExperimentCreateProcessor;
    })(ExperimentEditor.TrainedModelExperimentProcessorBase);
    ExperimentEditor.TrainedModelExperimentCreateProcessor = TrainedModelExperimentCreateProcessor;
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../../Global.ts" />
/// <reference path="../modelhelpers.ts" />
/// <reference path="../asyncoperation.ts" />
/// <reference path="../guidetours.ts" />
/// <reference path="IExperimentProcessor.ts" />
/// <reference path="Context.ts" />
/// <reference path="../AnimationOperation.ts" />
var ExperimentEditor;
(function (ExperimentEditor) {
    var Util = DataLab.Util;
    var TransformModuleExperimentProcessorBase = (function () {
        function TransformModuleExperimentProcessorBase(workspace) {
            this.transformResources = {};
            this.transformProducerNodes = {};
            this.transformModulesCache = workspace.transformModulesCache;
        }
        TransformModuleExperimentProcessorBase.prototype.preProcess = function (trainingExperiment, context) {
            var _this = this;
            // search for all modules producing ITransform and save <Node,ITransform> pairs
            var currentExperimentFamilyId = ExperimentEditor.ModelHelpers.parseExperimentFamilyId(trainingExperiment.experimentId());
            var promises = [];
            trainingExperiment.getModules().forEach(function (node) {
                var transformModulePort = Util.first(node.outputPorts, function (port) { return port.isTransformProducerPort(); }, null);
                if (transformModulePort) {
                    var transformModule = _this.searchTransformModule(_this.transformModulesCache, currentExperimentFamilyId, transformModulePort.parent.id, transformModulePort.name);
                    if (transformModule) {
                        promises.push(_this.saveTransformModel(context.workspace, transformModulePort, transformModule.name(), ExperimentEditor.ModelHelpers.parseModelFamilyId(transformModule.familyId), transformModule.description()).then(function (transform) {
                            _this.transformResources[node.id] = transform;
                            _this.transformProducerNodes[node.id] = node;
                        }));
                    }
                    else {
                        var transformModuleName = ExperimentEditor.ModelHelpers.getUniqueResourceName(_this.transformModulesCache, ExperimentEditor.ModelHelpers.formatResourceName(trainingExperiment.description()) + "[" + ExperimentEditor.ModelHelpers.formatResourceName(node.name) + "]");
                        promises.push(_this.saveTransformModel(context.workspace, transformModulePort, transformModuleName).then(function (transform) {
                            _this.transformResources[node.id] = transform;
                            _this.transformProducerNodes[node.id] = node;
                        }));
                    }
                }
            });
            return $.when.apply($, promises);
        };
        TransformModuleExperimentProcessorBase.prototype.process = function (scoringExperiment, context) {
            return Util.when("");
        };
        TransformModuleExperimentProcessorBase.prototype.postProcess = function (scoringExperiment, context) {
            return Util.when("");
        };
        TransformModuleExperimentProcessorBase.prototype.searchTransformModule = function (transformModulesCache, experimentFamilyId, moduleId, outputName) {
            return Util.first(transformModulesCache.items(), function (tm) {
                if (tm.experimentId && tm.experimentId.indexOf(experimentFamilyId) > 0) {
                    return (tm.moduleId === moduleId && tm.outputName === outputName);
                }
                else {
                    return false;
                }
            }, null);
        };
        TransformModuleExperimentProcessorBase.prototype.saveTransformModel = function (workspace, port, name, familyId, description) {
            return workspace.promoteOutputToTransformModuleAsync(port, name, familyId, description);
        };
        return TransformModuleExperimentProcessorBase;
    })();
    ExperimentEditor.TransformModuleExperimentProcessorBase = TransformModuleExperimentProcessorBase;
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../../Global.ts" />
/// <reference path="../modelhelpers.ts" />
/// <reference path="../asyncoperation.ts" />
/// <reference path="../guidetours.ts" />
/// <reference path="IExperimentProcessor.ts" />
/// <reference path="TransformModuleExperimentProcessorBase.ts" />
/// <reference path="Context.ts" />
/// <reference path="../AnimationOperation.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var ExperimentEditor;
(function (ExperimentEditor) {
    var Util = DataLab.Util;
    var TransformModuleExperimentCreateProcessor = (function (_super) {
        __extends(TransformModuleExperimentCreateProcessor, _super);
        function TransformModuleExperimentCreateProcessor(workspace) {
            _super.call(this, workspace);
            this.applyTransformModuleName = "Apply Transform";
            this.transformationOutputTransformPortName = "transformation";
            this.applyTransformInputPortName = "Transformation";
        }
        TransformModuleExperimentCreateProcessor.prototype.preProcess = function (trainingExperiment, context) {
            return _super.prototype.preProcess.call(this, trainingExperiment, context);
        };
        TransformModuleExperimentCreateProcessor.prototype.process = function (scoringExperiment, context) {
            var _this = this;
            var promises = [];
            $.each(this.transformResources, function (nodeId, transformResource) {
                var transformProducer = _this.transformProducerNodes[nodeId];
                var transformResourceNode = _this.addTransformToGraph(transformResource, transformProducer, context);
                // add/find apply transform module
                promises.push(_this.findOrCreateApplyTransformNodeAsync(context, scoringExperiment, transformProducer, transformResourceNode).then(function (applyTransformNode) {
                    // delete transformProducerNode
                    transformProducer.remove();
                    // conect resource to transform module
                    transformResourceNode.outputPorts[_this.transformationOutputTransformPortName].connectTo(applyTransformNode.inputPorts[_this.applyTransformInputPortName]);
                }));
            });
            return $.when.apply($, promises);
        };
        TransformModuleExperimentCreateProcessor.prototype.postProcess = function (scoringExperiment, context) {
            return Util.when("");
        };
        TransformModuleExperimentCreateProcessor.prototype.addTransformToGraph = function (tm, transformProducerNode, context) {
            return context.experimentEditorViewModel.addTransformById(tm.id, transformProducerNode.x(), transformProducerNode.y()).transformNode;
        };
        TransformModuleExperimentCreateProcessor.prototype.findOrCreateApplyTransformNodeAsync = function (context, experiment, transformProducerNode, transformResource) {
            var dfd = $.Deferred();
            var outputPort = Util.first(transformProducerNode.outputPorts, function (port) { return port.isTransformProducerPort(); }, null);
            // look for the first connected ApplyTransform node
            var applyTransformNode = null;
            var connectedPorts = outputPort.connectedNonWebServicePorts();
            if (connectedPorts != null) {
                var applyTransformInput = Util.first(connectedPorts, function (port) { return ExperimentEditor.ModelHelpers.isApplyTransformModuleNode(port.parent); }, null);
                if (applyTransformInput != null) {
                    applyTransformNode = applyTransformInput.parent;
                }
            }
            // if found, return
            if (applyTransformNode != null) {
                var itransformInputPortApplyTransform = Util.first(applyTransformNode.inputPorts, function (port) { return !port.isDatasetDataType(); }, null);
                itransformInputPortApplyTransform.disconnect();
                var transformDataInput = Util.first(transformProducerNode.inputPorts, function (port) { return port.isDatasetDataType(); });
                var itransformInputPortData = Util.first(applyTransformNode.inputPorts, function (port) { return port.isDatasetDataType(); }, null);
                itransformInputPortData.disconnect();
                itransformInputPortData.connectTo(transformDataInput.connectedOutputPort);
                dfd.resolve(applyTransformNode);
            }
            else {
                // if not, create a new ApplyTransform
                var applyTransformModule = Util.first(context.workspace.moduleCache.items(), function (m) {
                    return m.familyId.indexOf(DataLab.Constants.WellKnownResource.ApplyTransformationFamilyId) > -1;
                });
                applyTransformNode = context.experimentEditorViewModel.addModuleById(applyTransformModule.id, transformProducerNode.x(), transformProducerNode.y()).graphNode;
                var animation = new ExperimentEditor.MoveNodesAnimationOperation();
                animation.initialize(Util.values(experiment.nodes()));
                animation.AddMovement({
                    node: applyTransformNode,
                    direction: 1 /* down */
                });
                // only need to connect input of transformProducer to input of applyTransform
                // and connect output of transformProducer to output of applyTransform
                var inputPort1 = Util.first(transformProducerNode.inputPorts, function (port) { return port.isDatasetDataType(); });
                var outputPort1 = Util.first(transformProducerNode.outputPorts, function (port) { return port.isDatasetDataType(); }, null);
                var inputPort2 = Util.first(applyTransformNode.inputPorts, function (port) { return port.isDatasetDataType(); });
                var outputPort2 = Util.first(applyTransformNode.outputPorts, function (port) { return port.isDatasetDataType(); }, null);
                inputPort2.connectTo(inputPort1.connectedOutputPort);
                var allInputPortsConnectedToOutput1 = outputPort1.connectedPorts();
                for (var portName in allInputPortsConnectedToOutput1) {
                    var other = allInputPortsConnectedToOutput1[portName];
                    outputPort1.disconnectFrom(other);
                    outputPort2.connectTo(other);
                }
                ;
                animation.runAsync().done(function () {
                    dfd.resolve(applyTransformNode);
                });
            }
            return dfd.promise();
        };
        return TransformModuleExperimentCreateProcessor;
    })(ExperimentEditor.TransformModuleExperimentProcessorBase);
    ExperimentEditor.TransformModuleExperimentCreateProcessor = TransformModuleExperimentCreateProcessor;
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
/// <reference path="asyncoperation.ts" />
/// <reference path="guidetours.ts" />
/// <reference path="modelhelpers.ts" />
/// <reference path="ExperimentProcessor/TrainedModelExperimentCreateProcessor.ts" />
/// <reference path="ExperimentProcessor/TransformModuleExperimentCreateProcessor.ts" />
/// <reference path="ExperimentProcessor/IExperimentProcessor.ts" />
/// <reference path="ExperimentProcessor/Context.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var ExperimentEditor;
(function (ExperimentEditor) {
    var Contract = DataLab.DataContract;
    var LocalizedResources = DataLab.LocalizedResources;
    var CreateScoringGraphOperation = (function (_super) {
        __extends(CreateScoringGraphOperation, _super);
        function CreateScoringGraphOperation(experimentContainerViewModel, xeControlContainer) {
            _super.call(this);
            if (experimentContainerViewModel) {
                this.initialize(experimentContainerViewModel, xeControlContainer);
            }
        }
        CreateScoringGraphOperation.prototype.initialize = function (experimentContainerViewModel, xeControlContainer) {
            this.experimentContainerViewModel = experimentContainerViewModel;
            this.xeControlContainer = xeControlContainer;
            this.experiment = experimentContainerViewModel.experiment;
            this.workspace = experimentContainerViewModel.workspace;
            this.context = new ExperimentEditor.Context();
            this.context.workspace = this.workspace;
            this.context.experimentEditorViewModel = experimentContainerViewModel.experimentEditorViewModel;
            this.context.asyncOperation = this;
            // initialize the list of processors
            this.processors = [new ExperimentEditor.TrainedModelExperimentCreateProcessor(this.workspace), new ExperimentEditor.TransformModuleExperimentCreateProcessor(this.workspace)];
        };
        CreateScoringGraphOperation.prototype.runAsync = function () {
            var _this = this;
            Shell.Diagnostics.Telemetry.featureUsage(73 /* CreateScoringExperiment */, 72 /* ScoringExperiment */, this.workspace.id, this.experiment.experimentId());
            Shell.UI.Spinner.show();
            return _super.prototype.runAsync.call(this).fail(function (error) {
                Shell.Diagnostics.Telemetry.featureUsage(74 /* CreateScoringExperimentFailed */, 72 /* ScoringExperiment */, _this.workspace.id, _this.experiment.experimentId(), null, error && error.message);
            }).always(function () {
                Shell.UI.Spinner.hide();
            });
        };
        CreateScoringGraphOperation.prototype.runInternalAsync = function () {
            // If there is no train module in the graph, no-op
            if (!this.experiment.containsTrainingModule()) {
                return this.reject(new Error("No training module in the experiment"));
            }
            return this.createScoreGraph();
        };
        // Create score graph from training graph
        // 1. Call parseResource on all processors
        // 2. Copy training graph to new graph
        // 3. Call process on all processors
        // . [Optional] Auto layout the new graph
        CreateScoringGraphOperation.prototype.createScoreGraph = function () {
            var _this = this;
            var scoringProjectExperiment;
            var trainingExperimentId = this.experiment.experimentId();
            var projectId = this.experimentContainerViewModel.projectViewModel.projectId;
            this.startProgress(LocalizedResources.createScoringExperimentProgressTitle);
            var preProcessPromises = [];
            var processPromises = [];
            var postProcessPromises = [];
            this.addStep(LocalizedResources.lookingForTrainModuleStepTitle);
            this.processors.forEach(function (processor) {
                preProcessPromises.push(processor.preProcess(_this.experiment, _this.context));
            });
            return $.when.apply($, preProcessPromises).then(function () {
                _this.updateCurrentStep(LocalizedResources.foundTrainModuleStepTitle);
                _this.addStep(LocalizedResources.creatingTrainedModelStepTitle);
                _this.updateCurrentStep(LocalizedResources.createdTrainedModelStepTitle);
                _this.experimentContainerViewModel.copy(_this.experiment.description() + " [Scoring Exp.]");
                // add experiments to project
                _this.experimentContainerViewModel.projectViewModel.projectId = projectId;
                _this.addExperimentToProject(trainingExperimentId, Contract.ExperimentRole.Training);
                scoringProjectExperiment = _this.addExperimentToProject(_this.experiment.experimentId(), Contract.ExperimentRole.Scoring);
            }).then(function () {
                _this.processors.forEach(function (processor) {
                    processPromises.push(processor.process(_this.experiment, _this.context));
                });
                return $.when.apply($, processPromises);
            }).then(function () {
                _this.addStep(LocalizedResources.creatingScoreExperimentStepTitle);
                _this.processors.forEach(function (processor) {
                    postProcessPromises.push(processor.postProcess(_this.experiment, _this.context));
                });
                return $.when.apply($, postProcessPromises);
            }).then(function () {
                // Save draft experiment
                return _this.experimentContainerViewModel.save();
            }).then(function () {
                // Set experiment id to project experiment so that we can save the project 
                // with appropriate experiment id
                scoringProjectExperiment.experimentId(_this.experiment.experimentId());
                return _this.experimentContainerViewModel.projectViewModel.save();
            }).then(function () {
                _this.updateCurrentStep(LocalizedResources.createdScoreExperimentStepTitle);
                return _this.xeControlContainer.zoomToFitWithAnimation();
            }).then(function () {
                return ExperimentEditor.GuideTours.showCreatingScoringExperimentTourAsync(_this.context.inputNode || _this.context.outputNode, _this.experimentContainerViewModel.paletteViewModel, _this.experimentContainerViewModel.webServiceViewModel.webServiceCategory.name(), _this.context.trainedModelNode);
            }).done(function (bubbleViewModel) {
                if (bubbleViewModel.visible()) {
                    // remove notification if we shows guided tour
                    _this.removeNotification(_this.progress);
                }
            });
        };
        CreateScoringGraphOperation.prototype.addExperimentToProject = function (id, role) {
            var projectVM = this.experimentContainerViewModel.projectViewModel;
            return projectVM.addExperiment(id, role);
        };
        CreateScoringGraphOperation.prototype.isEnabled = function () {
            return this.experimentContainerViewModel.experiment.containsTrainingModule() && !this.isRunning();
        };
        return CreateScoringGraphOperation;
    })(ExperimentEditor.AsyncOperation);
    ExperimentEditor.CreateScoringGraphOperation = CreateScoringGraphOperation;
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var ExperimentEditor;
(function (ExperimentEditor) {
    (function (MoveDirection) {
        MoveDirection[MoveDirection["up"] = 0] = "up";
        MoveDirection[MoveDirection["down"] = 1] = "down";
    })(ExperimentEditor.MoveDirection || (ExperimentEditor.MoveDirection = {}));
    var MoveDirection = ExperimentEditor.MoveDirection;
    var NodeMovement = (function () {
        function NodeMovement() {
        }
        return NodeMovement;
    })();
    ExperimentEditor.NodeMovement = NodeMovement;
    var NodeRect = (function () {
        function NodeRect() {
        }
        Object.defineProperty(NodeRect.prototype, "right", {
            get: function () {
                return this.left + this.width;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NodeRect.prototype, "bottom", {
            get: function () {
                return this.top + this.height;
            },
            enumerable: true,
            configurable: true
        });
        return NodeRect;
    })();
    var MoveNodesAnimationOperation = (function (_super) {
        __extends(MoveNodesAnimationOperation, _super);
        function MoveNodesAnimationOperation() {
            _super.apply(this, arguments);
            this.yDistance = 120;
            this.xDistance = 120;
            this.nodeMovements = [];
            this.rects = [];
        }
        MoveNodesAnimationOperation.prototype.initialize = function (nodes) {
            this.nodes = nodes;
            this.rects = this.nodes.map(function (n) {
                var rect = new NodeRect();
                rect.left = n.x();
                rect.top = n.y();
                rect.height = n.height();
                rect.width = n.width();
                return rect;
            });
        };
        MoveNodesAnimationOperation.prototype.AddMovement = function (movement) {
            this.nodeMovements.push(movement);
        };
        MoveNodesAnimationOperation.prototype.runInternalAsync = function () {
            var _this = this;
            var animationOperation = new ExperimentEditor.AnimationOperation();
            this.nodeMovements.forEach(function (m) {
                var rect = _this.getBestPosition(m);
                animationOperation.animations.push({
                    context: {
                        graphNode: m.node,
                        dx: (rect.left - m.node.x()) / animationOperation.totalSteps,
                        dy: (rect.top - m.node.y()) / animationOperation.totalSteps,
                    },
                    stepFunc: function (step, context) {
                        var graphNode = context.graphNode;
                        graphNode.x(graphNode.x() + context.dx);
                        graphNode.y(graphNode.y() + context.dy);
                    }
                });
            });
            return animationOperation.runAsync();
        };
        MoveNodesAnimationOperation.prototype.getBestPosition = function (movement) {
            var _this = this;
            var rect = new NodeRect();
            rect.left = movement.node.x();
            rect.top = movement.node.y();
            rect.height = movement.node.height();
            rect.width = movement.node.width();
            rect.top = movement.direction === 0 /* up */ ? rect.top - this.yDistance - rect.height : rect.top + this.yDistance + rect.height;
            while (!this.rects.every(function (r) { return !_this.isOverlap(r, rect); })) {
                rect.left += this.xDistance;
            }
            this.rects.push(rect);
            return rect;
        };
        MoveNodesAnimationOperation.prototype.isOverlap = function (r1, r2) {
            return r1.left < r2.right && r1.right > r2.left && r1.top < r2.bottom && r1.bottom > r2.top;
        };
        return MoveNodesAnimationOperation;
    })(ExperimentEditor.AsyncOperation);
    ExperimentEditor.MoveNodesAnimationOperation = MoveNodesAnimationOperation;
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
/// <reference path="asyncoperation.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var ExperimentEditor;
(function (ExperimentEditor) {
    var Util = DataLab.Util;
    var PrepareWebServiceOperation = (function (_super) {
        __extends(PrepareWebServiceOperation, _super);
        function PrepareWebServiceOperation(experimentContainerViewModel, xeControlContainer) {
            _super.call(this);
            this.inputPort = null;
            this.outputPort = null;
            this.nodes = [];
            this.inputPortDepth = Number.MAX_VALUE;
            this.outputPortDepth = 0;
            this.inputToOutputDepth = 0;
            if (experimentContainerViewModel) {
                this.initialize(experimentContainerViewModel, xeControlContainer);
            }
        }
        PrepareWebServiceOperation.prototype.reset = function () {
            this.inputPort = null;
            this.outputPort = null;
            this.inputPortDepth = Number.MAX_VALUE;
            this.outputPortDepth = 0;
            this.inputToOutputDepth = 0;
        };
        PrepareWebServiceOperation.prototype.initialize = function (experimentContainerViewModel, xeControlContainer) {
            this.experimentContainerViewModel = experimentContainerViewModel;
            this.experiment = experimentContainerViewModel.experiment;
            this.experimentEditorViewModel = experimentContainerViewModel.experimentEditorViewModel;
            this.workspace = experimentContainerViewModel.workspace;
            this.nodes = Util.values(this.experiment.nodes());
            this.xeControlContainer = xeControlContainer;
            this.reset();
        };
        PrepareWebServiceOperation.prototype.runAsync = function () {
            var _this = this;
            Shell.Diagnostics.Telemetry.featureUsage(68 /* PrepareWebService */, 68 /* PrepareWebService */, this.workspace.id, this.experiment.experimentId());
            return _super.prototype.runAsync.call(this).fail(function (error) {
                Shell.Diagnostics.Telemetry.featureUsage(71 /* PrepareWebServiceFailed */, 68 /* PrepareWebService */, _this.workspace.id, _this.experiment.experimentId(), null, error && error.message);
            });
        };
        PrepareWebServiceOperation.prototype.runInternalAsync = function () {
            var _this = this;
            this.reset();
            this.searchGraph();
            var animation = new ExperimentEditor.AddWebServicePortAnimationOperation();
            animation.initialize(this.experiment, this.workspace);
            if (this.inputPort) {
                animation.webServiceInputPorts.push(this.inputPort);
            }
            if (this.outputPort) {
                animation.webServiceOutputPorts.push(this.outputPort);
            }
            this.experiment.isWebServiceExperiment(true);
            this.experimentEditorViewModel.experimentViewModel().displayFlowType(ExperimentEditor.Constants.ExperimentDataFlowType.WebService);
            return animation.runAsync().then(function () {
                return _this.xeControlContainer.zoomToFitWithAnimation();
            }).then(function () {
                var portNode = null;
                if (animation.webServiceInputPortNodes.length) {
                    portNode = animation.webServiceInputPortNodes[0];
                }
                else if (animation.webServiceOutputPortNodes.length) {
                    portNode = animation.webServiceOutputPortNodes[0];
                }
                return ExperimentEditor.GuideTours.showPrepareWebServiceTourAsync(portNode, _this.experimentContainerViewModel.paletteViewModel, _this.experimentContainerViewModel.webServiceViewModel.webServiceCategory.name());
            });
        };
        PrepareWebServiceOperation.prototype.searchGraph = function () {
            var _this = this;
            Util.forEach(this.nodes, function (n) {
                if (_this.isRoot(n)) {
                    _this.searchTree(n);
                }
            });
        };
        // The logic to find input/output ports is
        // 1. If the node's input ports accepts dataset type, it's a potential ws input
        // 2. If the node's output ports accepts dataset or trained model type, it's a potential ws output
        // 3. If there is a path between a potential ws input and output, choose pair which has the longest path
        // 4. If there is no such path found, choose ws input with min depth
        // 5. If there is no ws input found, choose ws output with max depth
        PrepareWebServiceOperation.prototype.searchTree = function (node, inputPort, depth, depthFromInputPort) {
            var _this = this;
            if (inputPort === void 0) { inputPort = null; }
            if (depth === void 0) { depth = 0; }
            if (depthFromInputPort === void 0) { depthFromInputPort = 0; }
            if (!inputPort) {
                // 1. If the node's input ports accepts dataset type, it's a potential ws input
                Util.forEach(node.inputPorts, function (p) {
                    if (p.isConnected() && p.isDatasetDataType()) {
                        inputPort = p;
                        depthFromInputPort = 1;
                        return false;
                    }
                    return true;
                });
            }
            // 2. If the node's output ports accepts dataset or trained model type, it's a potential ws output
            var outputPort = null;
            Util.forEach(node.outputPorts, function (p) {
                if (p.isDatasetDataType() || p.isTrainModulePort()) {
                    outputPort = p;
                    return false;
                }
                return true;
            });
            if (inputPort && outputPort) {
                // 3. If there is a path between a potential ws input and output, choose pair which has the longest path
                if (depthFromInputPort > this.inputToOutputDepth) {
                    this.inputPort = inputPort;
                    this.outputPort = outputPort;
                    this.inputToOutputDepth = depthFromInputPort;
                }
            }
            else if (!this.inputToOutputDepth) {
                // 4. If there is no such path found, choose ws input with min depth
                if (inputPort && depthFromInputPort === 1 && depth < this.inputPortDepth) {
                    this.inputPort = inputPort;
                    this.inputPortDepth = depth;
                    this.outputPort = null;
                    this.outputPortDepth = 0;
                }
                // 5. If there is no ws input found, choose ws output with max depth
                if (!this.inputPort && outputPort && depth + 1 > this.outputPortDepth) {
                    this.outputPort = outputPort;
                    this.outputPortDepth = depth + 1;
                }
            }
            if (depthFromInputPort) {
                depthFromInputPort++;
            }
            Util.forEach(node.outputPorts, function (p1) {
                Util.forEach(p1.connectedNonWebServicePorts(), function (p2) {
                    _this.searchTree(p2.parent, inputPort, depth + 1, depthFromInputPort);
                });
            });
        };
        PrepareWebServiceOperation.prototype.isRoot = function (node) {
            var inputPorts = Util.values(node.inputPorts);
            if (!inputPorts.length) {
                return true;
            }
            return inputPorts.every(function (p) { return !p.isConnected(); });
        };
        return PrepareWebServiceOperation;
    })(ExperimentEditor.AsyncOperation);
    ExperimentEditor.PrepareWebServiceOperation = PrepareWebServiceOperation;
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var ExperimentEditor;
(function (ExperimentEditor) {
    var SaveTrainedModelOperation = (function (_super) {
        __extends(SaveTrainedModelOperation, _super);
        function SaveTrainedModelOperation(workspace, port, name, familyId, description, showProgress) {
            if (showProgress === void 0) { showProgress = true; }
            _super.call(this);
            this.showProgress = true;
            if (!workspace) {
                throw new Error("workspace cannot be null.");
            }
            this.workspace = workspace;
            this.port = port;
            this.name = name;
            this.familyId = familyId;
            this.description = description;
            this.showProgress = showProgress;
        }
        SaveTrainedModelOperation.prototype.runInternalAsync = function () {
            if (!this.port) {
                return this.reject(new Error("Port is required to save as trained model."));
            }
            if (!this.name) {
                return this.reject(new Error("Name can't be null or empty for trained model."));
            }
            if (!this.port.isTrainModulePort()) {
                return this.reject(Error("The selected port can't be saved as trained model."));
            }
            if (this.showProgress) {
                this.startProgress(DataLab.LocalizedResources.promotionSavingIntermediateOutput);
            }
            return this.workspace.promoteOutputToTrainedModelAsync(this.port, this.name, this.familyId, this.description);
        };
        return SaveTrainedModelOperation;
    })(ExperimentEditor.AsyncOperation);
    ExperimentEditor.SaveTrainedModelOperation = SaveTrainedModelOperation;
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../guidetours.ts" />
/// <reference path="IExperimentProcessor.ts" />
/// <reference path="TrainedModelExperimentProcessorBase.ts" />
/// <reference path="Context.ts" />
/// <reference path="../AnimationOperation.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var ExperimentEditor;
(function (ExperimentEditor) {
    var Model = DataLab.Model;
    var TrainedModelExperimentUpdateProcessor = (function (_super) {
        __extends(TrainedModelExperimentUpdateProcessor, _super);
        function TrainedModelExperimentUpdateProcessor(workspace) {
            _super.call(this, workspace);
        }
        // Create trained model from training graph
        TrainedModelExperimentUpdateProcessor.prototype.preProcess = function (trainingExperiment, context) {
            this.trainingExperiment = trainingExperiment;
            return _super.prototype.preProcess.call(this, trainingExperiment, context);
        };
        TrainedModelExperimentUpdateProcessor.prototype.process = function (scoringExperiment, context) {
            var currentExperimentFamilyId = ExperimentEditor.ModelHelpers.parseExperimentFamilyId(this.trainingExperiment.experimentId());
            var foundTrainedModelNode = ExperimentEditor.ModelHelpers.searchTrainedModelInScoreGraph(scoringExperiment, currentExperimentFamilyId);
            if (!foundTrainedModelNode) {
                return context.asyncOperation.reject(new Error("No matching trained model which is generated from training graph."));
            }
            var newTrainedModelNode = new Model.TrainedModelNode(this.trainedModel);
            foundTrainedModelNode.replaceWith(newTrainedModelNode, {});
            return _super.prototype.process.call(this, scoringExperiment, context);
        };
        return TrainedModelExperimentUpdateProcessor;
    })(ExperimentEditor.TrainedModelExperimentProcessorBase);
    ExperimentEditor.TrainedModelExperimentUpdateProcessor = TrainedModelExperimentUpdateProcessor;
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../../Global.ts" />
/// <reference path="../modelhelpers.ts" />
/// <reference path="../asyncoperation.ts" />
/// <reference path="../guidetours.ts" />
/// <reference path="IExperimentProcessor.ts" />
/// <reference path="TransformModuleExperimentProcessorBase.ts" />
/// <reference path="Context.ts" />
/// <reference path="../AnimationOperation.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var ExperimentEditor;
(function (ExperimentEditor) {
    var Util = DataLab.Util;
    var Model = DataLab.Model;
    var TransformModuleExperimentUpdateProcessor = (function (_super) {
        __extends(TransformModuleExperimentUpdateProcessor, _super);
        function TransformModuleExperimentUpdateProcessor(workspace) {
            _super.call(this, workspace);
        }
        TransformModuleExperimentUpdateProcessor.prototype.preProcess = function (trainingExperiment, context) {
            this.trainingExperiment = trainingExperiment;
            return _super.prototype.preProcess.call(this, trainingExperiment, context);
        };
        TransformModuleExperimentUpdateProcessor.prototype.process = function (scoringExperiment, context) {
            var currentExperimentFamilyId = ExperimentEditor.ModelHelpers.parseExperimentFamilyId(this.trainingExperiment.experimentId());
            $.each(this.transformResources, function (nodeId, transformResource) {
                var transformNode = ExperimentEditor.ModelHelpers.searchTransformNodeInScoreGraph(scoringExperiment, currentExperimentFamilyId, transformResource);
                if (transformNode) {
                    var transformResourceNode = new Model.TransformNode(transformResource);
                    transformNode.replaceWith(transformResourceNode, {});
                }
            });
            return _super.prototype.process.call(this, scoringExperiment, context);
        };
        TransformModuleExperimentUpdateProcessor.prototype.postProcess = function (scoringExperiment, context) {
            return Util.when("");
        };
        return TransformModuleExperimentUpdateProcessor;
    })(ExperimentEditor.TransformModuleExperimentProcessorBase);
    ExperimentEditor.TransformModuleExperimentUpdateProcessor = TransformModuleExperimentUpdateProcessor;
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Global.ts" />
/// <reference path="asyncoperation.ts" />
/// <reference path="ExperimentProcessor/TrainedModelExperimentUpdateProcessor.ts" />
/// <reference path="ExperimentProcessor/TransformModuleExperimentUpdateProcessor.ts" />
/// <reference path="ExperimentProcessor/IExperimentProcessor.ts" />
/// <reference path="ExperimentProcessor/Context.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var ExperimentEditor;
(function (ExperimentEditor) {
    var Contract = DataLab.DataContract;
    var LocalizedResources = DataLab.LocalizedResources;
    var UpdateScoringGraphOperation = (function (_super) {
        __extends(UpdateScoringGraphOperation, _super);
        function UpdateScoringGraphOperation(experimentContainerViewModel) {
            _super.call(this);
            if (experimentContainerViewModel) {
                this.initialize(experimentContainerViewModel);
            }
        }
        UpdateScoringGraphOperation.prototype.initialize = function (experimentContainerViewModel) {
            this.experimentContainerViewModel = experimentContainerViewModel;
            this.experiment = experimentContainerViewModel.experiment;
            this.experimentEditorViewModel = experimentContainerViewModel.experimentEditorViewModel;
            this.workspace = experimentContainerViewModel.workspace;
            this.projectViewModel = experimentContainerViewModel.projectViewModel;
            this.context = new ExperimentEditor.Context();
            this.context.workspace = this.workspace;
            this.context.experimentEditorViewModel = experimentContainerViewModel.experimentEditorViewModel;
            this.context.asyncOperation = this;
            // initialize the list of processors
            this.processors = [new ExperimentEditor.TrainedModelExperimentUpdateProcessor(this.workspace), new ExperimentEditor.TransformModuleExperimentUpdateProcessor(this.workspace)];
        };
        UpdateScoringGraphOperation.prototype.runAsync = function () {
            var _this = this;
            Shell.Diagnostics.Telemetry.featureUsage(75 /* UpdateScoringExperiment */, 72 /* ScoringExperiment */, this.workspace.id, this.experiment.experimentId());
            return _super.prototype.runAsync.call(this).fail(function (error) {
                Shell.Diagnostics.Telemetry.featureUsage(76 /* UpdateScoringExperimentFailed */, 72 /* ScoringExperiment */, _this.workspace.id, _this.experiment.experimentId(), null, error && error.message);
            });
        };
        UpdateScoringGraphOperation.prototype.runInternalAsync = function () {
            var _this = this;
            this.startProgress(LocalizedResources.updateScoringExperimentProgressTitle);
            this.addStep(LocalizedResources.retreivingScoringExperimentStepTitle);
            var scoringExperiment = this.projectViewModel.findExperiment(function (vm) { return vm.role === Contract.ExperimentRole.Scoring; });
            if (!scoringExperiment) {
                return this.reject(new Error("No scoring graph found in the project."));
            }
            if (scoringExperiment.experimentId() === this.experiment.experimentId()) {
                return this.reject(Error("One can only update scoring graph from its training graph."));
            }
            var preProcessPromises = [];
            var processPromises = [];
            this.processors.forEach(function (processor) {
                preProcessPromises.push(processor.preProcess(_this.experiment, _this.context));
            });
            return this.workspace.getExperimentAsync(scoringExperiment.experimentId()).then(function (scoreExperiment) {
                return $.when.apply($, preProcessPromises).then(function () {
                    _this.addStep(LocalizedResources.lookingForTrainModuleStepTitle);
                    _this.processors.forEach(function (processor) {
                        processPromises.push(processor.process(scoreExperiment, _this.context));
                    });
                    _this.addStep(LocalizedResources.saveTrainModuleStepTitle);
                    return $.when.apply($, processPromises);
                }).then(function () {
                    _this.addStep(LocalizedResources.updateTrainedModelInScoringExperimentStepTitle);
                    scoreExperiment.setDraftState(true);
                    return _this.workspace.updateDraftAsync(scoreExperiment);
                }).done(function () {
                    Shell.UI.Navigation.navigate({
                        extension: DataLabViews.experimentExtensionName,
                        type: DataLabViews.ExperimentType.name,
                        name: scoringExperiment.experimentId()
                    });
                });
            });
        };
        UpdateScoringGraphOperation.prototype.isUpdatable = function () {
            var scoringExperiment = this.projectViewModel.findExperiment(function (vm) { return vm.role === Contract.ExperimentRole.Scoring; });
            if (!scoringExperiment) {
                return false;
            }
            if (scoringExperiment.experimentId() === this.experiment.experimentId()) {
                return false;
            }
            return true;
        };
        UpdateScoringGraphOperation.prototype.isEnabled = function () {
            return this.experimentContainerViewModel.experiment.containsTrainingModule() && !this.isRunning() && this.isUpdatable();
        };
        return UpdateScoringGraphOperation;
    })(ExperimentEditor.AsyncOperation);
    ExperimentEditor.UpdateScoringGraphOperation = UpdateScoringGraphOperation;
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../../Common/IMenuBuilder.ts" />
/// <reference path="../ExperimentEditor/ExperimentEditorViewModel.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var ExperimentEditor;
(function (ExperimentEditor) {
    // We extends Disposable so we can use helicopter mode in leakmaster
    var WebServiceParameterMenuBuilder = (function (_super) {
        __extends(WebServiceParameterMenuBuilder, _super);
        function WebServiceParameterMenuBuilder(experimentEditorViewModel) {
            var _this = this;
            _super.call(this);
            this.currentTarget = ko.observable(null);
            this.experimentEditorViewModel = experimentEditorViewModel;
            this.deleteCommand = new ExperimentEditor.CallbackCommand(function (target) {
                _this.featureUsage(50 /* RemoveParameter */);
                _this.experimentEditorViewModel.experiment.removeWebServiceParameter(target.property);
            });
            this.deleteCommand.canExecute = ko.computed(function () {
                return !_this.experimentEditorViewModel.experimentViewModel().readOnlyMode();
            });
            this.provideDefaultValueCommand = new ExperimentEditor.CallbackCommand(function (target) {
                var webServiceParameter = target.property;
                if (webServiceParameter.hasDefaultValue()) {
                    _this.featureUsage(49 /* RemoveDefaultValue */);
                }
                else {
                    _this.featureUsage(48 /* ProvideDefaultValue */);
                }
                webServiceParameter.hasDefaultValue(!webServiceParameter.hasDefaultValue());
                // Set empty default value
                webServiceParameter.value(null);
            });
            this.provideDefaultValueCommand.canExecute = ko.computed(function () {
                return !_this.experimentEditorViewModel.experimentViewModel().readOnlyMode();
            });
        }
        WebServiceParameterMenuBuilder.prototype.build = function (parameterViewModel) {
            this.currentTarget(parameterViewModel);
            var webServiceParameter = parameterViewModel.property;
            var menu = {
                width: 120,
                name: "propertyMenu",
                items: []
            };
            if (parameterViewModel.type !== 6 /* Credential */) {
                menu.items.push({
                    label: webServiceParameter.hasDefaultValue() ? DataLab.LocalizedResources.removeWebServiceParameterDefaultValue : DataLab.LocalizedResources.provideWebServiceParameterDefaultValue,
                    command: this.provideDefaultValueCommand,
                    iconClass: webServiceParameter.hasDefaultValue() ? "check" : ""
                });
                menu.items.push({
                    label: null,
                    divider: true,
                    command: null
                });
            }
            // Add the unlink command
            menu.items.push({
                label: DataLab.LocalizedResources.deleteWebServiceParameter,
                command: this.deleteCommand
            });
            return menu;
        };
        WebServiceParameterMenuBuilder.prototype.featureUsage = function (featureId) {
            Shell.Diagnostics.Telemetry.featureUsage(featureId, 43 /* WebServiceParameter */, this.experimentEditorViewModel.experimentViewModel().workspace.id, this.experimentEditorViewModel.experiment.experimentId());
        };
        return WebServiceParameterMenuBuilder;
    })(DataLab.Util.Disposable);
    ExperimentEditor.WebServiceParameterMenuBuilder = WebServiceParameterMenuBuilder;
})(ExperimentEditor || (ExperimentEditor = {}));

/// <reference path="../Typescript/Global.ts" />
/// <reference path="ExperimentView.ts" />
var DataLabViews;
(function (DataLabViews) {
    // Must mirror Microsoft.MetaAnalytics.Contracts.TaskStatusCode
    var experimentStatusCodeMap = {
        NotStarted: 'Not Started',
        InDraft: 'Draft',
        Running: 'Running',
        Failed: 'Failed',
        Finished: 'Finished',
        Canceled: 'Canceled',
    };
    function formatExperimentStatusCode(statusCode) {
        return experimentStatusCodeMap[statusCode];
    }
    DataLabViews.formatExperimentStatusCode = formatExperimentStatusCode;
    // Experiments that are not started and have very old data should be at the top of the list of Experiments
    function dateTimeSortFormatter(dateTime) {
        if (dateTime.getFullYear() < 1970) {
            return new Date();
        }
        return dateTime;
    }
    DataLabViews.dateTimeSortFormatter = dateTimeSortFormatter;
    function formatExperimentName(name, rowInfo) {
        var experimentId = rowInfo.rowMetadata.dataItem.ExperimentId;
        return "<span id='" + experimentId + "'>" + DataLab.Util.encodeAsHtml(name) + "</span>";
    }
    DataLabViews.formatExperimentName = formatExperimentName;
    var ExperimentListView = (function () {
        function ExperimentListView(renderArea, workspace, client, userName, experimentCategory) {
            var _this = this;
            this._renderArea = renderArea;
            this._data = [];
            this.listedExperiments = [];
            this._workspace = workspace;
            this._client = client;
            this._userName = userName;
            this._selectedRows = [];
            this._experimentCategory = experimentCategory;
            this.formatCheckbox = function (value, rowInfo) {
                var userWorkspaceExperiment = rowInfo.rowMetadata.dataItem.ExperimentId.split(".")[0] === _this._workspace.id;
                // We disable the checkboxes if the workspace of the experiment does not match
                // the current workspace. This allows us to prevent users from deleting experiments in the global
                // workspace.
                if (userWorkspaceExperiment) {
                    return "<input type='checkbox' class='rowCheckbox' />";
                }
                else {
                    return "<input type='checkbox' class='rowCheckbox' disabled='true' />";
                }
            };
            // We use wazDataGrid rather than the freestanding fxDataGrid since wazDataGrid supports the 'navigation' type,
            // which integrates with the shell's nav using item type and id.
            var columns = [
                { name: DataLab.LocalizedResources.experimentGridHeaderName, field: "Description", formatter: formatExperimentName, sorted: experimentCategory !== "user" ? "ascending" : undefined, cssClass: "navigationColumn" },
                { name: DataLab.LocalizedResources.experimentGridHeaderCreator, field: "Creator", cssClass: "navigationColumn" },
                { name: DataLab.LocalizedResources.experimentGridHeaderStatus, field: "StatusCode", formatter: formatExperimentStatusCode, cssClass: "navigationColumn" },
                { name: DataLab.LocalizedResources.experimentGridHeaderModificationTime, field: "CreationTime", formatter: DataLab.Util.formatDate, sorted: experimentCategory !== "user" ? undefined : "descending", sortFormatter: dateTimeSortFormatter, cssClass: "navigationColumn" },
                { name: DataLab.LocalizedResources.experimentGridHeaderStartTime, field: "StartTime", formatter: DataLab.Util.formatDate, sortFormatter: dateTimeSortFormatter, cssClass: "navigationColumn" },
                { name: DataLab.LocalizedResources.experimentGridHeaderEndTime, field: "EndTime", formatter: DataLab.Util.formatDate, cssClass: "navigationColumn" }
            ];
            if (experimentCategory === "user") {
                var checkboxColumn = { name: "", field: "Checkbox", formatter: this.formatCheckbox, cssClass: "checkboxColumn" };
                columns = $.merge([checkboxColumn], columns);
            }
            this._grid = $(renderArea).find("#grid").wazDataGrid({
                columns: columns,
                data: this._data,
                selectable: true,
                multiselect: true,
                resizable: true,
                rowSelect: function (evt, args) {
                    cdm.setActiveItem(_this);
                    if (_this.deleteCommand) {
                        _this.deleteCommand.setDisabled(_this._selectedRows.length === 0);
                    }
                }
            });
            this._grid.on("click", ".navigationColumn", function (event) {
                var row = $(event.target).closest("tr").view().data;
                if (row.rowMetadata) {
                    var experimentId = row.rowMetadata.dataItem.ExperimentId;
                    DataLabViews.navigateToExperiment(experimentId);
                }
            });
            this._grid.on("click", ".rowCheckbox", function (event) {
                var row = $(event.target).closest("tr").view().data.rowMetadata;
                var checked = $(event.target).is(":checked");
                if (checked) {
                    _this._selectedRows.push(row);
                    Shell.Diagnostics.Telemetry.customEvent("SelectRow", "ExperimentListView", JSON.stringify({ selectedRow: row, allSelectedRows: _this._selectedRows }));
                }
                else {
                    var index = _this._selectedRows.indexOf(row);
                    _this._selectedRows.splice(index, 1);
                    Shell.Diagnostics.Telemetry.customEvent("UnselectRow", "ExperimentListView", JSON.stringify({ selectedRow: row, allSelectedRows: _this._selectedRows }));
                }
            });
            cdm.setActiveItem(this);
        }
        ExperimentListView.prototype.refreshFromService = function () {
            var _this = this;
            Shell.UI.Spinner.show();
            var filter = { includeNonLeaf: false, includeArchived: false };
            DataLab.Util.then(this._workspace.listExperimentsAsync(filter), function (experiments) {
                if (cdm.currentActiveItem instanceof DataLabViews.ExperimentListView) {
                    DataLab.Performance.intervalEnd();
                    if (DataLab.Features.experimentListCategoriesEnabled()) {
                        _this.filterExperimentsByCategory(experiments);
                    }
                    else {
                        _this.filterExperiments(experiments);
                    }
                    _this._populateExperimentList(_this.listedExperiments);
                    Shell.UI.Spinner.hide();
                }
            });
        };
        ExperimentListView.prototype.changeExperimentArchiveState = function (archiveExperiment) {
            var _this = this;
            var removeExperiment = function (experimentId) {
                for (var i = 0; i < _this.listedExperiments.length; i++) {
                    if (_this.listedExperiments[i].ExperimentId === experimentId) {
                        _this.listedExperiments.splice(i, 1);
                        break;
                    }
                }
                _this.refreshFromLocal(_this.listedExperiments);
                Shell.UI.Spinner.hide();
            };
            Shell.UI.Spinner.show();
            DataLab.Util.forEach(this._selectedRows, function (selectedRow) {
                if (archiveExperiment) {
                    DataLab.Util.then(_this._workspace.archiveExperimentAsync(selectedRow.dataItem.ExperimentId), function () {
                        removeExperiment(selectedRow.dataItem.ExperimentId);
                    }, function () {
                        Shell.UI.Spinner.hide();
                    });
                }
                else {
                    DataLab.Util.then(_this._workspace.unarchiveExperimentAsync(selectedRow.dataItem.ExperimentId), function () {
                        removeExperiment(selectedRow.dataItem.ExperimentId);
                    }, function () {
                        Shell.UI.Spinner.hide();
                    });
                }
            });
        };
        ExperimentListView.prototype.setCommands = function () {
            if (this._experimentCategory === "user") {
                this.deleteCommand = new Shell.UI.Commands.Command("Delete", Shell.UI.Icons["delete"], this.deleteConfirmation.bind(this), null, true);
                Shell.UI.Commands.add([this.deleteCommand]);
            }
        };
        ExperimentListView.prototype.filterExperiments = function (experiments) {
            var _this = this;
            if (this._experimentCategory !== "user") {
                this.listedExperiments = $.grep(experiments, function (value) { return _this._isGlobalWorkspaceId(value.ExperimentId.split('.')[0]); }, false);
                this.listedExperiments = this.listedExperiments.filter(function (experiment) {
                    return experiment.Description === DataLab.Constants.GuidedExperimentDescription ? false : true;
                });
                if (DataLab.Trial.isWorkspaceTypeAnonymous()) {
                    this.listedExperiments = this.listedExperiments.filter(DataLab.Trial.filterSample);
                }
            }
            else {
                this.listedExperiments = $.grep(experiments, function (value) { return _this._isUserWorkspaceId(value.ExperimentId.split('.')[0]); }, false);
            }
        };
        ExperimentListView.prototype.filterExperimentsByCategory = function (experiments) {
            var _this = this;
            this.listedExperiments = experiments.filter(function (experiment) {
                var category = _this.getExperimentCategory(experiment);
                return category === _this._experimentCategory;
            });
            if (DataLab.Trial.isWorkspaceTypeAnonymous() && this._experimentCategory !== "user") {
                this.listedExperiments = this.listedExperiments.filter(DataLab.Trial.filterSample);
            }
        };
        ExperimentListView.prototype.refreshFromLocal = function (list) {
            Shell.UI.Spinner.show();
            this._populateExperimentList(list);
            Shell.UI.Spinner.hide();
        };
        ExperimentListView.prototype.getExperimentCategory = function (experiment) {
            return experiment.Category ? experiment.Category : "user";
        };
        ExperimentListView.prototype._populateExperimentList = function (serviceExperiments) {
            $.observable(this._data).refresh(serviceExperiments.map(function (e) {
                return {
                    ExperimentId: e.ExperimentId,
                    Description: e.Description,
                    Creator: e.Creator,
                    CreationTime: e.Status.CreationTime,
                    StartTime: e.Status.StartTime,
                    EndTime: e.Status.EndTime,
                    StatusCode: e.Status.StatusCode,
                    etag: e.Etag,
                    // See cdm.gridViewNavigationFormatter
                    type: DataLabViews.ExperimentType.name,
                };
            }));
        };
        ExperimentListView.prototype.deleteConfirmation = function () {
            var _this = this;
            var confirmMessage = this._grid.wazDataGrid('getSelectedRows').length > 1 ? DataLab.LocalizedResources.confirmDeleteSelectedExperiments : DataLab.LocalizedResources.confirmDeleteSelectedExperiment;
            var confirmation = new Shell.UI.Notifications.Confirmation(confirmMessage, 'active');
            JSON.stringify(this._grid.wazDataGrid('getSelectedRows')[0].dataItem);
            confirmation.setActions([
                new Shell.UI.Notifications.Buttons.yes(function () {
                    Shell.Diagnostics.Telemetry.customEvent("DeleteSelectedExperimentYes", "ExperimentListView", JSON.stringify(_this._selectedRows));
                    _this.delete();
                }),
                new Shell.UI.Notifications.Buttons.no(function () {
                    Shell.Diagnostics.Telemetry.customEvent("DeleteSelectedExperimentNo", "ExperimentListView");
                    Shell.UI.Notifications.remove(confirmation);
                })
            ]);
            Shell.UI.Notifications.add(confirmation);
        };
        ExperimentListView.prototype.delete = function () {
            var _this = this;
            var rowsToDelete = [];
            this._selectedRows.forEach(function (row) {
                rowsToDelete.push(row);
                DataLab.Util.first(_this.listedExperiments, function (experiment, i) {
                    if (_this.listedExperiments[i].ExperimentId === row.dataItem.ExperimentId) {
                        _this.listedExperiments.splice(i, 1);
                        return true;
                    }
                    else {
                        return false;
                    }
                }, null);
            });
            var deletePromises = [];
            var failed = false;
            rowsToDelete.forEach(function (row) {
                deletePromises.push(_this._workspace.deleteExperimentAndAncestorsAsync(row.dataItem.ExperimentId, row.dataItem.etag));
            });
            $.when.apply($, deletePromises).fail(function () {
                failed = true;
            }).always(function () {
                if (failed) {
                    _this.refreshFromService();
                }
                else {
                    _this.refreshFromLocal(_this.listedExperiments);
                }
            });
            this._selectedRows = [];
        };
        // we assume that non-local workspaces are global
        ExperimentListView.prototype._isGlobalWorkspaceId = function (workspaceId) {
            return workspaceId && workspaceId !== this._workspace.id;
        };
        ExperimentListView.prototype._isUserWorkspaceId = function (workspaceId) {
            return workspaceId && workspaceId === this._workspace.id;
        };
        return ExperimentListView;
    })();
    DataLabViews.ExperimentListView = ExperimentListView;
    ;
})(DataLabViews || (DataLabViews = {}));

/// <reference path="../Typescript/Global.ts" />
/// <reference path="ExperimentView.ts" />
/// <reference path="../Typescript/ViewModel/ExperimentEditor/ExperimentViewModel.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var DataLabViews;
(function (DataLabViews) {
    // using CSS to set the width of columns in wazDataGrid is glitchy
    // for equally spaced columns, leave these emtpy
    var gridColumnWidths = {
        Creator: "120px",
        Status: "100px",
        Date: "150px",
        Button: "70px"
    };
    var GridItemType;
    (function (GridItemType) {
        GridItemType[GridItemType["IExperimentInfo"] = 0] = "IExperimentInfo";
        GridItemType[GridItemType["IWebServiceGroup"] = 1] = "IWebServiceGroup";
    })(GridItemType || (GridItemType = {}));
    var Filter = {
        LastModified: "lastModified",
        LastRun: "lastRun",
        LastPublished: "lastPublished"
    };
    // creates a button formatter with given caption and callback for fxGrid columns
    function createButtonFormatter(htmlContent, callback, cssClass) {
        if (cssClass === void 0) { cssClass = ""; }
        var classDefinition = cssClass ? ' class="' + cssClass + '"' : "";
        var button = $('<div' + classDefinition + '>' + htmlContent + '</div>');
        // formatter reference:
        //     function formatter(value, { dataItem, rowMetadata, columnDefinition, rowNumber, columnNumber, filter }) { } (default function default 'return value || ""').
        return function (value, data) {
            return button.clone().click(function (event) {
                if (data.dataItem && callback) {
                    callback(data.dataItem);
                }
            });
        };
    }
    var PREVIEW_ICON_MARKUP = '<img src="/Libraries/Images/preview_24.svg" alt="' + DataLab.LocalizedResources.recentWorkPreview + '">';
    var LastEditExperimentGrid = (function (_super) {
        __extends(LastEditExperimentGrid, _super);
        function LastEditExperimentGrid(gridContainer, selection) {
            var _this = this;
            _super.call(this);
            this._logEventTag = "lastEdit";
            this._data = [];
            var previewButtonFormatter = createButtonFormatter(PREVIEW_ICON_MARKUP, function (dataItem) {
                Shell.Diagnostics.Telemetry.featureUsage(33 /* PreviewExperiment */, 0, null, dataItem && dataItem.ExperimentId, null, null);
                if (!selection() || dataItem !== selection().dataItem) {
                    selection({ dataItem: dataItem, Type: 0 /* IExperimentInfo */ });
                }
            }, "button");
            var grid = gridContainer.wazDataGrid({
                columns: [
                    { name: DataLab.LocalizedResources.recentWorkPreview, formatter: previewButtonFormatter, sortable: false, filterable: false, width: gridColumnWidths.Button, cssClass: "buttonColumn" },
                    { name: DataLab.LocalizedResources.experimentGridHeaderName, field: "Description", sortable: false, filterable: true, cssClass: "navigationColumn" },
                    { name: DataLab.LocalizedResources.experimentGridHeaderCreator, field: "Creator", sortable: false, filterable: true, width: gridColumnWidths.Creator, cssClass: "navigationColumn" },
                    { name: DataLab.LocalizedResources.experimentGridHeaderStatus, field: "StatusCode", sortable: false, filterable: true, width: gridColumnWidths.Status, cssClass: "navigationColumn" },
                    { name: DataLab.LocalizedResources.experimentGridHeaderSaveTime, field: "CreationTime", formatter: DataLab.Util.formatDate, sortable: false, filterable: false, width: gridColumnWidths.Date, cssClass: "navigationColumn" },
                ],
                data: this._data,
                selectable: false,
                multiselect: false,
                resizable: true,
                noRows: DataLab.LocalizedResources.recentWorkNoRows,
                pagerOptions: { pageSize: RecentWorkView.MAXRESULTS }
            });
            // open experiment on row click
            grid.on("click", ".navigationColumn", function (event) {
                var row = $(event.target).closest("tr").view().data;
                if (row.rowMetadata) {
                    var experimentId = row.rowMetadata.dataItem.ExperimentId;
                    Shell.Diagnostics.Telemetry.customEvent(_this._logEventTag, "OpeningExperiment", experimentId);
                    DataLabViews.navigateToExperiment(experimentId);
                }
            });
        }
        // replace all the rows
        LastEditExperimentGrid.prototype.update = function (items) {
            $.observable(this._data).refresh(items.map(function (e) {
                return {
                    ExperimentId: e.ExperimentId,
                    Description: e.Description,
                    Creator: e.Creator,
                    CreationTime: e.Status.CreationTime,
                    StatusCode: e.Status.StatusCode,
                    etag: e.Etag,
                };
            }));
        };
        return LastEditExperimentGrid;
    })(DataLab.Util.Disposable);
    var LastRunExperimentGrid = (function (_super) {
        __extends(LastRunExperimentGrid, _super);
        function LastRunExperimentGrid(gridContainer, selection) {
            var _this = this;
            _super.call(this);
            this._logEventTag = "lastRun";
            this._data = [];
            var previewButtonFormatter = createButtonFormatter(PREVIEW_ICON_MARKUP, function (dataItem) {
                Shell.Diagnostics.Telemetry.featureUsage(33 /* PreviewExperiment */, 0, null, dataItem && dataItem.ExperimentId, null, null);
                if (!selection() || dataItem !== selection().dataItem) {
                    selection({ dataItem: dataItem, Type: 0 /* IExperimentInfo */ });
                }
            }, "button");
            var grid = gridContainer.wazDataGrid({
                columns: [
                    { name: DataLab.LocalizedResources.recentWorkPreview, formatter: previewButtonFormatter, sortable: false, filterable: false, width: gridColumnWidths.Button, cssClass: "buttonColumn" },
                    { name: DataLab.LocalizedResources.experimentGridHeaderName, field: "Description", sortable: false, filterable: true, cssClass: "navigationColumn" },
                    { name: DataLab.LocalizedResources.experimentGridHeaderCreator, field: "Creator", sortable: false, filterable: true, width: gridColumnWidths.Creator, cssClass: "navigationColumn" },
                    { name: DataLab.LocalizedResources.experimentGridHeaderStatus, field: "StatusCode", sortable: false, filterable: true, width: gridColumnWidths.Status, cssClass: "navigationColumn" },
                    { name: DataLab.LocalizedResources.experimentGridHeaderStartTime, field: "StartTime", formatter: DataLab.Util.formatDate, sortable: false, filterable: false, width: gridColumnWidths.Date, cssClass: "navigationColumn" },
                    { name: DataLab.LocalizedResources.experimentGridHeaderEndTime, field: "EndTime", formatter: DataLab.Util.formatDate, sortable: false, filterable: false, width: gridColumnWidths.Date, cssClass: "navigationColumn" },
                ],
                data: this._data,
                selectable: false,
                multiselect: false,
                resizable: true,
                noRows: DataLab.LocalizedResources.recentWorkNoRows,
                pagerOptions: { pageSize: RecentWorkView.MAXRESULTS }
            });
            // open experiment on row click
            grid.on("click", ".navigationColumn", function (event) {
                var row = $(event.target).closest("tr").view().data;
                if (row.rowMetadata) {
                    var experimentId = row.rowMetadata.dataItem.ExperimentId;
                    Shell.Diagnostics.Telemetry.customEvent(_this._logEventTag, "OpeningExperiment", experimentId);
                    DataLabViews.navigateToExperiment(experimentId);
                }
            });
        }
        LastRunExperimentGrid.prototype.update = function (items) {
            $.observable(this._data).refresh(items.map(function (e) {
                return {
                    ExperimentId: e.ExperimentId,
                    Description: e.Description,
                    Creator: e.Creator,
                    StartTime: e.Status.StartTime,
                    EndTime: e.Status.EndTime,
                    StatusCode: e.Status.StatusCode,
                    etag: e.Etag,
                };
            }));
        };
        return LastRunExperimentGrid;
    })(DataLab.Util.Disposable);
    var LastPublishedExperimentGrid = (function (_super) {
        __extends(LastPublishedExperimentGrid, _super);
        function LastPublishedExperimentGrid(gridContainer, selection) {
            var _this = this;
            _super.call(this);
            this._logEventTag = "lastPublished";
            this._data = [];
            var previewButtonFormatter = createButtonFormatter(PREVIEW_ICON_MARKUP, function (dataItem) {
                Shell.Diagnostics.Telemetry.featureUsage(34 /* PreviewWebServiceGroup */, 0, null, dataItem && dataItem.Id, null, null);
                if (!selection() || dataItem !== selection().dataItem) {
                    selection({ dataItem: dataItem, Type: 1 /* IWebServiceGroup */ });
                }
            }, "button");
            var grid = gridContainer.wazDataGrid({
                columns: [
                    { name: DataLab.LocalizedResources.recentWorkPreview, formatter: previewButtonFormatter, sortable: false, filterable: false, width: gridColumnWidths.Button, cssClass: "buttonColumn" },
                    { name: DataLab.LocalizedResources.recentWorkLastPublishedHeaderName, field: "Name", sortable: false, filterable: true, cssClass: "navigationColumn" },
                    { name: DataLab.LocalizedResources.recentWorkLastPublishedHeaderCreationTime, field: "CreationTime", sortable: false, filterable: false, cssClass: "navigationColumn" },
                ],
                data: this._data,
                selectable: false,
                multiselect: false,
                resizable: true,
                noRows: DataLab.LocalizedResources.recentWorkNoRows,
                pagerOptions: { pageSize: RecentWorkView.MAXRESULTS }
            });
            // open web service group on row click
            grid.on("click", ".navigationColumn", function (event) {
                var row = $(event.target).closest("tr").view().data;
                if (row.rowMetadata) {
                    var webServiceGroupId = row.rowMetadata.dataItem.Id;
                    Shell.Diagnostics.Telemetry.customEvent(_this._logEventTag, "OpeningWebServiceGroup", webServiceGroupId);
                    DataLabViews.navigateToWebService(webServiceGroupId);
                }
            });
        }
        LastPublishedExperimentGrid.prototype.update = function (items) {
            $.observable(this._data).refresh(items.map(function (e) {
                return {
                    Id: e.Id,
                    Name: e.Name,
                    CreationTime: DataLab.Util.formatDate(DataLab.Util.parseJsonDate(e.CreationTime)),
                };
            }));
        };
        return LastPublishedExperimentGrid;
    })(DataLab.Util.Disposable);
    // this class is a simple wrapper/adapter so that the VM can be applied to the EditorSurfaceTemplate
    var ExperimentThumbnail = (function (_super) {
        __extends(ExperimentThumbnail, _super);
        function ExperimentThumbnail(experiment, workspace) {
            _super.call(this);
            var viewModel = new ExperimentEditor.ExperimentViewModel(experiment, workspace);
            this.registerForDisposal(viewModel);
            this.experimentViewModel = ko.observable(viewModel);
        }
        return ExperimentThumbnail;
    })(DataLab.Util.Disposable);
    DataLabViews.ExperimentThumbnail = ExperimentThumbnail;
    var RecentWorkView = (function (_super) {
        __extends(RecentWorkView, _super);
        function RecentWorkView(renderArea, workspace) {
            var _this = this;
            _super.call(this);
            this.renderThumbnail = true; // flag to use EditorSurfaceTemplate for generating the SVG
            this.loading = ko.observable(false); // for experiment preview spinner
            this._renderArea = renderArea.get(0);
            this._experiments = ko.observable([]);
            this._webServiceGroups = ko.observable([]);
            this._workspace = workspace;
            this.thumbnail = ko.observable();
            this._selectedItem = ko.observable();
            this.thumbnailSize = ko.observable("normal");
            // append the template generated mark-up to our page container
            this.registerForDisposal(new DataLab.Util.DisposableSetHTML(this._renderArea, ExperimentEditor._editorSurfaceMarkup + ExperimentEditor._recentWorkMarkup));
            this.setupFilterSelector();
            this.setupThumbnailSizeSelector(renderArea);
            // filter-out experiments not from our own workspace (e.g. sample experiments)
            var myExperiments = ko.computed(function () { return $.grep(_this._experiments() || [], function (experiment) {
                var experimentWorkspaceId = experiment.ExperimentId.split(".")[0];
                return experimentWorkspaceId === workspace.id;
            }, false); });
            // for all three grids, we sort the experiment list, display the result on the grid, and updates the thumbnail svg when a row is selected
            // grid for last edited experiments
            var sortedByLastEdit = ko.computed(function () {
                return myExperiments().slice(0).sort(RecentWorkView._compareEditDate);
            });
            var gridLastEdit = new LastEditExperimentGrid(renderArea.find(RecentWorkView.LASTEDITCONTAINER), this._selectedItem);
            this.registerForDisposal(gridLastEdit);
            sortedByLastEdit.subscribe(function (newItems) {
                gridLastEdit.update(newItems);
            });
            // grid for last run experiments
            var sortedByLastRun = ko.computed(function () {
                return $.grep(myExperiments(), function (value, index, array) {
                    return value.Status.StatusCode != DataLab.DataContract.State.InDraft && value.Status.StatusCode != DataLab.DataContract.State.NotStarted;
                }, false).sort(RecentWorkView._compareRunDate);
            });
            var gridLastRun = new LastRunExperimentGrid(renderArea.find(RecentWorkView.LASTRUNCONTAINER), this._selectedItem);
            this.registerForDisposal(gridLastRun);
            sortedByLastRun.subscribe(function (newItems) {
                gridLastRun.update(newItems);
            });
            // grid for last published experiments
            var sortedByLastPublish = ko.computed(function () {
                return _this._webServiceGroups() && _this._webServiceGroups().slice(0).sort(RecentWorkView._comparePublishDate) || [];
            });
            var gridLastPublish = new LastPublishedExperimentGrid(renderArea.find(RecentWorkView.LASTPUBLISHEDCONTAINER), this._selectedItem);
            this.registerForDisposal(gridLastPublish);
            sortedByLastPublish.subscribe(function (newItems) {
                gridLastPublish.update(newItems);
            });
            // watch for changes in current selected experiment for preview and update thumbnail accordingly
            // (waits for all caches to be ready first)
            ko.computed(function () {
                if (_this._workspace.applicationCache.allPrefetched() && _this._selectedItem()) {
                    _this._renderThumbnail(_this._selectedItem, _this.thumbnail, renderArea.find(RecentWorkView.THUMBNAIL));
                }
            });
            // thumbnail title stores the name/description of the current experiment thumbnail
            this.thumbnailTitle = ko.computed(function () {
                var selection = _this._selectedItem();
                if (selection) {
                    if (selection.Type === 0 /* IExperimentInfo */) {
                        return selection.dataItem.Description;
                    }
                    else if (selection.Type === 1 /* IWebServiceGroup */) {
                        return selection.dataItem.Name;
                    }
                }
                return null;
            });
            // watches the experiment list and autoselects the first experiment for preview
            var initialPreviewSubscription = ko.computed(function () {
                var list = [];
                var type = 0 /* IExperimentInfo */;
                switch (_this.selectedFilter()) {
                    case Filter.LastModified:
                        list = sortedByLastEdit();
                        break;
                    case Filter.LastRun:
                        list = sortedByLastRun();
                        break;
                    case Filter.LastPublished:
                        list = sortedByLastPublish();
                        type = 1 /* IWebServiceGroup */;
                        break;
                }
                if (list[0]) {
                    _this._selectedItem({ dataItem: list[0], Type: type });
                }
            }, this, { disposeWhen: function () { return _this._selectedItem(); } });
            this.registerForDisposal(new DataLab.Util.DisposableKOApplyBindings(this, this._renderArea));
            cdm.setActiveItem(this);
        }
        RecentWorkView.prototype.thumbnailOnClick = function () {
            var selection = this._selectedItem();
            if (selection) {
                switch (selection.Type) {
                    case 0 /* IExperimentInfo */:
                        DataLabViews.navigateToExperiment(selection.dataItem.ExperimentId);
                        break;
                    case 1 /* IWebServiceGroup */:
                        DataLabViews.navigateToWebService(selection.dataItem.Id);
                        break;
                    default:
                        Shell.Diagnostics.Telemetry.customEvent("RecentWork", "Unknown GridItemType", selection.Type);
                        break;
                }
            }
        };
        RecentWorkView.prototype.refreshFromService = function () {
            var _this = this;
            // grab list of experiments and web service groups
            Shell.UI.Spinner.show();
            var filter = { includeNonLeaf: false, includeArchived: false };
            var listExperimentsPromise = DataLab.Util.then(this._workspace.listExperimentsAsync(filter), function (experiments) {
                if (cdm.currentActiveItem instanceof DataLabViews.RecentWorkView) {
                    _this._experiments(experiments);
                }
            });
            var listWebServiceGroupsPromise = DataLab.Util.then(this._workspace.listWebServiceGroupsAsync(), function (serviceGroups) {
                if (cdm.currentActiveItem instanceof DataLabViews.RecentWorkView) {
                    _this._webServiceGroups(serviceGroups);
                }
            });
            $.when(listExperimentsPromise, listWebServiceGroupsPromise).fail(function () {
                Shell.Diagnostics.Telemetry.customEvent("RecentWork", "LoadingExperimentsFailed", _this._workspace.id);
                var notification = new Shell.UI.Notifications.Notification(DataLab.LocalizedResources.recentWorkListExperimentsFailure, 'error');
                notification.setActions([
                    new Shell.UI.Notifications.Buttons.close(function () {
                        Shell.UI.Notifications.remove(notification);
                    })
                ]);
                Shell.UI.Notifications.add(notification);
            }).always(function () {
                if (cdm.currentActiveItem instanceof DataLabViews.RecentWorkView) {
                    Shell.UI.Spinner.hide();
                    DataLab.Performance.intervalEnd();
                }
            });
        };
        // we assume that non-local workspaces are global
        RecentWorkView.prototype._isGlobalWorkspaceId = function (workspaceId) {
            return workspaceId && workspaceId !== this._workspace.id;
        };
        // helper func for array sorting, compares modification times
        RecentWorkView._compareEditDate = function (left, right) {
            if (left.Status.CreationTime > right.Status.CreationTime) {
                return -1;
            }
            if (left.Status.CreationTime < right.Status.CreationTime) {
                return 1;
            }
            return 0;
        };
        // helper func for array sorting, compares experiment run start times
        RecentWorkView._compareRunDate = function (left, right) {
            if (left.Status.StartTime > right.Status.StartTime) {
                return -1;
            }
            if (left.Status.StartTime < right.Status.StartTime) {
                return 1;
            }
            return 0;
        };
        // helper func for array sorting, compares publish date
        RecentWorkView._comparePublishDate = function (left, right) {
            if (left.CreationTime > right.CreationTime) {
                return -1;
            }
            if (left.CreationTime < right.CreationTime) {
                return 1;
            }
            return 0;
        };
        // scale and center to fit the whole contained-svg inside the container
        RecentWorkView._fitSvg = function (container) {
            var padding = 5;
            if (container) {
                var svg = container.find("svg");
                var g = svg.find("g");
                if (g.length > 0) {
                    var bbox = g[0].getBBox();
                    var newViewBox = (bbox.x - padding).toString() + " " + (bbox.y - padding) + " " + (bbox.width + 2 * padding) + " " + (bbox.height + 2 * padding);
                    svg[0].setAttribute("viewBox", newViewBox);
                }
            }
        };
        RecentWorkView.prototype._getExperimentIdAsync = function (item) {
            var deferred = $.Deferred();
            if (!item) {
                deferred.reject();
            }
            else {
                switch (item.Type) {
                    case 0 /* IExperimentInfo */:
                        deferred.resolve(item.dataItem.ExperimentId);
                        break;
                    case 1 /* IWebServiceGroup */:
                        DataLab.Util.then(this._workspace.getWebServiceGroupAsync(item.dataItem.Id), function (webServiceGroup) {
                            if (webServiceGroup.ModelPackages.length > 0) {
                                deferred.resolve(webServiceGroup.ModelPackages[0].LinkedExperimentId);
                            }
                            else {
                                deferred.reject();
                            }
                        }, function () { return deferred.reject(); });
                        break;
                    default:
                        Shell.Diagnostics.Telemetry.customEvent("RecentWork", "Unknown GridItemType", item.Type);
                        deferred.reject();
                        break;
                }
            }
            return deferred.promise();
        };
        // obtains the experiment from service and prepares a view model to be rendered by the thumbnail template
        RecentWorkView.prototype._renderThumbnail = function (selection, thumbnail, svgContainer) {
            var _this = this;
            var currentItem = selection();
            if (currentItem) {
                this.loading(true); // show spinner
                var failHandler = function () {
                    _this.loading(false);
                };
                var experimentIdPromise = DataLab.Util.then(this._getExperimentIdAsync(currentItem), this._workspace.getExperimentAsync.bind(this._workspace), failHandler);
                DataLab.Util.then(experimentIdPromise, function (experiment) {
                    // skip thumbnail update if the user selected something else while fetching the experiment
                    if (cdm.currentActiveItem instanceof RecentWorkView && selection() === currentItem) {
                        var newThumbnail = new ExperimentThumbnail(experiment, _this._workspace);
                        _this.registerForDisposal(newThumbnail);
                        var previousThumbnail = thumbnail();
                        thumbnail(newThumbnail);
                        RecentWorkView._fitSvg(svgContainer);
                        _this.loading(false);
                        // previous thumbnail VM is no longer needed
                        if (previousThumbnail) {
                            previousThumbnail.dispose();
                            previousThumbnail = null;
                        }
                    }
                }, failHandler);
            }
        };
        RecentWorkView.prototype.setupFilterSelector = function () {
            var _this = this;
            var filters = [
                { text: DataLab.LocalizedResources.recentWorkLastEditedLabel, value: Filter.LastModified },
                { text: DataLab.LocalizedResources.recentWorkLastRunLabel, value: Filter.LastRun },
                { text: DataLab.LocalizedResources.recentWorkLastPublishedLabel, value: Filter.LastPublished }
            ];
            var initialFilter = filters[0];
            var onFilterChange = function (event, args) {
                Shell.Diagnostics.Telemetry.customEvent("RecentWork", "ExperimentFilterChanged", args.value.value);
                $("#filterSelector").fxRadio("setOriginalValue");
                _this.selectedFilter(args.value.value);
            };
            $("#filterSelector").fxRadio({
                values: filters,
                value: initialFilter,
                change: onFilterChange
            });
            this.selectedFilter = ko.observable(initialFilter.value);
        };
        RecentWorkView.prototype.setupThumbnailSizeSelector = function (renderArea) {
            var _this = this;
            // the values serve as CSS class IDs
            var sizes = [
                { text: DataLab.LocalizedResources.recentWorkSizeNormal, value: "sizeNormal" },
                { text: DataLab.LocalizedResources.recentWorkSizeBig, value: "sizeBig" }
            ];
            var initialSize = sizes[0];
            var onSizeChange = function (event, args) {
                Shell.Diagnostics.Telemetry.featureUsage(35 /* ThumbnailSize */, 0, null, null, null, args.value.value);
                $("#thumbnailSizeSelector").fxRadio("setOriginalValue");
                _this.thumbnailSize(args.value.value);
                RecentWorkView._fitSvg(renderArea.find(RecentWorkView.THUMBNAIL));
            };
            $("#thumbnailSizeSelector").fxRadio({
                values: sizes,
                value: initialSize,
                change: onSizeChange
            });
            this.thumbnailSize(initialSize.value);
        };
        RecentWorkView.MAXRESULTS = 12;
        RecentWorkView.LASTEDITCONTAINER = "#gridLastEdited";
        RecentWorkView.LASTRUNCONTAINER = "#gridLastRun";
        RecentWorkView.LASTPUBLISHEDCONTAINER = "#gridLastPublished";
        RecentWorkView.THUMBNAIL = "#thumbnail";
        return RecentWorkView;
    })(DataLab.Util.Disposable);
    DataLabViews.RecentWorkView = RecentWorkView;
})(DataLabViews || (DataLabViews = {}));

/// <reference path="../Typescript/Global.ts" />
/// <reference path="ExperimentView.ts" />
/// <reference path="ExperimentListView.ts" />
/// <reference path="RecentWorkView.ts" />
/// <reference path="../typescript/viewmodel/experimenteditor/CommunityHelpers.ts" />
/// <reference path="../Typescript/ViewModel/experimenteditor/UserWorkspaceHelpers.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var DataLabViews;
(function (DataLabViews) {
    var AllExperimentsView = (function (_super) {
        __extends(AllExperimentsView, _super);
        function AllExperimentsView(renderArea, workspace, client, userName, samplesOnly) {
            var _this = this;
            if (samplesOnly === void 0) { samplesOnly = false; }
            _super.call(this);
            this.renderThumbnail = true; // used in html template
            this._renderArea = renderArea;
            this._data = [];
            this.listedExperiments = [];
            this._workspace = workspace;
            this._client = client;
            this._userName = userName;
            this._samplesOnly = samplesOnly;
            this.selectedItems = ko.observableArray([]);
            this.itemsSelectedMessage = ko.computed(function () { return DataLab.Util.format(DataLab.LocalizedResources.experimentListItemsSelectedMessage, _this.selectedItems().length.toString()); });
            this.pageLoaded = ko.observable(false);
            // load template used for rendering thumbnail
            this.registerForDisposal(new DataLab.Util.DisposableSetHTML(this._renderArea.get(0), ExperimentEditor._editorSurfaceMarkup + ExperimentEditor._allExperimentsMarkup));
            this.formatCheckbox = function (value, rowInfo) {
                var userWorkspaceExperiment = rowInfo.rowMetadata.dataItem.ExperimentId.split(".")[0] === _this._workspace.id;
                // We disable the checkboxes if the workspace of the experiment does not match
                // the current workspace. This allows us to prevent users from deleting experiments in the global
                // workspace.
                if (userWorkspaceExperiment) {
                    return "<input type='checkbox' class='rowCheckbox' />";
                }
                else {
                    return "<input type='checkbox' class='rowCheckbox' disabled='true' />";
                }
            };
            // We use wazDataGrid rather than the freestanding fxDataGrid since wazDataGrid supports the 'navigation' type,
            // which integrates with the shell's nav using item type and id.
            var columns = [
                {
                    name: DataLab.LocalizedResources.experimentGridHeaderName,
                    field: "Description",
                    sorted: samplesOnly ? "ascending" : undefined,
                    type: "navigationLink",
                    navigationField: "ExperimentId",
                    width: AllExperimentsView._GRID_COLUMN_WIDTHS.Description
                },
                {
                    name: DataLab.LocalizedResources.experimentGridHeaderCreator,
                    field: "Creator",
                    width: AllExperimentsView._GRID_COLUMN_WIDTHS.Creator
                },
                {
                    name: DataLab.LocalizedResources.experimentGridHeaderStatus,
                    field: "StatusCode",
                    formatter: DataLabViews.formatExperimentStatusCode,
                    width: AllExperimentsView._GRID_COLUMN_WIDTHS.Status
                },
                {
                    name: DataLab.LocalizedResources.experimentGridHeaderModificationTime,
                    field: "CreationTime",
                    formatter: DataLab.Util.formatDate,
                    sorted: samplesOnly ? undefined : "descending",
                    sortFormatter: DataLabViews.dateTimeSortFormatter,
                    width: AllExperimentsView._GRID_COLUMN_WIDTHS.Date
                }
            ];
            if (!samplesOnly) {
                var checkboxColumn = { name: "", field: "Checkbox", formatter: this.formatCheckbox, cssClass: "checkboxColumn", sortable: false, filterable: false, width: AllExperimentsView._GRID_COLUMN_WIDTHS.Button };
                columns = $.merge([checkboxColumn], columns);
            }
            this._grid = null;
            this._gridOptions = {
                columns: columns,
                data: this._data,
                selectable: true,
                selectFirstRowByDefault: true,
                multiselect: false,
                resizable: true,
                noRows: DataLab.LocalizedResources.allExperimentsNoRows,
                rowSelect: function (evt, args) { return _this.rowSelect(evt, args); },
                pagerOptions: {
                    pageSize: AllExperimentsView._PAGE_SIZE
                },
                filterQueryDelay: AllExperimentsView._GRID_SEARCH_DELAY
            };
            this._selectedExperiment = ko.observable();
            this.thumbnail = ko.observable();
            this.loading = ko.observable(false);
            this.registerForDisposal(new DataLab.Util.DisposableSubscription(this._selectedExperiment.subscribe(function (oldSelection) {
                _this._previousSelectedExperiment = oldSelection;
            }, null, "beforeChange")));
            this.registerForDisposal(new DataLab.Util.DisposableSubscription(this._selectedExperiment.subscribe(function (currentSelection) {
                if (!currentSelection) {
                    _this.thumbnail(null);
                    _this._getSelectedExperimentPromise = null;
                }
                else if (currentSelection !== _this._previousSelectedExperiment) {
                    Shell.Diagnostics.Telemetry.featureUsage(33 /* PreviewExperiment */, 0, null, currentSelection.ExperimentId, null, null);
                    _this.loading(true);
                    var failureHandler = function () {
                        if (cdm.currentActiveItem === _this) {
                            _this.loading(false);
                        }
                    };
                    _this._getSelectedExperimentPromise = DataLab.Util.whenTrue(_this._workspace.applicationCache.allPrefetched, _this).pipe(function () {
                        return _this._workspace.getExperimentAsync(currentSelection.ExperimentId);
                    });
                    _this._getSelectedExperimentPromise.done(function (experiment) {
                        if (cdm.currentActiveItem === _this && _this._selectedExperiment() === currentSelection) {
                            try {
                                var vm = new DataLabViews.ExperimentThumbnail(experiment, _this._workspace);
                                _this.registerForDisposal(vm);
                                _this.thumbnail(vm);
                                _this.fitSvg();
                            }
                            catch (error) {
                                DataLab.Log.exception(error, "Preview of experiment failed", "AllExperimentsView.constructor", { id: currentSelection.ExperimentId });
                            }
                            ;
                        }
                    }).fail($.noop).always(failureHandler);
                }
                _this._previousSelectedExperiment = null;
            })));
            this.registerForDisposal(new DataLab.Util.DisposableKOApplyBindings(this, this._renderArea.get(0)));
            cdm.setActiveItem(this);
            this.registerForDisposal(new DataLab.Util.DisposableEventListener(window, "resize", function () {
                if (_this.thumbnail()) {
                    _this.fitSvg();
                }
            }));
        }
        AllExperimentsView.prototype.refreshExperimentListFromService = function () {
            var _this = this;
            Shell.UI.Spinner.show();
            var filter = { includeNonLeaf: false, includeArchived: false };
            DataLab.Util.then(this._workspace.listExperimentsAsync(filter), function (experiments) {
                if (cdm.currentActiveItem instanceof DataLabViews.AllExperimentsView) {
                    DataLab.Performance.intervalEnd();
                    if (_this._samplesOnly) {
                        _this.listedExperiments = $.grep(experiments, function (value) { return _this._isGlobalWorkspaceId(value.ExperimentId.split('.')[0]); }, false);
                        _this.listedExperiments = _this.listedExperiments.filter(function (experiment) {
                            return experiment.Description === DataLab.Constants.GuidedExperimentDescription ? false : true;
                        });
                    }
                    else {
                        _this.listedExperiments = $.grep(experiments, function (value) { return _this._isUserWorkspaceId(value.ExperimentId.split('.')[0]); }, false);
                    }
                    _this._populateExperimentList(_this.listedExperiments);
                    if (!_this._grid) {
                        // grid created after populating data so that selectFirstRowByDefault has something to select
                        _this.createGrid(_this._gridOptions);
                        _this.pageLoaded(true);
                    }
                    Shell.UI.Spinner.hide();
                }
            });
        };
        AllExperimentsView.prototype.refreshFromService = function () {
            this.refreshExperimentListFromService();
            this.handleExperimentUnpackIfNecessary();
        };
        AllExperimentsView.prototype.handleExperimentUnpackIfNecessary = function () {
            var _this = this;
            var shouldUnpack = false;
            var startingURL = window.location.href;
            shouldUnpack = DataLab.Util.getQueryParamValueAndRemoveIfPresent("unpackConfirmation");
            var packageUri = DataLab.Util.getQueryParamValueAndRemoveIfPresent("packageUri");
            var communityUri = DataLab.Util.getQueryParamValueAndRemoveIfPresent("communityUri");
            if (shouldUnpack && (!packageUri || !communityUri)) {
                shouldUnpack = false;
                DataLab.Log.error("Malformed unpack URL: " + startingURL);
            }
            if (shouldUnpack) {
                var shouldSkipUnpackConfirmation = DataLab.Trial.isWorkspaceTypeAnonymous();
                packageUri = decodeURIComponent(packageUri);
                communityUri = decodeURIComponent(communityUri);
                Shell.UI.Spinner.show();
                if (shouldSkipUnpackConfirmation) {
                    ExperimentEditor.CopyExperimentFromGalleryDialogViewModel.copyExperiment(packageUri, communityUri, { WorkspaceId: DataLab.Workspace.id, FriendlyName: DataLab.Workspace.friendlyName }).always(Shell.UI.Spinner.hide);
                }
                else {
                    ExperimentEditor.UserWorkspacesHelper.getUserWorkspaces().done(function () {
                        var CopyExperimentFromGalleryDialogViewModel = new ExperimentEditor.CopyExperimentFromGalleryDialogViewModel(packageUri, communityUri);
                        Shell.Diagnostics.Telemetry.customEvent("CopyExperimentFromGalleryDialogOpened", "AllExperimentsView", JSON.stringify(_this.selectedItems()));
                        ExperimentEditor.DialogViews.CopyExperimentFromGallery.show(CopyExperimentFromGalleryDialogViewModel);
                    }).always(Shell.UI.Spinner.hide);
                }
            }
        };
        AllExperimentsView.prototype.setCommands = function () {
            var _this = this;
            if (!this._samplesOnly) {
                this.deleteCommand = new Shell.UI.Commands.Command("Delete", Shell.UI.Icons["delete"], this.deleteConfirmation.bind(this), null, true);
                Shell.UI.Commands.add([this.deleteCommand]);
                if (DataLab.Features.copyExperimentAcrossWorkspaceEnabled()) {
                    this.copyCommand = new Shell.UI.Commands.Command(DataLab.LocalizedResources.copyExperimentCommandName, Shell.UI.Icons.copy, this.copyDialog.bind(this), null, true);
                    var originalCopyCommand = this.copyCommand;
                    ExperimentEditor.UserWorkspacesHelper.getUserWorkspaces().done(function (workspaces) {
                        if (workspaces.length > 1 && _this.copyCommand === originalCopyCommand) {
                            _this.copyCommand.setDisabled(_this.selectedItems().length !== 1);
                            // This is called twice. Somehow the copy command gets added twice. To circumvent this we clear all commands and add them here.
                            Shell.UI.Commands.add([_this.copyCommand]);
                        }
                    }).fail(function () {
                    });
                }
            }
        };
        AllExperimentsView.isDeleteBlockedByDependencies = function (deleteError) {
            if (deleteError.error instanceof DataLab.Util.AjaxError) {
                var ajaxError = deleteError.error;
                return ajaxError.xmlHttpRequest.status === 409;
            }
            return false;
        };
        AllExperimentsView.formatDeleteError = function (deleteError) {
            if (AllExperimentsView.isDeleteBlockedByDependencies(deleteError)) {
                // specific error message for experiments published as web services not being deletable
                return DataLab.Util.format(DataLab.LocalizedResources.cantDeleteExperimentPartOfAWebService, deleteError.item.Description);
            }
            var message = deleteError.error.message;
            if (deleteError.error instanceof DataLab.Util.AjaxError) {
                var responseText = deleteError.error.xmlHttpRequest.responseText;
                message = responseText || message;
            }
            return DataLab.Util.format(DataLab.LocalizedResources.errorDeletingExperiment, deleteError.item.Description, message);
        };
        AllExperimentsView.prototype.createGrid = function (options) {
            var _this = this;
            this._grid = $(this._renderArea).find("#grid").wazDataGrid(options);
            this._grid.on("click", "tbody .checkboxColumn", function (event) {
                // allow the target row to be toggled
                _this._grid.wazDataGrid('option', 'multiselect', true);
            });
            // log the opening of experiments
            this._grid.on("click", ".waz-grid-navigation-link a", function (event) {
                var row = $(event.target).closest("tr").view().data;
                if (row.rowMetadata) {
                    var experimentId = row.rowMetadata.dataItem.ExperimentId;
                    Shell.Diagnostics.Telemetry.customEvent("experimentList", "OpeningExperiment", experimentId);
                }
            });
        };
        AllExperimentsView.prototype.refreshFromLocal = function (list) {
            Shell.UI.Spinner.show();
            this._populateExperimentList(list);
            Shell.UI.Spinner.hide();
        };
        AllExperimentsView.prototype._populateExperimentList = function (serviceExperiments) {
            $.observable(this._data).refresh(serviceExperiments.map(function (e) {
                return {
                    ExperimentId: e.ExperimentId,
                    Description: e.Description,
                    Creator: e.Creator,
                    CreationTime: e.Status.CreationTime,
                    StatusCode: e.Status.StatusCode,
                    etag: e.Etag,
                    // See cdm.gridViewNavigationFormatter
                    type: DataLabViews.ExperimentType.name
                };
            }));
        };
        AllExperimentsView.prototype.copyDialog = function () {
            var _this = this;
            if (this.selectedItems().length === 0) {
                return;
            }
            this._validateForCopyAsync().done(function () {
                var copyExperimentDialogViewModel = new ExperimentEditor.CopyExperimentDialogViewModel(_this.selectedItems()[0].Description, _this.selectedItems()[0].ExperimentId);
                Shell.Diagnostics.Telemetry.customEvent("CopyExperimentDialogOpened", "AllExperimentsView", JSON.stringify(_this.selectedItems()));
                ExperimentEditor.DialogViews.CopyExperiment.show(copyExperimentDialogViewModel);
            });
        };
        AllExperimentsView.prototype.deleteConfirmation = function () {
            var _this = this;
            var container = $('<div />', { class: "dependants-list" });
            var items = this.selectedItems().map(function (item) { return { name: item.Description }; });
            container.append(DataLabViews.createListOfDependants(items));
            var confirmMessage = this.selectedItems().length > 1 ? DataLab.Util.format(DataLab.LocalizedResources.confirmDeleteSelectedExperiments, this.selectedItems().length.toString()) : DataLab.LocalizedResources.confirmDeleteSelectedExperiment;
            var confirmation = new Shell.UI.Notifications.Confirmation(confirmMessage, 'active');
            confirmation.setDetailsUseHtml(true);
            confirmation.setDetailsText(container.get(0).outerHTML);
            confirmation.setActions([
                new Shell.UI.Notifications.Buttons.yes(function () {
                    Shell.Diagnostics.Telemetry.customEvent("DeleteSelectedExperimentYes", "AllExperimentsView", JSON.stringify(_this.selectedItems()));
                    _this.delete();
                }),
                new Shell.UI.Notifications.Buttons.no(function () {
                    Shell.Diagnostics.Telemetry.customEvent("DeleteSelectedExperimentNo", "AllExperimentsView");
                    Shell.UI.Notifications.remove(confirmation);
                })
            ]);
            Shell.UI.Notifications.add(confirmation);
        };
        // TODO: handle experiment dependencies (having a web service block deletion)
        AllExperimentsView.prototype.delete = function () {
            var _this = this;
            var itemsToDelete = [];
            this.selectedItems().forEach(function (item) {
                itemsToDelete.push(item);
                DataLab.Util.first(_this.listedExperiments, function (experiment, i) {
                    if (_this.listedExperiments[i].ExperimentId === item.ExperimentId) {
                        _this.listedExperiments.splice(i, 1);
                        return true;
                    }
                    else {
                        return false;
                    }
                }, null);
            });
            var deletePromises = [];
            var deleteErrors = []; // holds error messages for failed AJAX delete requests
            itemsToDelete.forEach(function (item) {
                var promise = _this._workspace.deleteExperimentAndAncestorsAsync(item.ExperimentId, item.etag);
                promise.fail(function (error) {
                    deleteErrors.push({ item: item, error: error });
                });
                // make the promise so it can't fail so that $.when waits for all of them to complete instead of stopping at first failure
                promise = DataLab.Util.then(promise, $.noop, function (ignored) { return DataLab.Util.when(null); });
                deletePromises.push(promise);
            });
            // TODO: handle when reaching here but context changed
            Shell.UI.Spinner.show();
            $.when.apply($, deletePromises).done(function () {
                if (deleteErrors.length > 0) {
                    // show each error message in the notification details
                    var title = itemsToDelete.length > 1 ? DataLab.Util.format(DataLab.LocalizedResources.failedToDeleteExperiments, deleteErrors.length.toString(), itemsToDelete.length.toString()) : DataLab.LocalizedResources.failedToDeleteExperiment;
                    var notification = new Shell.UI.Notifications.Notification(title, "error");
                    notification.setActions([Shell.UI.Notifications.Buttons.ok()]);
                    var list = $('<ul/>').addClass('bound-height');
                    deleteErrors.map(function (error) { return AllExperimentsView.formatDeleteError(error); }).forEach(function (message) {
                        $('<li/>').text(message).appendTo(list);
                    });
                    notification.setDetailsUseHtml(true);
                    notification.setDetailsText(list.get(0).outerHTML);
                    Shell.UI.Notifications.add(notification);
                }
            }).always(function () {
                if (cdm.getActiveItem() === _this) {
                    Shell.UI.Spinner.hide();
                    _this.selectedItems.removeAll();
                    if (deleteErrors.length > 0) {
                        _this.refreshFromService();
                    }
                    else {
                        _this.refreshFromLocal(_this.listedExperiments);
                    }
                }
            });
        };
        // we assume that non-local workspaces are global
        AllExperimentsView.prototype._isGlobalWorkspaceId = function (workspaceId) {
            return workspaceId && workspaceId !== this._workspace.id;
        };
        AllExperimentsView.prototype._isUserWorkspaceId = function (workspaceId) {
            return workspaceId && workspaceId === this._workspace.id;
        };
        AllExperimentsView.prototype.setPreviewMinimumHeight = function () {
            var pp = $(AllExperimentsView._PREVIEW_PANE_ID);
            var offset = pp.offset();
            // TFS 3898066 seen in telemetry where this can be null. happens when element is not found, or not attached to the document
            if (offset) {
                var body = $('#aux-body');
                var marginHeight = 100;
                var newHeight = $(window).height() - offset.top - marginHeight;
                newHeight = Math.max(newHeight, 0);
                pp.css('min-height', newHeight.toString() + "px");
            }
        };
        AllExperimentsView.prototype.fitSvg = function () {
            var svgContainer = $(this._renderArea).find(AllExperimentsView._SVG_CONTAINER_ID);
            if (svgContainer.length > 0) {
                this.setPreviewMinimumHeight();
                var svg = svgContainer.find("svg");
                var svgWidth = svg.width();
                var svgHeight = svg.height();
                var g = svg.find("g");
                if (g.length > 0 && svgWidth > 0 && svgHeight > 0) {
                    var bbox = g[0].getBBox();
                    if (bbox && bbox.width && bbox.height) {
                        var newViewBox = this.computeShrinkToFitViewBox(svgWidth, svgHeight, bbox, AllExperimentsView._SVG_MAX_ZOOM_IN_FACTOR);
                        svg[0].setAttribute("viewBox", newViewBox);
                    }
                }
            }
        };
        AllExperimentsView.prototype.previewExperiment = function (dataItem) {
            this._selectedExperiment(dataItem);
        };
        AllExperimentsView.prototype.computeShrinkToFitViewBox = function (containerWidth, containerHeight, bbox, zoomLimit) {
            var x = bbox.x;
            var y = bbox.y;
            var width = bbox.width;
            var height = bbox.height;
            // don't make small experiments too big in the preview
            var scaleRatio = Math.min(containerWidth / width, containerHeight / height);
            if (scaleRatio > zoomLimit) {
                var adjustment = scaleRatio / zoomLimit;
                width *= adjustment;
                height *= adjustment;
                x -= (width - bbox.width) / 2;
                y -= (height - bbox.height) / 2;
            }
            return x.toString() + " " + y + " " + width + " " + height;
        };
        AllExperimentsView.prototype.rowSelect = function (evt, args) {
            // reset multiselect in case it was enabled by using the checkboxes
            this._grid.wazDataGrid("option", "multiselect", false);
            // synchronize checkboxes with row selection
            var allCheckboxes = this._grid.find(".rowCheckbox");
            var displayedRowsMetadata = this._grid.find('tbody tr').toArray().map(function (row) { return $.view(row).data.rowMetadata; });
            var selectionChangesRowIndices = (args.unselected || []).map(function (row) { return displayedRowsMetadata.indexOf(row); });
            // if there is only one unselected item and its checkbox is selected, it is being selected again via the checkbox
            // and it should stay selected.
            if (args.unselected && args.unselected.length === 1 && !args.selected && allCheckboxes[selectionChangesRowIndices[0]].checked) {
                $.observable(args.unselected[0]).setProperty("selected", true);
            }
            if (args.selected) {
                selectionChangesRowIndices.push(displayedRowsMetadata.indexOf(args.selected));
            }
            selectionChangesRowIndices.filter(function (index) { return index >= 0 && index < allCheckboxes.length; }).forEach(function (index) {
                if (!displayedRowsMetadata[index].selected) {
                    allCheckboxes[index].checked = displayedRowsMetadata[index].selected;
                }
            });
            // If there are rows selected with check boxes, we need to unselect the row that does not have the checkbox checked.
            // Note allCheckboxes is a jQuery object. displayedRowsMetadata is a javascript array. Filter methods on the two are different.
            if (allCheckboxes.filter(function (index) { return allCheckboxes[index].checked; }).length > 0) {
                displayedRowsMetadata.filter(function (element, index) { return !allCheckboxes[index].checked && displayedRowsMetadata[index].selected; }).forEach(function (element) {
                    $.observable(element).setProperty("selected", false);
                });
            }
            // note: 'getSelectedRows' includes args.selected at this point
            var selectedRows = this._grid.wazDataGrid("getSelectedRows");
            this.selectedItems(selectedRows.map(function (row) { return row.dataItem; }));
            if (this.deleteCommand) {
                this.deleteCommand.setDisabled(this.selectedItems().length === 0);
            }
            if (this.copyCommand) {
                this.copyCommand.setDisabled(this.selectedItems().length !== 1);
            }
            if (this.selectedItems().length === 1) {
                this.previewExperiment(this.selectedItems()[0]);
            }
            else {
                // hide preview
                this.previewExperiment(null);
            }
        };
        // precondition: an experiment is selected
        AllExperimentsView.prototype._getSpaceUsedAsync = function () {
            var deferred = $.Deferred();
            if (this._getSelectedExperimentPromise) {
                this._getSelectedExperimentPromise.done(function (experiment) {
                    deferred.resolve(experiment.storageUsedByDatasets);
                }).fail(function (error) {
                    deferred.reject(error);
                });
            }
            else {
                deferred.resolve(0); // shouldn't happen, breaks precond
            }
            return deferred.promise();
        };
        // checks that selected experiment for copy-to-workspace doesn't exceed storage limits
        AllExperimentsView.prototype._validateForCopyAsync = function () {
            var _this = this;
            var deferred = $.Deferred();
            var title, details, notification;
            if (environment.copyToWorkspaceDatasetStorageLimit > 0) {
                this._getSpaceUsedAsync().done(function (spaceUsed) {
                    if (spaceUsed > environment.copyToWorkspaceDatasetStorageLimit) {
                        deferred.reject();
                        title = DataLab.Util.format(DataLab.LocalizedResources.copyExperiment_LargeDataset_Title, DataLab.Util.formatDataSize(environment.copyToWorkspaceDatasetStorageLimit));
                        notification = new Shell.UI.Notifications.Notification(title, "error");
                        notification.setActions([Shell.UI.Notifications.Buttons.close()]);
                        Shell.UI.Notifications.add(notification);
                        Shell.Diagnostics.Telemetry.customEvent("CopyExperimentExceedsMaxDatasetStorage", "AllExperimentsView", JSON.stringify({ spaceUsed: spaceUsed, selectedItems: _this.selectedItems() }));
                    }
                    else {
                        deferred.resolve();
                    }
                }).fail(function (error) {
                    // failed to perform validation
                    title = DataLab.Util.format(DataLab.LocalizedResources.copyExperiment_ValidationFailure_Title);
                    details = DataLab.Util.format(DataLab.LocalizedResources.copyExperiment_ValidationFailure_Details, error.message);
                    notification = new Shell.UI.Notifications.Notification(title, "error");
                    notification.setDetailsText(details);
                    notification.setActions([Shell.UI.Notifications.Buttons.close()]);
                    Shell.UI.Notifications.add(notification);
                    DataLab.Log.error("CopyExperimentValidationFailed", "AllExperimentsView", { selectedItems: _this.selectedItems(), message: error.message });
                    deferred.reject();
                });
            }
            else {
                deferred.resolve(); // no limit set
            }
            return deferred.promise();
        };
        AllExperimentsView._SVG_CONTAINER_ID = "#thumbnailContainer";
        AllExperimentsView._PREVIEW_PANE_ID = "#previewPane";
        AllExperimentsView._SVG_MAX_ZOOM_IN_FACTOR = 1;
        AllExperimentsView._PAGE_SIZE = 20;
        AllExperimentsView._GRID_COLUMN_WIDTHS = {
            Description: "",
            Creator: "",
            Status: "",
            Date: "",
            Button: ""
        };
        AllExperimentsView._GRID_SEARCH_DELAY = 160; // in ms
        return AllExperimentsView;
    })(DataLab.Util.Disposable);
    DataLabViews.AllExperimentsView = AllExperimentsView;
    ;
})(DataLabViews || (DataLabViews = {}));

/// <reference path="../Typescript/Global.ts" />
/// <reference path="ExperimentView.ts" />
var DataLabViews;
(function (DataLabViews) {
    var DataflowListView = (function () {
        function DataflowListView(renderArea, client) {
            this._renderArea = renderArea;
            this._data = [];
            this._client = client;
            this._grid = $(renderArea).find("#grid").wazDataGrid({
                columns: [
                    { name: "Name", field: "Description", type: "navigation", navigationField: "DataflowId" },
                    { name: "Id", field: "DataflowId" }
                ],
                data: this._data,
                selectable: true,
                multiselect: false,
                resizable: true,
            });
        }
        DataflowListView.prototype.refreshFromService = function () {
            var _this = this;
            Shell.UI.Spinner.show();
            this._client.listDataflowsAsync().done(function (d) {
                Shell.UI.Spinner.hide();
                _this._populateDataflowList(d);
            });
        };
        DataflowListView.prototype._populateDataflowList = function (serviceExperiments) {
            $.observable(this._data).refresh(serviceExperiments.map(function (e) {
                return {
                    Description: e.Description,
                    DataflowId: e.DataflowId,
                    // See cdm.gridViewNavigationFormatter
                    type: DataLabViews.DataflowType.name,
                };
            }));
        };
        return DataflowListView;
    })();
    DataLabViews.DataflowListView = DataflowListView;
})(DataLabViews || (DataLabViews = {}));

/// <reference path="../Typescript/Global.ts" />
/// <reference path="../Typescript/View/ExperimentEditorContainer.ts" />
/// <reference path="ExperimentView.ts" />
var DataLabViews;
(function (DataLabViews) {
    var DataflowView = (function () {
        function DataflowView(renderArea, dataflowId, workspace) {
            this._renderArea = renderArea;
            var rootExperimentContainer = document.querySelector("#ExperimentEditor");
            var graphFetcher = {
                loadFromService: function (id) {
                    return workspace.getDataflowAsync(id);
                }
            };
            this.xeViewModel = new ExperimentEditor.ExperimentEditorContainerViewModel(workspace, graphFetcher, dataflowId);
            this.xeControlContainer = new ExperimentEditor.ExperimentEditorContainer(rootExperimentContainer, this.xeViewModel);
            this.xeViewModel.registerNavigateToParentHandler(function (parentExperimentId) {
                if (parentExperimentId) {
                    DataLabViews.navigateToExperiment(parentExperimentId);
                }
            });
            // Set this view as the target of contextual commands (e.g. submit)
            cdm.setActiveItem(this);
            // Hide the page title (populated by AzureFX)
            document.querySelector("#tabcontainer .itemtitle").textContent = "";
        }
        DataflowView.prototype.dispose = function () {
            this.xeControlContainer.dispose();
            this.xeViewModel.dispose();
        };
        DataflowView.prototype.open = function () {
            var _this = this;
            var promise = this.xeViewModel.loadFromService();
            Shell.UI.Spinner.show();
            promise.done(function () {
                Shell.UI.Spinner.hide();
                // Set this view as the target of contextual commands (e.g. submit)
                cdm.setActiveItem(_this);
            });
        };
        return DataflowView;
    })();
    DataLabViews.DataflowView = DataflowView;
    ;
})(DataLabViews || (DataLabViews = {}));

/// <reference path="../Typescript/Global.ts" />
/// <reference path="../Typescript/ViewModel/Dialogs/ApiCodeDialogViewModel.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var DataLabViews;
(function (DataLabViews) {
    var DisposableSubscription = DataLab.Util.DisposableSubscription;
    var Notifications = Shell.UI.Notifications;
    var LocalizedResources = DataLab.LocalizedResources;
    ;
    var DatasetListView = (function (_super) {
        __extends(DatasetListView, _super);
        function DatasetListView(renderArea, workspace, client, options) {
            var _this = this;
            if (options === void 0) { options = null; }
            _super.call(this);
            this._selectedRows = ko.observableArray([]);
            this._commandsWereSet = false;
            this._renderArea = renderArea;
            this._data = [];
            this._client = client;
            this._options = $.extend({}, DatasetListView._defaultOptions, options);
            this._workspace = workspace;
            this._grid = $(renderArea).find("#grid");
            this._grid.fxDataGrid({
                columns: [
                    { name: "Name", field: "Name" },
                    { name: "Submitted By", field: "Owner" },
                    { name: "Description", field: "Description" },
                    { name: "Data Type", field: "DataTypeId" },
                    { name: "Created", field: "CreatedDate", formatter: DataLab.Util.formatDate, sorted: "descending" },
                    { name: "Size", field: "Size", formatter: waz.formatters.bytesFormatter, sortFormatter: function (value) { return value; } }
                ],
                data: this._data,
                selectable: true,
                multiselect: false,
                resizable: true,
                noRows: LocalizedResources.datasetsNoRows,
                rowSelect: function (evt, args) { return _this.onSelect(evt, args); },
                filterQueryDelay: 100 // TODO constant
            });
            this._downloadableTypeIds = Object.create(null);
            DataLab.Util.values(this._workspace.applicationCache.dataTypeRegistry.dataTypes).filter(function (type) { return type.allowUpload; }).forEach(function (type) { return _this._downloadableTypeIds[type.dataTypeId] = true; });
            this._downloader = new ExperimentEditor.EndpointDownloader();
            if (this._options.listSamples) {
                this._datasetFilter = function (dataset) { return dataset.isLatest() && dataset.familyId.lastIndexOf(workspace.id, 0) !== 0; };
            }
            else {
                this._datasetFilter = function (dataset) { return dataset.isLatest() && dataset.familyId.lastIndexOf(workspace.id, 0) === 0; };
            }
            this._isBusy = ko.observable(false);
            // Set this view as the target of contextual commands (e.g. dispose)
            cdm.setActiveItem(this);
            this._watchCacheChanges();
            this.populateDatasetList();
        }
        DatasetListView.prototype.populateDatasetList = function () {
            var _this = this;
            var allItems = DataLab.Util.values(this._workspace.datasetCache.items());
            var filteredItems = allItems.filter(function (item) { return _this._datasetFilter(item); });
            var rowsData = filteredItems.map(function (item) { return ({
                Owner: item.owner,
                Name: item.name(),
                Description: item.description(),
                DataTypeId: item.dataType.dataTypeId,
                CreatedDate: item.created,
                Id: item.id,
                FamilyId: item.familyId,
                DownloadLocation: item.downloadLocation,
                Dataset: item,
                Size: (item.downloadLocation && item.downloadLocation.Size) || 0
            }); });
            $.observable(this._data).refresh(rowsData);
        };
        DatasetListView.prototype.setCommands = function () {
            var _this = this;
            this._downloadCommand = new Shell.UI.Commands.Command("Download", Shell.UI.Icons.download, function () { return _this.downloadDataset(_this._selectedRows()[0]); }, null, true);
            Shell.UI.Commands.add(this._downloadCommand);
            if (!this._options.listSamples) {
                this._deleteCommand = new Shell.UI.Commands.Command("Delete", Shell.UI.Icons["delete"], function () { return _this.deleteResourceFamily(_this._selectedRows()[0]); }, null, true);
                Shell.UI.Commands.add(this._deleteCommand);
            }
            if (DataLab.Features.enableOutputPortApiCodeEnabled()) {
                this._apicodecopy = new Shell.UI.Commands.Command("Generate Data Access Code...", Shell.UI.Icons.copy, function () { return _this.apicodecopy(_this._selectedRows()[0]); }, null, true);
                Shell.UI.Commands.add(this._apicodecopy);
            }
            // command buttons state logic
            var singleSelected = ko.computed(function () { return _this._selectedRows().length === 1; });
            var hasWritePermission = ko.computed(function () { return _this._selectedRows().length > 0 && _this._selectedRows().every(function (dataset) { return dataset.Id.lastIndexOf(_this._client.workspaceId, 0) === 0; }); });
            var downloadDisabled = ko.computed(function () { return _this._isBusy() || !singleSelected() || !_this._selectedRows().every(function (dataset) { return _this._downloadableTypeIds[dataset.DataTypeId]; }); });
            var subscription = downloadDisabled.subscribe(function (value) { return _this._downloadCommand.setDisabled(value); });
            this.registerForDisposal(new DisposableSubscription(subscription));
            if (DataLab.Features.enableOutputPortApiCodeEnabled()) {
                var typesAvailableForApi = { PlainText: true, GenericCSV: true, GenericCSVNoHeader: true, GenericTSV: true, GenericTSVNoHeader: true };
                var apiCodeCopy = ko.computed(function () { return _this._isBusy() || !singleSelected() || !_this._selectedRows().every(function (dataset) { return typesAvailableForApi[dataset.DataTypeId]; }); });
                apiCodeCopy.subscribe(function (value) { return _this._apicodecopy.setDisabled(value); });
            }
            if (!this._options.listSamples) {
                var deleteDisabled = ko.computed(function () { return _this._isBusy() || !singleSelected() || !hasWritePermission(); });
                subscription = deleteDisabled.subscribe(function (value) { return _this._deleteCommand.setDisabled(value); });
                this.registerForDisposal(new DisposableSubscription(subscription));
            }
        };
        /* comamnd handlers */
        DatasetListView.prototype.apicodecopy = function (dataset) {
            var item = dataset.Dataset;
            this._workspace.getWorkspaceSettingsAsync().done(function (settings) {
                var dlg = new ExperimentEditor.ApiCodeDialogViewModel(item, settings.id, settings.authorizationToken);
                // Have to use showDialog helper rather than DialogViews
                // because the latter won't execute the JS we need.
                dlg.showDialog();
            }).fail(function () {
                var dlg = new ExperimentEditor.ApiCodeDialogViewModel(item, undefined, undefined);
                // Have to use showDialog helper rather than DialogViews
                // because the latter won't execute the JS we need.
                dlg.showDialog();
            });
        };
        DatasetListView.prototype.downloadDataset = function (dataset) {
            this._downloader.download(dataset.DownloadLocation);
        };
        DatasetListView.prototype.deleteResourceFamily = function (rowItem) {
            var _this = this;
            this.setBusy();
            // determine dependants & prompt to confirm operation
            var familyGuid = DatasetListView._extractFamilyGuid(rowItem.FamilyId);
            var getDependantsRequest = this._client.getResourceDependantsAsync(familyGuid);
            getDependantsRequest.always(function () { return _this.setBusy(false); });
            var confirmationPromise = DataLab.Util.then(getDependantsRequest, function (assetDependency) {
                var hardDependants = assetDependency.WebServiceGroups || [];
                if (hardDependants.length > 0) {
                    _this.showHardDependantsAsync(hardDependants);
                    return DataLab.Util.when(false);
                }
                else if (assetDependency.Experiments && assetDependency.Experiments.length > 0) {
                    // dependant experiments don't necessarily block deletion of resources
                    var dependants = assetDependency.Experiments.map(function (experiment) { return {
                        name: experiment.Description,
                        urlHash: Shell.UI.Navigation.calculateNavigationPath({ extension: DataLabViews.experimentExtensionName, type: "Experiment", name: experiment.ExperimentId, view: "ViewExperiment" }),
                    }; });
                    return _this.confirmDeletionWithSoftDependantsAsync(dependants);
                }
                return _this.confirmDeletetionAsync();
            });
            confirmationPromise.fail(function (error) {
                var notification = new Shell.UI.Notifications.Notification(DataLab.Util.format(LocalizedResources.deleteOperationFailed, error.message), "error");
                notification.setActions([Shell.UI.Notifications.Buttons.ok()]);
                Shell.UI.Notifications.add(notification);
            }).done(function (canProceed) {
                if (canProceed) {
                    var progress = new Notifications.Progress(LocalizedResources.deletingDataset, "active", true);
                    progress.setDismissable(true);
                    progress.setActions([Notifications.Buttons.close()]);
                    Notifications.add(progress);
                    var deleteRequest = _this._workspace.applicationCache.datasetCache.deleteFamily(rowItem.FamilyId);
                    deleteRequest.done(function () {
                        progress.setTitle(LocalizedResources.datasetDeleted);
                        progress.setStatus("success");
                    }).fail(function (error) {
                        progress.setTitle(DataLab.Util.format(LocalizedResources.deleteOperationFailed, error.message));
                        progress.setStatus("error");
                    });
                }
            });
        };
        DatasetListView.prototype.confirmDeletetionAsync = function () {
            var _this = this;
            var confirmMessage = LocalizedResources.confirmDeleteDataset;
            var confirmation = new Shell.UI.Notifications.Confirmation(confirmMessage, 'active');
            var deferred = $.Deferred();
            confirmation.setActions(Shell.UI.Notifications.ButtonSets.yesNo(function () {
                Shell.Diagnostics.Telemetry.customEvent("DeleteSelectedDatasetYes", "DatasetListView", JSON.stringify(_this._selectedRows));
                deferred.resolve(true);
            }, function () {
                Shell.Diagnostics.Telemetry.customEvent("DeleteSelectedDatasetNo", "DatasetListView");
                Shell.UI.Notifications.remove(confirmation);
                deferred.resolve(false);
            }));
            Shell.UI.Notifications.add(confirmation);
            return DataLab.Util.when(deferred.promise());
        };
        DatasetListView.prototype.confirmDeletionWithSoftDependantsAsync = function (items) {
            var deferred = $.Deferred();
            var container = $('<div />', { class: "dependants-list" });
            container.append(DataLabViews.createListOfDependants(items));
            var notification = new Shell.UI.Notifications.Confirmation(LocalizedResources.deleteDatasetDependenciesWarning, "active");
            notification.setDetailsUseHtml(true);
            notification.setDetailsText(container.get(0).outerHTML);
            notification.setActions(Shell.UI.Notifications.ButtonSets.yesNo(function () {
                deferred.resolve(true);
            }, function () {
                deferred.resolve(false);
            }));
            Shell.UI.Notifications.add(notification);
            return DataLab.Util.when(deferred.promise());
        };
        DatasetListView.prototype.showDependants = function (items) {
            var container = $('<div />', { class: "dependants-list" });
            container.append($('<p />').text(LocalizedResources.deleteDatasetBlockedByDependencies));
            container.append(DataLabViews.createListOfDependants(items, this._options.showDependantsLinks));
            var notification = new Shell.UI.Notifications.Notification(LocalizedResources.deleteDatasetBlockedByDependencies, "error");
            notification.setDetailsUseHtml(true);
            notification.setDetailsText(container.get(0).outerHTML);
            notification.setActions([Shell.UI.Notifications.Buttons.ok()]);
            Shell.UI.Notifications.add(notification);
        };
        DatasetListView.prototype.showHardDependantsAsync = function (webServiceGroups) {
            var dependants = webServiceGroups.map(function (item) { return {
                name: item.Name,
                urlHash: Shell.UI.Navigation.calculateNavigationPath({ extension: "WebServiceGroups", type: "WebServiceGroup", name: item.Id, view: "dashboard" }),
            }; });
            this.showDependants(dependants);
        };
        DatasetListView.prototype.setBusy = function (value) {
            if (value === void 0) { value = true; }
            if (value) {
                this._isBusy(true);
                if (cdm.getActiveItem() === this) {
                    Shell.UI.Spinner.show();
                }
            }
            else {
                this._isBusy(false);
                if (cdm.getActiveItem() === this) {
                    Shell.UI.Spinner.hide();
                }
            }
        };
        DatasetListView.prototype.unsetBusy = function () {
            this.setBusy(false);
        };
        DatasetListView.prototype._watchCacheChanges = function () {
            var _this = this;
            var subscription = this._workspace.datasetCache.resourceFamilyUpdated.subscribe(function () { return _this.populateDatasetList(); });
            this.registerForDisposal(new DisposableSubscription(subscription));
        };
        DatasetListView.prototype.onSelect = function (evt, args) {
            if (cdm.getActiveItem() !== this) {
                cdm.setActiveItem(this);
            }
            this._selectedRows(this._grid.fxDataGrid("getSelectedRows").map(function (row) { return row.dataItem; }));
        };
        DatasetListView._extractFamilyGuid = function (id) {
            var parts = id.split(".");
            return parts.length > 1 ? parts[1] : parts[0];
        };
        // static stuff
        DatasetListView._defaultOptions = {
            listSamples: false,
            showDependantsLinks: true,
        };
        return DatasetListView;
    })(DataLab.Util.Disposable);
    DataLabViews.DatasetListView = DatasetListView;
})(DataLabViews || (DataLabViews = {}));

/// <reference path="../Typescript/Global.ts" />
/// <reference path="ExperimentView.ts" />
var DataLabViews;
(function (DataLabViews) {
    var ExperimentLineageView = (function () {
        function ExperimentLineageView(renderArea, workspace, experimentId) {
            var _this = this;
            this._data = [];
            this._workspace = workspace;
            this._experimentId = experimentId;
            this._grid = $(renderArea).find("#grid").wazDataGrid({
                columns: [
                    { name: "Name", field: "Description", formatter: DataLabViews.formatExperimentName, cssClass: "navigationColumn" },
                    { name: "State", field: "State", cssClass: "navigationColumn" },
                    { name: "Status", field: "StatusCode", formatter: DataLabViews.formatExperimentStatusCode, cssClass: "navigationColumn" },
                    { name: "Start Time", field: "StartTime", formatter: DataLab.Util.formatDate, sorted: "descending", sortFormatter: DataLabViews.dateTimeSortFormatter, cssClass: "navigationColumn" },
                    { name: "End Time", field: "EndTime", formatter: DataLab.Util.formatDate, cssClass: "navigationColumn" }
                ],
                data: this._data,
                selectable: true,
                multiselect: true,
                resizable: true,
                rowSelect: function (evt, args) {
                    cdm.setActiveItem(_this);
                }
            });
            this._grid.on("click", ".navigationColumn", function (event) {
                var row = $(event.target).closest("tr").view().data;
                if (row.rowMetadata) {
                    var experimentId = row.rowMetadata.dataItem.ExperimentId;
                    DataLabViews.navigateToExperiment(experimentId);
                }
            });
            cdm.setActiveItem(this);
        }
        ExperimentLineageView.prototype.setCommands = function () {
            this.backCommand = new Shell.UI.Commands.Command("Back to Experiment", Shell.UI.Icons["previous"], this.navigateToSource.bind(this), null, false);
            Shell.UI.Commands.add([this.backCommand]);
        };
        ExperimentLineageView.prototype.refreshFromService = function () {
            var _this = this;
            Shell.UI.Spinner.show();
            var rootInfo;
            var rootExperimentInfo = DataLab.Util.then(this._workspace.getExperimentInfoAsync(this._experimentId), function (experimentInfo) {
                document.querySelector("#tabcontainer .itemtitle").textContent = experimentInfo.Description;
                // If the experiment is a draft, we pass its experiment info so it can be added to the lineage table
                if (experimentInfo.IsLeaf) {
                    _this.getLineage(experimentInfo.ExperimentId, experimentInfo);
                }
                else {
                    // TODO DEFECT 2669845 we should add to the service get lineage call the option of including the leaf. This code is messy because we have to get the leaf id from an archived id.
                    // Otherwise need to find if there is an InDraft leaf that has the same f-id.
                    // The InDraft experiment id is <Guid1>.f-id.<Guid2> where Guid1 and Guid2 can be obtained from the Archived experiment id whose form is <Guid1>.s-id.<Guid2>.<OtherCharacters>
                    // This regEx extracts Guid1 and Guid2 from <Guid1>.s-id.<Guid2>.<OtherCharacters>
                    var regEx = /([^\.]*)\.s-id\.([^\.]*)\.\S*/;
                    if (regEx.test(_this._experimentId)) {
                        var matchResults = _this._experimentId.match(regEx);
                        // match results are [full string, Guid1, Guid2]
                        if (matchResults.length === 3) {
                            var leafExperimentId = matchResults[1] + ".f-id." + matchResults[2];
                            var leafExperimentInfo = DataLab.Util.then(_this._workspace.getExperimentInfoAsync(leafExperimentId), function (leafExperimentInfo) {
                                if (leafExperimentInfo && leafExperimentInfo.IsLeaf) {
                                    _this.getLineage(experimentInfo.ExperimentId, leafExperimentInfo);
                                }
                                else {
                                    _this.getLineage(experimentInfo.ExperimentId);
                                }
                            });
                        }
                        else {
                            _this.getLineage(experimentInfo.ExperimentId);
                        }
                    }
                    else {
                        _this.getLineage(experimentInfo.ExperimentId);
                    }
                }
            });
        };
        ExperimentLineageView.prototype.navigateToSource = function () {
            DataLabViews.navigateToExperiment(this._experimentId);
        };
        ExperimentLineageView.prototype.getLineage = function (startExperimentId, leafExperimentInfo) {
            var _this = this;
            if (leafExperimentInfo === void 0) { leafExperimentInfo = null; }
            DataLab.Util.then(this._workspace.getExperimentLineageAsync(startExperimentId), function (experimentInfoList) {
                if (!(cdm.currentActiveItem instanceof ExperimentLineageView)) {
                    return;
                }
                _this._populateExperimentList(experimentInfoList);
                if (leafExperimentInfo) {
                    var leafExperimentToInsert = {
                        ExperimentId: leafExperimentInfo.ExperimentId,
                        Description: leafExperimentInfo.Description,
                        Creator: leafExperimentInfo.Creator,
                        StartTime: leafExperimentInfo.Status.StartTime,
                        EndTime: new Date(DataLab.Util.minDate),
                        State: "Editable",
                        StatusCode: leafExperimentInfo.Status.StatusCode,
                        etag: leafExperimentInfo.Etag,
                        // See cdm.gridViewNavigationFormatter
                        type: DataLabViews.ExperimentType.name,
                    };
                    if (leafExperimentInfo.Status.StatusCode !== DataLab.DataContract.State.Running) {
                        if (leafExperimentInfo.Status.StatusCode === DataLab.DataContract.State.NotStarted) {
                            leafExperimentToInsert.State = "Locked";
                        }
                        else if (leafExperimentInfo.Status.StatusCode === DataLab.DataContract.State.Finished || leafExperimentInfo.Status.StatusCode === DataLab.DataContract.State.Failed) {
                            leafExperimentToInsert.EndTime = new Date(leafExperimentInfo.Status.EndTime);
                        }
                        $.observable(_this._data).insert(0, leafExperimentToInsert);
                    }
                }
                _this._grid.wazDataGrid('option').data.forEach(function (item) {
                    if (item.ExperimentId === _this._experimentId) {
                        var rowMetadata = _this._grid.wazDataGrid('option').rowMetadata;
                        $.observable(rowMetadata).insert(0, { dataItem: item, cssClass: "lineageSource" });
                    }
                });
                Shell.UI.Spinner.hide();
            });
        };
        ExperimentLineageView.prototype._populateExperimentList = function (serviceExperiments) {
            $.observable(this._data).refresh(serviceExperiments.map(function (e) {
                return {
                    ExperimentId: e.ExperimentId,
                    Description: e.Description,
                    Creator: e.Creator,
                    StartTime: e.Status.StartTime,
                    EndTime: e.Status.EndTime,
                    State: "Locked",
                    StatusCode: e.Status.StatusCode,
                    etag: e.Etag,
                    // See cdm.gridViewNavigationFormatter
                    type: DataLabViews.ExperimentType.name,
                };
            }));
        };
        return ExperimentLineageView;
    })();
    DataLabViews.ExperimentLineageView = ExperimentLineageView;
})(DataLabViews || (DataLabViews = {}));

/// <reference path="../Typescript/Global.ts" />
var DataLabViews;
(function (DataLabViews) {
    function createListOfDependants(items, showLinks) {
        if (showLinks === void 0) { showLinks = false; }
        var list = $('<ol />');
        items.forEach(function (item) {
            var detailsEntry = $('<span />').text(item.name);
            if (showLinks) {
                var dependantLink = $('<a />', { href: item.urlHash }).text(DataLab.LocalizedResources.link);
                detailsEntry.append(" [").append(dependantLink).append("]");
            }
            list.append($('<li />').append(detailsEntry));
        });
        return list;
    }
    DataLabViews.createListOfDependants = createListOfDependants;
})(DataLabViews || (DataLabViews = {}));

/// <reference path="ExperimentView.ts" />
var DataLabViews;
(function (DataLabViews) {
    var ModuleListView = (function () {
        function ModuleListView(renderArea, workspace, client) {
            this._renderArea = renderArea;
            this._data = [];
            this._client = client;
            this._moduleCacheOnChange = null;
            this._workspace = workspace;
            this._grid = $(renderArea).find("#grid").fxDataGrid({
                columns: [
                    { name: "Name", field: "Name" },
                    { name: "Submitted By", field: "Owner" },
                    { name: "Version", field: "Version" },
                    { name: "Description", field: "Description" },
                    { name: "Created", field: "CreatedDate", formatter: DataLab.Util.formatDate, sorted: "descending" },
                ],
                data: this._data,
                selectable: false,
                multiselect: false,
                resizable: true,
            });
            // Set this view as the target of contextual commands (e.g. dispose)
            cdm.setActiveItem(this);
        }
        ModuleListView.prototype.populateModuleList = function () {
            // map modules to columns expected by the grid
            var modules = DataLab.Util.map(this._workspace.moduleCache.items(), function (modulesElement) {
                if (modulesElement.isLatest()) {
                    return {
                        Owner: modulesElement.owner,
                        Name: modulesElement.name(),
                        Version: modulesElement.clientVersion,
                        Description: modulesElement.description(),
                        CreatedDate: modulesElement.created
                    };
                }
                else {
                    return undefined;
                }
            });
            // filter out the non-latest modules represented by undefined
            modules = DataLab.Util.filter(modules, function (modulesElement) {
                if (modulesElement === undefined) {
                    return false;
                }
                return true;
            });
            $.observable(this._data).refresh(modules);
        };
        ModuleListView.prototype.dispose = function () {
            if (this._moduleCacheOnChange) {
                this._moduleCacheOnChange.dispose();
            }
        };
        return ModuleListView;
    })();
    DataLabViews.ModuleListView = ModuleListView;
})(DataLabViews || (DataLabViews = {}));

/// <reference path="../Typescript/Global.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var DataLabViews;
(function (DataLabViews) {
    var DisposableSubscription = DataLab.Util.DisposableSubscription;
    var Notifications = Shell.UI.Notifications;
    var LocalizedResources = DataLab.LocalizedResources;
    ;
    var TrainedModelListView = (function (_super) {
        __extends(TrainedModelListView, _super);
        function TrainedModelListView(renderArea, workspace, client, options) {
            var _this = this;
            if (options === void 0) { options = null; }
            _super.call(this);
            this._selectedRows = ko.observableArray([]);
            this._renderArea = renderArea;
            this._data = [];
            this._client = client;
            this._options = $.extend({}, TrainedModelListView._defaultOptions, options);
            this._workspace = workspace;
            this._grid = $(renderArea).find("#grid");
            this._grid.fxDataGrid({
                columns: [
                    { name: "Name", field: "Name" },
                    { name: "Submitted By", field: "Owner" },
                    { name: "Description", field: "Description" },
                    { name: "Data Type", field: "DataTypeId" },
                    { name: "Created", field: "CreatedDate", formatter: DataLab.Util.formatDate, sorted: "descending" }
                ],
                data: this._data,
                selectable: true,
                multiselect: false,
                resizable: true,
                noRows: LocalizedResources.trainedModelsNoRows,
                rowSelect: function (evt, args) { return _this.onSelect(evt, args); },
                filterQueryDelay: 100 // TODO constant
            });
            this._isBusy = ko.observable(false);
            // Set this view as the target of contextual commands (e.g. dispose)
            cdm.setActiveItem(this);
            this._watchCacheChanges();
            this.populateList();
        }
        TrainedModelListView.prototype.populateList = function () {
            var allItems = DataLab.Util.values(this._workspace.trainedModelCache.items());
            var rowsData = allItems.map(function (item) { return ({
                Owner: item.owner,
                Name: item.name(),
                Description: item.description(),
                DataTypeId: item.dataType.dataTypeId,
                CreatedDate: item.created,
                Id: item.id,
                FamilyId: item.familyId,
            }); });
            $.observable(this._data).refresh(rowsData);
        };
        TrainedModelListView.prototype.setCommands = function () {
            var _this = this;
            this._deleteCommand = new Shell.UI.Commands.Command("Delete", Shell.UI.Icons["delete"], function () { return _this.deleteResourceFamily(_this._selectedRows()[0]); }, null, true);
            Shell.UI.Commands.add(this._deleteCommand);
            // command buttons state logic
            var singleSelected = ko.computed(function () { return _this._selectedRows().length === 1; });
            var hasWritePermission = ko.computed(function () { return _this._selectedRows().length > 0 && _this._selectedRows().every(function (row) { return row.Id.lastIndexOf(_this._client.workspaceId, 0) === 0; }); });
            var deleteDisabled = ko.computed(function () { return _this._isBusy() || !singleSelected() || !hasWritePermission(); });
            var subscription = deleteDisabled.subscribe(function (value) { return _this._deleteCommand.setDisabled(value); });
            this.registerForDisposal(new DisposableSubscription(subscription));
        };
        /* comamnd handlers */
        TrainedModelListView.prototype.deleteResourceFamily = function (rowItem) {
            var _this = this;
            this.setBusy();
            // determine dependants & prompt to confirm operation
            var familyGuid = TrainedModelListView._extractFamilyGuid(rowItem.FamilyId);
            var getDependantsRequest = this._client.getResourceDependantsAsync(familyGuid);
            getDependantsRequest.always(function () { return _this.setBusy(false); });
            var confirmationPromise = DataLab.Util.then(getDependantsRequest, function (assetDependency) {
                var hardDependants = assetDependency.WebServiceGroups || [];
                if (hardDependants.length > 0) {
                    _this.showHardDependantsAsync(hardDependants);
                    return DataLab.Util.when(false);
                }
                else if (assetDependency.Experiments && assetDependency.Experiments.length > 0) {
                    // dependant experiments don't necessarily block deletion of resources
                    var dependants = assetDependency.Experiments.map(function (experiment) { return {
                        name: experiment.Description,
                        urlHash: Shell.UI.Navigation.calculateNavigationPath({ extension: DataLabViews.experimentExtensionName, type: "Experiment", name: experiment.ExperimentId, view: "ViewExperiment" }),
                    }; });
                    return _this.confirmDeletionWithSoftDependantsAsync(dependants);
                }
                return _this.confirmDeletetionAsync();
            });
            confirmationPromise.fail(function (error) {
                var notification = new Shell.UI.Notifications.Notification(DataLab.Util.format(LocalizedResources.deleteOperationFailed, error.message), "error");
                notification.setActions([Shell.UI.Notifications.Buttons.ok()]);
                Shell.UI.Notifications.add(notification);
            }).done(function (canProceed) {
                if (canProceed) {
                    var progress = new Notifications.Progress(LocalizedResources.deletingTrainedModel, "active", true);
                    progress.setDismissable(true);
                    progress.setActions([Notifications.Buttons.close()]);
                    Notifications.add(progress);
                    var deleteRequest = _this._workspace.applicationCache.trainedModelCache.deleteFamily(rowItem.FamilyId);
                    deleteRequest.done(function () {
                        progress.setTitle(LocalizedResources.trainedModelDeleted);
                        progress.setStatus("success");
                    }).fail(function (error) {
                        progress.setTitle(DataLab.Util.format(LocalizedResources.deleteOperationFailed, error.message));
                        progress.setStatus("error");
                    });
                }
            });
        };
        TrainedModelListView.prototype.confirmDeletetionAsync = function () {
            var _this = this;
            var confirmMessage = LocalizedResources.confirmDeleteTrainedModel;
            var confirmation = new Shell.UI.Notifications.Confirmation(confirmMessage, 'active');
            var deferred = $.Deferred();
            confirmation.setActions(Shell.UI.Notifications.ButtonSets.yesNo(function () {
                Shell.Diagnostics.Telemetry.customEvent("DeleteSelectedTrainedModelYes", "TrainedModelListView", JSON.stringify(_this._selectedRows));
                deferred.resolve(true);
            }, function () {
                Shell.Diagnostics.Telemetry.customEvent("DeleteSelectedTrainedModelNo", "TrainedModelListView");
                Shell.UI.Notifications.remove(confirmation);
                deferred.resolve(false);
            }));
            Shell.UI.Notifications.add(confirmation);
            return DataLab.Util.when(deferred.promise());
        };
        TrainedModelListView.prototype.confirmDeletionWithSoftDependantsAsync = function (items) {
            var deferred = $.Deferred();
            var container = $('<div />', { class: "dependants-list" });
            container.append(DataLabViews.createListOfDependants(items));
            var notification = new Shell.UI.Notifications.Confirmation(LocalizedResources.deleteTrainedModelDependenciesWarning, "active");
            notification.setDetailsUseHtml(true);
            notification.setDetailsText(container.get(0).outerHTML);
            notification.setActions(Shell.UI.Notifications.ButtonSets.yesNo(function () {
                deferred.resolve(true);
            }, function () {
                deferred.resolve(false);
            }));
            Shell.UI.Notifications.add(notification);
            return DataLab.Util.when(deferred.promise());
        };
        TrainedModelListView.prototype.showDependants = function (items) {
            var container = $('<div />', { class: "dependants-list" });
            container.append($('<p />').text(LocalizedResources.deleteTrainedModelBlockedByDependencies));
            container.append(DataLabViews.createListOfDependants(items, this._options.showDependantsLinks));
            var notification = new Shell.UI.Notifications.Notification(LocalizedResources.deleteTrainedModelBlockedByDependencies, "error");
            notification.setDetailsUseHtml(true);
            notification.setDetailsText(container.get(0).outerHTML);
            notification.setActions([Shell.UI.Notifications.Buttons.ok()]);
            Shell.UI.Notifications.add(notification);
        };
        TrainedModelListView.prototype.showHardDependantsAsync = function (webServiceGroups) {
            var dependants = webServiceGroups.map(function (item) { return {
                name: item.Name,
                urlHash: Shell.UI.Navigation.calculateNavigationPath({ extension: "WebServiceGroups", type: "WebServiceGroup", name: item.Id, view: "dashboard" }),
            }; });
            this.showDependants(dependants);
        };
        TrainedModelListView.prototype.setBusy = function (value) {
            if (value === void 0) { value = true; }
            if (value) {
                this._isBusy(true);
                if (cdm.getActiveItem() === this) {
                    Shell.UI.Spinner.show();
                }
            }
            else {
                this._isBusy(false);
                if (cdm.getActiveItem() === this) {
                    Shell.UI.Spinner.hide();
                }
            }
        };
        TrainedModelListView.prototype.unsetBusy = function () {
            this.setBusy(false);
        };
        TrainedModelListView.prototype._watchCacheChanges = function () {
            var _this = this;
            var subscription = this._workspace.trainedModelCache.resourceFamilyUpdated.subscribe(function () { return _this.populateList(); });
            this.registerForDisposal(new DisposableSubscription(subscription));
        };
        TrainedModelListView.prototype.onSelect = function (evt, args) {
            if (cdm.getActiveItem() !== this) {
                cdm.setActiveItem(this);
            }
            this._selectedRows(this._grid.fxDataGrid("getSelectedRows").map(function (row) { return row.dataItem; }));
        };
        TrainedModelListView._extractFamilyGuid = function (id) {
            var parts = id.split(".");
            return parts.length > 1 ? parts[1] : parts[0];
        };
        // static stuff
        TrainedModelListView._defaultOptions = {
            showDependantsLinks: true,
        };
        return TrainedModelListView;
    })(DataLab.Util.Disposable);
    DataLabViews.TrainedModelListView = TrainedModelListView;
})(DataLabViews || (DataLabViews = {}));

/// <reference path="../Typescript/Global.ts" />
/// <reference path="../Typescript/View/DialogViewFactories.ts" />
/// <reference path="../Typescript/ViewModel/Dialogs/ScoreDialogViewModel.ts" />
/// <reference path="../Typescript/View/ExperimentEditorContainer.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var DataLabViews;
(function (DataLabViews) {
    var InputOutputViewModel = (function () {
        function InputOutputViewModel(name, type, friendlyName) {
            this.columnName = name;
            this.columnType = type;
            this.columnFriendlyName = friendlyName;
            this.columnDisplayName = DataLab.Util.format(DataLab.LocalizedResources.modelPackageConfigColumnSchemaTemplate, this.columnName, this.columnType);
        }
        return InputOutputViewModel;
    })();
    DataLabViews.InputOutputViewModel = InputOutputViewModel;
    var WebServiceParameterViewModel = (function () {
        function WebServiceParameterViewModel(parameter) {
            var _this = this;
            this.name = parameter.Name;
            this.type = parameter.Type;
            this.description = parameter.Description;
            this.defaultValue = parameter.DefaultValue;
            this.parameterRules = parameter.ParameterRules;
            this.displayName = ko.computed(function () { return _this.name + " (" + _this.type + ")"; });
        }
        return WebServiceParameterViewModel;
    })();
    DataLabViews.WebServiceParameterViewModel = WebServiceParameterViewModel;
    var WebServiceGroupConfigViewModel = (function () {
        function WebServiceGroupConfigViewModel(webServiceGroupId, workspace) {
            this.allowAnonymousTest = ko.observable(false);
            this.diagnosticsMode = ko.observable(false);
            this.webServiceGroupId = webServiceGroupId;
            this._workspace = workspace;
            this.description = ko.observable("");
            this.name = ko.observable("");
            this.inputs = ko.observableArray();
            this.outputs = ko.observableArray();
            this.globalParameters = ko.observableArray();
        }
        WebServiceGroupConfigViewModel.prototype.refreshFromService = function (isInitialLoad) {
            var _this = this;
            DataLab.Util.then(this._workspace.getWebServiceGroupAsync(this.webServiceGroupId), function (webServiceGroup) {
                if (cdm.currentActiveItem != null && (!(cdm.currentActiveItem instanceof DataLabViews.WebServiceGroupConfigContainerViewModel) || webServiceGroup == null || webServiceGroup.Id != _this.webServiceGroupId)) {
                    return; // user switched to a different view
                }
                _this.webServiceGroup = webServiceGroup;
                var stagingWS = webServiceGroup.StagingWebService;
                // TODO: staging service should always be there, the check here is to bypass the rrs service issue. After pusheng deploy to rrs server, we 
                // should change the code to assume staging service is always there.
                if (stagingWS) {
                    var modelPackageId = stagingWS.ModelPackageId;
                    _this.modelPackageInfo = webServiceGroup.ModelPackages.filter(function (value) { return value.Id === modelPackageId; })[0];
                }
                else {
                    _this.modelPackageInfo = webServiceGroup.ModelPackages[webServiceGroup.ModelPackages.length - 1];
                }
                var diagnosticsSettings = stagingWS.DiagnosticsSettings;
                _this._existingDiagnosticsMode = diagnosticsSettings != null && diagnosticsSettings.DiagnosticsTraceLevel != DataLab.DataContract.DiagnosticsTraceLevel.None;
                _this.name(webServiceGroup.Name);
                _this.description(webServiceGroup.Description);
                _this.allowAnonymousTest(webServiceGroup.StagingWebService.AllowAnonymousTest);
                _this.diagnosticsMode(_this._existingDiagnosticsMode);
                _this.refreshedFromServiceHandler(isInitialLoad, _this);
            });
        };
        WebServiceGroupConfigViewModel.prototype.loadSchema = function () {
            this.modelPackageStatusCode = DataLabViews.WebServiceGroupDashboardView.getProductionStatus(this.modelPackageInfo);
            this.allowAnonymousTest(this.webServiceGroup.StagingWebService.AllowAnonymousTest);
            this.diagnosticsMode(this._existingDiagnosticsMode);
            // TODO: currently only support 1st input as web service input.
            var inputSchema;
            var inputsData;
            if (this.modelPackageInfo.Inputs !== null && this.modelPackageInfo.Inputs.length > 0 && this.modelPackageInfo.Inputs[0] !== null) {
                inputSchema = JSON.parse(this.modelPackageInfo.Inputs[0].Schema);
                if (inputSchema != null) {
                    inputsData = $.map(inputSchema.columnAttributes, function (column, index) {
                        return new InputOutputViewModel(column.name, column.type, "");
                    });
                }
            }
            if (this.modelPackageInfo.InputsMetadata !== null && inputsData !== undefined) {
                var currentPortMetadata = this.modelPackageInfo.InputsMetadata[this.modelPackageInfo.Inputs[0].Id];
                if (currentPortMetadata !== undefined && currentPortMetadata !== null) {
                    var currentInput;
                    var friendlyName;
                    for (var i = 0; i < inputsData.length; i++) {
                        currentInput = inputsData[i];
                        friendlyName = currentPortMetadata[currentInput.columnName];
                        if (friendlyName !== undefined) {
                            inputsData[i].columnFriendlyName = friendlyName;
                        }
                    }
                }
            }
            var outputSchema;
            var outputData;
            if (this.modelPackageInfo.Outputs != null && this.modelPackageInfo.Outputs.length > 0 && this.modelPackageInfo.Outputs[0] !== null) {
                outputSchema = JSON.parse(this.modelPackageInfo.Outputs[0].Schema);
                if (outputSchema != null) {
                    outputData = $.map(outputSchema.columnAttributes, function (column, index) {
                        return new InputOutputViewModel(column.name, column.type, "");
                    });
                }
            }
            // set Friedly names if defined
            if (this.modelPackageInfo.OutputsMetadata !== null && outputData != undefined) {
                var currentPortMetadata = this.modelPackageInfo.OutputsMetadata[this.modelPackageInfo.Outputs[0].Id];
                if (currentPortMetadata !== undefined && currentPortMetadata !== null) {
                    var currentOutput;
                    var friendlyName;
                    for (var i = 0; i < outputData.length; i++) {
                        currentOutput = outputData[i];
                        friendlyName = currentPortMetadata[currentOutput.columnName];
                        if (friendlyName !== undefined) {
                            outputData[i].columnFriendlyName = friendlyName;
                        }
                    }
                }
            }
            this.inputs(inputsData);
            this.outputs(outputData);
            if (this.modelPackageInfo.GlobalParametersMetadata) {
                this.globalParameters(this.modelPackageInfo.GlobalParametersMetadata.map(function (p) { return new WebServiceParameterViewModel(p); }));
            }
            this._existingFriendlyNames = this.getFriendlyNames();
        };
        WebServiceGroupConfigViewModel.prototype.getFriendlyNames = function () {
            var names = [];
            if (this.globalParameters()) {
                $.each(this.globalParameters(), function (index, p) {
                    names.push(p.description);
                });
            }
            if (this.inputs()) {
                $.each(this.inputs(), function (index, input) {
                    names.push(input.columnFriendlyName);
                });
            }
            if (this.outputs()) {
                $.each(this.outputs(), function (index, output) {
                    names.push(output.columnFriendlyName);
                });
            }
            return names.join('');
        };
        WebServiceGroupConfigViewModel.prototype.update = function () {
            var _this = this;
            var deferred = $.Deferred();
            // prep data and update schema
            var outputsMetadataInner = {};
            var outputsMetadata = {};
            var inputsMetadataInner = {};
            var inputsMetadata = {};
            var apiParameterMetadata = [];
            var needToUpdateModelPackage = (this._existingFriendlyNames != this.getFriendlyNames());
            if (needToUpdateModelPackage) {
                if (this.modelPackageInfo.GlobalParametersMetadata) {
                    apiParameterMetadata = this.globalParameters().map(function (p) {
                        return {
                            Name: p.name,
                            Type: p.type,
                            DefaultValue: p.defaultValue,
                            Description: p.description,
                            ParameterRules: p.parameterRules
                        };
                    });
                }
                if (this.outputs()) {
                    $.each(this.outputs(), function (index, output) {
                        outputsMetadataInner[output.columnName] = output.columnFriendlyName;
                    });
                    if (this.modelPackageInfo.Outputs[0] !== undefined) {
                        outputsMetadata[this.modelPackageInfo.Outputs[0].Id] = outputsMetadataInner;
                    }
                }
                if (this.inputs()) {
                    $.each(this.inputs(), function (index, input) {
                        inputsMetadataInner[input.columnName] = input.columnFriendlyName;
                    });
                    if (this.modelPackageInfo.Inputs[0] !== undefined) {
                        inputsMetadata[this.modelPackageInfo.Inputs[0].Id] = inputsMetadataInner;
                    }
                }
            }
            var needToUpdateWebServiceGroup = (this.webServiceGroup.Name != this.name() || this.webServiceGroup.Description != this.description() || this.webServiceGroup.StagingWebService.AllowAnonymousTest != this.allowAnonymousTest());
            var needToUpdateWebService = (this._existingDiagnosticsMode != this.diagnosticsMode());
            var promises = [];
            if (needToUpdateModelPackage) {
                promises.push(this._workspace.updateModelPackageAsync(this.webServiceGroup.Id, this.modelPackageInfo.Id, this.modelPackageStatusCode, inputsMetadata, outputsMetadata, apiParameterMetadata).done(function () {
                    if (cdm.currentActiveItem != null && !(cdm.currentActiveItem instanceof DataLabViews.WebServiceGroupConfigContainerViewModel)) {
                        return; // user switched to a different view
                    }
                    _this._existingFriendlyNames = _this.getFriendlyNames();
                }).fail(function (error) {
                    if (cdm.currentActiveItem != null && !(cdm.currentActiveItem instanceof DataLabViews.WebServiceGroupConfigContainerViewModel)) {
                        return; // user switched to a different view
                    }
                    _this.errorSchemaUpdateHandler();
                }));
            }
            if (needToUpdateWebServiceGroup) {
                // update namem, decription abd whether or not to allow anonynmous test
                promises.push(this._workspace.updateWebServiceGroupAsync(this.webServiceGroup.Id, this.name(), this.description(), this.allowAnonymousTest()).fail(function (error) {
                    if (cdm.currentActiveItem != null && !(cdm.currentActiveItem instanceof DataLabViews.WebServiceGroupConfigContainerViewModel)) {
                        return; // user switched to a different view
                    }
                    _this.errorNameUpdateHandler();
                }));
            }
            if (needToUpdateWebService) {
                var diagnosticsTraceLevel = this.diagnosticsMode() ? DataLab.DataContract.DiagnosticsTraceLevel.All : DataLab.DataContract.DiagnosticsTraceLevel.None;
                var diagnosticsSettings = this.webServiceGroup.StagingWebService.DiagnosticsSettings;
                if (diagnosticsSettings === null) {
                    diagnosticsSettings = {
                        DiagnosticsBESJobsPath: null,
                        DiagnosticsConnectionString: null,
                        DiagnosticsExpiryTime: null,
                        DiagnosticsRRSInitializationsPath: null,
                        DiagnosticsRRSRequestsPath: null,
                        DiagnosticsTraceLevel: diagnosticsTraceLevel
                    };
                }
                else {
                    diagnosticsSettings.DiagnosticsTraceLevel = diagnosticsTraceLevel;
                }
                promises.push(this._workspace.updateWebServiceAsync(this.webServiceGroup.Id, this.webServiceGroup.StagingWebService.Id, this.modelPackageInfo.Id, diagnosticsSettings).done(function () {
                    if (cdm.currentActiveItem != null && !(cdm.currentActiveItem instanceof DataLabViews.WebServiceGroupConfigContainerViewModel)) {
                        return; // user switched to a different view
                    }
                    _this._existingDiagnosticsMode = _this.diagnosticsMode();
                }).fail(function (error) {
                    if (cdm.currentActiveItem != null && !(cdm.currentActiveItem instanceof DataLabViews.WebServiceGroupConfigContainerViewModel)) {
                        return; // user switched to a different view
                    }
                    _this.errorDiagnosticsModeUpdateHandler();
                    _this.diagnosticsMode(_this._existingDiagnosticsMode);
                }));
            }
            // when both 2 calls are finished => hide spinner and show changes
            var completeUpdatePromise = DataLab.Util.when(promises);
            completeUpdatePromise.always(function () {
                if (cdm.currentActiveItem != null && !(cdm.currentActiveItem instanceof DataLabViews.WebServiceGroupConfigContainerViewModel)) {
                    return; // user switched to a different view
                }
                // hide spinner
                _this.finishedUpdateHandler();
                deferred.resolve(inputsMetadata, outputsMetadata, _this.name(), _this.description(), _this.diagnosticsMode());
            }).done(function () {
                if (cdm.currentActiveItem != null && !(cdm.currentActiveItem instanceof DataLabViews.WebServiceGroupConfigContainerViewModel)) {
                    return; // user switched to a different view
                }
                _this.successUpdateHandler();
                //    this.hasBeenEdited(false); // reset hasBeenEdited flag in case of success
            });
            return DataLab.Util.when(deferred);
        };
        return WebServiceGroupConfigViewModel;
    })();
    DataLabViews.WebServiceGroupConfigViewModel = WebServiceGroupConfigViewModel;
    var WebServiceGroupConfigContainerViewModel = (function (_super) {
        __extends(WebServiceGroupConfigContainerViewModel, _super);
        function WebServiceGroupConfigContainerViewModel(renderArea, webServiceGroupId, workspace) {
            _super.call(this);
            this.hasBeenEdited = ko.observable(false);
            this._renderArea = renderArea.get(0);
            this._workspace = workspace;
            this.configViewModel = new WebServiceGroupConfigViewModel(webServiceGroupId, workspace);
            //event handlers
            this.configViewModel.refreshedFromServiceHandler = this.configRefreshedFromServiceEventHandler;
            this.configViewModel.errorSchemaUpdateHandler = function () {
                cdm.currentActiveItem.setErrorNotification(DataLab.LocalizedResources.modelPackageConfigErrorSchema);
            };
            this.configViewModel.errorNameUpdateHandler = function () {
                cdm.currentActiveItem.setErrorNotification(DataLab.LocalizedResources.modelPackageConfigErrorName);
            };
            this.configViewModel.errorDiagnosticsModeUpdateHandler = function () {
                cdm.currentActiveItem.setErrorNotification(DataLab.LocalizedResources.modelPackageConfigErrorDiagnosticsMode);
            };
            this.configViewModel.finishedUpdateHandler = function () {
                Shell.UI.Spinner.hide();
            };
            this.configViewModel.successUpdateHandler = this.successfulUpdateEventHandler;
            cdm.setActiveItem(this);
            // Hide the page title (populated by AzureFX)
            document.querySelector("#tabcontainer .itemtitle").textContent = "";
            this._allowAnonymousTest = [
                { text: DataLab.LocalizedResources.webServiceTestEnabledYes, value: true },
                { text: DataLab.LocalizedResources.webServiceTestEnabledNo, value: false }
            ];
            this._diagnosticsModeOptions = [
                { text: DataLab.LocalizedResources.webServiceDiagnosticsModeAll, value: true },
                { text: DataLab.LocalizedResources.webServiceDiagnosticsModeNone, value: false }
            ];
        }
        WebServiceGroupConfigContainerViewModel.prototype.open = function () {
            var _this = this;
            DataLab.Util.then(this._workspace.getWorkspaceSettingsAsync(), function (workspaceSettings) {
                if (cdm.currentActiveItem != null && !(cdm.currentActiveItem instanceof DataLabViews.WebServiceGroupConfigContainerViewModel)) {
                    return; // user switched to a different view
                }
                var isProductionWorkspace = DataLab.Model.WorkspaceTypeExtensions.isProduction(workspaceSettings.type);
                _this.shouldShowDiagnosticsButton = isProductionWorkspace;
                _this.refreshFromService(true);
            });
        };
        // sets commands in bottom ribbon
        WebServiceGroupConfigContainerViewModel.prototype.setCommands = function () {
            var _this = this;
            // parameters for a new Command: text, icon, click, group, disabled            
            this.saveCommand = new Shell.UI.Commands.Command(DataLab.LocalizedResources.modelPackageConfigSave, Shell.UI.Icons.save, this.update.bind(this), null, true);
            this.discardCommand = new Shell.UI.Commands.Command(DataLab.LocalizedResources.modelPackageConfigDiscard, Shell.UI.Icons.undo, this.discard.bind(this), null, true);
            Shell.UI.Commands.add([this.saveCommand, this.discardCommand]);
            this.hasBeenEdited.subscribe(function () {
                _this.saveCommand.setDisabled(!_this.hasBeenEdited());
                _this.discardCommand.setDisabled(!_this.hasBeenEdited());
            });
        };
        // inputs\radio update event handler
        WebServiceGroupConfigContainerViewModel.prototype.configUpdated = function (rootObj) {
            //retrieve the context  ko.contextFor(this) does not work here...
            var viewModel = cdm.currentActiveItem;
            if (!viewModel.hasBeenEdited()) {
                viewModel.hasBeenEdited(true);
            }
        };
        // fetches data from WS and re-inits UI
        // used in initial load and save\discard
        WebServiceGroupConfigContainerViewModel.prototype.refreshFromService = function (isInitialLoad) {
            Shell.UI.Spinner.show();
            this.configViewModel.refreshFromService(isInitialLoad);
            // spinner will be hidden by configRefreshedFromServiceEventHandler
        };
        WebServiceGroupConfigContainerViewModel.prototype.configRefreshedFromServiceEventHandler = function (isInitialLoad, source) {
            // "this" now is pointing to the source of event -- configViewModel
            var view = cdm.currentActiveItem;
            if (source.modelPackageInfo !== undefined || source.modelPackageInfo != null) {
                view.refreshModelPackageUI();
            }
            view.hasBeenEdited(false);
            if (isInitialLoad) {
                view.registerForDisposal(new DataLab.Util.DisposableKOApplyBindings(view, view._renderArea));
            }
            $("#WebServiceGroupConfig").show();
            Shell.UI.Spinner.hide();
        };
        WebServiceGroupConfigContainerViewModel.prototype.successfulUpdateEventHandler = function () {
            // "this" now is pointing to the source of event -- configViewModel
            var view = cdm.currentActiveItem;
            view.updateTitles(view.configViewModel.name());
            view.hasBeenEdited(false);
        };
        WebServiceGroupConfigContainerViewModel.prototype.refreshModelPackageUI = function () {
            var _this = this;
            this.configViewModel.loadSchema();
            var defaultAllowAnonymousTest = this.configViewModel.allowAnonymousTest() ? this._allowAnonymousTest[0] : this._allowAnonymousTest[1];
            $("#radioAllowAnonymousTest").fxRadio({
                value: defaultAllowAnonymousTest,
                values: this._allowAnonymousTest,
                trackedit: false,
                change: function (event, args) {
                    _this.configViewModel.allowAnonymousTest(args.value.value);
                    _this.configUpdated(_this);
                }
            });
            var defaultDiagnosticsMode = this.configViewModel.diagnosticsMode() ? this._diagnosticsModeOptions[0] : this._diagnosticsModeOptions[1];
            $("#radioDiagnosticsMode").fxRadio({
                value: defaultDiagnosticsMode,
                values: this._diagnosticsModeOptions,
                trackedit: false,
                change: function (event, args) {
                    _this.configViewModel.diagnosticsMode(args.value.value);
                    _this.configUpdated(_this);
                }
            });
            this.updateTitles(this.configViewModel.name());
        };
        // "Save" button handler
        WebServiceGroupConfigContainerViewModel.prototype.update = function () {
            Shell.UI.Spinner.show();
            this.configViewModel.update();
            // spinner will be hidden in this.configViewModel.finishedUpdateHandler
        };
        WebServiceGroupConfigContainerViewModel.prototype.discard = function () {
            this.refreshFromService(false);
        };
        // helper function for creating a generic error notification for failed promises
        WebServiceGroupConfigContainerViewModel.prototype.setErrorNotification = function (title) {
            var errorNotification = new Shell.UI.Notifications.Notification(title, "error");
            errorNotification.setActions([Shell.UI.Notifications.Buttons.close(function () {
            })]);
            Shell.UI.Notifications.add(errorNotification);
        };
        WebServiceGroupConfigContainerViewModel.prototype.updateTitles = function (title) {
            // update tab title
            document.querySelector("#tabcontainer .itemtitle").textContent = this.configViewModel.name();
            // Set sidebar text
            // We additionally set the title attribute to prevent the original guid from  showing up on hover.
            $(".fxshell-nav2-item.selected a span").text(title).attr('title', title);
        };
        return WebServiceGroupConfigContainerViewModel;
    })(DataLab.Util.Disposable);
    DataLabViews.WebServiceGroupConfigContainerViewModel = WebServiceGroupConfigContainerViewModel;
    ;
})(DataLabViews || (DataLabViews = {}));

/// <reference path="../Typescript/Global.ts" />
/// <reference path="../Typescript/View/DialogViewFactories.ts" />
/// <reference path="../Typescript/ViewModel/Dialogs/ScoreDialogViewModel.ts" />
/// <reference path="../Typescript/View/ExperimentEditorContainer.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var DataLabViews;
(function (DataLabViews) {
    // this class is the ViewModel for the View/template in WebServiceGroups/DashboardTab.htm. 
    // However, the name below follows the convention already in use in this folder.
    var WebServiceGroupDashboardView = (function (_super) {
        __extends(WebServiceGroupDashboardView, _super);
        function WebServiceGroupDashboardView(renderArea, webServiceGroupId, workspace) {
            _super.call(this);
            this.parentExperimentLatestId = null;
            this.relatedWebServiceGroupId = null;
            this.relatedWebServiceName = null;
            this.relatedWebServiceLabel = null;
            this._renderArea = renderArea.get(0);
            this._webServiceGroupId = webServiceGroupId;
            this._workspace = workspace;
            cdm.setActiveItem(this);
            // Hide the page title (populated by AzureFX)
            document.querySelector("#tabcontainer .itemtitle").textContent = "";
        }
        WebServiceGroupDashboardView.prototype.open = function () {
            var _this = this;
            Shell.UI.Spinner.show();
            DataLab.Util.then(this._workspace.getWebServiceGroupAsync(this._webServiceGroupId), function (webServiceGroup) {
                if (!(cdm.currentActiveItem instanceof DataLabViews.WebServiceGroupDashboardView) || webServiceGroup == null || webServiceGroup.Id != _this._webServiceGroupId) {
                    return; // user switched to a different view
                }
                _this._webServiceGroup = webServiceGroup;
                _this.wsgDescription = webServiceGroup.Description;
                _this.webServices = [];
                var stagingWS = webServiceGroup.StagingWebService;
                // TODO: staging service should always be there, the check here is to bypass the rrs service issue. After pusheng deploy to rrs server, we 
                // should change the code to assume staging service is always there.
                if (stagingWS) {
                    var modelPackageId = stagingWS.ModelPackageId;
                    _this._modelPackageInfo = webServiceGroup.ModelPackages.filter(function (value) { return value.Id === modelPackageId; })[0];
                    _this.webServices.push(new DataLabViews.WebService(stagingWS.Id, _this.getApiHelpPageUrl("score"), DataLab.LocalizedResources.webServiceGroupDashboardWsRRSType, new Date(parseInt(_this._modelPackageInfo.CreationTime.substr(6)))));
                    _this.webServices.push(new DataLabViews.WebService(stagingWS.Id, _this.getApiHelpPageUrl("jobs"), DataLab.LocalizedResources.webServiceGroupDashboardWsBatchType, new Date(parseInt(_this._modelPackageInfo.CreationTime.substr(6)))));
                    _this.setupWebServiceGrid();
                    var copyButtonOwner = $("#WebServicePrimaryKey");
                    if (copyButtonOwner.is(":data(fxs-fxsCopyButton)")) {
                        copyButtonOwner.fxsCopyButton("destroy");
                    }
                    copyButtonOwner.fxsCopyButton({ text: stagingWS.PrimaryKey });
                }
                else if (webServiceGroup.ModelPackages.length > 0) {
                    _this._modelPackageInfo = webServiceGroup.ModelPackages[webServiceGroup.ModelPackages.length - 1];
                }
                else {
                    _this._modelPackageInfo = null;
                }
                DataLab.Util.then(_this._workspace.getWorkspaceSettingsAsync(), function (workspaceSettings) {
                    if (!(cdm.currentActiveItem instanceof DataLabViews.WebServiceGroupDashboardView)) {
                        return; // user switched to a different view
                    }
                    _this.shouldShowProductionElements = DataLab.Model.WorkspaceTypeExtensions.isProduction(workspaceSettings.type);
                    _this.showProductionStatus();
                    document.querySelector("#tabcontainer .itemtitle").textContent = webServiceGroup.Name;
                    _this.updateSidebarTitle(webServiceGroup.Name);
                    if (_this._modelPackageInfo != null) {
                        _this.parentExperimentId = _this._modelPackageInfo.LinkedExperimentId;
                        _this.parentExperimentLatestId = _this.getLatestExperimentRunId();
                        DataLab.Util.then(_this._workspace.getExperimentInfoAsync(_this.parentExperimentId), function (experiment) {
                            if (!(cdm.currentActiveItem instanceof DataLabViews.WebServiceGroupDashboardView) || experiment == null || experiment.ExperimentId != _this.parentExperimentId) {
                                return; // user switched to a different view
                            }
                            _this.parentExperimentDescription = experiment.Description;
                            _this.registerForDisposal(new DataLab.Util.DisposableKOApplyBindings(_this, _this._renderArea));
                            $("#WebServiceGroupDashboardViewContent").show();
                            Shell.UI.Spinner.hide();
                        });
                        _this.setUpRelatedWebserviceLink();
                    }
                    else {
                        $("#WebServiceGroupDashboardViewContent").show();
                        Shell.UI.Spinner.hide();
                    }
                });
            });
        };
        WebServiceGroupDashboardView.prototype.setCommands = function () {
            var _this = this;
            // always enable delete wsg button but show error when the wsg is in production status
            var deleteCommand = new Shell.UI.Commands.Command(DataLab.LocalizedResources.deleteItem, Shell.UI.Icons["delete"], function () { return _this.onDeleteWebServiceGroup(); }, null, false);
            Shell.UI.Commands.add([
                deleteCommand
            ]);
        };
        WebServiceGroupDashboardView.prototype.getLatestExperimentRunId = function () {
            if (!this.parentExperimentId) {
                throw new Error("Experiment id cannot be null");
            }
            var segments = this.parentExperimentId.split(".");
            if (segments.length < 3) {
                throw new Error("invalid experiment id: " + this.parentExperimentId);
            }
            return segments[0] + ".f-id." + segments[2];
        };
        WebServiceGroupDashboardView.prototype.setUpRelatedWebserviceLink = function () {
            var _this = this;
            this.shouldShowRelatedWebService = false;
            if (this.parentExperimentLatestId) {
                // get the project for this experiment
                this._workspace.listProjects(this.parentExperimentLatestId).done(function (projects) {
                    if (projects && projects.length && projects[0].Experiments) {
                        var relatedProjectExperiment = DataLab.Util.first(projects[0].Experiments, function (projectExperiment) {
                            return (projectExperiment.ExperimentId != _this.parentExperimentLatestId && (projectExperiment.Role === DataLab.DataContract.ExperimentRole.Training || projectExperiment.Role === DataLab.DataContract.ExperimentRole.Scoring));
                        }, null);
                        if (relatedProjectExperiment) {
                            _this._workspace.getExperimentAsync(relatedProjectExperiment.ExperimentId).done(function (relatedExperiment) {
                                if (relatedExperiment.publishedWebServiceGroupId) {
                                    _this._workspace.getWebServiceGroupAsync(relatedExperiment.publishedWebServiceGroupId).done(function (relatedWebServiceGroup) {
                                        _this.shouldShowRelatedWebService = true;
                                        _this.relatedWebServiceGroupId = relatedExperiment.publishedWebServiceGroupId;
                                        _this.relatedWebServiceName = relatedWebServiceGroup.Name;
                                        _this.relatedWebServiceLabel = (relatedProjectExperiment.Role === DataLab.DataContract.ExperimentRole.Training) ? DataLab.LocalizedResources.trainingWebServiceLabel : DataLab.LocalizedResources.scoringWebServiceLabel;
                                        var nodeToUpdate = $("#relatedWebServiceSection")[0];
                                        ko.cleanNode(nodeToUpdate);
                                        ko.applyBindings(_this, nodeToUpdate);
                                    });
                                }
                            });
                        }
                    }
                });
            }
        };
        WebServiceGroupDashboardView.prototype.showProductionStatus = function () {
            if (!this.shouldShowProductionElements) {
                this.productionStatusSectionTitle = "";
                this.productionStatusDescription = "";
                this.productionActionDescription = "";
                this.productionActionUrl = "";
            }
            else if (this._modelPackageInfo != null && this._webServiceGroup != null) {
                var workspaceName = this._workspace.friendlyName;
                var azureManagementPortalUrl = DataLab.Util.format("{0}/#Workspaces/MachineLearningExtension/Workspace/{1}", DataLab.Configuration.ClientConfiguration.AzureManagementPortalUrl, workspaceName);
                var productionStatus = WebServiceGroupDashboardView.getProductionStatus(this._modelPackageInfo);
                this.productionStatusSectionTitle = DataLab.LocalizedResources.webServiceEndpointsSectionTitle;
                var productionEndpointCount = (this._webServiceGroup.Endpoints == null) ? 0 : this._webServiceGroup.Endpoints.length - 1;
                this.productionStatusDescription = DataLab.Util.format(DataLab.LocalizedResources.webServiceEndpointCount, productionEndpointCount.toString());
                this.productionActionDescription = DataLab.LocalizedResources.webServiceManageEndpointsLink;
                this.productionActionUrl = DataLab.Util.format("{0}/WebService/{1}/Dashboard", azureManagementPortalUrl, this._webServiceGroup.Id);
            }
        };
        WebServiceGroupDashboardView.prototype.getConfigTabUrl = function () {
            // Construct the URL to the Configuration tab, by replacing "/dashboard" (at the end of the current window URL) with "/configuration"
            var currentUrl = window.location.href;
            var indexLastSlash = currentUrl.lastIndexOf("/");
            if (currentUrl.substring(indexLastSlash) == "/dashboard") {
                return currentUrl.substr(0, indexLastSlash) + "/configuration";
            }
            else {
                DataLab.Log.warn("Expected the web service URL to end with /dashboard", this._webServiceGroup.Id, currentUrl);
                return currentUrl;
            }
        };
        WebServiceGroupDashboardView.prototype.getApiHelpPageUrl = function (methodId) {
            return DataLab.Util.format("/apihelp/workspaces/{0}/webservices/{1}/endpoints/{2}/{3}", this._workspace.id, this._webServiceGroup.Id, this._webServiceGroup.StagingWebService.Id, methodId);
        };
        WebServiceGroupDashboardView.prototype.getDownloadExcelUrl = function () {
            return DataLab.Util.format("/apihelpdownload/workspaces/{0}/webservices/{1}/endpoints/{2}/excel", this._workspace.id, this._webServiceGroup.Id, this._webServiceGroup.StagingWebService.Id);
        };
        WebServiceGroupDashboardView.prototype.showExcelLink = function () {
            if (DataLab.Features.excelDownloadEnabled()) {
                if (this._modelPackageInfo.Outputs && this._modelPackageInfo.Outputs.length === 1 && (!this._modelPackageInfo.Outputs[0].OutputType || this._modelPackageInfo.Outputs[0].OutputType === "DataTable")) {
                    if (this._modelPackageInfo.GlobalParametersMetadata) {
                        for (var i = 0; i < this._modelPackageInfo.GlobalParametersMetadata.length; i++) {
                            if (!this._modelPackageInfo.GlobalParametersMetadata[i].DefaultValue) {
                                return false;
                            }
                        }
                        return true;
                    }
                }
            }
            return false;
        };
        WebServiceGroupDashboardView.prototype.setupWebServiceGrid = function () {
            var _this = this;
            var gridOptions = {
                columns: [
                    {
                        name: DataLab.LocalizedResources.webServiceApiHelpLabel,
                        field: "Url",
                        formatter: function (data, context) {
                            var webService = context.dataItem;
                            return $.fxGridFormatter.url({
                                url: data,
                                text: webService.Type,
                                target: "_blank"
                            }, context);
                        }
                    }
                ],
                data: this.webServices,
                selectable: false,
                multiselect: false,
                resizable: true,
            };
            if (this._modelPackageInfo != null) {
                ////    && this._modelPackageInfo.Inputs
                ////    && this._modelPackageInfo.Inputs.length > 0
                ////    && this._modelPackageInfo.Inputs[0].Schema
                // If there is no input, scoring test is disabled
                gridOptions.columns.push({
                    name: DataLab.LocalizedResources.webServiceGroupDashboardWsTestHeader,
                    field: "Id",
                    formatter: function (data, context) {
                        var webService = context.dataItem;
                        // Only show test link for RRS endpoint
                        if (webService.Type === DataLab.LocalizedResources.webServiceGroupDashboardWsRRSType) {
                            var link = $("<a href=\"#\" class=\"WebServiceTestLink\">" + DataLab.LocalizedResources.webServiceGroupDashboardWsTestButtonText + "</a>");
                            link.click(function (ev) {
                                _this.showInteractiveScoreDialog(data);
                                return false;
                            });
                            return link;
                        }
                    }
                });
                if (this.showExcelLink()) {
                    gridOptions.columns.push({
                        name: DataLab.LocalizedResources.webServiceGroupDashboardWsAppsHeader,
                        field: "Id",
                        formatter: function (data, context) {
                            var webService = context.dataItem;
                            // Only show excel download link for RRS endpoint
                            if (webService.Type === DataLab.LocalizedResources.webServiceGroupDashboardWsRRSType) {
                                var link = $("<a href=\"" + _this.getDownloadExcelUrl() + "\">" + "<img src=\"/Content/Images/icxlsx.png\" >" + " " + DataLab.LocalizedResources.webServiceDownloadExcelLabel + "</a>");
                                return link;
                            }
                        }
                    });
                }
            }
            gridOptions.columns.push({
                name: DataLab.LocalizedResources.webServiceGroupDashboardWsLastUpdatedHeader,
                field: "CreationTime",
                formatter: DataLab.Util.formatDate,
                sorted: "descending"
            });
            this._grid = $(this._renderArea).find("#webServiceGrid").wazDataGrid(gridOptions);
        };
        WebServiceGroupDashboardView.prototype.onDeleteWebServiceGroup = function () {
            if (this._webServiceGroup.ProductionWebService) {
                // show error when it has production service
                this.showError(DataLab.Util.format(DataLab.LocalizedResources.cannotDeleteWebServiceGroupError, this._webServiceGroup.Name));
            }
            else {
                // show confirmation before deletion
                this.confirmDelete();
            }
        };
        WebServiceGroupDashboardView.prototype.showError = function (message) {
            var error = new Shell.UI.Notifications.Confirmation(message, 'active');
            error.setActions([
                new Shell.UI.Notifications.Buttons.ok(function () {
                    Shell.UI.Notifications.remove(error);
                })
            ]);
            Shell.UI.Notifications.add(error);
        };
        WebServiceGroupDashboardView.prototype.confirmDelete = function () {
            var _this = this;
            var confirmation = new Shell.UI.Notifications.Confirmation(DataLab.Util.format(DataLab.LocalizedResources.confirmDeleteWebServiceGroup, this._webServiceGroup.Name), 'active');
            confirmation.setActions([
                new Shell.UI.Notifications.Buttons.yes(function () {
                    Shell.UI.Spinner.show();
                    _this.deleteWebServiceGroup().done(function () {
                        Shell.UI.Navigation.navigate({
                            extension: DataLabViews.webServiceGroupExtensionName
                        });
                    }).fail(function (error) {
                        _this.showError(error.message);
                    }).always(function () {
                        Shell.UI.Spinner.hide();
                    });
                    Shell.UI.Notifications.remove(confirmation);
                }),
                new Shell.UI.Notifications.Buttons.no(function () {
                    Shell.UI.Notifications.remove(confirmation);
                })
            ]);
            Shell.UI.Notifications.add(confirmation);
        };
        WebServiceGroupDashboardView.prototype.deleteWebServiceGroup = function () {
            return this._workspace.deleteWebServiceGroupAsync(this._webServiceGroupId);
        };
        WebServiceGroupDashboardView.prototype.showInteractiveScoreDialog = function (webServiceId) {
            // TODO: pass first webservice id for now. Will support user select which one to call later
            var vm = new ExperimentEditor.ScoreDialogViewModel(this._modelPackageInfo, this._webServiceGroup, webServiceId, this._workspace);
            var result = ExperimentEditor.DialogViews.InteractiveScore.show(vm);
        };
        WebServiceGroupDashboardView.prototype.updateSidebarTitle = function (title) {
            // The sidebar text is initially set by ExperimentType.dataFunction, but at that point we only have
            // the experiment ID. Here we reach in after the fact to keep the displayed text in sync with the
            // actual experiment title. We additionally set the title attribute to prevent the original guid from
            // showing up on hover.
            $(".fxshell-nav2-item.selected a span").text(title).attr('title', title);
        };
        WebServiceGroupDashboardView.getProductionStatus = function (modelPackageInfo) {
            // note:  at Runtime _modelPackageInfo.StatusCode is serialized as string "ReadyForProduction" and  === against enum fails
            var curentProdStatus = modelPackageInfo.StatusCode;
            var currentProdStatusString = String(modelPackageInfo.StatusCode); // explicitly convert to string
            var productionStatus = 3 /* Retired */;
            if (curentProdStatus == 1 /* ReadyForProduction */ || DataLab.DataContract.ModelPackageStatusCode[currentProdStatusString] === 1 /* ReadyForProduction */) {
                productionStatus = 1 /* ReadyForProduction */;
            }
            else if (curentProdStatus == 2 /* DeployedToProduction */ || DataLab.DataContract.ModelPackageStatusCode[currentProdStatusString] === 2 /* DeployedToProduction */) {
                productionStatus = 2 /* DeployedToProduction */;
            }
            else if (curentProdStatus == 0 /* InTesting */ || DataLab.DataContract.ModelPackageStatusCode[currentProdStatusString] === 0 /* InTesting */) {
                productionStatus = 0 /* InTesting */;
            }
            else {
                throw new Error(DataLab.Util.format("Unexpected ModelPackageStatusCode: {0}", currentProdStatusString));
            }
            return productionStatus;
        };
        return WebServiceGroupDashboardView;
    })(DataLab.Util.Disposable);
    DataLabViews.WebServiceGroupDashboardView = WebServiceGroupDashboardView;
    ;
})(DataLabViews || (DataLabViews = {}));

/// <reference path="../Typescript/Global.ts" />
/// <reference path="ExperimentView.ts" />
/// <reference path="./WebServiceGroupView.ts" />
var DataLabViews;
(function (DataLabViews) {
    // Note: This class does a bit of View work (such as creating and managing the grid) and also acts as the ViewModel for the View/template in Grid.htm. 
    var WebServiceGroupListView = (function () {
        function WebServiceGroupListView(renderArea, workspace, client) {
            this._renderArea = renderArea;
            this._data = [];
            this._workspace = workspace;
            this._client = client;
            this._webServiceGroup = null;
            cdm.setActiveItem(this);
        }
        WebServiceGroupListView.prototype.setCommands = function () {
            var _this = this;
            var deleteCommand = new Shell.UI.Commands.Command(DataLab.LocalizedResources.deleteItem, Shell.UI.Icons["delete"], function () { return _this.confirmDelete(); }, null, false);
            Shell.UI.Commands.add([
                deleteCommand
            ]);
        };
        WebServiceGroupListView.prototype.refreshFromService = function () {
            var _this = this;
            Shell.UI.Spinner.show();
            DataLab.Util.then(this._workspace.listWebServiceGroupsAsync(), function (webServiceGroups) {
                if (cdm.currentActiveItem instanceof DataLabViews.WebServiceGroupListView) {
                    // Note: We need to map the infos to insert the type. 
                    // Except for that, we could have simply done:
                    // $.observable(this._data).refresh(modelPackageInfos);
                    //
                    $.observable(_this._data).refresh(webServiceGroups.map(function (wsg) {
                        return {
                            Id: wsg.Id,
                            Name: wsg.Name,
                            CreationTime: DataLab.Util.parseJsonDate(wsg.CreationTime),
                            type: DataLabViews.WebServiceGroupType.name
                        };
                    }));
                    // grid created after populating data so that selectFirstRowByDefault has something to select
                    _this.createGrid();
                    Shell.UI.Spinner.hide();
                }
            });
        };
        WebServiceGroupListView.prototype.navigateToWebServiceGroup = function (webServiceGroupId) {
            Shell.UI.Navigation.navigate({
                extension: DataLabViews.webServiceGroupExtensionName,
                type: DataLabViews.WebServiceGroupType.name,
                name: webServiceGroupId
            });
        };
        WebServiceGroupListView.prototype.createGrid = function () {
            var _this = this;
            this._grid = $(this._renderArea).find("#grid").wazDataGrid({
                columns: [
                    { name: DataLab.LocalizedResources.webServiceGroupNameLabel, field: "Name", cssClass: "navigationColumn" },
                    { name: DataLab.LocalizedResources.webServiceGroupCreationTimeLabel, field: "CreationTime", formatter: DataLab.Util.formatDate, sorted: "descending" }
                ],
                data: this._data,
                selectable: true,
                selectFirstRowByDefault: true,
                multiselect: false,
                resizable: true,
                rowSelect: function (evt, args) {
                    cdm.setActiveItem(_this);
                    if (args.selected) {
                        _this._webServiceGroup = args.selected.dataItem;
                    }
                    else {
                        _this._webServiceGroup = null;
                    }
                }
            });
            this._grid.on("click", ".navigationColumn", function (event) {
                var row = $(event.target).closest("tr").view().data;
                if (row.rowMetadata) {
                    var webServiceGroupId = row.rowMetadata.dataItem.Id;
                    _this.navigateToWebServiceGroup(webServiceGroupId);
                }
            });
        };
        WebServiceGroupListView.prototype.showError = function (message) {
            var error = new Shell.UI.Notifications.Confirmation(message, 'active');
            error.setActions([
                new Shell.UI.Notifications.Buttons.ok(function () {
                    Shell.UI.Notifications.remove(error);
                })
            ]);
            Shell.UI.Notifications.add(error);
        };
        WebServiceGroupListView.prototype.confirmDelete = function () {
            var _this = this;
            if (!this._webServiceGroup) {
                return;
            }
            var confirmation = new Shell.UI.Notifications.Confirmation(DataLab.Util.format(DataLab.LocalizedResources.confirmDeleteWebServiceGroup, this._webServiceGroup.Name), 'active');
            confirmation.setActions([
                new Shell.UI.Notifications.Buttons.yes(function () {
                    Shell.UI.Notifications.remove(confirmation);
                    Shell.UI.Spinner.show();
                    if (_this._webServiceGroup) {
                        _this.deleteWebServiceGroup().done(function () {
                            Shell.UI.Navigation.navigate({
                                extension: DataLabViews.webServiceGroupExtensionName
                            });
                        }).fail(function (error) {
                            _this.showError(error.message);
                        }).always(function () {
                            Shell.UI.Spinner.hide();
                        });
                    }
                }),
                new Shell.UI.Notifications.Buttons.no(function () {
                    Shell.UI.Notifications.remove(confirmation);
                })
            ]);
            Shell.UI.Notifications.add(confirmation);
        };
        WebServiceGroupListView.prototype.deleteWebServiceGroup = function () {
            var _this = this;
            // First, check if this web service has any non-default endpoints
            return DataLab.Util.then(this._workspace.getWebServiceGroupAsync(this._webServiceGroup.Id), function (webServiceGroup) {
                if (cdm.currentActiveItem instanceof DataLabViews.WebServiceGroupListView) {
                    Shell.UI.Spinner.hide();
                    if (webServiceGroup.ProductionWebService) {
                        // show error when it has production service
                        _this.showError(DataLab.Util.format(DataLab.LocalizedResources.cannotDeleteWebServiceGroupError, _this._webServiceGroup.Name));
                    }
                    else {
                        return _this._workspace.deleteWebServiceGroupAsync(_this._webServiceGroup.Id);
                    }
                }
            });
        };
        return WebServiceGroupListView;
    })();
    DataLabViews.WebServiceGroupListView = WebServiceGroupListView;
})(DataLabViews || (DataLabViews = {}));

/// <reference path="../Typescript/Global.ts" />
/// <reference path="../Typescript/ViewModel/ExperimentEditor/Help.ts" />
/// <reference path="../Typescript/ViewModel/ExperimentEditor/CustomUX.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var DataLabViews;
(function (DataLabViews) {
    var GetStartedVideo = (function (_super) {
        __extends(GetStartedVideo, _super);
        function GetStartedVideo(id, url, thumbnail, title, width, height, description, openMoreInfo, hasBeenWatched, selected) {
            if (description === void 0) { description = null; }
            if (openMoreInfo === void 0) { openMoreInfo = null; }
            if (hasBeenWatched === void 0) { hasBeenWatched = ko.observable(false); }
            if (selected === void 0) { selected = ko.observable(false); }
            _super.call(this);
            this.id = id;
            this.url = url;
            this.thumbnail = thumbnail;
            this.title = title;
            this.width = width;
            this.height = height;
            this.description = description;
            this.openMoreInfo = openMoreInfo;
            this.hasBeenWatched = hasBeenWatched;
            this.hasBeenWatched(this.getWatchedVideosIds().indexOf(this.id) >= 0);
            this.selected = selected;
        }
        GetStartedVideo.prototype.markAsWatched = function () {
            this.hasBeenWatched(true);
            this.setWatchedVideId(this.id);
        };
        GetStartedVideo.prototype.getWatchedVideosIds = function () {
            // cookie's name is 'videosWatched'
            var watchedVideoIdsString = decodeURIComponent(document.cookie.replace(new RegExp("(?:(?:^|.*;)\\s*videosWatched\\s*\\=\\s*([^;]*).*$)|^.*$"), "$1"));
            var watchedVideoIds = watchedVideoIdsString.split(',').map(function (s) { return s.trim(); }).filter(function (s) { return s.length > 0; });
            return watchedVideoIds;
        };
        GetStartedVideo.prototype.setWatchedVideId = function (videoId) {
            var watchedVideoIds = this.getWatchedVideosIds();
            if (watchedVideoIds.indexOf(videoId) < 0) {
                watchedVideoIds.push(videoId);
                var expiration = new Date();
                expiration.setFullYear(expiration.getFullYear() + 1);
                document.cookie = "videosWatched=" + encodeURIComponent(watchedVideoIds.join(',')) + "; expires=" + expiration.toUTCString();
            }
        };
        return GetStartedVideo;
    })(DataLab.Util.Disposable);
    DataLabViews.GetStartedVideo = GetStartedVideo;
    var WelcomeView = (function (_super) {
        __extends(WelcomeView, _super);
        function WelcomeView(client, workspace, renderArea) {
            _super.call(this);
            this.infoSections = WelcomeView.INFOSECTIONS;
            var welcomeSkipOptionStorage = localStorage.getItem(DataLab.Constants.WelcomeSkipOptionId);
            // If it is loading for the first time, set to NOT skip the welcome page
            if (!welcomeSkipOptionStorage) {
                welcomeSkipOptionStorage = "false";
                localStorage.setItem(DataLab.Constants.WelcomeSkipOptionId, welcomeSkipOptionStorage);
            }
            this.welcomeSkipOption = ko.observable(welcomeSkipOptionStorage === "true");
            this.welcomeSkipOption.subscribe(function (newValue) {
                localStorage.setItem(DataLab.Constants.WelcomeSkipOptionId, String(newValue));
            });
            // Include welcome caption as view title and hide page title (populated by AzureFX)
            $("#tabcontainer .itemtitle").text(DataLab.LocalizedResources.welcomePageTitle);
            // keep track of which video the user has selected
            this.selectedVideo = ko.observable();
            this.selectedVideo.subscribe(function (previousVideo) {
                if (previousVideo) {
                    previousVideo.selected(false);
                }
            }, this, "beforeChange");
            this.selectedVideo.subscribe(function (video) {
                if (video) {
                    video.selected(true);
                    var xPadding = WelcomeView._CUSTOMUX_XPADDING;
                    var yPadding = WelcomeView._CUSTOMUX_YPADDING;
                    ExperimentEditor.CustomUX.open(ExperimentEditor._videoMarkup, video, (video.height + yPadding).toString() + "px", (video.width + xPadding).toString() + "px");
                }
            });
            // Get Started videos
            this.videos = [];
            this.videos.push(new GetStartedVideo("getStartedVideo1", DataLab.LocalizedResources.gettingStartedVideo1Link, "/Libraries/Images/" + DataLab.LocalizedResources.gettingStartedVideoThumbnail, DataLab.LocalizedResources.welcomeTextSegment1Title, 1098, 720, DataLab.Util.format(DataLab.LocalizedResources.welcomeTextSegment1Body, DataLab.LocalizedResources.productNameMedium)));
            this.videos.push(new GetStartedVideo("getStartedVideo2", DataLab.LocalizedResources.gettingStartedVideo2Link, "/Libraries/Images/" + DataLab.LocalizedResources.gettingStartedVideoThumbnail, DataLab.LocalizedResources.welcomeTextSegment2Title, 1098, 720, DataLab.LocalizedResources.welcomeTextSegment2Body));
            this.videos.push(new GetStartedVideo("getStartedVideo3", DataLab.LocalizedResources.gettingStartedVideo3Link, "/Libraries/Images/" + DataLab.LocalizedResources.gettingStartedVideoThumbnail, DataLab.LocalizedResources.welcomeTextSegment3Title, 1098, 720, DataLab.LocalizedResources.welcomeTextSegment3Body));
            this.videos.push(new GetStartedVideo("getStartedVideo4", DataLab.LocalizedResources.gettingStartedVideo4Link, "/Libraries/Images/" + DataLab.LocalizedResources.gettingStartedVideoThumbnail, DataLab.LocalizedResources.welcomeTextSegment4Title, 1098, 720, DataLab.Util.format(DataLab.LocalizedResources.welcomeTextSegment4Body)));
            this.videos.push(new GetStartedVideo("getStartedVideo5", DataLab.LocalizedResources.gettingStartedVideo5Link, "/Libraries/Images/" + DataLab.LocalizedResources.gettingStartedVideoThumbnail, DataLab.LocalizedResources.welcomeTextSegment5Title, 1098, 720, DataLab.LocalizedResources.welcomeTextSegment5Body));
            this.registerForDisposal(new DataLab.Util.DisposableKOApplyBindings(this, renderArea.get(0)));
        }
        WelcomeView.prototype.goNewExperiment = function () {
            Shell.UI.Drawer.open();
        };
        WelcomeView.prototype.selectVideo = function (video) {
            this.selectedVideo(video);
        };
        // adding some padding to the customUX dialog to make room for margins
        WelcomeView._CUSTOMUX_XPADDING = 40;
        WelcomeView._CUSTOMUX_YPADDING = 90;
        // these are topic IDs to the online help documents, these are used with a utility function
        // that opens the help topic in pop-up window
        WelcomeView._TOPIC_ID_CREATE_EXPERIMENT = "e76c990c-bb44-4dea-b834-39d4c4e864ec";
        WelcomeView._TOPIC_ID_GETTING_DATA = "5beb7766-f9ff-4115-b06b-a6f54daa3d0a";
        WelcomeView._TOPIC_ID_SHARING_WORKSPACES = "20ff2e97-6a44-4312-88b6-64457f0583d8";
        WelcomeView._TOPIC_ID_CREATING_EXPERIMENTS = "e1a8c2a1-3a47-43a9-b228-20869cdf898b";
        WelcomeView._TOPIC_ID_AZ_LIST = "DFDCB393-0285-4A60-A2BD-7C79F80E4D20";
        WelcomeView._TOPIC_ID_MODULE_LIST = "C72A3E1A-29CF-46C1-BF98-BD3D30D62C96";
        WelcomeView._TOPIC_ID_OVERVIEW = "e76c990c-bb44-4dea-b834-39d4c4e864ec";
        WelcomeView._TOPIC_ID_CREATING_SIMPLE_EXPERIMENT = "e548ed9d-064b-42fd-a1b7-4c34eccb88f8";
        WelcomeView._TOPIC_ID_SAMPLE_EXPERIMENTS = "83df9d4f-f8c2-4ee4-b897-7c06692f252c";
        WelcomeView._TOPIC_ID_SAMPLE_DATA = "af7ae79e-ea60-45fd-add0-f016059d3202";
        WelcomeView._TOPIC_ID_PUBLISHING = "01e46943-7479-4d3b-adeb-35cf9e0a43bc";
        WelcomeView._TOPIC_ID_GUIDE_START = "96b39d63-f6dd-4461-a244-b90ab3891cda";
        WelcomeView.INFOSECTIONS = [
            {
                title: DataLab.LocalizedResources.welcomeInfo1Title,
                text: DataLab.LocalizedResources.welcomeInfo1Text,
                links: [
                    {
                        caption: DataLab.LocalizedResources.welcomeInfo1Link2CaptionUpdates,
                        url: DataLab.LocalizedResources.welcomeInfo1Link2HrefUpdates,
                        openInNewWindow: true
                    },
                    {
                        caption: DataLab.LocalizedResources.welcomeInfo1Link1CaptionReleaseNotes,
                        url: DataLab.LocalizedResources.welcomeInfo1Link1HrefReleaseNotes,
                        openInNewWindow: true
                    }
                ]
            },
            {
                title: DataLab.LocalizedResources.welcomeInfo2Title,
                text: DataLab.LocalizedResources.welcomeInfo2Text,
                links: [
                    {
                        caption: DataLab.LocalizedResources.welcomeInfo2Link2CaptionGettingData,
                        onclick: ExperimentEditor.Help.openHelpWindow.bind(undefined, WelcomeView._TOPIC_ID_GETTING_DATA, "")
                    },
                    {
                        caption: DataLab.LocalizedResources.welcomeInfo2Link2aCaptionCreatingAndRunningExperiments,
                        onclick: ExperimentEditor.Help.openHelpWindow.bind(undefined, WelcomeView._TOPIC_ID_CREATING_EXPERIMENTS, "")
                    },
                    {
                        caption: DataLab.LocalizedResources.welcomeInfo2Link3CaptionSharingWorkspaces,
                        onclick: ExperimentEditor.Help.openHelpWindow.bind(undefined, WelcomeView._TOPIC_ID_SHARING_WORKSPACES, "")
                    },
                    {
                        caption: DataLab.LocalizedResources.welcomeInfo2Link4CaptionPublishingExperiments,
                        onclick: ExperimentEditor.Help.openHelpWindow.bind(undefined, WelcomeView._TOPIC_ID_PUBLISHING, "")
                    }
                ],
                moreLink: {
                    caption: DataLab.LocalizedResources.welcomeInfo2MoreCaption,
                    onclick: ExperimentEditor.Help.openHelpWindow.bind(undefined, WelcomeView._TOPIC_ID_GUIDE_START, "")
                }
            },
            {
                title: DataLab.LocalizedResources.welcomeInfo3Title,
                text: DataLab.LocalizedResources.welcomeInfo3Text,
                links: [
                    {
                        caption: DataLab.LocalizedResources.welcomeInfo3Link1CaptionFeedback,
                        url: DataLab.LocalizedResources.welcomeInfo3Link1CaptionHrefFeedback,
                        openInNewWindow: true
                    },
                    {
                        caption: DataLab.LocalizedResources.welcomeInfo3Link2CaptionFeedback,
                        url: DataLab.LocalizedResources.welcomeInfo3Link2CaptionHrefFeedback,
                        openInNewWindow: true
                    }
                ]
            },
            {
                title: DataLab.LocalizedResources.welcomeInfo4Title,
                text: DataLab.LocalizedResources.welcomeInfo4Text,
                links: [
                    {
                        caption: DataLab.LocalizedResources.welcomeInfo4Link4CaptionOpenSamplesPivot,
                        onclick: Shell.UI.Navigation.navigate.bind(undefined, { extension: DataLabViews.experimentExtensionName, type: "SampleExperiments", name: "" }),
                    },
                    {
                        caption: DataLab.LocalizedResources.welcomeInfo4Link1CaptionExperiments,
                        onclick: ExperimentEditor.Help.openHelpWindow.bind(undefined, WelcomeView._TOPIC_ID_SAMPLE_EXPERIMENTS, "")
                    },
                    {
                        caption: DataLab.LocalizedResources.welcomeInfo4Link2CaptionDatasets,
                        onclick: ExperimentEditor.Help.openHelpWindow.bind(undefined, WelcomeView._TOPIC_ID_SAMPLE_DATA, "")
                    },
                    {
                        caption: DataLab.LocalizedResources.welcomeInfo4Link3CaptionModels,
                        url: DataLab.LocalizedResources.welcomeInfo4Link3CaptionHrefModels,
                        openInNewWindow: true
                    }
                ]
            },
            {
                title: DataLab.LocalizedResources.welcomeInfo5Title,
                text: DataLab.LocalizedResources.welcomeInfo5Text,
                links: [
                    {
                        caption: DataLab.LocalizedResources.welcomeInfo5Link1CaptionAlphabeticalList,
                        onclick: ExperimentEditor.Help.openHelpWindow.bind(undefined, WelcomeView._TOPIC_ID_AZ_LIST, "")
                    }
                ],
            },
            {
                title: DataLab.LocalizedResources.welcomeInfo6Title,
                text: DataLab.LocalizedResources.welcomeInfo6Text,
                links: [
                    {
                        caption: DataLab.LocalizedResources.welcomeInfo6Link4CaptionMLCenter,
                        url: DataLab.LocalizedResources.welcomeInfo6Link4CaptionHrefMLCenter,
                        openInNewWindow: true
                    },
                    {
                        caption: DataLab.LocalizedResources.welcomeInfo6Link3CaptionMLSupportSite,
                        url: DataLab.LocalizedResources.welcomeInfo6Link3CaptionHrefMLSupportSite,
                        openInNewWindow: true
                    },
                    {
                        caption: DataLab.LocalizedResources.welcomeInfo6Link5CaptionWAManagementPortal,
                        url: DataLab.LocalizedResources.welcomeInfo6Link5CaptionHrefWAManagementPortal,
                        openInNewWindow: true
                    }
                ],
            }
        ];
        return WelcomeView;
    })(DataLab.Util.Disposable);
    DataLabViews.WelcomeView = WelcomeView;
})(DataLabViews || (DataLabViews = {}));
