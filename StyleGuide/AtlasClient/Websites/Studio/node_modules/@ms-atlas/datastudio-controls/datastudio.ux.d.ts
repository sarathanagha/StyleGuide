
declare module Microsoft.DataStudioUX.Knockout.Bindings {
    class MenuBinding implements KnockoutBindingHandler {
        static menuId: string;
        static initMenuCounter: number;
        private static checkmark;
        private static removeMenuBinding(element?);
        init(element: HTMLElement, valueAccessor: () => Interfaces.IMenuBindingParams, allBindingsAccessor: () => any, viewModel: any, bindingContext: KnockoutBindingContext): void;
    }
}
declare module Microsoft.DataStudioUX.Knockout.Binding {
    class BindingDatePicker {
        init(element: HTMLElement, valueAccessor: () => any, allBindingsAccessor: () => any, viewModel: any, bindingContext: KnockoutBindingContext): void;
    }
}
declare module Microsoft.DataStudio.Application.Knockout {
    class DataStudioControlsEventListenerBag {
        private bag;
        addEventListener(target: EventTarget, type: string, listener: EventListener, useCapture?: boolean): void;
        removeEventListeners(): void;
    }
}
declare module Microsoft.DataStudio.Application.Knockout.Bindings {
    class DropdownBindingHandler implements KnockoutBindingHandler {
        static BindingName: string;
        update(element: HTMLElement, valueAccessor: () => any): void;
        private static accessorDropdownElement(targetElement, value?);
        private static accessorEventHandlers(targetElement);
        private static accessorCloseHandlers(targetElement);
        private static accessorOpened(targetElement, value?);
        private static registerEventHandlers(targetElement, dropdownElement);
        private static unregisterEventHandlers(targetElement, dropdownElement);
        private static registerCloseHandlers(targetElement, dropdownElement);
        private static unregisterCloseHandlers(targetElement);
        private static targetClick(targetElement, dropdownElement, event);
        private static openDropdown(targetElement, dropdownElement);
        private static closeDropdown(targetElement, dropdownElement);
    }
}
declare module Microsoft.DataStudio.Application.Knockout.Bindings {
    enum LoaderType {
        Page = 1,
        Nested = 2,
        Dialog = 3,
    }
    interface ILoaderOptions {
        visible?: KnockoutObservable<boolean>;
        type?: LoaderType;
    }
    /**
     * custom loader binding.
     * usage example <div data-bind="loader: { visible: {Observable<boolean>}, type: {LoaderType} }"></div>
     * default {LoaderType} is page loader. It means that it will take the whole screen and will block it.
     */
    class LoaderControlBinding implements KnockoutBindingHandler {
        /**
         * defines template name used for loader depending on current browser.
         */
        private static templateName;
        private static pageLoaderClass;
        private static nestedLoaderClass;
        private static dialogLoaderClass;
        /**
         * Toggles element visibility state.
         * @param {JQuery} $element: JQuery element for switching visibility .
         * @param {ILoaderOptions} options: Binding options.
         */
        private static toggleElementVisibility($element, options);
        init(element: HTMLElement, valueAccessor: () => any, allBindingsAccessor: () => any, viewModel: any, bindingContext: KnockoutBindingContext): void;
        update(element: HTMLElement, valueAccessor: () => any, allBindingsAccessor: () => any, viewModel: any, bindingContext: KnockoutBindingContext): void;
    }
}
/**
POC: Stephen Pryor (stpryor)

Description:
A knockout binding intended to allow a user to use part if their component template as the contents of a modal while retaining access to their view modal scope.

Input (Type - IModalBindingParams):
    isVisible: A KnockoutObservable returning a boolean. If it returns true, show the modal, if false, hide the modal.
    modalContainerClass (Optional): This class will be applied to the modalContainer allowing customized styles.
    disableFadeClose (Optional): If this boolean is set to true, clicking the fade area will NOT close the modal. Defaults to false.
    useSmallModal (Optional): If true, the modal will appear as the small variant rather than the default
    template (Optional): A string containing the contents of the modal. If this string is not provided, the contents of the bound DOM element will be the contents.

Example Usage:
    (viewModel)
    public isModalVisible: KnockoutObservable<boolean> = ko.obsevable(true);
    public exampleText: KnockoutObservable<string> = ko.obsevable("example text");

    (template)
    <div data-bind="datastudio-ux-modal: { isVisible: isModalVisible }">
        I still have access to the parent view model scope
       <span data-bind="text: exampleText"></span>
    </div>
*/
declare module Microsoft.DataStudioUX.Knockout.Bindings {
    class ModalControlBinding implements KnockoutBindingHandler {
        static modalIdAttr: string;
        init(element: HTMLElement, valueAccessor: () => Interfaces.IModalBindingParams, allBindingsAccessor: () => any, viewModel: any, bindingContext: KnockoutBindingContext): any;
        update(element: HTMLElement, valueAccessor: () => any, allBindingsAccessor: () => any, viewModel: any, bindingContext: KnockoutBindingContext): void;
    }
}
declare module Microsoft.DataStudioUX.Knockout.Bindings {
    enum ProgressType {
        DeterminateBar = 0,
        DeterminateBarTextSmall = 1,
        DeterminateBarTextLarge = 2,
        IndeterminateInline = 3,
        IndeterminatePage = 4,
    }
    interface ProgressOptions {
        type: ProgressType;
        visible?: KnockoutObservable<boolean>;
        percentComplete?: KnockoutObservable<number>;
    }
    class ProgressControlBinding implements KnockoutBindingHandler {
        private static templateHTML;
        private static toggleElementVisibility($element, options);
        init(element: HTMLElement, valueAccessor: () => ProgressOptions, allBindingsAccessor: () => any, viewModel: any, bindingContext: KnockoutBindingContext): void;
        update(element: HTMLElement, valueAccessor: () => ProgressOptions, allBindingsAccessor: () => any, viewModel: any, bindingContext: KnockoutBindingContext): void;
    }
}
/**
POC: Stephen Pryor (stpryor)

Description:
A knockout binding to creat eselect menu drop downs

Input (Interfaces.SelectMenuParams):
    options: An array of options for the menu
    select: An observable containing the select option

Example Usage:
    (viewModel)
    var exampleOptions: dsuxInterfaces.SelectMenuOption[] = [
        { label: 'Label 1', value: 1 },
        { label: 'Label 2', value: 2 },
    ];

    var exampleMenuParams = {
            options: exampleOptions,
            selected: ko.observable(options[0])
        };

    (html)
    <a href="#" data-bind="datastudio-ux-selectmenu: exampleMenuParams">
        <span class="text" data-bind="text: exampleMenuParams.selected().label"></span>
        <span class="icon icon-right chevronDown"></span>
    </a>
*/
declare module Microsoft.DataStudioUX.Knockout.Bindings {
    class SelectMenuBinding implements KnockoutBindingHandler {
        static menuId: string;
        static menuLabelClass: string;
        static menuCounter: number;
        private static removeEventFunc(e);
        init(element: HTMLElement, valueAccessor: () => Interfaces.SelectMenuParams, allBindingsAccessor: () => any, viewModel: any, bindingContext: KnockoutBindingContext): void;
        private static removeSelectMenu(element?);
    }
}
declare module Microsoft.DataStudioUX.Knockout.Bindings {
    interface ContextualMenuOption {
        name: string;
        action: () => any;
        isDisabled?: any;
        isSelected?: any;
    }
    interface ContextualMenuParams {
        options: ContextualMenuOption[];
        leftOffset?: number;
        topOffset?: number;
    }
    class ContextualMenuControlBinding implements KnockoutBindingHandler {
        static menuId: string;
        static menuCounter: number;
        private static removeEventFunc(e);
        init(element: HTMLElement, valueAccessor: () => ContextualMenuParams, allBindingsAccessor: () => any, viewModel: any, bindingContext: KnockoutBindingContext): void;
        private static removeMenu(element?);
    }
}
declare module Microsoft.DataStudio.Application.Knockout.Bindings {
    class SizeTracker {
        private diffX;
        private diffY;
        private width;
        private height;
        isGrowingX: () => boolean;
        isGrowingY: () => boolean;
        isShrinkingX: () => boolean;
        isShrinkingY: () => boolean;
        updateWidth: (newWidth: number) => void;
        updateHeight: (newHeight: number) => void;
    }
    class SplitterStatic {
        static PANEL_MIN_WIDTH: number;
        static PANEL_COLLAPSED_WIDTH: number;
        static PANEL_AUTO_OPEN_WIDTH: number;
        static PANEL_AUTO_COLLAPSE_WIDTH: number;
        static PANEL_ANIMATION_DURATION: number;
        static COLLAPSED_CLASS: string;
        static RESIZABLE_SELECTOR: string;
        static RESIZABLE_CLASS_PREFIX: string;
        static HELPER_CLASS_PREFIX: string;
        static COLLAPSE_EVENT: string;
        static RESIZE_EVENT: string;
        static IS_AW_EXPANDED: string;
        static IS_SPLITTER_BUTTON_ENABLED: string;
        static SPLITTER_DIV: string;
        static SPLITTER_BUTTON: string;
        static SPLITTER_ICON: string;
        static SPLITTER_BUTTON_ICON: string;
        static SPLITTER_BUTTON_ICON_UP: string;
        static SPLITTER_BUTTON_ICON_DOWN: string;
        static createSplitter(resizable: JQuery, options: any): void;
        static getHandle(location: string): string;
        static toggleCollapsed(panel: JQuery, width: number): void;
        static getDim(location: string): string;
        static restoreSplitter: (resizable: JQuery, splitterKey: string, dimension?: string, defaultPosition?: string) => void;
        static saveSplitter: (splitterKey: string, value: string) => void;
        static collapsedKey(key: string): string;
        static restoreCollapsed: (panel: JQuery, key: string) => void;
        static updateWidth(jquery: JQuery, width: number): void;
        static createSplitterButton(resizable: JQuery): void;
        static createSplitterIcon(resizable: JQuery): void;
    }
    interface ISplitterControlValueAccessor {
        key?: string;
        location?: string;
        close?: KnockoutObservable<boolean>;
        moveSplitter?: KnockoutObservable<boolean>;
        position?: string;
        startSize?: string;
    }
    interface IExtendedSplitterControlOptions extends ISplitterControlValueAccessor {
        stop: any;
    }
    class SplitterControlBinding implements KnockoutBindingHandler {
        init(element: HTMLElement, valueAccessor: () => ISplitterControlValueAccessor): void | {
            controlsDescendantBindings: boolean;
        };
        update: (element: HTMLElement, valueAccessor: () => ISplitterControlValueAccessor, allBindingsAccessor: () => any, viewModel: any, bindingContext: KnockoutBindingContext) => void;
        private onStop;
    }
    class PanelSplitterControlBinding implements KnockoutBindingHandler {
        resizeCover: JQuery;
        static leftPanelKey: string;
        static rightPanelKey: string;
        static leftPanelSelector: string;
        static centerSelector: string;
        static rightPanelSelector: string;
        constructor();
        init(element: HTMLElement, valueAccessor: () => any): void | {
            controlsDescendantBindings: boolean;
        };
        update: (element: HTMLElement, valueAccessor: () => any, allBindingsAccessor: () => any, viewModel: any, bindingContext: KnockoutBindingContext) => void;
        private createSplitter(panel, otherPanel, center, location);
        private onResized;
        private onCollapse;
    }
}
/**
POC: Stephen Pryor (stpryor)

Description:
A knockout binding to load an svg into the html

Input: A string containing the path to an svg.

Example Usage:
    <span data-bind="datastudio-ux-svgloader: 'datastudio-mymextensionname/images/mySpecialSvg.svg'"></span>
*/
declare module Microsoft.DataStudio.Application.Knockout.Bindings {
}
declare module Microsoft.DataStudioUX.Helpers {
    enum Keycodes {
        Enter = 13,
        ArrowUp = 38,
        ArrowDown = 40,
        ArrowLeft = 37,
        ArrowRight = 39,
        Escape = 27,
        Spacebar = 32,
        Ctrl = 17,
        Alt = 18,
        Tab = 9,
        Shift = 16,
        Capslock = 20,
        Windows = 91,
        WindowsOption = 93,
        Backspace = 8,
        Home = 36,
        End = 35,
        Insert = 45,
        Delete = 46,
        PageUp = 33,
        PageDown = 34,
        Numlock = 144,
        ScrollLock = 145,
        Pausebreak = 19,
    }
}
/**
POC: Stephen pryor (stpryor)

Description:
The ModalHelper is, as the name suggests, intended to help create modals.
This class provides a single source to store the html and css definitions for what constitues a modal.
This class also provides an abstract, function chaining approach to constructing modals.

Example Usage:
    var modalBtns: Interfaces.IModalButton[] = [
            {
                label: "Ok",
                isPrimary: true,
                action: (actions: Interfaces.IModalActions) => actions.remove()
            }
        ];
    var modal: ModalHelper = new ModalHelper();
    modal.addHeader("Header")
        .addMessage("This is a modal message")
        .addButtons(modalBtns)
        .show();
*/
declare module Microsoft.DataStudioUX.Helpers {
    enum ModalSizes {
        small = 0,
    }
    class ModalHelper {
        private static uniqueModalCounter;
        private static modalStandardId;
        static modalContainerClass: string;
        static modalContentClass: string;
        static modalCloseIconClass: string;
        static modalHeaderClass: string;
        static modalMessageClass: string;
        static modalActionBtnsClass: string;
        static modalDefaultContentClass: string;
        static modalSmallContentClass: string;
        modalId: string;
        modalContainer: JQuery;
        modalContent: JQuery;
        modalCloseIcon: JQuery;
        modalHeader: JQuery;
        modalMessage: JQuery;
        modalActionButtons: JQuery;
        constructor();
        chooseSize(size: ModalSizes): ModalHelper;
        fadeBoxClickAction(callback: (actions: Interfaces.IModalActions) => any): ModalHelper;
        addHeader(header: string): ModalHelper;
        addMessage(message: string): ModalHelper;
        addButtons(buttons: Interfaces.IModalButton[]): void;
        addContent(content: string): ModalHelper;
        show(): ModalHelper;
        edit(editFunc: (ModalHelper) => any): ModalHelper;
        addCloseIcon(closeCallback: (actions: Interfaces.IModalActions) => any): ModalHelper;
        remove(): void;
        static removeModal(element: JQuery): void;
        getActions(): Interfaces.IModalActions;
        construct(): ModalHelper;
    }
}
declare module Microsoft.DataStudio.Application.Knockout.Components {
    interface IMenuItem {
        text: string;
        iconSymbol: string;
        activeMenuMatchKey: string;
        navigationUrl: string;
        action: any;
    }
    interface IMenu {
        menuItems: KnockoutObservable<IMenuItem[]>;
        activeMenuItem: KnockoutObservable<IMenuItem>;
        action: any;
    }
}
declare module Microsoft.DataStudioUX.Interfaces {
    interface IModalActions {
        remove: () => void;
        getId: () => string;
    }
    interface IModalButton {
        label: string;
        action: (helper: IModalActions, event: JQueryEventObject) => any;
        isPrimary?: boolean;
    }
    interface IModalBindingParams {
        isVisible: KnockoutObservable<boolean>;
        modalContainerClass?: string;
        disableFadeClose?: boolean;
        useSmallModal?: string;
        template?: string;
    }
    interface IModalManagerParams {
        content?: string;
        header?: string;
        message?: string;
        buttons?: IModalButton[];
        modalContainerClass?: string;
        disableFadeClose?: boolean;
        viewModel?: any;
        closeModalText?: string;
        closeCallback?: () => any;
        useSmallModal?: string;
    }
}
declare module Microsoft.DataStudioUX.Interfaces {
    interface SelectMenuOption {
        label: string;
        value: any;
        action?: () => any;
    }
    interface SelectMenuParams {
        options: KnockoutObservableArray<SelectMenuOption> | SelectMenuOption[];
        selected: KnockoutObservable<any>;
        leftOffset?: number;
        topOffset?: number;
    }
}
declare module Microsoft.DataStudioUX.Interfaces {
    type MenuBindingGenericOption = string | IMenuBindingOption;
    type MenuBindingOptions = KnockoutObservableArray<MenuBindingGenericOption> | MenuBindingGenericOption[];
    interface IMenuBindingOption {
        description?: KnockoutObservable<string> | string;
        iconPath?: string;
        isDisabled?: KnockoutObservable<boolean> | boolean;
        label: KnockoutObservable<string> | string;
        options?: MenuBindingOptions;
        value?: any;
    }
    interface IMenuBindingParams {
        options: MenuBindingOptions;
        level?: number;
        isMultiselect?: KnockoutObservable<boolean> | boolean;
        selected?: KnockoutObservableArray<IMenuBindingOption>;
        leftOffset?: number;
        topOffset?: number;
        scrollClass?: string;
    }
}
/**
POC: Stephen Pryor (stpryor)

Description:
The Modal Manager allows the user to create modal dialogs using only javascript.

Input (Type - IModalManagerParams):
(Note: All parameters in the modal parameters are optional for customizability)
    content: Overrides the internal contents of the modal for custom configurations
    header: The modal header string
    message: The modal message string
    buttons: An array of buttons to be added to the modal
    modalContainerClass: This class will be applied to the modalContainer allowing customized styles.
    disableFadeClose: If this boolean is set to true, clicking the fade area will NOT close the modal. Defaults to false.
    viewModel: A view model to be bound to the contents of the modal
    closeModalText: A shortcut for adding a single button that closes the modal.
                    If a string is provided, a button with the given text will appear after any already added buttons.
    closeCallback: A callback function to be called whenever the modal is closed with a close icon or the fade box is clicked
    useSmallModal: If true, the modal will appear as the small variant rather than the default

Example usage:
    // Define the modal buttons
    var modalBtns: Interfaces.IModalButton[] = [
            {
                label: "Ok",
                isPrimary: true,
                action: (actions: Interfaces.IModalActions) => actions.remove()
            }
        ];
    // Create the modal parameters
    var modalParams: Interfaces.IModalManagerParams = {
            header: "Header text",
            message: "Message text",
            buttons: modalBtns
        };
    // Create and display the modal
    Microsoft.DataStudioUX.Managers.ModalManager.show(modalParams);
*/
declare module Microsoft.DataStudioUX.Managers {
    class ModalManager {
        static openModalCloseFunctions: any;
        static show(params: Interfaces.IModalManagerParams): Interfaces.IModalActions;
        static initialize(): void;
    }
}
declare module Microsoft.DataStudioUX.Managers {
    class Balloon {
        private balloonContainer;
        private messageContainer;
        private balloonActionsContainer;
        private okBtn;
        static balloonContainerClass: string;
        static balloonMessageClass: string;
        static balloonActionsClass: string;
        static okBtnClass: string;
        constructor(message: string);
        appendTo(parent: JQuery): Balloon;
        show(): Balloon;
        static hide(balloonContainer: any): void;
    }
}
declare module Microsoft.DataStudioUX.Managers {
    class NotificationManager {
        private static _instance;
        private static notificationContainer;
        constructor();
        static getInstance(): NotificationManager;
        notify(message: string): NotificationManager;
    }
}
declare module Microsoft.DataStudioUX.Managers {
    class ToasterManager {
        private static _instance;
        private static toasterId;
        private static animateSpeed;
        private messageQueue;
        private displayingMessages;
        private currentTimeout;
        constructor();
        static getInstance: () => ToasterManager;
        notify: (message: string) => ToasterManager;
        private displayMessage;
        private removeToaster;
    }
}
