
var Microsoft;
(function (Microsoft) {
    var DataStudioUX;
    (function (DataStudioUX) {
        var Knockout;
        (function (Knockout) {
            var Bindings;
            (function (Bindings) {
                "use strict";
                var MenuBinding = (function () {
                    function MenuBinding() {
                    }
                    MenuBinding.removeMenuBinding = function (element) {
                        var element = element ? element : $('div[id^="' + MenuBinding.menuId + '"]');
                        if (element.length > 0) {
                            $.each(element.children(), function (index) {
                                ko.cleanNode(element[index]);
                            });
                            element.remove();
                        }
                    };
                    MenuBinding.prototype.init = function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
                        var $element = $(element);
                        var params = valueAccessor();
                        if (MenuBinding.initMenuCounter++ < 1) {
                            $(document).keyup(function (event) {
                                if (event.keyCode === DataStudioUX.Helpers.Keycodes.Escape)
                                    MenuBinding.removeMenuBinding();
                            });
                            $(document).click(function (event) {
                                if (!$(event.target).closest($('div[id^="' + MenuBinding.menuId + '"]')).length && !$(event.target).is($('div[id^="' + MenuBinding.menuId + '"]'))) {
                                    MenuBinding.removeMenuBinding();
                                }
                            });
                            // Remove the menu on page resize since the position will be incorrect
                            $(window).resize(function () { return MenuBinding.removeMenuBinding(); });
                            // Remove the menu if the user scrolls the page
                            $(document).scroll(function (event) { return MenuBinding.removeMenuBinding(); });
                        }
                        if (params.scrollClass) {
                            $element.closest('.' + params.scrollClass).scroll(function (event) {
                                MenuBinding.removeMenuBinding();
                            });
                        }
                        $element.click(function (event) {
                            event.preventDefault();
                            event.stopPropagation();
                            // Remove any already open menu
                            var removableMenusSelector = 'div[id^="' + MenuBinding.menuId + '"]';
                            if (!params.level) {
                                MenuBinding.removeMenuBinding($('#' + MenuBinding.menuId + "0"));
                            }
                            else {
                                MenuBinding.removeMenuBinding($('#' + MenuBinding.menuId + (params.level - 1)).nextAll(removableMenusSelector));
                            }
                            var menuLevelId = params.level ? MenuBinding.menuId + params.level : MenuBinding.menuId + 0;
                            // Adjust for any offset overrides
                            var newSelectMenu = $('<div id="' + menuLevelId + '"></div>');
                            var offset = $element.offset();
                            var newLeft = offset.left + (params.leftOffset ? $element.outerWidth() : 0);
                            var newTop = offset.top + $element.outerHeight() + (params.topOffset ? -$element.height() : 0);
                            newSelectMenu.css({ left: newLeft, top: newTop });
                            var contents = $('<div class="contents"></div>');
                            var options;
                            var tempOptions = params.options;
                            if (ko.isObservable(tempOptions)) {
                                options = tempOptions();
                            }
                            else {
                                options = tempOptions;
                            }
                            options = options || [];
                            // Don't show a memu with no options
                            if (options.length < 1)
                                return;
                            options.forEach(function (option) {
                                var className = '';
                                if (typeof option === 'string') {
                                    var menuItem = (option === '-') ? $('<hr>') : $('<span class="header">' + option + '</span>');
                                }
                                else {
                                    var menuItem = $('<a href="#">' + option.label + '</a>');
                                    if (option.isDisabled)
                                        menuItem.addClass('disabled');
                                    if (option.options) {
                                        if (menuItem.find('.caretright').length === 0) {
                                            var rightArrow = $('<span class="caretright checkmark right" data-bind="datastudio-ux-svgloader:\'node_modules/@ms-atlas/datastudio-controls/Images/chevron-right.svg\'" > </span>');
                                            menuItem.append(rightArrow);
                                            ko.applyBindings(option, rightArrow[0]);
                                        }
                                        var optionViewModel = {
                                            options: option.options,
                                            leftOffset: $element.width(),
                                            topOffset: -$element.height(),
                                            level: params.level ? (params.level + 1) : 1
                                        };
                                        ko.bindingHandlers['datastudio-ux-menubinding'].init(menuItem[0], function () { return optionViewModel; });
                                    }
                                    if (option.iconPath) {
                                        console.log("iconPath", option.iconPath);
                                        var iconImage = $('<span class="menu-icon left" data-bind="datastudio-ux-svgloader:\'' + option.iconPath + '\'"></span>');
                                        menuItem.prepend(iconImage);
                                        ko.applyBindings(option, iconImage[0]);
                                    }
                                    if (option.description) {
                                        var description = option.description;
                                        var desc;
                                        if (ko.isObservable(description)) {
                                            desc = description();
                                        }
                                        else {
                                            desc = description;
                                        }
                                        menuItem.append("<section>" + desc + "</section>");
                                    }
                                    if (!option.isDisabled) {
                                        menuItem.click(function (event) {
                                            event.preventDefault();
                                            event.stopPropagation();
                                            if (params.selected) {
                                                if (!params.isMultiselect) {
                                                    params.selected()[0] = option;
                                                }
                                                else {
                                                    var existingIndex = params.selected.indexOf(option);
                                                    if (existingIndex >= 0) {
                                                        // Deselect case
                                                        params.selected.splice(existingIndex, 1);
                                                        menuItem.find('.checkmark').remove();
                                                    }
                                                    else {
                                                        // New selection case
                                                        params.selected.push(option);
                                                        var checkmark = $(MenuBinding.checkmark);
                                                        menuItem.prepend(checkmark);
                                                        ko.applyBindings(option, checkmark[0]);
                                                    }
                                                    return false;
                                                }
                                            }
                                            //   if (option.action) option.action();
                                            if (!option.options)
                                                MenuBinding.removeMenuBinding($('div[id^="' + MenuBinding.menuId + '"]'));
                                            return false;
                                        });
                                    }
                                    if (params.selected) {
                                        var checkmark = $(MenuBinding.checkmark);
                                        if (!params.isMultiselect) {
                                            if (params.selected()[0].value == option.value) {
                                                menuItem.prepend(checkmark);
                                            }
                                        }
                                        else {
                                            params.selected().forEach(function (param) {
                                                if (param.value == option.value) {
                                                    menuItem.prepend(checkmark);
                                                }
                                            });
                                        }
                                        ko.applyBindings({}, checkmark[0]);
                                    }
                                }
                                contents.append(menuItem);
                            });
                            newSelectMenu.append(contents).appendTo('body');
                            // Check if the menu drops off the bottom of the page, if so, move it up
                            var currWindow = $(window);
                            if (currWindow.scrollTop() + currWindow.height() <= (newSelectMenu.offset().top + newSelectMenu.outerHeight())) {
                                offset = $element.offset();
                                newTop = offset.top - newSelectMenu.outerHeight() + (params.topOffset ? -1 * params.topOffset : 0);
                                newSelectMenu.css({ top: newTop });
                            }
                            var rightEdge = newSelectMenu.width() + newSelectMenu.offset().left;
                            if (currWindow.width() < newSelectMenu.offset().left + newSelectMenu.width()) {
                                newSelectMenu.css({ left: newSelectMenu.offset().left - newSelectMenu.width() });
                            }
                            // Animate the contents after appending so the height is known
                            contents.css({ top: -1 * (contents.height() - 1) }).animate({ top: 0 }, 150);
                        });
                    };
                    MenuBinding.menuId = "datastudio-ux-menubinding";
                    MenuBinding.initMenuCounter = 0;
                    MenuBinding.checkmark = '<span class="checkmark left" data-bind="datastudio-ux-svgloader:\'node_modules/@ms-atlas/datastudio-controls/Images/checkmark.svg\'" ></span>';
                    return MenuBinding;
                })();
                Bindings.MenuBinding = MenuBinding;
                ko.bindingHandlers["datastudio-ux-menubinding"] = new MenuBinding();
            })(Bindings = Knockout.Bindings || (Knockout.Bindings = {}));
        })(Knockout = DataStudioUX.Knockout || (DataStudioUX.Knockout = {}));
    })(DataStudioUX = Microsoft.DataStudioUX || (Microsoft.DataStudioUX = {}));
})(Microsoft || (Microsoft = {}));
/// <reference path="../References.d.ts" />
/// <amd-dependency path="css!./datepicker.css" />
require(["css!datastudio.controls/Bindings/datepicker/datepicker.css"]);
var Microsoft;
(function (Microsoft) {
    var DataStudioUX;
    (function (DataStudioUX) {
        var Knockout;
        (function (Knockout) {
            var Binding;
            (function (Binding) {
                var BindingDatePicker = (function () {
                    function BindingDatePicker() {
                    }
                    BindingDatePicker.prototype.init = function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
                        ($(element)).datetimepicker({
                            timeFormat: "hh:mm tt",
                            dateFormat: 'mm-dd-yy',
                            showButtonPanel: true,
                            currentText: 'NOW',
                            closeText: 'APPLY',
                            showOtherMonths: true,
                            beforeShow: function () {
                            }
                        });
                        ($('#ui-datepicker-div,.ui-datepicker-inline')).addClass('datepicker-wrapper');
                        ($(element)).datepicker("setDate", new Date());
                        ko.utils.registerEventHandler(element, "change", function (event) {
                            valueAccessor().myDate(($(element)).datetimepicker("getDate"));
                        });
                        ko.utils.registerEventHandler(document.getElementsByClassName('editorArea'), "scroll", function (event) {
                            ($(element)).datepicker("hide");
                        });
                        ko.utils.registerEventHandler(element, "click", function (event) {
                            ($(element)).datepicker("show");
                        });
                    };
                    return BindingDatePicker;
                })();
                Binding.BindingDatePicker = BindingDatePicker;
                ko.bindingHandlers["datastudio-ux-BindingDatePicker"] = new BindingDatePicker();
            })(Binding = Knockout.Binding || (Knockout.Binding = {}));
        })(Knockout = DataStudioUX.Knockout || (DataStudioUX.Knockout = {}));
    })(DataStudioUX = Microsoft.DataStudioUX || (Microsoft.DataStudioUX = {}));
})(Microsoft || (Microsoft = {}));
// <amd-dependency path ="css!./Stylesheets/datastudioux.css" / >
require(["css!datastudio.controls/Stylesheets/datastudioux.css"]);
var Microsoft;
(function (Microsoft) {
    var DataStudio;
    (function (DataStudio) {
        var Application;
        (function (Application) {
            var Knockout;
            (function (Knockout) {
                var DataStudioControlsEventListenerBag = (function () {
                    function DataStudioControlsEventListenerBag() {
                        this.bag = [];
                    }
                    DataStudioControlsEventListenerBag.prototype.addEventListener = function (target, type, listener, useCapture) {
                        target.addEventListener(type, listener, useCapture);
                        this.bag.push([target, type, listener]);
                    };
                    DataStudioControlsEventListenerBag.prototype.removeEventListeners = function () {
                        while (this.bag.length > 0) {
                            var item = this.bag.pop();
                            item[0].removeEventListener(item[1], item[2]);
                        }
                    };
                    return DataStudioControlsEventListenerBag;
                })();
                Knockout.DataStudioControlsEventListenerBag = DataStudioControlsEventListenerBag;
            })(Knockout = Application.Knockout || (Application.Knockout = {}));
        })(Application = DataStudio.Application || (DataStudio.Application = {}));
    })(DataStudio = Microsoft.DataStudio || (Microsoft.DataStudio = {}));
})(Microsoft || (Microsoft = {}));

/// <reference path="../../Common/EventListner.ts" />
var Microsoft;
(function (Microsoft) {
    var DataStudio;
    (function (DataStudio) {
        var Application;
        (function (Application) {
            var Knockout;
            (function (Knockout) {
                var Bindings;
                (function (Bindings) {
                    var DropdownBindingHandler = (function () {
                        function DropdownBindingHandler() {
                        }
                        DropdownBindingHandler.prototype.update = function (element, valueAccessor) {
                            var dropdownElementOld = DropdownBindingHandler.accessorDropdownElement(element);
                            var dropdownElementNew = document.getElementById(ko.unwrap(valueAccessor()));
                            if (dropdownElementOld != dropdownElementNew) {
                                DropdownBindingHandler.accessorDropdownElement(element, dropdownElementNew);
                                if (dropdownElementOld) {
                                    DropdownBindingHandler.unregisterEventHandlers(element, dropdownElementOld);
                                }
                                if (dropdownElementNew) {
                                    DropdownBindingHandler.registerEventHandlers(element, dropdownElementNew);
                                }
                            }
                        };
                        DropdownBindingHandler.accessorDropdownElement = function (targetElement, value) {
                            if (value !== undefined) {
                                ko.utils.domData.set(targetElement, "dropdown_dropdownElement", value);
                                return value;
                            }
                            else {
                                return ko.utils.domData.get(targetElement, "dropdown_dropdownElement");
                            }
                        };
                        DropdownBindingHandler.accessorEventHandlers = function (targetElement) {
                            var handlers = ko.utils.domData.get(targetElement, "dropdown_eventHandlers");
                            if (handlers === undefined) {
                                handlers = new Knockout.DataStudioControlsEventListenerBag();
                                ko.utils.domData.set(targetElement, "dropdown_eventHandlers", handlers);
                            }
                            return handlers;
                        };
                        DropdownBindingHandler.accessorCloseHandlers = function (targetElement) {
                            var handlers = ko.utils.domData.get(targetElement, "dropdown_closeHandlers");
                            if (handlers === undefined) {
                                handlers = new Knockout.DataStudioControlsEventListenerBag();
                                ko.utils.domData.set(targetElement, "dropdown_closeHandlers", handlers);
                            }
                            return handlers;
                        };
                        DropdownBindingHandler.accessorOpened = function (targetElement, value) {
                            if (value !== undefined) {
                                ko.utils.domData.set(targetElement, "dropdown_opened", value);
                                return value;
                            }
                            else {
                                return ko.utils.domData.get(targetElement, "dropdown_opened");
                            }
                        };
                        DropdownBindingHandler.registerEventHandlers = function (targetElement, dropdownElement) {
                            var eventHandlers = DropdownBindingHandler.accessorEventHandlers(targetElement);
                            eventHandlers.addEventListener(targetElement, "click", function (event) {
                                DropdownBindingHandler.targetClick(targetElement, dropdownElement, event);
                            });
                            eventHandlers.addEventListener(dropdownElement, "click", function (event) {
                                event.stopPropagation();
                            });
                        };
                        DropdownBindingHandler.unregisterEventHandlers = function (targetElement, dropdownElement) {
                            var eventHandlers = DropdownBindingHandler.accessorEventHandlers(targetElement);
                            eventHandlers.removeEventListeners();
                            DropdownBindingHandler.closeDropdown(targetElement, dropdownElement);
                        };
                        DropdownBindingHandler.registerCloseHandlers = function (targetElement, dropdownElement) {
                            var closeHandlers = DropdownBindingHandler.accessorCloseHandlers(targetElement);
                            closeHandlers.addEventListener(document, "click", function () {
                                DropdownBindingHandler.closeDropdown(targetElement, dropdownElement);
                            });
                            var closeElements = dropdownElement.querySelectorAll(".click-close");
                            for (var i = 0; i < closeElements.length; i++) {
                                closeHandlers.addEventListener(closeElements[i], "click", function () {
                                    DropdownBindingHandler.closeDropdown(targetElement, dropdownElement);
                                });
                            }
                        };
                        DropdownBindingHandler.unregisterCloseHandlers = function (targetElement) {
                            var closeHandlers = DropdownBindingHandler.accessorCloseHandlers(targetElement);
                            closeHandlers.removeEventListeners();
                        };
                        DropdownBindingHandler.targetClick = function (targetElement, dropdownElement, event) {
                            event.preventDefault();
                            event.stopPropagation();
                            if (DropdownBindingHandler.accessorOpened(targetElement)) {
                                DropdownBindingHandler.closeDropdown(targetElement, dropdownElement);
                            }
                            else {
                                DropdownBindingHandler.openDropdown(targetElement, dropdownElement);
                            }
                        };
                        DropdownBindingHandler.openDropdown = function (targetElement, dropdownElement) {
                            if (DropdownBindingHandler.accessorOpened(targetElement))
                                return;
                            // Calculate drop-down position
                            var targetRect = targetElement.getBoundingClientRect();
                            dropdownElement.style.left = targetRect.left + "px";
                            dropdownElement.style.top = targetRect.bottom + "px";
                            // Open drop-down
                            dropdownElement.style.display = "block";
                            DropdownBindingHandler.registerCloseHandlers(targetElement, dropdownElement);
                            DropdownBindingHandler.accessorOpened(targetElement, true);
                        };
                        DropdownBindingHandler.closeDropdown = function (targetElement, dropdownElement) {
                            if (!DropdownBindingHandler.accessorOpened(targetElement))
                                return;
                            // Close drop-down
                            dropdownElement.style.display = "none";
                            DropdownBindingHandler.unregisterCloseHandlers(targetElement);
                            DropdownBindingHandler.accessorOpened(targetElement, false);
                        };
                        DropdownBindingHandler.BindingName = "dropdown";
                        return DropdownBindingHandler;
                    })();
                    Bindings.DropdownBindingHandler = DropdownBindingHandler;
                    ko.bindingHandlers["dropdown"] = new DropdownBindingHandler();
                })(Bindings = Knockout.Bindings || (Knockout.Bindings = {}));
            })(Knockout = Application.Knockout || (Application.Knockout = {}));
        })(Application = DataStudio.Application || (DataStudio.Application = {}));
    })(DataStudio = Microsoft.DataStudio || (Microsoft.DataStudio = {}));
})(Microsoft || (Microsoft = {}));

/// <amd-dependency path="css!./loaderControl.css" />
/// <amd-dependency path="text!./loaderControl.html" />
require(["css!datastudio.controls/Bindings/LoaderControl/loaderControl.css"]);
require(["text!datastudio.controls/Bindings/LoaderControl/loaderControl.html"]);
var Microsoft;
(function (Microsoft) {
    var DataStudio;
    (function (DataStudio) {
        var Application;
        (function (Application) {
            var Knockout;
            (function (Knockout) {
                var Bindings;
                (function (Bindings) {
                    "use strict";
                    /* Loader types. */
                    (function (LoaderType) {
                        LoaderType[LoaderType["Page"] = 1] = "Page";
                        LoaderType[LoaderType["Nested"] = 2] = "Nested";
                        LoaderType[LoaderType["Dialog"] = 3] = "Dialog";
                    })(Bindings.LoaderType || (Bindings.LoaderType = {}));
                    var LoaderType = Bindings.LoaderType;
                    /**
                     * custom loader binding.
                     * usage example <div data-bind="loader: { visible: {Observable<boolean>}, type: {LoaderType} }"></div>
                     * default {LoaderType} is page loader. It means that it will take the whole screen and will block it.
                     */
                    var LoaderControlBinding = (function () {
                        function LoaderControlBinding() {
                        }
                        /**
                         * Toggles element visibility state.
                         * @param {JQuery} $element: JQuery element for switching visibility .
                         * @param {ILoaderOptions} options: Binding options.
                         */
                        LoaderControlBinding.toggleElementVisibility = function ($element, options) {
                            var isVisible = $element.is(":visible");
                            var optionVisible = ko.utils.unwrapObservable(options.visible) || false;
                            if (optionVisible !== isVisible) {
                                $element.toggle();
                            }
                        };
                        /*
                         * Implementation of {KnockoutBindingHandler} interface method
                         */
                        LoaderControlBinding.prototype.init = function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
                            var browserisIE = !!(navigator.userAgent.match(/edge/i) || navigator.userAgent.match(/trident/i));
                            LoaderControlBinding.templateName = browserisIE ? "loader-template-ie" : "loader-template";
                            var $element = $(element);
                            var loaderClass;
                            var options = ko.utils.unwrapObservable(valueAccessor() || {});
                            ko.applyBindingsToNode(element, {
                                template: { name: LoaderControlBinding.templateName }
                            });
                            options.type = options.type || LoaderType.Page;
                            switch (options.type) {
                                case LoaderType.Page:
                                    loaderClass = LoaderControlBinding.pageLoaderClass;
                                    break;
                                case LoaderType.Nested:
                                    loaderClass = LoaderControlBinding.nestedLoaderClass;
                                    $element.parent().css("position", "relative");
                                    break;
                                case LoaderType.Dialog:
                                    loaderClass = LoaderControlBinding.dialogLoaderClass;
                                    break;
                                default:
                                    console.error("Unknown loader type " + options.type);
                            }
                            $element.addClass(loaderClass);
                            LoaderControlBinding.toggleElementVisibility($element, options);
                        };
                        /*
                         * Implementation of {KnockoutBindingHandler} interface method
                         */
                        LoaderControlBinding.prototype.update = function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
                            var $element = $(element);
                            var options = ko.utils.unwrapObservable(valueAccessor() || {});
                            LoaderControlBinding.toggleElementVisibility($element, options);
                        };
                        LoaderControlBinding.pageLoaderClass = "page-loader";
                        LoaderControlBinding.nestedLoaderClass = "nested-loader";
                        LoaderControlBinding.dialogLoaderClass = "dialog-loader";
                        return LoaderControlBinding;
                    })();
                    Bindings.LoaderControlBinding = LoaderControlBinding;
                    ko.bindingHandlers["datastudio-ux-loader"] = new LoaderControlBinding();
                })(Bindings = Knockout.Bindings || (Knockout.Bindings = {}));
            })(Knockout = Application.Knockout || (Application.Knockout = {}));
        })(Application = DataStudio.Application || (DataStudio.Application = {}));
    })(DataStudio = Microsoft.DataStudio || (Microsoft.DataStudio = {}));
})(Microsoft || (Microsoft = {}));

/**
POC: Stephen Pryor (stpryor)

Description:
A knockout binding intended to allow a user to use part if their component template as the contents of a modal while retaining access to their view modal scope.

Input (Type - IModalBindingParams):
    isVisible: A KnockoutObservable returning a boolean. If it returns true, show the modal, if false, hide the modal.
    modalContainerClass (Optional): This class will be applied to the modalContainer allowing customized styles.
    disableFadeClose (Optional): If this boolean is set to true, clicking the fade area will NOT close the modal. Defaults to false.
    useSmallModal (Optional): If true, the modal will appear as the small variant rather than the default
    template (Optional): A string containing the contents of the modal. If this string is not provided, the contents of the bound DOM element will be the contents.

Example Usage:
    (viewModel)
    public isModalVisible: KnockoutObservable<boolean> = ko.obsevable(true);
    public exampleText: KnockoutObservable<string> = ko.obsevable("example text");

    (template)
    <div data-bind="datastudio-ux-modal: { isVisible: isModalVisible }">
        I still have access to the parent view model scope
       <span data-bind="text: exampleText"></span>
    </div>
*/
var Microsoft;
(function (Microsoft) {
    var DataStudioUX;
    (function (DataStudioUX) {
        var Knockout;
        (function (Knockout) {
            var Bindings;
            (function (Bindings) {
                "use strict";
                // Modal Control Binding
                var ModalControlBinding = (function () {
                    function ModalControlBinding() {
                    }
                    // When the modal is first bound, hide the bound element and stop compiling Knockout for its child elements
                    ModalControlBinding.prototype.init = function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
                        var $element = $(element);
                        $element.hide();
                        // If the element with the modal bindings is ever destroyed, destroy the modal as well
                        ko.utils.domNodeDisposal.addDisposeCallback(element, function () {
                            var modalId = $element.attr(ModalControlBinding.modalIdAttr);
                            DataStudioUX.Helpers.ModalHelper.removeModal($("#" + modalId));
                        });
                        // Stop knockout from compiling the internal html
                        return { controlsDescendantBindings: true };
                    };
                    ModalControlBinding.prototype.update = function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
                        var $element = $(element);
                        var params = valueAccessor();
                        var modalId = $element.attr(ModalControlBinding.modalIdAttr);
                        var isVisible = params.isVisible;
                        if (isVisible()) {
                            var modalContainerClass = params.modalContainerClass;
                            var disableFadeClose = params.disableFadeClose;
                            // Create a new modal
                            (new DataStudioUX.Helpers.ModalHelper())
                                .addContent(params.template || $element.html())
                                .chooseSize(params.useSmallModal ? DataStudioUX.Helpers.ModalSizes.small : null)
                                .edit(function (modal) {
                                $element.attr(ModalControlBinding.modalIdAttr, modal.modalId);
                                if (modalContainerClass)
                                    modal.modalContainer.addClass(modalContainerClass);
                                if (!disableFadeClose) {
                                    modal.fadeBoxClickAction(function () { return isVisible(false); });
                                }
                                ko.applyBindings(viewModel, modal.modalContent[0]);
                            })
                                .construct()
                                .show();
                            DataStudioUX.Managers.ModalManager.openModalCloseFunctions.push(function () { return isVisible(false); });
                        }
                        else {
                            // Destroy the associated modal if it exists
                            DataStudioUX.Helpers.ModalHelper.removeModal($("#" + modalId));
                        }
                    };
                    ModalControlBinding.modalIdAttr = "data-modalid";
                    return ModalControlBinding;
                })();
                Bindings.ModalControlBinding = ModalControlBinding;
                ko.bindingHandlers["datastudio-ux-modal"] = new ModalControlBinding();
            })(Bindings = Knockout.Bindings || (Knockout.Bindings = {}));
        })(Knockout = DataStudioUX.Knockout || (DataStudioUX.Knockout = {}));
    })(DataStudioUX = Microsoft.DataStudioUX || (Microsoft.DataStudioUX = {}));
})(Microsoft || (Microsoft = {}));

/// <amd-dependency path="text!./progressControlDeterminateBar.html" />
/// <amd-dependency path="text!./progressControlDeterminateBarTextSmall.html" />
/// <amd-dependency path="text!./progressControlDeterminateBarTextLarge.html" />
/// <amd-dependency path="text!./progressControlIndeterminateSpinner.html" />
require(["text!datastudio.controls/Bindings/ProgressControl/progressControlDeterminateBar.html"]);
require(["text!datastudio.controls/Bindings/ProgressControl/progressControlDeterminateBarTextSmall.html"]);
require(["text!datastudio.controls/Bindings/ProgressControl/progressControlDeterminateBarTextLarge.html"]);
require(["text!datastudio.controls/Bindings/ProgressControl/progressControlIndeterminateSpinner.html"]);
//TODO: Add indeterminate progress styles
var Microsoft;
(function (Microsoft) {
    var DataStudioUX;
    (function (DataStudioUX) {
        var Knockout;
        (function (Knockout) {
            var Bindings;
            (function (Bindings) {
                "use strict";
                /* Progress types. */
                (function (ProgressType) {
                    ProgressType[ProgressType["DeterminateBar"] = 0] = "DeterminateBar";
                    ProgressType[ProgressType["DeterminateBarTextSmall"] = 1] = "DeterminateBarTextSmall";
                    ProgressType[ProgressType["DeterminateBarTextLarge"] = 2] = "DeterminateBarTextLarge";
                    ProgressType[ProgressType["IndeterminateInline"] = 3] = "IndeterminateInline";
                    ProgressType[ProgressType["IndeterminatePage"] = 4] = "IndeterminatePage";
                })(Bindings.ProgressType || (Bindings.ProgressType = {}));
                var ProgressType = Bindings.ProgressType;
                var ProgressControlBinding = (function () {
                    function ProgressControlBinding() {
                    }
                    ProgressControlBinding.toggleElementVisibility = function ($element, options) {
                        var isVisible = options.visible && ko.isObservable(options.visible) ? options.visible() : true;
                        isVisible ? $element.show() : $element.hide();
                    };
                    ProgressControlBinding.prototype.init = function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
                        var options = valueAccessor();
                        var progressHtml;
                        switch (options.type) {
                            case ProgressType.DeterminateBar:
                                progressHtml = require("text!datastudio.controls/Bindings/ProgressControl/progressControlDeterminateBar.html");
                                break;
                            case ProgressType.DeterminateBarTextSmall:
                                progressHtml = require("text!datastudio.controls/Bindings/ProgressControl/progressControlDeterminateBarTextSmall.html");
                                break;
                            case ProgressType.DeterminateBarTextLarge:
                                progressHtml = require("text!datastudio.controls/Bindings/ProgressControl/progressControlDeterminateBarTextLarge.html");
                                break;
                            case ProgressType.IndeterminateInline:
                                progressHtml = require("text!datastudio.controls/Bindings/ProgressControl/progressControlIndeterminateSpinner.html");
                                break;
                            case ProgressType.IndeterminatePage:
                                progressHtml = "";
                                break;
                            default:
                                console.error("Unknown progress type " + options.type);
                        }
                        ko.applyBindingsToNode(element, {
                            html: progressHtml
                        });
                    };
                    ProgressControlBinding.prototype.update = function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
                        var $element = $(element);
                        var options = valueAccessor();
                        if (options.type == ProgressType.DeterminateBar
                            || options.type == ProgressType.DeterminateBarTextSmall
                            || options.type == ProgressType.DeterminateBarTextLarge) {
                            if (options.percentComplete) {
                                var newWidth = options.percentComplete();
                                if (newWidth < 0 || newWidth > 100) {
                                    console.log("Provided percentage of " + newWidth + " is outside the allowed range of 0-100");
                                }
                                var progressBar = $element.find(".progress-bar > span");
                                var prevWidth = 100 * progressBar.width() / progressBar.offsetParent().width();
                                // Stop any existing animations
                                progressBar.stop(true);
                                if (prevWidth >= newWidth) {
                                    // Don't animate backwards
                                    progressBar.css({ width: newWidth + "%" });
                                }
                                else {
                                    // Animate 10% for every 100 milliseconds
                                    var speed = Math.abs(newWidth - prevWidth) * 10;
                                    progressBar.animate({ width: newWidth + "%" }, speed);
                                }
                            }
                            else {
                                console.error("Missing determinate progress loader parameter \"percentComplete\"");
                            }
                        }
                        ProgressControlBinding.toggleElementVisibility($element, options);
                    };
                    return ProgressControlBinding;
                })();
                Bindings.ProgressControlBinding = ProgressControlBinding;
                ko.bindingHandlers["datastudio-ux-progress"] = new ProgressControlBinding();
            })(Bindings = Knockout.Bindings || (Knockout.Bindings = {}));
        })(Knockout = DataStudioUX.Knockout || (DataStudioUX.Knockout = {}));
    })(DataStudioUX = Microsoft.DataStudioUX || (Microsoft.DataStudioUX = {}));
})(Microsoft || (Microsoft = {}));

/**
POC: Stephen Pryor (stpryor)

Description:
A knockout binding to creat eselect menu drop downs

Input (Interfaces.SelectMenuParams):
    options: An array of options for the menu
    select: An observable containing the select option

Example Usage:
    (viewModel)
    var exampleOptions: dsuxInterfaces.SelectMenuOption[] = [
        { label: 'Label 1', value: 1 },
        { label: 'Label 2', value: 2 },
    ];

    var exampleMenuParams = {
            options: exampleOptions,
            selected: ko.observable(options[0])
        };

    (html)
    <a href="#" data-bind="datastudio-ux-selectmenu: exampleMenuParams">
        <span class="text" data-bind="text: exampleMenuParams.selected().label"></span>
        <span class="icon icon-right chevronDown"></span>
    </a>
*/
var Microsoft;
(function (Microsoft) {
    var DataStudioUX;
    (function (DataStudioUX) {
        var Knockout;
        (function (Knockout) {
            var Bindings;
            (function (Bindings) {
                "use strict";
                var SelectMenuBinding = (function () {
                    function SelectMenuBinding() {
                    }
                    SelectMenuBinding.removeEventFunc = function (e) {
                        var container = $('#' + SelectMenuBinding.menuId);
                        if (!container.is(e.target) && container.has(e.target).length === 0) {
                            SelectMenuBinding.removeSelectMenu(container);
                        }
                    };
                    SelectMenuBinding.prototype.init = function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
                        var $element = $(element);
                        var params = valueAccessor();
                        if (SelectMenuBinding.menuCounter++ < 1) {
                            // Remove the menu if the user clicks outside it
                            var idString = '#' + SelectMenuBinding.menuId;
                            $(document).click(function (event) {
                                if (!$(event.target).closest(idString).length && !$(event.target).is(idString)) {
                                    SelectMenuBinding.removeSelectMenu();
                                }
                            });
                            // Remove the menu if the user hits ESC
                            $(document).keyup(function (event) {
                                if (event.keyCode === DataStudioUX.Helpers.Keycodes.Escape)
                                    SelectMenuBinding.removeSelectMenu();
                            });
                            // Remove the menu on page resize since the position will be incorrect
                            $(window).resize(function () { return SelectMenuBinding.removeSelectMenu(); });
                            // Remove the menu if the user scrolls the page
                            // TODO (stpryor): Local scroll events are not handled here (e.g. scroll the div with the open menu link), handle these cases
                            $(document).scroll(function (event) { return SelectMenuBinding.removeSelectMenu(); });
                        }
                        $element.click(function (event) {
                            event.preventDefault();
                            event.stopPropagation();
                            // Remove any already open menu
                            SelectMenuBinding.removeSelectMenu();
                            // Adjust for any offset overrides
                            var newSelectMenu = $('<div id="' + SelectMenuBinding.menuId + '"></div>');
                            var offset = $element.offset();
                            var newLeft = offset.left + (params.leftOffset ? params.leftOffset : 0);
                            var newTop = offset.top + $element.outerHeight() + (params.topOffset ? params.topOffset : 0);
                            newSelectMenu.css({ left: newLeft, top: newTop });
                            var contents = $('<div class="contents"></div>');
                            var options;
                            var tempOptions = params.options;
                            if (ko.isObservable(tempOptions)) {
                                options = tempOptions();
                            }
                            else {
                                options = tempOptions;
                            }
                            options = options || [];
                            // Don't show a memu with no options
                            if (options.length < 1)
                                return;
                            options.forEach(function (option) {
                                var menuItem = $('<a href="#">' + option.label + '</a>');
                                menuItem.click(function (event) {
                                    event.preventDefault();
                                    event.stopPropagation();
                                    params.selected(option);
                                    if (option.action)
                                        option.action();
                                    SelectMenuBinding.removeSelectMenu();
                                    return false;
                                });
                                contents.append(menuItem);
                            });
                            newSelectMenu.append(contents).appendTo('body');
                            // Check if the menu drops off the bottom of the page, if so, move it up
                            var currWindow = $(window);
                            if (currWindow.scrollTop() + currWindow.height() <= (newSelectMenu.offset().top + newSelectMenu.outerHeight())) {
                                offset = $element.offset();
                                newTop = offset.top - newSelectMenu.outerHeight() + (params.topOffset ? -1 * params.topOffset : 0);
                                newSelectMenu.css({ top: newTop });
                            }
                            // Animate the contents after appending so the height is known
                            contents.css({ top: -1 * (contents.height() - 1) }).animate({ top: 0 }, 150);
                        });
                    };
                    SelectMenuBinding.removeSelectMenu = function (element) {
                        var element = element ? element : $('#' + SelectMenuBinding.menuId);
                        if (element.length > 0) {
                            ko.cleanNode(element[0]);
                            element.remove();
                        }
                    };
                    SelectMenuBinding.menuId = "datastudio-ux-selectmenu";
                    SelectMenuBinding.menuLabelClass = "datastudio-ux-selectmenu-label";
                    SelectMenuBinding.menuCounter = 0;
                    return SelectMenuBinding;
                })();
                Bindings.SelectMenuBinding = SelectMenuBinding;
                ko.bindingHandlers["datastudio-ux-selectmenu"] = new SelectMenuBinding();
            })(Bindings = Knockout.Bindings || (Knockout.Bindings = {}));
        })(Knockout = DataStudioUX.Knockout || (DataStudioUX.Knockout = {}));
    })(DataStudioUX = Microsoft.DataStudioUX || (Microsoft.DataStudioUX = {}));
})(Microsoft || (Microsoft = {}));

/// <amd-dependency path="css!./singleContextualMenuControl.css" />
require(["css!datastudio.controls/Bindings/SingleContextualMenu/singleContextualMenuControl.css"]);
var Microsoft;
(function (Microsoft) {
    var DataStudioUX;
    (function (DataStudioUX) {
        var Knockout;
        (function (Knockout) {
            var Bindings;
            (function (Bindings) {
                "use strict";
                ;
                ;
                var ContextualMenuControlBinding = (function () {
                    function ContextualMenuControlBinding() {
                    }
                    ContextualMenuControlBinding.removeEventFunc = function (e) {
                        var container = $('#' + ContextualMenuControlBinding.menuId);
                        if (!container.is(e.target) && container.has(e.target).length === 0) {
                            ContextualMenuControlBinding.removeMenu(container);
                        }
                    };
                    ContextualMenuControlBinding.prototype.init = function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
                        var $element = $(element);
                        var params = valueAccessor();
                        if (ContextualMenuControlBinding.menuCounter++ < 1) {
                            // Remove the menu if the user clicks outside it, hits ESC, or scrolls the page
                            // Click case
                            var idString = '#' + ContextualMenuControlBinding.menuId;
                            $(document).click(function (event) {
                                if (!$(event.target).closest(idString).length && !$(event.target).is(idString)) {
                                    ContextualMenuControlBinding.removeMenu();
                                }
                            });
                            // ESC case
                            $(document).keyup(function (event) {
                                if (event.keyCode === DataStudioUX.Helpers.Keycodes.Escape)
                                    ContextualMenuControlBinding.removeMenu();
                            });
                            // Document scroll case
                            // TODO (stpryor): Local scroll events are not handled here (e.g. scroll the div with the open menu link), handler these cases
                            $(document).scroll(function (event) { return ContextualMenuControlBinding.removeMenu(); });
                            // Remove the menu on page resize since the position will be incorrect
                            $(window).resize(function () { return ContextualMenuControlBinding.removeMenu(); });
                        }
                        $element.click(function (event) {
                            event.stopPropagation();
                            // Remove any already open menu
                            ContextualMenuControlBinding.removeMenu();
                            var newMenu = $('<div id="' + ContextualMenuControlBinding.menuId + '"></div>');
                            var offset = $element.offset();
                            var newLeft = offset.left + (params.leftOffset ? params.leftOffset : 0);
                            var newTop = offset.top + $element.outerHeight() + (params.topOffset ? params.topOffset : 0);
                            newMenu.css({ left: newLeft, top: newTop });
                            var contents = $("<div class=\"contents\"></div>");
                            params.options.forEach(function (option) {
                                var menuItem = $('<a href="#" data-bind="css: {selected: isSelected, disabled: isDisabled}">' + option.name + '</a>');
                                var optionViewModal = {
                                    isDisabled: ko.isObservable(option.isDisabled) ? option.isDisabled : !!option.isDisabled,
                                    isSelected: ko.isObservable(option.isSelected) ? option.isSelected : !!option.isSelected,
                                };
                                ko.applyBindings(optionViewModal, menuItem[0]);
                                menuItem.click(function (event) {
                                    event.stopPropagation();
                                    if (!(ko.isObservable(option.isDisabled) ? option.isDisabled() : !!option.isDisabled)) {
                                        option.action();
                                        ContextualMenuControlBinding.removeMenu();
                                    }
                                    return false;
                                });
                                contents.append(menuItem);
                            });
                            newMenu.append(contents).appendTo('body');
                            // Check if the menu drops off the bottom of the page, if so, move it up
                            var currWindow = $(window);
                            if (currWindow.scrollTop() + currWindow.height() <= (newMenu.offset().top + newMenu.outerHeight())) {
                                offset = $element.offset();
                                newTop = offset.top - newMenu.outerHeight() + (params.topOffset ? -1 * params.topOffset : 0);
                                newMenu.css({ top: newTop });
                            }
                            // Animate the contents after appending so the height is known
                            contents.css({ top: -1 * (contents.height() - 1) }).animate({ top: 0 }, 150);
                        });
                    };
                    ContextualMenuControlBinding.removeMenu = function (element) {
                        var element = element ? element : $('#' + ContextualMenuControlBinding.menuId);
                        if (element.length > 0) {
                            ko.cleanNode(element[0]);
                            element.remove();
                        }
                    };
                    ContextualMenuControlBinding.menuId = "datastudio-ux-contextual-menu";
                    ContextualMenuControlBinding.menuCounter = 0;
                    return ContextualMenuControlBinding;
                })();
                Bindings.ContextualMenuControlBinding = ContextualMenuControlBinding;
                ko.bindingHandlers["datastudio-ux-contextual-menu"] = new ContextualMenuControlBinding();
            })(Bindings = Knockout.Bindings || (Knockout.Bindings = {}));
        })(Knockout = DataStudioUX.Knockout || (DataStudioUX.Knockout = {}));
    })(DataStudioUX = Microsoft.DataStudioUX || (Microsoft.DataStudioUX = {}));
})(Microsoft || (Microsoft = {}));

/// <amd-dependency path="css!./splitterControl.css" />
require(["css!datastudio.controls/Bindings/SplitterControl/splitterControl.css"]);
var Microsoft;
(function (Microsoft) {
    var DataStudio;
    (function (DataStudio) {
        var Application;
        (function (Application) {
            var Knockout;
            (function (Knockout) {
                var Bindings;
                (function (Bindings) {
                    var SizeTracker = (function () {
                        function SizeTracker() {
                            var _this = this;
                            this.diffX = 0;
                            this.diffY = 0;
                            this.width = null;
                            this.height = null;
                            this.isGrowingX = function () {
                                return _this.diffX > 0;
                            };
                            this.isGrowingY = function () {
                                return _this.diffY > 0;
                            };
                            this.isShrinkingX = function () {
                                return _this.diffX < 0;
                            };
                            this.isShrinkingY = function () {
                                return _this.diffY < 0;
                            };
                            this.updateWidth = function (newWidth) {
                                if (_this.width !== null) {
                                    _this.diffX = _this.width - newWidth;
                                }
                                _this.width = newWidth;
                            };
                            this.updateHeight = function (newHeight) {
                                if (_this.height !== null) {
                                    _this.diffY = _this.height - newHeight;
                                }
                                _this.height = newHeight;
                            };
                        }
                        return SizeTracker;
                    })();
                    Bindings.SizeTracker = SizeTracker;
                    var SplitterStatic = (function () {
                        function SplitterStatic() {
                        }
                        SplitterStatic.createSplitter = function (resizable, options) {
                            // remove existing splitter (if it exists)
                            if (resizable.is(SplitterStatic.RESIZABLE_SELECTOR)) {
                                resizable.resizable("destroy");
                            }
                            resizable.addClass(SplitterStatic.RESIZABLE_CLASS_PREFIX + options.location);
                            // add new splitter
                            resizable.resizable(options);
                        };
                        // convert the location into its cardinal direction
                        SplitterStatic.getHandle = function (location) {
                            switch (location) {
                                case "top":
                                    return "n";
                                case "left":
                                    return "w";
                                case "bottom":
                                    return "s";
                                case "right":
                                    return "e";
                                default:
                                    return "s";
                            }
                        };
                        // toggles the collapsed class if the width is small enough
                        SplitterStatic.toggleCollapsed = function (panel, width) {
                            if (width <= SplitterStatic.PANEL_COLLAPSED_WIDTH) {
                                panel.addClass(SplitterStatic.COLLAPSED_CLASS);
                            }
                            else {
                                panel.removeClass(SplitterStatic.COLLAPSED_CLASS);
                            }
                            panel.trigger(SplitterStatic.COLLAPSE_EVENT, panel.hasClass(SplitterStatic.COLLAPSED_CLASS));
                        };
                        SplitterStatic.getDim = function (location) {
                            return (location === "top" || location === "bottom") ? "height" : "width";
                        };
                        // add extra info to the key to specify it holds the collapsed value
                        SplitterStatic.collapsedKey = function (key) {
                            return key + "." + SplitterStatic.COLLAPSED_CLASS;
                        };
                        SplitterStatic.updateWidth = function (jquery, width) {
                            jquery.css({ "flex-basis": width, height: "", width: "" });
                        };
                        SplitterStatic.createSplitterButton = function (resizable) {
                            if (!resizable.find("." + SplitterStatic.SPLITTER_BUTTON).length) {
                                // Initial creation
                                var div = resizable.find("." + SplitterStatic.RESIZABLE_CLASS_PREFIX + "s");
                                var button = document.createElement("div");
                                var icon_1 = document.createElement("span");
                                $(icon_1).addClass(SplitterStatic.SPLITTER_BUTTON_ICON);
                                $(button).addClass(SplitterStatic.SPLITTER_BUTTON);
                                div.append(button);
                                $(button).append(icon_1);
                                $(button).attr("data-bind", "click: moveSplitter");
                            }
                            // Toggling icon arrow direction
                            var icon = resizable.find("." + SplitterStatic.SPLITTER_BUTTON_ICON);
                            $(icon).removeClass((localStorage.getItem(SplitterStatic.IS_AW_EXPANDED) === "true") ? SplitterStatic.SPLITTER_BUTTON_ICON_UP : SplitterStatic.SPLITTER_BUTTON_ICON_DOWN);
                            $(icon).addClass((localStorage.getItem(SplitterStatic.IS_AW_EXPANDED) === "true") ? SplitterStatic.SPLITTER_BUTTON_ICON_DOWN : SplitterStatic.SPLITTER_BUTTON_ICON_UP);
                        };
                        SplitterStatic.createSplitterIcon = function (resizable) {
                            var div = resizable.find("." + SplitterStatic.SPLITTER_DIV);
                            var icon = document.createElement("span");
                            $(icon).addClass(SplitterStatic.SPLITTER_ICON);
                            div.append(icon);
                        };
                        SplitterStatic.PANEL_MIN_WIDTH = 200;
                        SplitterStatic.PANEL_COLLAPSED_WIDTH = 48;
                        SplitterStatic.PANEL_AUTO_OPEN_WIDTH = 50;
                        SplitterStatic.PANEL_AUTO_COLLAPSE_WIDTH = 150;
                        SplitterStatic.PANEL_ANIMATION_DURATION = 50;
                        SplitterStatic.COLLAPSED_CLASS = "collapsed";
                        SplitterStatic.RESIZABLE_SELECTOR = "[class |= ui-resizable-]";
                        SplitterStatic.RESIZABLE_CLASS_PREFIX = "ui-resizable-";
                        SplitterStatic.HELPER_CLASS_PREFIX = "ui-resizable-helper-";
                        SplitterStatic.COLLAPSE_EVENT = "collapse";
                        SplitterStatic.RESIZE_EVENT = "splitter.resized";
                        SplitterStatic.IS_AW_EXPANDED = "isawexpanded";
                        SplitterStatic.IS_SPLITTER_BUTTON_ENABLED = "issplitterbuttonenabled";
                        SplitterStatic.SPLITTER_DIV = "splitterDiv";
                        SplitterStatic.SPLITTER_BUTTON = "splitterButton";
                        SplitterStatic.SPLITTER_ICON = "splitterIcon";
                        SplitterStatic.SPLITTER_BUTTON_ICON = "splitterButtonIcon";
                        SplitterStatic.SPLITTER_BUTTON_ICON_UP = "splitterButtonIconUp";
                        SplitterStatic.SPLITTER_BUTTON_ICON_DOWN = "splitterButtonIconDown";
                        SplitterStatic.restoreSplitter = function (resizable, splitterKey, dimension, defaultPosition) {
                            if (dimension === void 0) { dimension = "flex-basis"; }
                            if (defaultPosition === void 0) { defaultPosition = null; }
                            var position = defaultPosition;
                            // get a position from local storage when applicable
                            if (splitterKey && position === null && localStorage.getItem(splitterKey)) {
                                position = localStorage.getItem(splitterKey);
                            }
                            // restore it if we have any value
                            if (position) {
                                var resetProperties = {};
                                resetProperties[dimension] = position;
                                resetProperties["flex-grow"] = 0;
                                resizable.css(resetProperties);
                                resizable.trigger(SplitterStatic.RESIZE_EVENT, position);
                            }
                        };
                        SplitterStatic.saveSplitter = function (splitterKey, value) {
                            localStorage.setItem(splitterKey, value);
                        };
                        // if there's a collpased key, collapse the panel
                        SplitterStatic.restoreCollapsed = function (panel, key) {
                            var collapsedKey = SplitterStatic.collapsedKey(key);
                            if (localStorage.getItem(collapsedKey)) {
                                panel.addClass(SplitterStatic.COLLAPSED_CLASS);
                            }
                        };
                        return SplitterStatic;
                    })();
                    Bindings.SplitterStatic = SplitterStatic;
                    ;
                    ;
                    // Generic splitter control binding
                    var SplitterControlBinding = (function () {
                        function SplitterControlBinding() {
                            var _this = this;
                            this.update = function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
                                // paverma Confirm why we are or'ing with {}? Do we allow creation of splitters without a key?
                                var options = valueAccessor() || {};
                                // unwrap all observable properties
                                for (var prop in options) {
                                    if (prop !== "close") {
                                        options[prop] = ko.unwrap(options[prop]);
                                    }
                                }
                                // set default location if it doesn't exist
                                options.location = options.location ? options.location : "bottom";
                                var resizable = $(element);
                                // add other default properties
                                var extendedOptions = $.extend({
                                    helper: SplitterStatic.HELPER_CLASS_PREFIX + options.location,
                                    handles: SplitterStatic.getHandle(options.location),
                                    stop: $.noop,
                                    minHeight: 2,
                                    minWidth: 2
                                }, options);
                                // add our own stop handler which will call theirs
                                extendedOptions.stop = _this.onStop(extendedOptions.location, extendedOptions.key, extendedOptions.stop);
                                // the position is just the initial flex-basis of the element
                                var position;
                                if (localStorage.getItem(SplitterStatic.IS_AW_EXPANDED) === "true") {
                                    position = "8px";
                                }
                                else {
                                    position = extendedOptions.position;
                                }
                                SplitterStatic.restoreSplitter(resizable, extendedOptions.key, "flex-basis", position);
                                SplitterStatic.createSplitter(resizable, extendedOptions);
                                var div = resizable.find("." + SplitterStatic.RESIZABLE_CLASS_PREFIX + "handle");
                                div.addClass(SplitterStatic.SPLITTER_DIV);
                                if (localStorage.getItem(SplitterStatic.IS_SPLITTER_BUTTON_ENABLED) === "true") {
                                    SplitterStatic.createSplitterButton(resizable);
                                }
                                else {
                                    SplitterStatic.createSplitterIcon(resizable);
                                }
                            };
                            this.onStop = function (location, splitterKey, onStop) {
                                return function (event, ui) {
                                    // reset splitterButton if the splitter is moved
                                    localStorage.setItem(SplitterStatic.IS_AW_EXPANDED, "false");
                                    if (localStorage.getItem(SplitterStatic.IS_SPLITTER_BUTTON_ENABLED) === "true") {
                                        var icon = $(ui.element).find("." + SplitterStatic.SPLITTER_BUTTON_ICON);
                                        $(icon).removeClass(SplitterStatic.SPLITTER_BUTTON_ICON_DOWN);
                                        $(icon).addClass(SplitterStatic.SPLITTER_BUTTON_ICON_UP);
                                    }
                                    // update the flex
                                    var value = ui.size[SplitterStatic.getDim(location)];
                                    ui.element.css({ "flex-basis": value, width: '', height: '', "flex-grow": 0 });
                                    if (splitterKey) {
                                        SplitterStatic.saveSplitter(splitterKey, value + "px");
                                    }
                                    // call the user's onstop
                                    onStop(event, ui);
                                };
                            };
                        }
                        SplitterControlBinding.prototype.init = function (element, valueAccessor) {
                            var options = valueAccessor();
                            if (options.close) {
                                ko.applyBindingsToNode(element, {
                                    visible: ko.pureComputed(function () { return !options.close(); })
                                });
                            }
                            if (options.startSize && !localStorage.getItem(options.key)) {
                                $(element).css({ "flex-basis": options.startSize });
                                SplitterStatic.saveSplitter(options.key, options.startSize);
                            }
                            if (options.moveSplitter) {
                                localStorage.setItem(SplitterStatic.IS_SPLITTER_BUTTON_ENABLED, "true");
                                options.moveSplitter.subscribe(function (newValue) {
                                    localStorage.setItem(SplitterStatic.IS_AW_EXPANDED, localStorage.getItem(SplitterStatic.IS_AW_EXPANDED) === "true" ? "false" : "true");
                                });
                            }
                            else {
                                localStorage.setItem(SplitterStatic.IS_SPLITTER_BUTTON_ENABLED, "false");
                            }
                            return { controlsDescendantBindings: false };
                        };
                        return SplitterControlBinding;
                    })();
                    Bindings.SplitterControlBinding = SplitterControlBinding;
                    // Specifically handles the splitters
                    var PanelSplitterControlBinding = (function () {
                        function PanelSplitterControlBinding() {
                            var _this = this;
                            this.resizeCover = null;
                            this.update = function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
                                var parent = $(element);
                                var leftPanel = parent.find(PanelSplitterControlBinding.leftPanelSelector);
                                var centerPanel = parent.find(PanelSplitterControlBinding.centerSelector);
                                var rightPanel = parent.find(PanelSplitterControlBinding.rightPanelSelector);
                                _this.createSplitter(leftPanel, rightPanel, centerPanel, "right");
                                _this.createSplitter(rightPanel, leftPanel, centerPanel, "left");
                                SplitterStatic.restoreSplitter(leftPanel, PanelSplitterControlBinding.leftPanelKey);
                                SplitterStatic.restoreSplitter(rightPanel, PanelSplitterControlBinding.rightPanelKey);
                                SplitterStatic.restoreCollapsed(leftPanel, PanelSplitterControlBinding.leftPanelKey);
                                SplitterStatic.restoreCollapsed(rightPanel, PanelSplitterControlBinding.rightPanelKey);
                                // Handle events
                                leftPanel.on(SplitterStatic.RESIZE_EVENT, _this.onResized(PanelSplitterControlBinding.leftPanelKey));
                                rightPanel.on(SplitterStatic.RESIZE_EVENT, _this.onResized(PanelSplitterControlBinding.rightPanelKey));
                                leftPanel.on(SplitterStatic.COLLAPSE_EVENT, _this.onCollapse(PanelSplitterControlBinding.leftPanelKey));
                                rightPanel.on(SplitterStatic.COLLAPSE_EVENT, _this.onCollapse(PanelSplitterControlBinding.rightPanelKey));
                            };
                            // Store resize state on each resize event
                            this.onResized = function (key) {
                                return function (event, value) {
                                    // don't save info for collapsed panels
                                    if (value <= SplitterStatic.PANEL_COLLAPSED_WIDTH) {
                                        return;
                                    }
                                    SplitterStatic.saveSplitter(key, value + "px");
                                };
                            };
                            // Store collapsed state for each collapse
                            this.onCollapse = function (key) {
                                return function (event, collapsed) {
                                    var collapsedKey = SplitterStatic.collapsedKey(key);
                                    if (collapsed) {
                                        localStorage.setItem(collapsedKey, "1");
                                    }
                                    else {
                                        localStorage.removeItem(collapsedKey);
                                    }
                                };
                            };
                            this.resizeCover = $("<div class='resizeCover'></div>");
                            $("body").append(this.resizeCover);
                            this.resizeCover.hide();
                        }
                        PanelSplitterControlBinding.prototype.init = function (element, valueAccessor) {
                            return { controlsDescendantBindings: false };
                        };
                        PanelSplitterControlBinding.prototype.createSplitter = function (panel, otherPanel, center, location) {
                            var _this = this;
                            var sizeTracker = new SizeTracker();
                            // wrap the width in an object to pass by reference
                            var helperDims = { panelWidth: null, windowWidth: null };
                            var onResize = function (event, ui) {
                                sizeTracker.updateWidth(ui.size.width);
                                var helperWidth = null;
                                // if this panel is less than the min width, adjust accordingly
                                if (ui.size.width < SplitterStatic.PANEL_MIN_WIDTH) {
                                    if (sizeTracker.isGrowingX()) {
                                        helperWidth = ui.size.width > SplitterStatic.PANEL_AUTO_OPEN_WIDTH ? SplitterStatic.PANEL_MIN_WIDTH : SplitterStatic.PANEL_COLLAPSED_WIDTH;
                                    }
                                    else if (sizeTracker.isShrinkingX()) {
                                        helperWidth = ui.size.width < SplitterStatic.PANEL_AUTO_COLLAPSE_WIDTH ? SplitterStatic.PANEL_COLLAPSED_WIDTH : SplitterStatic.PANEL_MIN_WIDTH;
                                    }
                                }
                                ;
                                // if we should update the helper to a new width
                                if (helperWidth !== null) {
                                    ui.helper.css({ width: helperWidth, left: ui.position.left === 0 ? 0 : helperDims.windowWidth - helperWidth });
                                }
                                // update the object
                                helperDims.panelWidth = helperWidth === null ? ui.size.width : helperWidth;
                            };
                            var onStop = function (event, ui) {
                                _this.resizeCover.hide();
                                // update our width to be our helper width
                                ui.size.width = helperDims.panelWidth;
                                SplitterStatic.updateWidth(panel, Math.max(ui.size.width, SplitterStatic.PANEL_MIN_WIDTH));
                                // Collapse ourself if we need to
                                SplitterStatic.toggleCollapsed(panel, ui.size.width);
                                panel.trigger(SplitterStatic.RESIZE_EVENT, ui.size.width);
                                // if we no longer have a center, resize the other panel accordingly
                                if (center.width() === 0) {
                                    var newWidth = Math.max(helperDims.windowWidth - ui.size.width, SplitterStatic.PANEL_MIN_WIDTH);
                                    SplitterStatic.updateWidth(otherPanel, newWidth);
                                    otherPanel.trigger(SplitterStatic.RESIZE_EVENT, newWidth);
                                }
                            };
                            var onStart = function (event, ui) {
                                _this.resizeCover.show();
                                // initialize the window width every time
                                helperDims.windowWidth = $(window).width();
                                // Set the max to be the entire window minus the collapsed length (so there's room for the opposite panel)
                                panel.resizable("option", "maxWidth", helperDims.windowWidth - SplitterStatic.PANEL_MIN_WIDTH);
                                // height should not be modifiable
                                panel.resizable("option", "maxHeight", ui.size.height);
                                panel.resizable("option", "minHeight", ui.size.height);
                                helperDims.panelWidth = ui.size.width;
                            };
                            // add default properties
                            var options = {
                                location: location,
                                helper: SplitterStatic.HELPER_CLASS_PREFIX + location,
                                handles: SplitterStatic.getHandle(location),
                                stop: onStop,
                                start: onStart,
                                resize: onResize,
                                minWidth: SplitterStatic.PANEL_COLLAPSED_WIDTH
                            };
                            // remove existing splitter (if it exists)
                            if (panel.is(SplitterStatic.RESIZABLE_SELECTOR)) {
                                panel.resizable("destroy");
                            }
                            panel.addClass("noAnimation");
                            panel.css("overflow", "hidden");
                            SplitterStatic.createSplitter(panel, options);
                        };
                        PanelSplitterControlBinding.leftPanelKey = "shell-leftPanelKey";
                        PanelSplitterControlBinding.rightPanelKey = "shell-rightPanelKey";
                        PanelSplitterControlBinding.leftPanelSelector = ".leftSidePanel";
                        PanelSplitterControlBinding.centerSelector = ".centerPanel";
                        PanelSplitterControlBinding.rightPanelSelector = ".rightSidePanel";
                        return PanelSplitterControlBinding;
                    })();
                    Bindings.PanelSplitterControlBinding = PanelSplitterControlBinding;
                    ko.bindingHandlers["splitter"] = new SplitterControlBinding();
                    ko.bindingHandlers["panelSplitter"] = new PanelSplitterControlBinding();
                })(Bindings = Knockout.Bindings || (Knockout.Bindings = {}));
            })(Knockout = Application.Knockout || (Application.Knockout = {}));
        })(Application = DataStudio.Application || (DataStudio.Application = {}));
    })(DataStudio = Microsoft.DataStudio || (Microsoft.DataStudio = {}));
})(Microsoft || (Microsoft = {}));
;

/**
POC: Stephen Pryor (stpryor)

Description:
A knockout binding to load an svg into the html

Input: A string containing the path to an svg.

Example Usage:
    <span data-bind="datastudio-ux-svgloader: 'datastudio-mymextensionname/images/mySpecialSvg.svg'"></span>
*/
var Microsoft;
(function (Microsoft) {
    var DataStudio;
    (function (DataStudio) {
        var Application;
        (function (Application) {
            var Knockout;
            (function (Knockout) {
                var Bindings;
                (function (Bindings) {
                    var SvgLoader = (function () {
                        function SvgLoader() {
                        }
                        SvgLoader.prototype.init = function (element, valueAccessor) {
                            var $element = $(element);
                            var resourcePath = valueAccessor();
                            require(["text!" + resourcePath], function (svgString) {
                                var svg = $(svgString || '');
                                if (!!svg && svg.length) {
                                    // Clean up the svg a bit
                                    svg.removeAttr('id')
                                        .attr('height', '100%')
                                        .attr('width', '100%');
                                    // Serialize the xml to reconstruct the string
                                    var xml = new XMLSerializer();
                                    var svgXML = svg.toArray().map(function (val) { return xml.serializeToString(val); }).join('');
                                    $element.html(svgXML);
                                }
                            });
                        };
                        return SvgLoader;
                    })();
                    ko.bindingHandlers["datastudio-ux-svgloader"] = new SvgLoader();
                })(Bindings = Knockout.Bindings || (Knockout.Bindings = {}));
            })(Knockout = Application.Knockout || (Application.Knockout = {}));
        })(Application = DataStudio.Application || (DataStudio.Application = {}));
    })(DataStudio = Microsoft.DataStudio || (Microsoft.DataStudio = {}));
})(Microsoft || (Microsoft = {}));
;
/*
    A mapping of common keycodes exported as an enum
*/
var Microsoft;
(function (Microsoft) {
    var DataStudioUX;
    (function (DataStudioUX) {
        var Helpers;
        (function (Helpers) {
            (function (Keycodes) {
                Keycodes[Keycodes["Enter"] = 13] = "Enter";
                Keycodes[Keycodes["ArrowUp"] = 38] = "ArrowUp";
                Keycodes[Keycodes["ArrowDown"] = 40] = "ArrowDown";
                Keycodes[Keycodes["ArrowLeft"] = 37] = "ArrowLeft";
                Keycodes[Keycodes["ArrowRight"] = 39] = "ArrowRight";
                Keycodes[Keycodes["Escape"] = 27] = "Escape";
                Keycodes[Keycodes["Spacebar"] = 32] = "Spacebar";
                Keycodes[Keycodes["Ctrl"] = 17] = "Ctrl";
                Keycodes[Keycodes["Alt"] = 18] = "Alt";
                Keycodes[Keycodes["Tab"] = 9] = "Tab";
                Keycodes[Keycodes["Shift"] = 16] = "Shift";
                Keycodes[Keycodes["Capslock"] = 20] = "Capslock";
                Keycodes[Keycodes["Windows"] = 91] = "Windows";
                Keycodes[Keycodes["WindowsOption"] = 93] = "WindowsOption";
                Keycodes[Keycodes["Backspace"] = 8] = "Backspace";
                Keycodes[Keycodes["Home"] = 36] = "Home";
                Keycodes[Keycodes["End"] = 35] = "End";
                Keycodes[Keycodes["Insert"] = 45] = "Insert";
                Keycodes[Keycodes["Delete"] = 46] = "Delete";
                Keycodes[Keycodes["PageUp"] = 33] = "PageUp";
                Keycodes[Keycodes["PageDown"] = 34] = "PageDown";
                Keycodes[Keycodes["Numlock"] = 144] = "Numlock";
                //F1-F12  112-123,
                Keycodes[Keycodes["ScrollLock"] = 145] = "ScrollLock";
                Keycodes[Keycodes["Pausebreak"] = 19] = "Pausebreak";
            })(Helpers.Keycodes || (Helpers.Keycodes = {}));
            var Keycodes = Helpers.Keycodes;
        })(Helpers = DataStudioUX.Helpers || (DataStudioUX.Helpers = {}));
    })(DataStudioUX = Microsoft.DataStudioUX || (Microsoft.DataStudioUX = {}));
})(Microsoft || (Microsoft = {}));
/**
POC: Stephen pryor (stpryor)

Description:
The ModalHelper is, as the name suggests, intended to help create modals.
This class provides a single source to store the html and css definitions for what constitues a modal.
This class also provides an abstract, function chaining approach to constructing modals.

Example Usage:
    var modalBtns: Interfaces.IModalButton[] = [
            {
                label: "Ok",
                isPrimary: true,
                action: (actions: Interfaces.IModalActions) => actions.remove()
            }
        ];
    var modal: ModalHelper = new ModalHelper();
    modal.addHeader("Header")
        .addMessage("This is a modal message")
        .addButtons(modalBtns)
        .show();
*/
var Microsoft;
(function (Microsoft) {
    var DataStudioUX;
    (function (DataStudioUX) {
        var Helpers;
        (function (Helpers) {
            (function (ModalSizes) {
                ModalSizes[ModalSizes["small"] = 0] = "small";
            })(Helpers.ModalSizes || (Helpers.ModalSizes = {}));
            var ModalSizes = Helpers.ModalSizes;
            var ModalHelper = (function () {
                // The contructor initializes the modal elements
                function ModalHelper() {
                    // Generate a unique modal ID
                    this.modalId = ModalHelper.modalStandardId + ModalHelper.uniqueModalCounter++;
                    this.modalContainer = $('<div class="' + ModalHelper.modalContainerClass + '" id="' + this.modalId + '"></div>');
                    this.modalContent = $('<div class="' + ModalHelper.modalContentClass + '"></div>');
                }
                // Allow a choice between the default and the small modal
                ModalHelper.prototype.chooseSize = function (size) {
                    switch (size) {
                        case ModalSizes.small:
                            this.modalContent.addClass(ModalHelper.modalSmallContentClass);
                            break;
                    }
                    return this;
                };
                // Assigns an action to a click event on the modal fade box
                ModalHelper.prototype.fadeBoxClickAction = function (callback) {
                    var _this = this;
                    this.modalContainer.click(function (eventObject) {
                        var target = $(eventObject.target);
                        if (target.attr('id') === _this.modalId && callback) {
                            callback(_this.getActions());
                        }
                    });
                    return this;
                };
                // Creates and updates the header contents
                ModalHelper.prototype.addHeader = function (header) {
                    if (this.modalHeader) {
                        this.modalHeader.html(header);
                    }
                    else {
                        this.modalHeader = $('<div class="' + ModalHelper.modalHeaderClass + '">' + header + '</div>');
                    }
                    return this;
                };
                // Creates and updates the message contents
                ModalHelper.prototype.addMessage = function (message) {
                    if (this.modalMessage) {
                        this.modalMessage.html(message);
                    }
                    else {
                        this.modalMessage = $('<div class="' + ModalHelper.modalMessageClass + '">' + message + '</div>');
                    }
                    return this;
                };
                // Creates the modal buttons
                ModalHelper.prototype.addButtons = function (buttons) {
                    var _this = this;
                    if (buttons.length > 0) {
                        this.modalActionButtons = $('<div class="' + ModalHelper.modalActionBtnsClass + '"></div>');
                        buttons.forEach(function (btnParams) {
                            var btnHTML = $('<button class="btn' + (btnParams.isPrimary ? ' btn-primary' : '') + '">' + btnParams.label + '</button>');
                            btnHTML.click(function (eventObject) { return btnParams.action(_this.getActions(), eventObject); });
                            btnHTML.appendTo(_this.modalActionButtons);
                        });
                    }
                };
                // Updates the modal content, overriding any existing contents
                ModalHelper.prototype.addContent = function (content) {
                    this.modalContent.html(content);
                    return this;
                };
                // Constructs the modal and appends it to the page body tag
                ModalHelper.prototype.show = function () {
                    this.modalContainer.hide().appendTo('body').fadeIn(200);
                    return this;
                };
                // Provides a raw edit mode for adding custom functionality while still supporting chaining
                ModalHelper.prototype.edit = function (editFunc) {
                    editFunc(this);
                    return this;
                };
                // Adds a cross close icon to the modal content
                ModalHelper.prototype.addCloseIcon = function (closeCallback) {
                    var _this = this;
                    this.modalCloseIcon = $('<a class="' + ModalHelper.modalCloseIconClass + '"></a>');
                    this.modalCloseIcon.click(function () {
                        closeCallback(_this.getActions());
                    });
                    return this;
                };
                // Remove the modal assocaited with the current class instance
                ModalHelper.prototype.remove = function () {
                    ModalHelper.removeModal($('#' + this.modalId));
                };
                // Generic method to remove modals
                ModalHelper.removeModal = function (element) {
                    if (element.length > 0) {
                        ko.cleanNode(element[0]);
                        element.remove();
                    }
                };
                // Returns the list of available actions for the current model class instance
                ModalHelper.prototype.getActions = function () {
                    var _this = this;
                    return {
                        remove: function () { return _this.remove(); },
                        getId: function () { return _this.modalId; }
                    };
                };
                // Appends all the partial DOM elements into a completed modal.
                // Note: If addContent is called, any headers, messages, or buttons will be skipped
                ModalHelper.prototype.construct = function () {
                    if (!this.modalContent.html()) {
                        if (this.modalCloseIcon)
                            this.modalCloseIcon.appendTo(this.modalContent);
                        if (this.modalHeader)
                            this.modalHeader.appendTo(this.modalContent);
                        if (this.modalMessage)
                            this.modalMessage.appendTo(this.modalContent);
                        if (this.modalActionButtons)
                            this.modalActionButtons.appendTo(this.modalContent);
                    }
                    this.modalContainer.append(this.modalContent);
                    return this;
                };
                /* Static variables*/
                ModalHelper.uniqueModalCounter = 0;
                ModalHelper.modalStandardId = "datastudio-ux-modal";
                ModalHelper.modalContainerClass = "modal-container";
                ModalHelper.modalContentClass = "modal-content";
                ModalHelper.modalCloseIconClass = "close-wizard-btn";
                ModalHelper.modalHeaderClass = "modal-header";
                ModalHelper.modalMessageClass = "modal-message";
                ModalHelper.modalActionBtnsClass = "modal-action-btns";
                ModalHelper.modalDefaultContentClass = "default-content";
                ModalHelper.modalSmallContentClass = "small-content";
                return ModalHelper;
            })();
            Helpers.ModalHelper = ModalHelper;
        })(Helpers = DataStudioUX.Helpers || (DataStudioUX.Helpers = {}));
    })(DataStudioUX = Microsoft.DataStudioUX || (Microsoft.DataStudioUX = {}));
})(Microsoft || (Microsoft = {}));
var Microsoft;
(function (Microsoft) {
    var DataStudioUX;
    (function (DataStudioUX) {
        var Interfaces;
        (function (Interfaces) {
            ;
            ;
            ;
            ;
        })(Interfaces = DataStudioUX.Interfaces || (DataStudioUX.Interfaces = {}));
    })(DataStudioUX = Microsoft.DataStudioUX || (Microsoft.DataStudioUX = {}));
})(Microsoft || (Microsoft = {}));
var Microsoft;
(function (Microsoft) {
    var DataStudioUX;
    (function (DataStudioUX) {
        var Interfaces;
        (function (Interfaces) {
            ;
            ;
        })(Interfaces = DataStudioUX.Interfaces || (DataStudioUX.Interfaces = {}));
    })(DataStudioUX = Microsoft.DataStudioUX || (Microsoft.DataStudioUX = {}));
})(Microsoft || (Microsoft = {}));
/**
POC: Stephen Pryor (stpryor)

Description:
The Modal Manager allows the user to create modal dialogs using only javascript.

Input (Type - IModalManagerParams):
(Note: All parameters in the modal parameters are optional for customizability)
    content: Overrides the internal contents of the modal for custom configurations
    header: The modal header string
    message: The modal message string
    buttons: An array of buttons to be added to the modal
    modalContainerClass: This class will be applied to the modalContainer allowing customized styles.
    disableFadeClose: If this boolean is set to true, clicking the fade area will NOT close the modal. Defaults to false.
    viewModel: A view model to be bound to the contents of the modal
    closeModalText: A shortcut for adding a single button that closes the modal.
                    If a string is provided, a button with the given text will appear after any already added buttons.
    closeCallback: A callback function to be called whenever the modal is closed with a close icon or the fade box is clicked
    useSmallModal: If true, the modal will appear as the small variant rather than the default

Example usage:
    // Define the modal buttons
    var modalBtns: Interfaces.IModalButton[] = [
            {
                label: "Ok",
                isPrimary: true,
                action: (actions: Interfaces.IModalActions) => actions.remove()
            }
        ];
    // Create the modal parameters
    var modalParams: Interfaces.IModalManagerParams = {
            header: "Header text",
            message: "Message text",
            buttons: modalBtns
        };
    // Create and display the modal
    Microsoft.DataStudioUX.Managers.ModalManager.show(modalParams);
*/
var Microsoft;
(function (Microsoft) {
    var DataStudioUX;
    (function (DataStudioUX) {
        var Managers;
        (function (Managers) {
            // Modal Control Manager
            var ModalManager = (function () {
                function ModalManager() {
                }
                // Method: show
                // Given a set of modal input parameters, the show method creates and displays a modal on the screen
                // Returns: An object of type IModalActions for the newly associated modal
                ModalManager.show = function (params) {
                    var modalContainerClass = params.modalContainerClass;
                    var disableFadeClose = params.disableFadeClose;
                    // Create a new modal
                    var newModal = new DataStudioUX.Helpers.ModalHelper();
                    // Add the contents
                    if (params.useSmallModal)
                        newModal.chooseSize(DataStudioUX.Helpers.ModalSizes.small);
                    if (params.content) {
                        newModal.addContent(params.content);
                    }
                    else {
                        if (params.header)
                            newModal.addHeader(params.header);
                        if (params.message)
                            newModal.addMessage(params.message);
                        var buttons = params.buttons ? params.buttons.slice(0) : [];
                        if (params.closeModalText) {
                            buttons.push({
                                label: params.closeModalText,
                                isPrimary: true,
                                action: function (actions) {
                                    if (params.closeCallback)
                                        params.closeCallback();
                                    actions.remove();
                                }
                            });
                        }
                        newModal.addButtons(buttons);
                    }
                    // Add any override classes and enable default close functionality and show the modal
                    newModal
                        .addCloseIcon(function (actions) {
                        if (params.closeCallback)
                            params.closeCallback();
                        actions.remove();
                    })
                        .edit(function (modal) {
                        if (modalContainerClass)
                            modal.modalContainer.addClass(modalContainerClass);
                        if (!disableFadeClose) {
                            modal.fadeBoxClickAction(function (actions) {
                                if (params.closeCallback)
                                    params.closeCallback();
                                actions.remove();
                            });
                        }
                    })
                        .construct()
                        .edit(function (modal) {
                        if (params.viewModel) {
                            ko.applyBindings(params.viewModel, modal.modalContent[0]);
                        }
                    })
                        .show();
                    ModalManager.openModalCloseFunctions.push(function () {
                        if (params.closeCallback)
                            params.closeCallback();
                        newModal.remove();
                    });
                    ;
                    return newModal.getActions();
                };
                // The initialize functions enables pressing ESC to close any modals
                ModalManager.initialize = function () {
                    $(document).keyup(function (event) {
                        if (event.keyCode === DataStudioUX.Helpers.Keycodes.Escape) {
                            ModalManager.openModalCloseFunctions.forEach(function (closeFunc) { return closeFunc(); });
                            ModalManager.openModalCloseFunctions = [];
                        }
                    });
                };
                ModalManager.openModalCloseFunctions = [];
                return ModalManager;
            })();
            Managers.ModalManager = ModalManager;
        })(Managers = DataStudioUX.Managers || (DataStudioUX.Managers = {}));
    })(DataStudioUX = Microsoft.DataStudioUX || (Microsoft.DataStudioUX = {}));
})(Microsoft || (Microsoft = {}));
Microsoft.DataStudioUX.Managers.ModalManager.initialize();
/// <amd-dependency path="css!./notificationBalloon.css" />
require(["css!datastudio.controls/Managers/Notifications/notificationBalloon.css"]);
var Microsoft;
(function (Microsoft) {
    var DataStudioUX;
    (function (DataStudioUX) {
        var Managers;
        (function (Managers) {
            var Balloon = (function () {
                function Balloon(message) {
                    var self = this;
                    self.balloonContainer = $('<div class="' + Balloon.balloonContainerClass + '"></div>');
                    self.messageContainer = $('<div class="' + Balloon.balloonMessageClass + '">' + message + '</div>');
                    self.balloonActionsContainer = $('<div class="' + Balloon.balloonActionsClass + '"></div>');
                    self.okBtn = $('<input type="button" value="Ok" class="' + Balloon.okBtnClass + '">');
                    self.balloonActionsContainer.append(self.okBtn);
                    self.balloonContainer
                        .append(self.messageContainer)
                        .append(self.balloonActionsContainer);
                }
                Balloon.prototype.appendTo = function (parent) {
                    this.balloonContainer.appendTo(parent);
                    return this;
                };
                Balloon.prototype.show = function () {
                    var self = this;
                    self.balloonContainer.slideDown(150, function () {
                        self.balloonContainer.css({ bottom: "-20px" }).animate({ opacity: 1, bottom: "0px" }, 100);
                        self.messageContainer.css({ opacity: 0, top: "-20px", display: "block" }).animate({ opacity: 1, top: "0px" }, 200);
                        self.okBtn.css({ opacity: 0, right: "-20px", display: "block" }).animate({ opacity: 1, right: "0px" }, 200);
                    });
                    return this;
                };
                Balloon.hide = function (balloonContainer) {
                    balloonContainer
                        .animate({ opacity: 0, bottom: "-20px" }, 100, function () {
                        $(this).slideUp(150, function () {
                            $(this).remove();
                        });
                    });
                };
                Balloon.balloonContainerClass = "dsux-balloon-container";
                Balloon.balloonMessageClass = "dsux-balloon-message";
                Balloon.balloonActionsClass = "dsux-balloon-actions";
                Balloon.okBtnClass = "dsux-balloon-action-btn";
                return Balloon;
            })();
            Managers.Balloon = Balloon;
        })(Managers = DataStudioUX.Managers || (DataStudioUX.Managers = {}));
    })(DataStudioUX = Microsoft.DataStudioUX || (Microsoft.DataStudioUX = {}));
})(Microsoft || (Microsoft = {}));
/// <reference path="Balloon.ts" />
var Microsoft;
(function (Microsoft) {
    var DataStudioUX;
    (function (DataStudioUX) {
        var Managers;
        (function (Managers) {
            var NotificationManager = (function () {
                function NotificationManager() {
                    if (NotificationManager._instance) {
                        throw new Error("Error: Instantiation failed: USE [Microsoft.DataStudio.Application.Notifications.NotificationManager.getInstance()] instead of new.");
                    }
                    else {
                        NotificationManager._instance = this;
                    }
                    // Initialize the notification container and append it to the page
                    NotificationManager.notificationContainer = $('<div id="dsux-notification-container"></div>');
                    NotificationManager.notificationContainer.click(function (eventHandler) {
                        var clickedElement = $(eventHandler.target);
                        if (clickedElement.hasClass(Managers.Balloon.okBtnClass)) {
                            var balloonContainer = clickedElement.closest('.' + Managers.Balloon.balloonContainerClass);
                            Managers.Balloon.hide(balloonContainer);
                        }
                    });
                    $("body").append(NotificationManager.notificationContainer);
                }
                NotificationManager.getInstance = function () {
                    return NotificationManager._instance;
                };
                NotificationManager.prototype.notify = function (message) {
                    (new Managers.Balloon(message))
                        .appendTo(NotificationManager.notificationContainer)
                        .show();
                    return this;
                };
                NotificationManager._instance = new NotificationManager();
                return NotificationManager;
            })();
            Managers.NotificationManager = NotificationManager;
        })(Managers = DataStudioUX.Managers || (DataStudioUX.Managers = {}));
    })(DataStudioUX = Microsoft.DataStudioUX || (Microsoft.DataStudioUX = {}));
})(Microsoft || (Microsoft = {}));
/// <amd-dependency path="css!./Toaster.css" />
require(["css!datastudio.controls/Managers/ToasterManager/Toaster.css"]);
var Microsoft;
(function (Microsoft) {
    var DataStudioUX;
    (function (DataStudioUX) {
        var Managers;
        (function (Managers) {
            var ToasterManager = (function () {
                function ToasterManager() {
                    var _this = this;
                    // Instance variables
                    this.messageQueue = [];
                    this.displayingMessages = false;
                    this.currentTimeout = null;
                    // Method: notify
                    // Add a message to the message queue and begin displaying if needed
                    this.notify = function (message) {
                        _this.messageQueue.push(message);
                        if (!_this.displayingMessages) {
                            _this.displayingMessages = true;
                            _this.displayMessage(_this.messageQueue.shift());
                        }
                        return _this;
                    };
                    // Method: displayMessage
                    // Create the toaster DOM element, attach it to the page, and animate it into view
                    // Continue to call recursively until the messageQueue is empty
                    this.displayMessage = function (message) {
                        var self = _this;
                        // Only display a message if no toaster is currently active
                        if (!!!document.getElementById(ToasterManager.toasterId)) {
                            var toaster = $('<div id="' + ToasterManager.toasterId + '">' + message + '</div>');
                            var closeBnt = $('<span class="btn-close-toaster">&times;</span>');
                            closeBnt.click(function () { return self.removeToaster(toaster); });
                            toaster.append(closeBnt).appendTo('body').animate({ right: '0px', opacity: 1 }, ToasterManager.animateSpeed);
                            self.currentTimeout = setTimeout(function () { return self.removeToaster(toaster); }, message.length * 100 + 1000);
                        }
                    };
                    // Method: removeToaster
                    // Contains the logic to stop any existing timeouts and remove the provided toaster
                    this.removeToaster = function (toaster) {
                        var self = _this;
                        self.currentTimeout = clearTimeout(self.currentTimeout);
                        toaster.animate({ right: '-320px', opacity: 0 }, ToasterManager.animateSpeed, function () {
                            toaster.remove();
                            // If there are more messages, display the next message
                            self.displayingMessages = self.messageQueue.length > 0;
                            if (self.displayingMessages)
                                self.displayMessage(self.messageQueue.shift());
                        });
                    };
                    if (ToasterManager._instance) {
                        throw new Error("Error: Instantiation failed: USE [Microsoft.DataStudioUX.Managers.ToasterManager.getInstance()] instead of new.");
                    }
                    else {
                        ToasterManager._instance = this;
                    }
                }
                // Static variables
                ToasterManager._instance = new ToasterManager();
                ToasterManager.toasterId = 'dsux-toaster-container';
                ToasterManager.animateSpeed = 300;
                // Method: getInstance
                // Return the instance of the toaster manager
                ToasterManager.getInstance = function () { return ToasterManager._instance; };
                return ToasterManager;
            })();
            Managers.ToasterManager = ToasterManager;
        })(Managers = DataStudioUX.Managers || (DataStudioUX.Managers = {}));
    })(DataStudioUX = Microsoft.DataStudioUX || (Microsoft.DataStudioUX = {}));
})(Microsoft || (Microsoft = {}));
//# sourceMappingURL=datastudio.ux.js.map